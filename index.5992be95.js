// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"aLV6j":[function(require,module,exports) {
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "4a236f9275d0a351";
module.bundle.HMR_BUNDLE_ID = "8b1183145992be95";
"use strict";
function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {
            };
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = o[Symbol.iterator]();
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function accept(fn) {
            this._acceptCallbacks.push(fn || function() {
            });
        },
        dispose: function dispose(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';
    var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/'); // $FlowFixMe
    ws.onmessage = function(event) {
        checkedAssets = {
        };
        acceptedAssets = {
        };
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === 'update') {
            // Remove error overlay if there is one
            if (typeof document !== 'undefined') removeErrorOverlay();
            var assets = data.assets.filter(function(asset) {
                return asset.envHash === HMR_ENV_HASH;
            }); // Handle HMR Update
            var handled = assets.every(function(asset) {
                return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                assets.forEach(function(asset) {
                    hmrApply(module.bundle.root, asset);
                });
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else window.location.reload();
        }
        if (data.type === 'error') {
            // Log parcel errors to console
            var _iterator = _createForOfIteratorHelper(data.diagnostics.ansi), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var ansiDiagnostic = _step.value;
                    var stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                    console.error('🚨 [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
            if (typeof document !== 'undefined') {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn('[parcel] 🚨 Connection to the HMR server was lost');
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log('[parcel] ✨ Error resolved');
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    var errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    var _iterator2 = _createForOfIteratorHelper(diagnostics), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var diagnostic = _step2.value;
            var stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
            errorHTML += "\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          \uD83D\uDEA8 ".concat(diagnostic.message, "\n        </div>\n        <pre>").concat(stack, "</pre>\n        <div>\n          ").concat(diagnostic.hints.map(function(hint) {
                return '<div>💡 ' + hint + '</div>';
            }).join(''), "\n        </div>\n        ").concat(diagnostic.documentation ? "<div>\uD83D\uDCDD <a style=\"color: violet\" href=\"".concat(diagnostic.documentation, "\" target=\"_blank\">Learn more</a></div>") : '', "\n      </div>\n    ");
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', link.getAttribute('href').split('?')[0] + '?' + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(window.location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        var deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                var oldDeps = modules[asset.id][1];
                for(var dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    var id = oldDeps[dep];
                    var parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            var fn = new Function('require', 'module', 'exports', asset.output);
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id1) {
    var modules = bundle.modules;
    if (!modules) return;
    if (modules[id1]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        var deps = modules[id1][1];
        var orphans = [];
        for(var dep in deps){
            var parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id1];
        delete bundle.cache[id1]; // Now delete the orphans.
        orphans.forEach(function(id) {
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id1);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    var parents = getParents(module.bundle.root, id);
    var accepted = false;
    while(parents.length > 0){
        var v = parents.shift();
        var a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            var p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push.apply(parents, _toConsumableArray(p));
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) return true;
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {
    };
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"6xtYJ":[function(require,module,exports) {
/**
 * by bitbof (bitbof.com)
 */ var _polyfills = require("./polyfills");
var _bb = require("./bb/bb");
var _kl = require("./klecks/kl");
var _klHistory = require("./klecks/history/kl-history");
var _klApp = require("./app/kl-app");
var _language = require("./language/language");
(async ()=>{
    let klApp;
    let domIsLoaded = false;
    _bb.BB.addEventListener(window, 'DOMContentLoaded', ()=>{
        domIsLoaded = true;
    });
    await _language.initLANG();
    function onProjectLoaded(project, projectStore) {
        if (klApp) throw 'onKlProjectObjLoaded called more than once';
        let loadingScreenEl = document.getElementById("loading-screen");
        try {
            // in case an extension screwed with the page
            loadingScreenEl.parentNode.removeChild(loadingScreenEl);
        } catch (e) {
        }
        const saveReminder = new _kl.KL.SaveReminder(_klHistory.klHistory, true, true);
        klApp = new _klApp.KlApp(project, {
            saveReminder,
            projectStore
        });
        saveReminder.init();
        if (project) setTimeout(()=>{
            klApp.out(_language.LANG('file-storage-restored'));
        }, 100);
        document.body.appendChild(klApp.getEl());
    }
    async function onDomLoaded() {
        _bb.BB.removeEventListener(window, 'DOMContentLoaded', onDomLoaded);
        let projectStore = new _kl.KL.ProjectStore();
        let project = null;
        try {
            const readResult = await projectStore.read();
            if (readResult) project = readResult.project;
        } catch (e) {
            let message;
            if (e.message === 'db-error') message = 'Failed to access Browser Storage';
            else if (e.message === 'format-error') message = 'Failed to restore from Browser Storage';
            if (message) setTimeout(function() {
                klApp && klApp.out(message);
                throw new Error('Initial browser storage error, ' + e);
            }, 100);
        }
        onProjectLoaded(project, projectStore);
    }
    if (domIsLoaded) onDomLoaded();
    else _bb.BB.addEventListener(window, 'DOMContentLoaded', onDomLoaded);
})();

},{"./polyfills":"6xfEN","./bb/bb":"e3nbn","./klecks/kl":"3bnx1","./klecks/history/kl-history":"ai9zE","./app/kl-app":"dPWb5","./language/language":"lvNW4"}],"6xfEN":[function(require,module,exports) {
var _coreJs = require("core-js");
var _nodePrototypeAppend = require("mdn-polyfills/Node.prototype.append");
if (!('scrollTo' in Element.prototype)) Object.defineProperty(Element.prototype, 'scrollTo', {
    value: function(x, y) {
        this.scrollLeft = x;
        this.scrollTop = y;
    }
});
if (!('scrollBy' in Element.prototype)) Object.defineProperty(Element.prototype, 'scrollBy', {
    value: function(x, y) {
        this.scrollLeft += x;
        this.scrollTop += y;
    }
});
// sometimes Android WebView has no localStorage
if (!('localStorage' in window)) try {
    window['localStorage'] = {
        getItem: ()=>null
        ,
        setItem: ()=>{
        },
        removeItem: ()=>{
        }
    };
} catch (e) {
// maybe it doesn't let me set this
}

},{"core-js":"88g82","mdn-polyfills/Node.prototype.append":"bpUQH"}],"88g82":[function(require,module,exports) {
module.exports = require('./features');

},{"./features":"6NwpH"}],"6NwpH":[function(require,module,exports) {
require('../modules/es.symbol');
require('../modules/es.symbol.description');
require('../modules/es.symbol.async-iterator');
require('../modules/es.symbol.has-instance');
require('../modules/es.symbol.is-concat-spreadable');
require('../modules/es.symbol.iterator');
require('../modules/es.symbol.match');
require('../modules/es.symbol.match-all');
require('../modules/es.symbol.replace');
require('../modules/es.symbol.search');
require('../modules/es.symbol.species');
require('../modules/es.symbol.split');
require('../modules/es.symbol.to-primitive');
require('../modules/es.symbol.to-string-tag');
require('../modules/es.symbol.unscopables');
require('../modules/es.error.cause');
require('../modules/es.error.to-string');
require('../modules/es.aggregate-error');
require('../modules/es.aggregate-error.cause');
require('../modules/es.array.at');
require('../modules/es.array.concat');
require('../modules/es.array.copy-within');
require('../modules/es.array.every');
require('../modules/es.array.fill');
require('../modules/es.array.filter');
require('../modules/es.array.find');
require('../modules/es.array.find-index');
require('../modules/es.array.flat');
require('../modules/es.array.flat-map');
require('../modules/es.array.for-each');
require('../modules/es.array.from');
require('../modules/es.array.includes');
require('../modules/es.array.index-of');
require('../modules/es.array.is-array');
require('../modules/es.array.iterator');
require('../modules/es.array.join');
require('../modules/es.array.last-index-of');
require('../modules/es.array.map');
require('../modules/es.array.of');
require('../modules/es.array.reduce');
require('../modules/es.array.reduce-right');
require('../modules/es.array.reverse');
require('../modules/es.array.slice');
require('../modules/es.array.some');
require('../modules/es.array.sort');
require('../modules/es.array.species');
require('../modules/es.array.splice');
require('../modules/es.array.unscopables.flat');
require('../modules/es.array.unscopables.flat-map');
require('../modules/es.array-buffer.constructor');
require('../modules/es.array-buffer.is-view');
require('../modules/es.array-buffer.slice');
require('../modules/es.data-view');
require('../modules/es.date.get-year');
require('../modules/es.date.now');
require('../modules/es.date.set-year');
require('../modules/es.date.to-gmt-string');
require('../modules/es.date.to-iso-string');
require('../modules/es.date.to-json');
require('../modules/es.date.to-primitive');
require('../modules/es.date.to-string');
require('../modules/es.escape');
require('../modules/es.function.bind');
require('../modules/es.function.has-instance');
require('../modules/es.function.name');
require('../modules/es.global-this');
require('../modules/es.json.stringify');
require('../modules/es.json.to-string-tag');
require('../modules/es.map');
require('../modules/es.math.acosh');
require('../modules/es.math.asinh');
require('../modules/es.math.atanh');
require('../modules/es.math.cbrt');
require('../modules/es.math.clz32');
require('../modules/es.math.cosh');
require('../modules/es.math.expm1');
require('../modules/es.math.fround');
require('../modules/es.math.hypot');
require('../modules/es.math.imul');
require('../modules/es.math.log10');
require('../modules/es.math.log1p');
require('../modules/es.math.log2');
require('../modules/es.math.sign');
require('../modules/es.math.sinh');
require('../modules/es.math.tanh');
require('../modules/es.math.to-string-tag');
require('../modules/es.math.trunc');
require('../modules/es.number.constructor');
require('../modules/es.number.epsilon');
require('../modules/es.number.is-finite');
require('../modules/es.number.is-integer');
require('../modules/es.number.is-nan');
require('../modules/es.number.is-safe-integer');
require('../modules/es.number.max-safe-integer');
require('../modules/es.number.min-safe-integer');
require('../modules/es.number.parse-float');
require('../modules/es.number.parse-int');
require('../modules/es.number.to-exponential');
require('../modules/es.number.to-fixed');
require('../modules/es.number.to-precision');
require('../modules/es.object.assign');
require('../modules/es.object.create');
require('../modules/es.object.define-getter');
require('../modules/es.object.define-properties');
require('../modules/es.object.define-property');
require('../modules/es.object.define-setter');
require('../modules/es.object.entries');
require('../modules/es.object.freeze');
require('../modules/es.object.from-entries');
require('../modules/es.object.get-own-property-descriptor');
require('../modules/es.object.get-own-property-descriptors');
require('../modules/es.object.get-own-property-names');
require('../modules/es.object.get-prototype-of');
require('../modules/es.object.has-own');
require('../modules/es.object.is');
require('../modules/es.object.is-extensible');
require('../modules/es.object.is-frozen');
require('../modules/es.object.is-sealed');
require('../modules/es.object.keys');
require('../modules/es.object.lookup-getter');
require('../modules/es.object.lookup-setter');
require('../modules/es.object.prevent-extensions');
require('../modules/es.object.seal');
require('../modules/es.object.set-prototype-of');
require('../modules/es.object.to-string');
require('../modules/es.object.values');
require('../modules/es.parse-float');
require('../modules/es.parse-int');
require('../modules/es.promise');
require('../modules/es.promise.all-settled');
require('../modules/es.promise.any');
require('../modules/es.promise.finally');
require('../modules/es.reflect.apply');
require('../modules/es.reflect.construct');
require('../modules/es.reflect.define-property');
require('../modules/es.reflect.delete-property');
require('../modules/es.reflect.get');
require('../modules/es.reflect.get-own-property-descriptor');
require('../modules/es.reflect.get-prototype-of');
require('../modules/es.reflect.has');
require('../modules/es.reflect.is-extensible');
require('../modules/es.reflect.own-keys');
require('../modules/es.reflect.prevent-extensions');
require('../modules/es.reflect.set');
require('../modules/es.reflect.set-prototype-of');
require('../modules/es.reflect.to-string-tag');
require('../modules/es.regexp.constructor');
require('../modules/es.regexp.dot-all');
require('../modules/es.regexp.exec');
require('../modules/es.regexp.flags');
require('../modules/es.regexp.sticky');
require('../modules/es.regexp.test');
require('../modules/es.regexp.to-string');
require('../modules/es.set');
require('../modules/es.string.at-alternative');
require('../modules/es.string.code-point-at');
require('../modules/es.string.ends-with');
require('../modules/es.string.from-code-point');
require('../modules/es.string.includes');
require('../modules/es.string.iterator');
require('../modules/es.string.match');
require('../modules/es.string.match-all');
require('../modules/es.string.pad-end');
require('../modules/es.string.pad-start');
require('../modules/es.string.raw');
require('../modules/es.string.repeat');
require('../modules/es.string.replace');
require('../modules/es.string.replace-all');
require('../modules/es.string.search');
require('../modules/es.string.split');
require('../modules/es.string.starts-with');
require('../modules/es.string.substr');
require('../modules/es.string.trim');
require('../modules/es.string.trim-end');
require('../modules/es.string.trim-start');
require('../modules/es.string.anchor');
require('../modules/es.string.big');
require('../modules/es.string.blink');
require('../modules/es.string.bold');
require('../modules/es.string.fixed');
require('../modules/es.string.fontcolor');
require('../modules/es.string.fontsize');
require('../modules/es.string.italics');
require('../modules/es.string.link');
require('../modules/es.string.small');
require('../modules/es.string.strike');
require('../modules/es.string.sub');
require('../modules/es.string.sup');
require('../modules/es.typed-array.float32-array');
require('../modules/es.typed-array.float64-array');
require('../modules/es.typed-array.int8-array');
require('../modules/es.typed-array.int16-array');
require('../modules/es.typed-array.int32-array');
require('../modules/es.typed-array.uint8-array');
require('../modules/es.typed-array.uint8-clamped-array');
require('../modules/es.typed-array.uint16-array');
require('../modules/es.typed-array.uint32-array');
require('../modules/es.typed-array.at');
require('../modules/es.typed-array.copy-within');
require('../modules/es.typed-array.every');
require('../modules/es.typed-array.fill');
require('../modules/es.typed-array.filter');
require('../modules/es.typed-array.find');
require('../modules/es.typed-array.find-index');
require('../modules/es.typed-array.for-each');
require('../modules/es.typed-array.from');
require('../modules/es.typed-array.includes');
require('../modules/es.typed-array.index-of');
require('../modules/es.typed-array.iterator');
require('../modules/es.typed-array.join');
require('../modules/es.typed-array.last-index-of');
require('../modules/es.typed-array.map');
require('../modules/es.typed-array.of');
require('../modules/es.typed-array.reduce');
require('../modules/es.typed-array.reduce-right');
require('../modules/es.typed-array.reverse');
require('../modules/es.typed-array.set');
require('../modules/es.typed-array.slice');
require('../modules/es.typed-array.some');
require('../modules/es.typed-array.sort');
require('../modules/es.typed-array.subarray');
require('../modules/es.typed-array.to-locale-string');
require('../modules/es.typed-array.to-string');
require('../modules/es.unescape');
require('../modules/es.weak-map');
require('../modules/es.weak-set');
require('../modules/esnext.aggregate-error');
require('../modules/esnext.array.from-async');
require('../modules/esnext.array.at');
require('../modules/esnext.array.filter-out');
require('../modules/esnext.array.filter-reject');
require('../modules/esnext.array.find-last');
require('../modules/esnext.array.find-last-index');
require('../modules/esnext.array.group-by');
require('../modules/esnext.array.group-by-to-map');
require('../modules/esnext.array.is-template-object');
require('../modules/esnext.array.last-index');
require('../modules/esnext.array.last-item');
require('../modules/esnext.array.to-reversed');
require('../modules/esnext.array.to-sorted');
require('../modules/esnext.array.to-spliced');
require('../modules/esnext.array.unique-by');
require('../modules/esnext.array.with');
require('../modules/esnext.async-iterator.constructor');
require('../modules/esnext.async-iterator.as-indexed-pairs');
require('../modules/esnext.async-iterator.drop');
require('../modules/esnext.async-iterator.every');
require('../modules/esnext.async-iterator.filter');
require('../modules/esnext.async-iterator.find');
require('../modules/esnext.async-iterator.flat-map');
require('../modules/esnext.async-iterator.for-each');
require('../modules/esnext.async-iterator.from');
require('../modules/esnext.async-iterator.map');
require('../modules/esnext.async-iterator.reduce');
require('../modules/esnext.async-iterator.some');
require('../modules/esnext.async-iterator.take');
require('../modules/esnext.async-iterator.to-array');
require('../modules/esnext.bigint.range');
require('../modules/esnext.composite-key');
require('../modules/esnext.composite-symbol');
require('../modules/esnext.function.is-callable');
require('../modules/esnext.function.is-constructor');
require('../modules/esnext.function.un-this');
require('../modules/esnext.global-this');
require('../modules/esnext.iterator.constructor');
require('../modules/esnext.iterator.as-indexed-pairs');
require('../modules/esnext.iterator.drop');
require('../modules/esnext.iterator.every');
require('../modules/esnext.iterator.filter');
require('../modules/esnext.iterator.find');
require('../modules/esnext.iterator.flat-map');
require('../modules/esnext.iterator.for-each');
require('../modules/esnext.iterator.from');
require('../modules/esnext.iterator.map');
require('../modules/esnext.iterator.reduce');
require('../modules/esnext.iterator.some');
require('../modules/esnext.iterator.take');
require('../modules/esnext.iterator.to-array');
require('../modules/esnext.iterator.to-async');
require('../modules/esnext.map.delete-all');
require('../modules/esnext.map.emplace');
require('../modules/esnext.map.every');
require('../modules/esnext.map.filter');
require('../modules/esnext.map.find');
require('../modules/esnext.map.find-key');
require('../modules/esnext.map.from');
require('../modules/esnext.map.group-by');
require('../modules/esnext.map.includes');
require('../modules/esnext.map.key-by');
require('../modules/esnext.map.key-of');
require('../modules/esnext.map.map-keys');
require('../modules/esnext.map.map-values');
require('../modules/esnext.map.merge');
require('../modules/esnext.map.of');
require('../modules/esnext.map.reduce');
require('../modules/esnext.map.some');
require('../modules/esnext.map.update');
require('../modules/esnext.map.update-or-insert');
require('../modules/esnext.map.upsert');
require('../modules/esnext.math.clamp');
require('../modules/esnext.math.deg-per-rad');
require('../modules/esnext.math.degrees');
require('../modules/esnext.math.fscale');
require('../modules/esnext.math.iaddh');
require('../modules/esnext.math.imulh');
require('../modules/esnext.math.isubh');
require('../modules/esnext.math.rad-per-deg');
require('../modules/esnext.math.radians');
require('../modules/esnext.math.scale');
require('../modules/esnext.math.seeded-prng');
require('../modules/esnext.math.signbit');
require('../modules/esnext.math.umulh');
require('../modules/esnext.number.from-string');
require('../modules/esnext.number.range');
require('../modules/esnext.object.has-own');
require('../modules/esnext.object.iterate-entries');
require('../modules/esnext.object.iterate-keys');
require('../modules/esnext.object.iterate-values');
require('../modules/esnext.observable');
require('../modules/esnext.promise.all-settled');
require('../modules/esnext.promise.any');
require('../modules/esnext.promise.try');
require('../modules/esnext.reflect.define-metadata');
require('../modules/esnext.reflect.delete-metadata');
require('../modules/esnext.reflect.get-metadata');
require('../modules/esnext.reflect.get-metadata-keys');
require('../modules/esnext.reflect.get-own-metadata');
require('../modules/esnext.reflect.get-own-metadata-keys');
require('../modules/esnext.reflect.has-metadata');
require('../modules/esnext.reflect.has-own-metadata');
require('../modules/esnext.reflect.metadata');
require('../modules/esnext.set.add-all');
require('../modules/esnext.set.delete-all');
require('../modules/esnext.set.difference');
require('../modules/esnext.set.every');
require('../modules/esnext.set.filter');
require('../modules/esnext.set.find');
require('../modules/esnext.set.from');
require('../modules/esnext.set.intersection');
require('../modules/esnext.set.is-disjoint-from');
require('../modules/esnext.set.is-subset-of');
require('../modules/esnext.set.is-superset-of');
require('../modules/esnext.set.join');
require('../modules/esnext.set.map');
require('../modules/esnext.set.of');
require('../modules/esnext.set.reduce');
require('../modules/esnext.set.some');
require('../modules/esnext.set.symmetric-difference');
require('../modules/esnext.set.union');
require('../modules/esnext.string.at');
require('../modules/esnext.string.cooked');
require('../modules/esnext.string.code-points');
require('../modules/esnext.string.match-all');
require('../modules/esnext.string.replace-all');
require('../modules/esnext.symbol.async-dispose');
require('../modules/esnext.symbol.dispose');
require('../modules/esnext.symbol.matcher');
require('../modules/esnext.symbol.metadata');
require('../modules/esnext.symbol.observable');
require('../modules/esnext.symbol.pattern-match');
require('../modules/esnext.symbol.replace-all');
require('../modules/esnext.typed-array.from-async');
require('../modules/esnext.typed-array.at');
require('../modules/esnext.typed-array.filter-out');
require('../modules/esnext.typed-array.filter-reject');
require('../modules/esnext.typed-array.find-last');
require('../modules/esnext.typed-array.find-last-index');
require('../modules/esnext.typed-array.group-by');
require('../modules/esnext.typed-array.to-reversed');
require('../modules/esnext.typed-array.to-sorted');
require('../modules/esnext.typed-array.to-spliced');
require('../modules/esnext.typed-array.unique-by');
require('../modules/esnext.typed-array.with');
require('../modules/esnext.weak-map.delete-all');
require('../modules/esnext.weak-map.from');
require('../modules/esnext.weak-map.of');
require('../modules/esnext.weak-map.emplace');
require('../modules/esnext.weak-map.upsert');
require('../modules/esnext.weak-set.add-all');
require('../modules/esnext.weak-set.delete-all');
require('../modules/esnext.weak-set.from');
require('../modules/esnext.weak-set.of');
require('../modules/web.dom-collections.for-each');
require('../modules/web.dom-collections.iterator');
require('../modules/web.dom-exception.constructor');
require('../modules/web.dom-exception.stack');
require('../modules/web.dom-exception.to-string-tag');
require('../modules/web.immediate');
require('../modules/web.queue-microtask');
require('../modules/web.structured-clone');
require('../modules/web.timers');
require('../modules/web.url');
require('../modules/web.url.to-json');
require('../modules/web.url-search-params');
module.exports = require('../internals/path');

},{"../modules/es.symbol":"cn8Ok","../modules/es.symbol.description":"TdRlp","../modules/es.symbol.async-iterator":"ihdMq","../modules/es.symbol.has-instance":"9Mkmh","../modules/es.symbol.is-concat-spreadable":"9wmiv","../modules/es.symbol.iterator":"2mIbY","../modules/es.symbol.match":"44uyZ","../modules/es.symbol.match-all":"kVLfA","../modules/es.symbol.replace":"6HjgK","../modules/es.symbol.search":"689vN","../modules/es.symbol.species":"4nGCq","../modules/es.symbol.split":"5f6H5","../modules/es.symbol.to-primitive":"eh2Ju","../modules/es.symbol.to-string-tag":"eTBog","../modules/es.symbol.unscopables":"ljFuZ","../modules/es.error.cause":"aqHio","../modules/es.error.to-string":"dJ5Ap","../modules/es.aggregate-error":"j0Eys","../modules/es.aggregate-error.cause":"hF3Zy","../modules/es.array.at":"jo7av","../modules/es.array.concat":"hZv4u","../modules/es.array.copy-within":"lpZOH","../modules/es.array.every":"7h9iA","../modules/es.array.fill":"8QWQB","../modules/es.array.filter":"6MJ0X","../modules/es.array.find":"8KdiF","../modules/es.array.find-index":"c2wrk","../modules/es.array.flat":"iXBaL","../modules/es.array.flat-map":"6XfAZ","../modules/es.array.for-each":"4BjMF","../modules/es.array.from":"6k4iU","../modules/es.array.includes":"2opYk","../modules/es.array.index-of":"fclII","../modules/es.array.is-array":"8Ekd6","../modules/es.array.iterator":"bLuDU","../modules/es.array.join":"7ggFm","../modules/es.array.last-index-of":"9cdXg","../modules/es.array.map":"i0aqD","../modules/es.array.of":"9zSOw","../modules/es.array.reduce":"8W8UG","../modules/es.array.reduce-right":"9rWU2","../modules/es.array.reverse":"9QaOG","../modules/es.array.slice":"4FAgT","../modules/es.array.some":"1kmsQ","../modules/es.array.sort":"6yZcJ","../modules/es.array.species":"59wEf","../modules/es.array.splice":"fFvxO","../modules/es.array.unscopables.flat":"kxzUm","../modules/es.array.unscopables.flat-map":"fWXha","../modules/es.array-buffer.constructor":"iMKfl","../modules/es.array-buffer.is-view":"6Wt3y","../modules/es.array-buffer.slice":"aTGHe","../modules/es.data-view":"14b9P","../modules/es.date.get-year":"DuEIw","../modules/es.date.now":"2eHz3","../modules/es.date.set-year":"jQnkS","../modules/es.date.to-gmt-string":"2bG0B","../modules/es.date.to-iso-string":"72zEL","../modules/es.date.to-json":"k6wIs","../modules/es.date.to-primitive":"1hEtM","../modules/es.date.to-string":"i9lAX","../modules/es.escape":"k9DQ7","../modules/es.function.bind":"8v673","../modules/es.function.has-instance":"cmqa2","../modules/es.function.name":"kYqsO","../modules/es.global-this":"3I5ZQ","../modules/es.json.stringify":"6eewm","../modules/es.json.to-string-tag":"fVE60","../modules/es.map":"ayxWX","../modules/es.math.acosh":"1v5kF","../modules/es.math.asinh":"eSOGV","../modules/es.math.atanh":"iqYu2","../modules/es.math.cbrt":"7NViC","../modules/es.math.clz32":"iOLyn","../modules/es.math.cosh":"aCMZ8","../modules/es.math.expm1":"Rejd3","../modules/es.math.fround":"aHwOt","../modules/es.math.hypot":"fCCrs","../modules/es.math.imul":"gLxis","../modules/es.math.log10":"7LS2V","../modules/es.math.log1p":"k96xt","../modules/es.math.log2":"3Uu1S","../modules/es.math.sign":"8oTXY","../modules/es.math.sinh":"NNqsf","../modules/es.math.tanh":"c0L87","../modules/es.math.to-string-tag":"eGSGW","../modules/es.math.trunc":"3G59j","../modules/es.number.constructor":"1GiiH","../modules/es.number.epsilon":"gBHjr","../modules/es.number.is-finite":"ihkUc","../modules/es.number.is-integer":"26hJ1","../modules/es.number.is-nan":"byONP","../modules/es.number.is-safe-integer":"5upSm","../modules/es.number.max-safe-integer":"cSyXk","../modules/es.number.min-safe-integer":"6iXsJ","../modules/es.number.parse-float":"9ZUeM","../modules/es.number.parse-int":"bbKgY","../modules/es.number.to-exponential":"kVrcj","../modules/es.number.to-fixed":"9LVCp","../modules/es.number.to-precision":"eheVs","../modules/es.object.assign":"d9U4P","../modules/es.object.create":"2OzxE","../modules/es.object.define-getter":"rUotD","../modules/es.object.define-properties":"7N8aI","../modules/es.object.define-property":"43HUr","../modules/es.object.define-setter":"6pPBW","../modules/es.object.entries":"65Ttp","../modules/es.object.freeze":"95squ","../modules/es.object.from-entries":"Hyj7V","../modules/es.object.get-own-property-descriptor":"ktsyI","../modules/es.object.get-own-property-descriptors":"kDpK6","../modules/es.object.get-own-property-names":"bf1Ns","../modules/es.object.get-prototype-of":"lrIcR","../modules/es.object.has-own":"fwKd5","../modules/es.object.is":"AZbGS","../modules/es.object.is-extensible":"8opwh","../modules/es.object.is-frozen":"c0NSD","../modules/es.object.is-sealed":"ku0Er","../modules/es.object.keys":"5whyw","../modules/es.object.lookup-getter":"daJYk","../modules/es.object.lookup-setter":"hW914","../modules/es.object.prevent-extensions":"lgjwP","../modules/es.object.seal":"iSUTX","../modules/es.object.set-prototype-of":"5guzB","../modules/es.object.to-string":"wRGKV","../modules/es.object.values":"8yXbZ","../modules/es.parse-float":"8K5Js","../modules/es.parse-int":"8F8si","../modules/es.promise":"8nMUv","../modules/es.promise.all-settled":"drqVJ","../modules/es.promise.any":"6J3yz","../modules/es.promise.finally":"knKVr","../modules/es.reflect.apply":"jKk5w","../modules/es.reflect.construct":"c6DZw","../modules/es.reflect.define-property":"bYULV","../modules/es.reflect.delete-property":"iz4MV","../modules/es.reflect.get":"k2Fmj","../modules/es.reflect.get-own-property-descriptor":"aepGb","../modules/es.reflect.get-prototype-of":"azie1","../modules/es.reflect.has":"hIAaJ","../modules/es.reflect.is-extensible":"75Mar","../modules/es.reflect.own-keys":"ayzfz","../modules/es.reflect.prevent-extensions":"lp3Ou","../modules/es.reflect.set":"4NxGA","../modules/es.reflect.set-prototype-of":"xbAth","../modules/es.reflect.to-string-tag":"52bAT","../modules/es.regexp.constructor":"hhsNe","../modules/es.regexp.dot-all":"3shaH","../modules/es.regexp.exec":"1vrnL","../modules/es.regexp.flags":"6Ugwt","../modules/es.regexp.sticky":"fBzp5","../modules/es.regexp.test":"7KtW6","../modules/es.regexp.to-string":"dhZg0","../modules/es.set":"8dCmg","../modules/es.string.at-alternative":"hbXFo","../modules/es.string.code-point-at":"4sQAm","../modules/es.string.ends-with":"jWSjD","../modules/es.string.from-code-point":"3eS7x","../modules/es.string.includes":"CsNki","../modules/es.string.iterator":"b0sE2","../modules/es.string.match":"d8k57","../modules/es.string.match-all":"hNQS5","../modules/es.string.pad-end":"93KvT","../modules/es.string.pad-start":"iZS0g","../modules/es.string.raw":"5GoQv","../modules/es.string.repeat":"eBErx","../modules/es.string.replace":"bbUl2","../modules/es.string.replace-all":"3DDbg","../modules/es.string.search":"aRDsg","../modules/es.string.split":"eWFDr","../modules/es.string.starts-with":"eH6fZ","../modules/es.string.substr":"wWZGf","../modules/es.string.trim":"iHEeA","../modules/es.string.trim-end":"l55Rx","../modules/es.string.trim-start":"8F6Kw","../modules/es.string.anchor":"93wbJ","../modules/es.string.big":"46Sza","../modules/es.string.blink":"eKWOl","../modules/es.string.bold":"54FVv","../modules/es.string.fixed":"9IBmc","../modules/es.string.fontcolor":"84dI7","../modules/es.string.fontsize":"39t2d","../modules/es.string.italics":"66Iat","../modules/es.string.link":"3RAvD","../modules/es.string.small":"bZDHb","../modules/es.string.strike":"31OJy","../modules/es.string.sub":"aFIua","../modules/es.string.sup":"3RzhA","../modules/es.typed-array.float32-array":"ep1pl","../modules/es.typed-array.float64-array":"idfXY","../modules/es.typed-array.int8-array":"kbnYC","../modules/es.typed-array.int16-array":"46Ijs","../modules/es.typed-array.int32-array":"l06wp","../modules/es.typed-array.uint8-array":"l5EEt","../modules/es.typed-array.uint8-clamped-array":"cp2gb","../modules/es.typed-array.uint16-array":"gEEQI","../modules/es.typed-array.uint32-array":"lm14q","../modules/es.typed-array.at":"eSUgO","../modules/es.typed-array.copy-within":"gGJHn","../modules/es.typed-array.every":"hBvO4","../modules/es.typed-array.fill":"4utKX","../modules/es.typed-array.filter":"izheQ","../modules/es.typed-array.find":"YMlI3","../modules/es.typed-array.find-index":"aZxn3","../modules/es.typed-array.for-each":"jD85u","../modules/es.typed-array.from":"jlZLn","../modules/es.typed-array.includes":"2gl1y","../modules/es.typed-array.index-of":"kXPbg","../modules/es.typed-array.iterator":"jUDTl","../modules/es.typed-array.join":"cMZaK","../modules/es.typed-array.last-index-of":"OvuT4","../modules/es.typed-array.map":"ePlyz","../modules/es.typed-array.of":"avnFD","../modules/es.typed-array.reduce":"b0apc","../modules/es.typed-array.reduce-right":"4TSIU","../modules/es.typed-array.reverse":"iMuym","../modules/es.typed-array.set":"i2kBQ","../modules/es.typed-array.slice":"h67Ud","../modules/es.typed-array.some":"jZLEc","../modules/es.typed-array.sort":"a5k4K","../modules/es.typed-array.subarray":"1curj","../modules/es.typed-array.to-locale-string":"9YOPt","../modules/es.typed-array.to-string":"fzEVR","../modules/es.unescape":"gTLOR","../modules/es.weak-map":"lEfis","../modules/es.weak-set":"cSvCc","../modules/esnext.aggregate-error":"70EYB","../modules/esnext.array.from-async":"ktLIO","../modules/esnext.array.at":"di5CS","../modules/esnext.array.filter-out":"ccrhr","../modules/esnext.array.filter-reject":"4e7QK","../modules/esnext.array.find-last":"62TqK","../modules/esnext.array.find-last-index":"cpUL5","../modules/esnext.array.group-by":"9Ud4n","../modules/esnext.array.group-by-to-map":"gyeat","../modules/esnext.array.is-template-object":"g7cAj","../modules/esnext.array.last-index":"6p2xc","../modules/esnext.array.last-item":"4kVea","../modules/esnext.array.to-reversed":"gV8bc","../modules/esnext.array.to-sorted":"3ivwY","../modules/esnext.array.to-spliced":"g115k","../modules/esnext.array.unique-by":"7d8QQ","../modules/esnext.array.with":"lsRPZ","../modules/esnext.async-iterator.constructor":"eMV4r","../modules/esnext.async-iterator.as-indexed-pairs":"1TCwH","../modules/esnext.async-iterator.drop":"cYNpf","../modules/esnext.async-iterator.every":"dnh5V","../modules/esnext.async-iterator.filter":"hssZz","../modules/esnext.async-iterator.find":"iFZL2","../modules/esnext.async-iterator.flat-map":"4L5wI","../modules/esnext.async-iterator.for-each":"2NZEj","../modules/esnext.async-iterator.from":"4I85Q","../modules/esnext.async-iterator.map":"26Mtn","../modules/esnext.async-iterator.reduce":"Y3GEp","../modules/esnext.async-iterator.some":"gWclC","../modules/esnext.async-iterator.take":"bt9Td","../modules/esnext.async-iterator.to-array":"iTt4i","../modules/esnext.bigint.range":"7Yfjk","../modules/esnext.composite-key":"9oI2D","../modules/esnext.composite-symbol":"4cZHd","../modules/esnext.function.is-callable":"1qlYY","../modules/esnext.function.is-constructor":"h2oIG","../modules/esnext.function.un-this":"htuAE","../modules/esnext.global-this":"euics","../modules/esnext.iterator.constructor":"hhAVF","../modules/esnext.iterator.as-indexed-pairs":"6B0J9","../modules/esnext.iterator.drop":"k1ek5","../modules/esnext.iterator.every":"6rXrL","../modules/esnext.iterator.filter":"iVsDp","../modules/esnext.iterator.find":"9BC4R","../modules/esnext.iterator.flat-map":"6neKF","../modules/esnext.iterator.for-each":"7S92S","../modules/esnext.iterator.from":"hpOTI","../modules/esnext.iterator.map":"a6W9Q","../modules/esnext.iterator.reduce":"YIpsq","../modules/esnext.iterator.some":"7DnaM","../modules/esnext.iterator.take":"7ID7Q","../modules/esnext.iterator.to-array":"7TI8P","../modules/esnext.iterator.to-async":"8jp9R","../modules/esnext.map.delete-all":"2YiIi","../modules/esnext.map.emplace":"bOO2p","../modules/esnext.map.every":"gyAAN","../modules/esnext.map.filter":"aej1a","../modules/esnext.map.find":"gdx3a","../modules/esnext.map.find-key":"4oJli","../modules/esnext.map.from":"ebR4F","../modules/esnext.map.group-by":"adTFE","../modules/esnext.map.includes":"02KWf","../modules/esnext.map.key-by":"hG3nB","../modules/esnext.map.key-of":"bVfpe","../modules/esnext.map.map-keys":"dNgs8","../modules/esnext.map.map-values":"1ynz9","../modules/esnext.map.merge":"1BNOD","../modules/esnext.map.of":"hGshw","../modules/esnext.map.reduce":"92SIE","../modules/esnext.map.some":"eXnP7","../modules/esnext.map.update":"2dDW5","../modules/esnext.map.update-or-insert":"gnbfb","../modules/esnext.map.upsert":"bEOE2","../modules/esnext.math.clamp":"kH4QW","../modules/esnext.math.deg-per-rad":"jJkpH","../modules/esnext.math.degrees":"lMntd","../modules/esnext.math.fscale":"f4pY4","../modules/esnext.math.iaddh":"gU7xA","../modules/esnext.math.imulh":"gSmGL","../modules/esnext.math.isubh":"ai2ZI","../modules/esnext.math.rad-per-deg":"5Xw5Q","../modules/esnext.math.radians":"3pizV","../modules/esnext.math.scale":"1Hici","../modules/esnext.math.seeded-prng":"ltxqc","../modules/esnext.math.signbit":"93Af1","../modules/esnext.math.umulh":"8FapI","../modules/esnext.number.from-string":"dcrra","../modules/esnext.number.range":"bwLIP","../modules/esnext.object.has-own":"cv3dG","../modules/esnext.object.iterate-entries":"eav8f","../modules/esnext.object.iterate-keys":"Tv2RH","../modules/esnext.object.iterate-values":"gw6b3","../modules/esnext.observable":"aFQ7a","../modules/esnext.promise.all-settled":"1EjGT","../modules/esnext.promise.any":"kCS9D","../modules/esnext.promise.try":"eJs6O","../modules/esnext.reflect.define-metadata":"kBQIa","../modules/esnext.reflect.delete-metadata":"4gsYN","../modules/esnext.reflect.get-metadata":"7sMI1","../modules/esnext.reflect.get-metadata-keys":"4wehQ","../modules/esnext.reflect.get-own-metadata":"lyeG8","../modules/esnext.reflect.get-own-metadata-keys":"67yRm","../modules/esnext.reflect.has-metadata":"4RJ2Z","../modules/esnext.reflect.has-own-metadata":"fgTte","../modules/esnext.reflect.metadata":"iolfU","../modules/esnext.set.add-all":"jv0cJ","../modules/esnext.set.delete-all":"3Wgu2","../modules/esnext.set.difference":"hFHYU","../modules/esnext.set.every":"7zC6t","../modules/esnext.set.filter":"gSQqX","../modules/esnext.set.find":"hhbAH","../modules/esnext.set.from":"aGi3H","../modules/esnext.set.intersection":"gpRel","../modules/esnext.set.is-disjoint-from":"BQOKB","../modules/esnext.set.is-subset-of":"94dBs","../modules/esnext.set.is-superset-of":"lfTb9","../modules/esnext.set.join":"byvs7","../modules/esnext.set.map":"iwGoP","../modules/esnext.set.of":"bJUYk","../modules/esnext.set.reduce":"7UiJD","../modules/esnext.set.some":"gJ8rp","../modules/esnext.set.symmetric-difference":"kG944","../modules/esnext.set.union":"6zkeN","../modules/esnext.string.at":"2dQvW","../modules/esnext.string.cooked":"ijNn8","../modules/esnext.string.code-points":"1GQw4","../modules/esnext.string.match-all":"c3ZN3","../modules/esnext.string.replace-all":"elCVp","../modules/esnext.symbol.async-dispose":"d5Hvw","../modules/esnext.symbol.dispose":"91OZ3","../modules/esnext.symbol.matcher":"7e0KR","../modules/esnext.symbol.metadata":"1rAX6","../modules/esnext.symbol.observable":"lUJcr","../modules/esnext.symbol.pattern-match":"20Egz","../modules/esnext.symbol.replace-all":"6Oysi","../modules/esnext.typed-array.from-async":"3lGbr","../modules/esnext.typed-array.at":"ezffH","../modules/esnext.typed-array.filter-out":"aC7FP","../modules/esnext.typed-array.filter-reject":"3nhN5","../modules/esnext.typed-array.find-last":"epong","../modules/esnext.typed-array.find-last-index":"ex7Ja","../modules/esnext.typed-array.group-by":"awKab","../modules/esnext.typed-array.to-reversed":"b9379","../modules/esnext.typed-array.to-sorted":"jhhlF","../modules/esnext.typed-array.to-spliced":"bwpqF","../modules/esnext.typed-array.unique-by":"gGjlC","../modules/esnext.typed-array.with":"bEgOQ","../modules/esnext.weak-map.delete-all":"jJPKp","../modules/esnext.weak-map.from":"28OCP","../modules/esnext.weak-map.of":"48CKd","../modules/esnext.weak-map.emplace":"9mTD5","../modules/esnext.weak-map.upsert":"juSVe","../modules/esnext.weak-set.add-all":"dSVOD","../modules/esnext.weak-set.delete-all":"beZeG","../modules/esnext.weak-set.from":"aAw8l","../modules/esnext.weak-set.of":"3wee4","../modules/web.dom-collections.for-each":"d06QC","../modules/web.dom-collections.iterator":"cNl8W","../modules/web.dom-exception.constructor":"jKOFN","../modules/web.dom-exception.stack":"b7W4C","../modules/web.dom-exception.to-string-tag":"ewDGe","../modules/web.immediate":"bzVdw","../modules/web.queue-microtask":"jDEHx","../modules/web.structured-clone":"21ror","../modules/web.timers":"7iQ00","../modules/web.url":"fQSbp","../modules/web.url.to-json":"gk5Ay","../modules/web.url-search-params":"gLlKq","../internals/path":"f1yhZ"}],"cn8Ok":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var global = require('../internals/global');
var getBuiltIn = require('../internals/get-built-in');
var apply = require('../internals/function-apply');
var call = require('../internals/function-call');
var uncurryThis = require('../internals/function-uncurry-this');
var IS_PURE = require('../internals/is-pure');
var DESCRIPTORS = require('../internals/descriptors');
var NATIVE_SYMBOL = require('../internals/native-symbol');
var fails = require('../internals/fails');
var hasOwn = require('../internals/has-own-property');
var isArray = require('../internals/is-array');
var isCallable = require('../internals/is-callable');
var isObject = require('../internals/is-object');
var isPrototypeOf = require('../internals/object-is-prototype-of');
var isSymbol = require('../internals/is-symbol');
var anObject = require('../internals/an-object');
var toObject = require('../internals/to-object');
var toIndexedObject = require('../internals/to-indexed-object');
var toPropertyKey = require('../internals/to-property-key');
var $toString = require('../internals/to-string');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var nativeObjectCreate = require('../internals/object-create');
var objectKeys = require('../internals/object-keys');
var getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');
var getOwnPropertyNamesExternal = require('../internals/object-get-own-property-names-external');
var getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
var definePropertyModule = require('../internals/object-define-property');
var definePropertiesModule = require('../internals/object-define-properties');
var propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');
var arraySlice = require('../internals/array-slice');
var redefine = require('../internals/redefine');
var shared = require('../internals/shared');
var sharedKey = require('../internals/shared-key');
var hiddenKeys = require('../internals/hidden-keys');
var uid = require('../internals/uid');
var wellKnownSymbol = require('../internals/well-known-symbol');
var wrappedWellKnownSymbolModule = require('../internals/well-known-symbol-wrapped');
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
var setToStringTag = require('../internals/set-to-string-tag');
var InternalStateModule = require('../internals/internal-state');
var $forEach = require('../internals/array-iteration').forEach;
var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE = 'prototype';
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SYMBOL);
var ObjectPrototype = Object[PROTOTYPE];
var $Symbol = global.Symbol;
var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
var TypeError = global.TypeError;
var QObject = global.QObject;
var $stringify = getBuiltIn('JSON', 'stringify');
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var push = uncurryThis([].push);
var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');
var WellKnownSymbolsStore = shared('wks');
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDescriptor = DESCRIPTORS && fails(function() {
    return nativeObjectCreate(nativeDefineProperty({
    }, 'a', {
        get: function() {
            return nativeDefineProperty(this, 'a', {
                value: 7
            }).a;
        }
    })).a != 7;
}) ? function(O, P, Attributes) {
    var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
    if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
    nativeDefineProperty(O, P, Attributes);
    if (ObjectPrototypeDescriptor && O !== ObjectPrototype) nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
} : nativeDefineProperty;
var wrap = function(tag, description) {
    var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
    setInternalState(symbol, {
        type: SYMBOL,
        tag: tag,
        description: description
    });
    if (!DESCRIPTORS) symbol.description = description;
    return symbol;
};
var $defineProperty = function defineProperty(O, P, Attributes) {
    if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
    anObject(O);
    var key = toPropertyKey(P);
    anObject(Attributes);
    if (hasOwn(AllSymbols, key)) {
        if (!Attributes.enumerable) {
            if (!hasOwn(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {
            }));
            O[HIDDEN][key] = true;
        } else {
            if (hasOwn(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
            Attributes = nativeObjectCreate(Attributes, {
                enumerable: createPropertyDescriptor(0, false)
            });
        }
        return setSymbolDescriptor(O, key, Attributes);
    }
    return nativeDefineProperty(O, key, Attributes);
};
var $defineProperties = function defineProperties(O, Properties) {
    anObject(O);
    var properties = toIndexedObject(Properties);
    var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
    $forEach(keys, function(key) {
        if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key)) $defineProperty(O, key, properties[key]);
    });
    return O;
};
var $create = function create(O, Properties) {
    return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};
var $propertyIsEnumerable = function propertyIsEnumerable(V) {
    var P = toPropertyKey(V);
    var enumerable = call(nativePropertyIsEnumerable, this, P);
    if (this === ObjectPrototype && hasOwn(AllSymbols, P) && !hasOwn(ObjectPrototypeSymbols, P)) return false;
    return enumerable || !hasOwn(this, P) || !hasOwn(AllSymbols, P) || hasOwn(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
    var it = toIndexedObject(O);
    var key = toPropertyKey(P);
    if (it === ObjectPrototype && hasOwn(AllSymbols, key) && !hasOwn(ObjectPrototypeSymbols, key)) return;
    var descriptor = nativeGetOwnPropertyDescriptor(it, key);
    if (descriptor && hasOwn(AllSymbols, key) && !(hasOwn(it, HIDDEN) && it[HIDDEN][key])) descriptor.enumerable = true;
    return descriptor;
};
var $getOwnPropertyNames = function getOwnPropertyNames(O) {
    var names = nativeGetOwnPropertyNames(toIndexedObject(O));
    var result = [];
    $forEach(names, function(key) {
        if (!hasOwn(AllSymbols, key) && !hasOwn(hiddenKeys, key)) push(result, key);
    });
    return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
    var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
    var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
    var result = [];
    $forEach(names, function(key) {
        if (hasOwn(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key))) push(result, AllSymbols[key]);
    });
    return result;
};
// `Symbol` constructor
// https://tc39.es/ecma262/#sec-symbol-constructor
if (!NATIVE_SYMBOL) {
    $Symbol = function Symbol() {
        if (isPrototypeOf(SymbolPrototype, this)) throw TypeError('Symbol is not a constructor');
        var description = !arguments.length || arguments[0] === undefined ? undefined : $toString(arguments[0]);
        var tag = uid(description);
        var setter = function(value) {
            if (this === ObjectPrototype) call(setter, ObjectPrototypeSymbols, value);
            if (hasOwn(this, HIDDEN) && hasOwn(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
            setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
        };
        if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, {
            configurable: true,
            set: setter
        });
        return wrap(tag, description);
    };
    SymbolPrototype = $Symbol[PROTOTYPE];
    redefine(SymbolPrototype, 'toString', function toString() {
        return getInternalState(this).tag;
    });
    redefine($Symbol, 'withoutSetter', function(description) {
        return wrap(uid(description), description);
    });
    propertyIsEnumerableModule.f = $propertyIsEnumerable;
    definePropertyModule.f = $defineProperty;
    definePropertiesModule.f = $defineProperties;
    getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
    getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
    getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
    wrappedWellKnownSymbolModule.f = function(name) {
        return wrap(wellKnownSymbol(name), name);
    };
    if (DESCRIPTORS) {
        // https://github.com/tc39/proposal-Symbol-description
        nativeDefineProperty(SymbolPrototype, 'description', {
            configurable: true,
            get: function description() {
                return getInternalState(this).description;
            }
        });
        if (!IS_PURE) redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, {
            unsafe: true
        });
    }
}
$({
    global: true,
    wrap: true,
    forced: !NATIVE_SYMBOL,
    sham: !NATIVE_SYMBOL
}, {
    Symbol: $Symbol
});
$forEach(objectKeys(WellKnownSymbolsStore), function(name) {
    defineWellKnownSymbol(name);
});
$({
    target: SYMBOL,
    stat: true,
    forced: !NATIVE_SYMBOL
}, {
    // `Symbol.for` method
    // https://tc39.es/ecma262/#sec-symbol.for
    'for': function(key) {
        var string = $toString(key);
        if (hasOwn(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
        var symbol = $Symbol(string);
        StringToSymbolRegistry[string] = symbol;
        SymbolToStringRegistry[symbol] = string;
        return symbol;
    },
    // `Symbol.keyFor` method
    // https://tc39.es/ecma262/#sec-symbol.keyfor
    keyFor: function keyFor(sym) {
        if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
        if (hasOwn(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
    },
    useSetter: function() {
        USE_SETTER = true;
    },
    useSimple: function() {
        USE_SETTER = false;
    }
});
$({
    target: 'Object',
    stat: true,
    forced: !NATIVE_SYMBOL,
    sham: !DESCRIPTORS
}, {
    // `Object.create` method
    // https://tc39.es/ecma262/#sec-object.create
    create: $create,
    // `Object.defineProperty` method
    // https://tc39.es/ecma262/#sec-object.defineproperty
    defineProperty: $defineProperty,
    // `Object.defineProperties` method
    // https://tc39.es/ecma262/#sec-object.defineproperties
    defineProperties: $defineProperties,
    // `Object.getOwnPropertyDescriptor` method
    // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});
$({
    target: 'Object',
    stat: true,
    forced: !NATIVE_SYMBOL
}, {
    // `Object.getOwnPropertyNames` method
    // https://tc39.es/ecma262/#sec-object.getownpropertynames
    getOwnPropertyNames: $getOwnPropertyNames,
    // `Object.getOwnPropertySymbols` method
    // https://tc39.es/ecma262/#sec-object.getownpropertysymbols
    getOwnPropertySymbols: $getOwnPropertySymbols
});
// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
$({
    target: 'Object',
    stat: true,
    forced: fails(function() {
        getOwnPropertySymbolsModule.f(1);
    })
}, {
    getOwnPropertySymbols: function getOwnPropertySymbols(it) {
        return getOwnPropertySymbolsModule.f(toObject(it));
    }
});
// `JSON.stringify` method behavior with symbols
// https://tc39.es/ecma262/#sec-json.stringify
if ($stringify) {
    var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function() {
        var symbol = $Symbol();
        // MS Edge converts symbol values to JSON as {}
        return $stringify([
            symbol
        ]) != '[null]' || $stringify({
            a: symbol
        }) != '{}' || $stringify(Object(symbol)) != '{}';
    });
    $({
        target: 'JSON',
        stat: true,
        forced: FORCED_JSON_STRINGIFY
    }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        stringify: function stringify(it, replacer, space) {
            var args = arraySlice(arguments);
            var $replacer = replacer;
            if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
            if (!isArray(replacer)) replacer = function(key, value) {
                if (isCallable($replacer)) value = call($replacer, this, key, value);
                if (!isSymbol(value)) return value;
            };
            args[1] = replacer;
            return apply($stringify, null, args);
        }
    });
}
// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
if (!SymbolPrototype[TO_PRIMITIVE]) {
    var valueOf = SymbolPrototype.valueOf;
    // eslint-disable-next-line no-unused-vars -- required for .length
    redefine(SymbolPrototype, TO_PRIMITIVE, function(hint) {
        // TODO: improve hint logic
        return call(valueOf, this);
    });
}
// `Symbol.prototype[@@toStringTag]` property
// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag($Symbol, SYMBOL);
hiddenKeys[HIDDEN] = true;

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/get-built-in":"78arb","../internals/function-apply":"206oi","../internals/function-call":"jhLed","../internals/function-uncurry-this":"jJnXC","../internals/is-pure":"6Bbq0","../internals/descriptors":"6ZLib","../internals/native-symbol":"cBk0s","../internals/fails":"8IfZQ","../internals/has-own-property":"3ZdUC","../internals/is-array":"gN5mt","../internals/is-callable":"kPhuP","../internals/is-object":"dplrD","../internals/object-is-prototype-of":"fyf1A","../internals/is-symbol":"imyt8","../internals/an-object":"1LIz9","../internals/to-object":"eEdae","../internals/to-indexed-object":"8ueFu","../internals/to-property-key":"bMDpS","../internals/to-string":"4cTlm","../internals/create-property-descriptor":"ermgb","../internals/object-create":"1As5O","../internals/object-keys":"9bK4Y","../internals/object-get-own-property-names":"evqXT","../internals/object-get-own-property-names-external":"7r5nw","../internals/object-get-own-property-symbols":"dBB9V","../internals/object-get-own-property-descriptor":"1gCBk","../internals/object-define-property":"bauTd","../internals/object-define-properties":"8PPlc","../internals/object-property-is-enumerable":"bz2pv","../internals/array-slice":"bI1dk","../internals/redefine":"kxbj8","../internals/shared":"7VLeP","../internals/shared-key":"oNjWG","../internals/hidden-keys":"lHxXS","../internals/uid":"eMBx9","../internals/well-known-symbol":"5C8sm","../internals/well-known-symbol-wrapped":"cvrEK","../internals/define-well-known-symbol":"iX7WZ","../internals/set-to-string-tag":"9arwS","../internals/internal-state":"i6AaM","../internals/array-iteration":"8a6lB"}],"8yfGv":[function(require,module,exports) {
var global = require('../internals/global');
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var redefine = require('../internals/redefine');
var setGlobal = require('../internals/set-global');
var copyConstructorProperties = require('../internals/copy-constructor-properties');
var isForced = require('../internals/is-forced');
/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
  options.name        - the .name of the function if it does not match the key
*/ module.exports = function(options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var FORCED, target, key, targetProperty, sourceProperty, descriptor;
    if (GLOBAL) target = global;
    else if (STATIC) target = global[TARGET] || setGlobal(TARGET, {
    });
    else target = (global[TARGET] || {
    }).prototype;
    if (target) for(key in source){
        sourceProperty = source[key];
        if (options.noTargetGet) {
            descriptor = getOwnPropertyDescriptor(target, key);
            targetProperty = descriptor && descriptor.value;
        } else targetProperty = target[key];
        FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
        // contained in target
        if (!FORCED && targetProperty !== undefined) {
            if (typeof sourceProperty == typeof targetProperty) continue;
            copyConstructorProperties(sourceProperty, targetProperty);
        }
        // add a flag to not completely full polyfills
        if (options.sham || targetProperty && targetProperty.sham) createNonEnumerableProperty(sourceProperty, 'sham', true);
        // extend global
        redefine(target, key, sourceProperty, options);
    }
};

},{"../internals/global":"jxPDA","../internals/object-get-own-property-descriptor":"1gCBk","../internals/create-non-enumerable-property":"6Z1es","../internals/redefine":"kxbj8","../internals/set-global":"kehc7","../internals/copy-constructor-properties":"bCh2q","../internals/is-forced":"eTyNf"}],"jxPDA":[function(require,module,exports) {
var global = arguments[3];
var check = function(it) {
    return it && it.Math == Math && it;
};
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports = // eslint-disable-next-line es/no-global-this -- safe
check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || // eslint-disable-next-line no-restricted-globals -- safe
check(typeof self == 'object' && self) || check(typeof global == 'object' && global) || // eslint-disable-next-line no-new-func -- fallback
(function() {
    return this;
})() || Function('return this')();

},{}],"1gCBk":[function(require,module,exports) {
var DESCRIPTORS = require('../internals/descriptors');
var call = require('../internals/function-call');
var propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var toIndexedObject = require('../internals/to-indexed-object');
var toPropertyKey = require('../internals/to-property-key');
var hasOwn = require('../internals/has-own-property');
var IE8_DOM_DEFINE = require('../internals/ie8-dom-define');
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
    O = toIndexedObject(O);
    P = toPropertyKey(P);
    if (IE8_DOM_DEFINE) try {
        return $getOwnPropertyDescriptor(O, P);
    } catch (error) {
    }
    if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};

},{"../internals/descriptors":"6ZLib","../internals/function-call":"jhLed","../internals/object-property-is-enumerable":"bz2pv","../internals/create-property-descriptor":"ermgb","../internals/to-indexed-object":"8ueFu","../internals/to-property-key":"bMDpS","../internals/has-own-property":"3ZdUC","../internals/ie8-dom-define":"8jKhl"}],"6ZLib":[function(require,module,exports) {
var fails = require('../internals/fails');
// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function() {
    // eslint-disable-next-line es/no-object-defineproperty -- required for testing
    return Object.defineProperty({
    }, 1, {
        get: function() {
            return 7;
        }
    })[1] != 7;
});

},{"../internals/fails":"8IfZQ"}],"8IfZQ":[function(require,module,exports) {
module.exports = function(exec) {
    try {
        return !!exec();
    } catch (error) {
        return true;
    }
};

},{}],"jhLed":[function(require,module,exports) {
var NATIVE_BIND = require('../internals/function-bind-native');
var call = Function.prototype.call;
module.exports = NATIVE_BIND ? call.bind(call) : function() {
    return call.apply(call, arguments);
};

},{"../internals/function-bind-native":"7GJc3"}],"7GJc3":[function(require,module,exports) {
var fails = require('../internals/fails');
module.exports = !fails(function() {
    var test = (function() {
    }).bind();
    // eslint-disable-next-line no-prototype-builtins -- safe
    return typeof test != 'function' || test.hasOwnProperty('prototype');
});

},{"../internals/fails":"8IfZQ"}],"bz2pv":[function(require,module,exports) {
'use strict';
var $propertyIsEnumerable = {
}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({
    1: 2
}, 1);
// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
    var descriptor = getOwnPropertyDescriptor(this, V);
    return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;

},{}],"ermgb":[function(require,module,exports) {
module.exports = function(bitmap, value) {
    return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value: value
    };
};

},{}],"8ueFu":[function(require,module,exports) {
// toObject with fallback for non-array-like ES3 strings
var IndexedObject = require('../internals/indexed-object');
var requireObjectCoercible = require('../internals/require-object-coercible');
module.exports = function(it) {
    return IndexedObject(requireObjectCoercible(it));
};

},{"../internals/indexed-object":"e5ccT","../internals/require-object-coercible":"3Qlyo"}],"e5ccT":[function(require,module,exports) {
var global = require('../internals/global');
var uncurryThis = require('../internals/function-uncurry-this');
var fails = require('../internals/fails');
var classof = require('../internals/classof-raw');
var Object = global.Object;
var split = uncurryThis(''.split);
// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function() {
    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
    // eslint-disable-next-line no-prototype-builtins -- safe
    return !Object('z').propertyIsEnumerable(0);
}) ? function(it) {
    return classof(it) == 'String' ? split(it, '') : Object(it);
} : Object;

},{"../internals/global":"jxPDA","../internals/function-uncurry-this":"jJnXC","../internals/fails":"8IfZQ","../internals/classof-raw":"A9m3U"}],"jJnXC":[function(require,module,exports) {
var NATIVE_BIND = require('../internals/function-bind-native');
var FunctionPrototype = Function.prototype;
var bind = FunctionPrototype.bind;
var call = FunctionPrototype.call;
var uncurryThis = NATIVE_BIND && bind.bind(call, call);
module.exports = NATIVE_BIND ? function(fn) {
    return fn && uncurryThis(fn);
} : function(fn) {
    return fn && function() {
        return call.apply(fn, arguments);
    };
};

},{"../internals/function-bind-native":"7GJc3"}],"A9m3U":[function(require,module,exports) {
var uncurryThis = require('../internals/function-uncurry-this');
var toString = uncurryThis({
}.toString);
var stringSlice = uncurryThis(''.slice);
module.exports = function(it) {
    return stringSlice(toString(it), 8, -1);
};

},{"../internals/function-uncurry-this":"jJnXC"}],"3Qlyo":[function(require,module,exports) {
var global = require('../internals/global');
var TypeError = global.TypeError;
// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function(it) {
    if (it == undefined) throw TypeError("Can't call method on " + it);
    return it;
};

},{"../internals/global":"jxPDA"}],"bMDpS":[function(require,module,exports) {
var toPrimitive = require('../internals/to-primitive');
var isSymbol = require('../internals/is-symbol');
// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function(argument) {
    var key = toPrimitive(argument, 'string');
    return isSymbol(key) ? key : key + '';
};

},{"../internals/to-primitive":"ilNgA","../internals/is-symbol":"imyt8"}],"ilNgA":[function(require,module,exports) {
var global = require('../internals/global');
var call = require('../internals/function-call');
var isObject = require('../internals/is-object');
var isSymbol = require('../internals/is-symbol');
var getMethod = require('../internals/get-method');
var ordinaryToPrimitive = require('../internals/ordinary-to-primitive');
var wellKnownSymbol = require('../internals/well-known-symbol');
var TypeError = global.TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function(input, pref) {
    if (!isObject(input) || isSymbol(input)) return input;
    var exoticToPrim = getMethod(input, TO_PRIMITIVE);
    var result;
    if (exoticToPrim) {
        if (pref === undefined) pref = 'default';
        result = call(exoticToPrim, input, pref);
        if (!isObject(result) || isSymbol(result)) return result;
        throw TypeError("Can't convert object to primitive value");
    }
    if (pref === undefined) pref = 'number';
    return ordinaryToPrimitive(input, pref);
};

},{"../internals/global":"jxPDA","../internals/function-call":"jhLed","../internals/is-object":"dplrD","../internals/is-symbol":"imyt8","../internals/get-method":"hEJ6b","../internals/ordinary-to-primitive":"fsThT","../internals/well-known-symbol":"5C8sm"}],"dplrD":[function(require,module,exports) {
var isCallable = require('../internals/is-callable');
module.exports = function(it) {
    return typeof it == 'object' ? it !== null : isCallable(it);
};

},{"../internals/is-callable":"kPhuP"}],"kPhuP":[function(require,module,exports) {
// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
module.exports = function(argument) {
    return typeof argument == 'function';
};

},{}],"imyt8":[function(require,module,exports) {
var global = require('../internals/global');
var getBuiltIn = require('../internals/get-built-in');
var isCallable = require('../internals/is-callable');
var isPrototypeOf = require('../internals/object-is-prototype-of');
var USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');
var Object = global.Object;
module.exports = USE_SYMBOL_AS_UID ? function(it) {
    return typeof it == 'symbol';
} : function(it) {
    var $Symbol = getBuiltIn('Symbol');
    return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, Object(it));
};

},{"../internals/global":"jxPDA","../internals/get-built-in":"78arb","../internals/is-callable":"kPhuP","../internals/object-is-prototype-of":"fyf1A","../internals/use-symbol-as-uid":"b6wgs"}],"78arb":[function(require,module,exports) {
var global = require('../internals/global');
var isCallable = require('../internals/is-callable');
var aFunction = function(argument) {
    return isCallable(argument) ? argument : undefined;
};
module.exports = function(namespace, method) {
    return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
};

},{"../internals/global":"jxPDA","../internals/is-callable":"kPhuP"}],"fyf1A":[function(require,module,exports) {
var uncurryThis = require('../internals/function-uncurry-this');
module.exports = uncurryThis({
}.isPrototypeOf);

},{"../internals/function-uncurry-this":"jJnXC"}],"b6wgs":[function(require,module,exports) {
/* eslint-disable es/no-symbol -- required for testing */ var NATIVE_SYMBOL = require('../internals/native-symbol');
module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == 'symbol';

},{"../internals/native-symbol":"cBk0s"}],"cBk0s":[function(require,module,exports) {
/* eslint-disable es/no-symbol -- required for testing */ var V8_VERSION = require('../internals/engine-v8-version');
var fails = require('../internals/fails');
// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function() {
    var symbol = Symbol();
    // Chrome 38 Symbol has incorrect toString conversion
    // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
    return !String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});

},{"../internals/engine-v8-version":"9gYOM","../internals/fails":"8IfZQ"}],"9gYOM":[function(require,module,exports) {
var global = require('../internals/global');
var userAgent = require('../internals/engine-user-agent');
var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;
if (v8) {
    match = v8.split('.');
    // in old Chrome, versions of V8 isn't V8 = Chrome / 10
    // but their correct versions are not interesting for us
    version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}
// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
    match = userAgent.match(/Edge\/(\d+)/);
    if (!match || match[1] >= 74) {
        match = userAgent.match(/Chrome\/(\d+)/);
        if (match) version = +match[1];
    }
}
module.exports = version;

},{"../internals/global":"jxPDA","../internals/engine-user-agent":"boFeV"}],"boFeV":[function(require,module,exports) {
var getBuiltIn = require('../internals/get-built-in');
module.exports = getBuiltIn('navigator', 'userAgent') || '';

},{"../internals/get-built-in":"78arb"}],"hEJ6b":[function(require,module,exports) {
var aCallable = require('../internals/a-callable');
// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function(V, P) {
    var func = V[P];
    return func == null ? undefined : aCallable(func);
};

},{"../internals/a-callable":"83opn"}],"83opn":[function(require,module,exports) {
var global = require('../internals/global');
var isCallable = require('../internals/is-callable');
var tryToString = require('../internals/try-to-string');
var TypeError = global.TypeError;
// `Assert: IsCallable(argument) is true`
module.exports = function(argument) {
    if (isCallable(argument)) return argument;
    throw TypeError(tryToString(argument) + ' is not a function');
};

},{"../internals/global":"jxPDA","../internals/is-callable":"kPhuP","../internals/try-to-string":"1hxsu"}],"1hxsu":[function(require,module,exports) {
var global = require('../internals/global');
var String = global.String;
module.exports = function(argument) {
    try {
        return String(argument);
    } catch (error) {
        return 'Object';
    }
};

},{"../internals/global":"jxPDA"}],"fsThT":[function(require,module,exports) {
var global = require('../internals/global');
var call = require('../internals/function-call');
var isCallable = require('../internals/is-callable');
var isObject = require('../internals/is-object');
var TypeError = global.TypeError;
// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function(input, pref) {
    var fn, val;
    if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
    if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
    if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
    throw TypeError("Can't convert object to primitive value");
};

},{"../internals/global":"jxPDA","../internals/function-call":"jhLed","../internals/is-callable":"kPhuP","../internals/is-object":"dplrD"}],"5C8sm":[function(require,module,exports) {
var global = require('../internals/global');
var shared = require('../internals/shared');
var hasOwn = require('../internals/has-own-property');
var uid = require('../internals/uid');
var NATIVE_SYMBOL = require('../internals/native-symbol');
var USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');
var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var symbolFor = Symbol && Symbol['for'];
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;
module.exports = function(name) {
    if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
        var description = 'Symbol.' + name;
        if (NATIVE_SYMBOL && hasOwn(Symbol, name)) WellKnownSymbolsStore[name] = Symbol[name];
        else if (USE_SYMBOL_AS_UID && symbolFor) WellKnownSymbolsStore[name] = symbolFor(description);
        else WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
    }
    return WellKnownSymbolsStore[name];
};

},{"../internals/global":"jxPDA","../internals/shared":"7VLeP","../internals/has-own-property":"3ZdUC","../internals/uid":"eMBx9","../internals/native-symbol":"cBk0s","../internals/use-symbol-as-uid":"b6wgs"}],"7VLeP":[function(require,module,exports) {
var IS_PURE = require('../internals/is-pure');
var store = require('../internals/shared-store');
(module.exports = function(key, value) {
    return store[key] || (store[key] = value !== undefined ? value : {
    });
})('versions', []).push({
    version: '3.20.3',
    mode: IS_PURE ? 'pure' : 'global',
    copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',
    license: 'https://github.com/zloirock/core-js/blob/v3.20.3/LICENSE',
    source: 'https://github.com/zloirock/core-js'
});

},{"../internals/is-pure":"6Bbq0","../internals/shared-store":"3QdEO"}],"6Bbq0":[function(require,module,exports) {
module.exports = false;

},{}],"3QdEO":[function(require,module,exports) {
var global = require('../internals/global');
var setGlobal = require('../internals/set-global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {
});
module.exports = store;

},{"../internals/global":"jxPDA","../internals/set-global":"kehc7"}],"kehc7":[function(require,module,exports) {
var global = require('../internals/global');
// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;
module.exports = function(key, value) {
    try {
        defineProperty(global, key, {
            value: value,
            configurable: true,
            writable: true
        });
    } catch (error) {
        global[key] = value;
    }
    return value;
};

},{"../internals/global":"jxPDA"}],"3ZdUC":[function(require,module,exports) {
var uncurryThis = require('../internals/function-uncurry-this');
var toObject = require('../internals/to-object');
var hasOwnProperty = uncurryThis({
}.hasOwnProperty);
// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
module.exports = Object.hasOwn || function hasOwn(it, key) {
    return hasOwnProperty(toObject(it), key);
};

},{"../internals/function-uncurry-this":"jJnXC","../internals/to-object":"eEdae"}],"eEdae":[function(require,module,exports) {
var global = require('../internals/global');
var requireObjectCoercible = require('../internals/require-object-coercible');
var Object = global.Object;
// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function(argument) {
    return Object(requireObjectCoercible(argument));
};

},{"../internals/global":"jxPDA","../internals/require-object-coercible":"3Qlyo"}],"eMBx9":[function(require,module,exports) {
var uncurryThis = require('../internals/function-uncurry-this');
var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1..toString);
module.exports = function(key) {
    return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};

},{"../internals/function-uncurry-this":"jJnXC"}],"8jKhl":[function(require,module,exports) {
var DESCRIPTORS = require('../internals/descriptors');
var fails = require('../internals/fails');
var createElement = require('../internals/document-create-element');
// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function() {
    // eslint-disable-next-line es/no-object-defineproperty -- required for testing
    return Object.defineProperty(createElement('div'), 'a', {
        get: function() {
            return 7;
        }
    }).a != 7;
});

},{"../internals/descriptors":"6ZLib","../internals/fails":"8IfZQ","../internals/document-create-element":"jKd7d"}],"jKd7d":[function(require,module,exports) {
var global = require('../internals/global');
var isObject = require('../internals/is-object');
var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);
module.exports = function(it) {
    return EXISTS ? document.createElement(it) : {
    };
};

},{"../internals/global":"jxPDA","../internals/is-object":"dplrD"}],"6Z1es":[function(require,module,exports) {
var DESCRIPTORS = require('../internals/descriptors');
var definePropertyModule = require('../internals/object-define-property');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
module.exports = DESCRIPTORS ? function(object, key, value) {
    return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function(object, key, value) {
    object[key] = value;
    return object;
};

},{"../internals/descriptors":"6ZLib","../internals/object-define-property":"bauTd","../internals/create-property-descriptor":"ermgb"}],"bauTd":[function(require,module,exports) {
var global = require('../internals/global');
var DESCRIPTORS = require('../internals/descriptors');
var IE8_DOM_DEFINE = require('../internals/ie8-dom-define');
var V8_PROTOTYPE_DEFINE_BUG = require('../internals/v8-prototype-define-bug');
var anObject = require('../internals/an-object');
var toPropertyKey = require('../internals/to-property-key');
var TypeError = global.TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';
// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
    anObject(O);
    P = toPropertyKey(P);
    anObject(Attributes);
    if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
        var current = $getOwnPropertyDescriptor(O, P);
        if (current && current[WRITABLE]) {
            O[P] = Attributes.value;
            Attributes = {
                configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
                enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
                writable: false
            };
        }
    }
    return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
    anObject(O);
    P = toPropertyKey(P);
    anObject(Attributes);
    if (IE8_DOM_DEFINE) try {
        return $defineProperty(O, P, Attributes);
    } catch (error) {
    }
    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
};

},{"../internals/global":"jxPDA","../internals/descriptors":"6ZLib","../internals/ie8-dom-define":"8jKhl","../internals/v8-prototype-define-bug":"cQXpv","../internals/an-object":"1LIz9","../internals/to-property-key":"bMDpS"}],"cQXpv":[function(require,module,exports) {
var DESCRIPTORS = require('../internals/descriptors');
var fails = require('../internals/fails');
// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function() {
    // eslint-disable-next-line es/no-object-defineproperty -- required for testing
    return Object.defineProperty(function() {
    }, 'prototype', {
        value: 42,
        writable: false
    }).prototype != 42;
});

},{"../internals/descriptors":"6ZLib","../internals/fails":"8IfZQ"}],"1LIz9":[function(require,module,exports) {
var global = require('../internals/global');
var isObject = require('../internals/is-object');
var String = global.String;
var TypeError = global.TypeError;
// `Assert: Type(argument) is Object`
module.exports = function(argument) {
    if (isObject(argument)) return argument;
    throw TypeError(String(argument) + ' is not an object');
};

},{"../internals/global":"jxPDA","../internals/is-object":"dplrD"}],"kxbj8":[function(require,module,exports) {
var global = require('../internals/global');
var isCallable = require('../internals/is-callable');
var hasOwn = require('../internals/has-own-property');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var setGlobal = require('../internals/set-global');
var inspectSource = require('../internals/inspect-source');
var InternalStateModule = require('../internals/internal-state');
var CONFIGURABLE_FUNCTION_NAME = require('../internals/function-name').CONFIGURABLE;
var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(String).split('String');
(module.exports = function(O, key, value, options) {
    var unsafe = options ? !!options.unsafe : false;
    var simple = options ? !!options.enumerable : false;
    var noTargetGet = options ? !!options.noTargetGet : false;
    var name = options && options.name !== undefined ? options.name : key;
    var state;
    if (isCallable(value)) {
        if (String(name).slice(0, 7) === 'Symbol(') name = '[' + String(name).replace(/^Symbol\(([^)]*)\)/, '$1') + ']';
        if (!hasOwn(value, 'name') || CONFIGURABLE_FUNCTION_NAME && value.name !== name) createNonEnumerableProperty(value, 'name', name);
        state = enforceInternalState(value);
        if (!state.source) state.source = TEMPLATE.join(typeof name == 'string' ? name : '');
    }
    if (O === global) {
        if (simple) O[key] = value;
        else setGlobal(key, value);
        return;
    } else if (!unsafe) delete O[key];
    else if (!noTargetGet && O[key]) simple = true;
    if (simple) O[key] = value;
    else createNonEnumerableProperty(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
    return isCallable(this) && getInternalState(this).source || inspectSource(this);
});

},{"../internals/global":"jxPDA","../internals/is-callable":"kPhuP","../internals/has-own-property":"3ZdUC","../internals/create-non-enumerable-property":"6Z1es","../internals/set-global":"kehc7","../internals/inspect-source":"7DOzX","../internals/internal-state":"i6AaM","../internals/function-name":"6v6mP"}],"7DOzX":[function(require,module,exports) {
var uncurryThis = require('../internals/function-uncurry-this');
var isCallable = require('../internals/is-callable');
var store = require('../internals/shared-store');
var functionToString = uncurryThis(Function.toString);
// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) store.inspectSource = function(it) {
    return functionToString(it);
};
module.exports = store.inspectSource;

},{"../internals/function-uncurry-this":"jJnXC","../internals/is-callable":"kPhuP","../internals/shared-store":"3QdEO"}],"i6AaM":[function(require,module,exports) {
var NATIVE_WEAK_MAP = require('../internals/native-weak-map');
var global = require('../internals/global');
var uncurryThis = require('../internals/function-uncurry-this');
var isObject = require('../internals/is-object');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var hasOwn = require('../internals/has-own-property');
var shared = require('../internals/shared-store');
var sharedKey = require('../internals/shared-key');
var hiddenKeys = require('../internals/hidden-keys');
var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = global.TypeError;
var WeakMap = global.WeakMap;
var set, get, has;
var enforce = function(it) {
    return has(it) ? get(it) : set(it, {
    });
};
var getterFor = function(TYPE) {
    return function(it) {
        var state;
        if (!isObject(it) || (state = get(it)).type !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required');
        return state;
    };
};
if (NATIVE_WEAK_MAP || shared.state) {
    var store = shared.state || (shared.state = new WeakMap());
    var wmget = uncurryThis(store.get);
    var wmhas = uncurryThis(store.has);
    var wmset = uncurryThis(store.set);
    set = function(it, metadata) {
        if (wmhas(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        wmset(store, it, metadata);
        return metadata;
    };
    get = function(it) {
        return wmget(store, it) || {
        };
    };
    has = function(it) {
        return wmhas(store, it);
    };
} else {
    var STATE = sharedKey('state');
    hiddenKeys[STATE] = true;
    set = function(it, metadata) {
        if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        createNonEnumerableProperty(it, STATE, metadata);
        return metadata;
    };
    get = function(it) {
        return hasOwn(it, STATE) ? it[STATE] : {
        };
    };
    has = function(it) {
        return hasOwn(it, STATE);
    };
}
module.exports = {
    set: set,
    get: get,
    has: has,
    enforce: enforce,
    getterFor: getterFor
};

},{"../internals/native-weak-map":"3Q3X6","../internals/global":"jxPDA","../internals/function-uncurry-this":"jJnXC","../internals/is-object":"dplrD","../internals/create-non-enumerable-property":"6Z1es","../internals/has-own-property":"3ZdUC","../internals/shared-store":"3QdEO","../internals/shared-key":"oNjWG","../internals/hidden-keys":"lHxXS"}],"3Q3X6":[function(require,module,exports) {
var global = require('../internals/global');
var isCallable = require('../internals/is-callable');
var inspectSource = require('../internals/inspect-source');
var WeakMap = global.WeakMap;
module.exports = isCallable(WeakMap) && /native code/.test(inspectSource(WeakMap));

},{"../internals/global":"jxPDA","../internals/is-callable":"kPhuP","../internals/inspect-source":"7DOzX"}],"oNjWG":[function(require,module,exports) {
var shared = require('../internals/shared');
var uid = require('../internals/uid');
var keys = shared('keys');
module.exports = function(key) {
    return keys[key] || (keys[key] = uid(key));
};

},{"../internals/shared":"7VLeP","../internals/uid":"eMBx9"}],"lHxXS":[function(require,module,exports) {
module.exports = {
};

},{}],"6v6mP":[function(require,module,exports) {
var DESCRIPTORS = require('../internals/descriptors');
var hasOwn = require('../internals/has-own-property');
var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() {
}).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable);
module.exports = {
    EXISTS: EXISTS,
    PROPER: PROPER,
    CONFIGURABLE: CONFIGURABLE
};

},{"../internals/descriptors":"6ZLib","../internals/has-own-property":"3ZdUC"}],"bCh2q":[function(require,module,exports) {
var hasOwn = require('../internals/has-own-property');
var ownKeys = require('../internals/own-keys');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
var definePropertyModule = require('../internals/object-define-property');
module.exports = function(target, source, exceptions) {
    var keys = ownKeys(source);
    var defineProperty = definePropertyModule.f;
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    for(var i = 0; i < keys.length; i++){
        var key = keys[i];
        if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
};

},{"../internals/has-own-property":"3ZdUC","../internals/own-keys":"e0KjM","../internals/object-get-own-property-descriptor":"1gCBk","../internals/object-define-property":"bauTd"}],"e0KjM":[function(require,module,exports) {
var getBuiltIn = require('../internals/get-built-in');
var uncurryThis = require('../internals/function-uncurry-this');
var getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');
var getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');
var anObject = require('../internals/an-object');
var concat = uncurryThis([].concat);
// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
    var keys = getOwnPropertyNamesModule.f(anObject(it));
    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};

},{"../internals/get-built-in":"78arb","../internals/function-uncurry-this":"jJnXC","../internals/object-get-own-property-names":"evqXT","../internals/object-get-own-property-symbols":"dBB9V","../internals/an-object":"1LIz9"}],"evqXT":[function(require,module,exports) {
var internalObjectKeys = require('../internals/object-keys-internal');
var enumBugKeys = require('../internals/enum-bug-keys');
var hiddenKeys = enumBugKeys.concat('length', 'prototype');
// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return internalObjectKeys(O, hiddenKeys);
};

},{"../internals/object-keys-internal":"3Jr1l","../internals/enum-bug-keys":"a0vpC"}],"3Jr1l":[function(require,module,exports) {
var uncurryThis = require('../internals/function-uncurry-this');
var hasOwn = require('../internals/has-own-property');
var toIndexedObject = require('../internals/to-indexed-object');
var indexOf = require('../internals/array-includes').indexOf;
var hiddenKeys = require('../internals/hidden-keys');
var push = uncurryThis([].push);
module.exports = function(object, names) {
    var O = toIndexedObject(object);
    var i = 0;
    var result = [];
    var key;
    for(key in O)!hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
    // Don't enum bug & hidden keys
    while(names.length > i)if (hasOwn(O, key = names[i++])) ~indexOf(result, key) || push(result, key);
    return result;
};

},{"../internals/function-uncurry-this":"jJnXC","../internals/has-own-property":"3ZdUC","../internals/to-indexed-object":"8ueFu","../internals/array-includes":"SXf52","../internals/hidden-keys":"lHxXS"}],"SXf52":[function(require,module,exports) {
var toIndexedObject = require('../internals/to-indexed-object');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var lengthOfArrayLike = require('../internals/length-of-array-like');
// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function(IS_INCLUDES) {
    return function($this, el, fromIndex) {
        var O = toIndexedObject($this);
        var length = lengthOfArrayLike(O);
        var index = toAbsoluteIndex(fromIndex, length);
        var value;
        // Array#includes uses SameValueZero equality algorithm
        // eslint-disable-next-line no-self-compare -- NaN check
        if (IS_INCLUDES && el != el) while(length > index){
            value = O[index++];
            // eslint-disable-next-line no-self-compare -- NaN check
            if (value != value) return true;
        // Array#indexOf ignores holes, Array#includes - not
        }
        else for(; length > index; index++){
            if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
        }
        return !IS_INCLUDES && -1;
    };
};
module.exports = {
    // `Array.prototype.includes` method
    // https://tc39.es/ecma262/#sec-array.prototype.includes
    includes: createMethod(true),
    // `Array.prototype.indexOf` method
    // https://tc39.es/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod(false)
};

},{"../internals/to-indexed-object":"8ueFu","../internals/to-absolute-index":"dDgEq","../internals/length-of-array-like":"afDy6"}],"dDgEq":[function(require,module,exports) {
var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
var max = Math.max;
var min = Math.min;
// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function(index, length) {
    var integer = toIntegerOrInfinity(index);
    return integer < 0 ? max(integer + length, 0) : min(integer, length);
};

},{"../internals/to-integer-or-infinity":"aqyxv"}],"aqyxv":[function(require,module,exports) {
var ceil = Math.ceil;
var floor = Math.floor;
// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function(argument) {
    var number = +argument;
    // eslint-disable-next-line no-self-compare -- safe
    return number !== number || number === 0 ? 0 : (number > 0 ? floor : ceil)(number);
};

},{}],"afDy6":[function(require,module,exports) {
var toLength = require('../internals/to-length');
// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function(obj) {
    return toLength(obj.length);
};

},{"../internals/to-length":"bMgmi"}],"bMgmi":[function(require,module,exports) {
var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
var min = Math.min;
// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function(argument) {
    return argument > 0 ? min(toIntegerOrInfinity(argument), 9007199254740991) : 0; // 2 ** 53 - 1 == 9007199254740991
};

},{"../internals/to-integer-or-infinity":"aqyxv"}],"a0vpC":[function(require,module,exports) {
// IE8- don't enum bug keys
module.exports = [
    'constructor',
    'hasOwnProperty',
    'isPrototypeOf',
    'propertyIsEnumerable',
    'toLocaleString',
    'toString',
    'valueOf'
];

},{}],"dBB9V":[function(require,module,exports) {
// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;

},{}],"eTyNf":[function(require,module,exports) {
var fails = require('../internals/fails');
var isCallable = require('../internals/is-callable');
var replacement = /#|\.prototype\./;
var isForced = function(feature, detection) {
    var value = data[normalize(feature)];
    return value == POLYFILL ? true : value == NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
};
var normalize = isForced.normalize = function(string) {
    return String(string).replace(replacement, '.').toLowerCase();
};
var data = isForced.data = {
};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';
module.exports = isForced;

},{"../internals/fails":"8IfZQ","../internals/is-callable":"kPhuP"}],"206oi":[function(require,module,exports) {
var NATIVE_BIND = require('../internals/function-bind-native');
var FunctionPrototype = Function.prototype;
var apply = FunctionPrototype.apply;
var call = FunctionPrototype.call;
// eslint-disable-next-line es/no-reflect -- safe
module.exports = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {
    return call.apply(apply, arguments);
});

},{"../internals/function-bind-native":"7GJc3"}],"gN5mt":[function(require,module,exports) {
var classof = require('../internals/classof-raw');
// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(argument) {
    return classof(argument) == 'Array';
};

},{"../internals/classof-raw":"A9m3U"}],"4cTlm":[function(require,module,exports) {
var global = require('../internals/global');
var classof = require('../internals/classof');
var String = global.String;
module.exports = function(argument) {
    if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
    return String(argument);
};

},{"../internals/global":"jxPDA","../internals/classof":"kJ8JQ"}],"kJ8JQ":[function(require,module,exports) {
var global = require('../internals/global');
var TO_STRING_TAG_SUPPORT = require('../internals/to-string-tag-support');
var isCallable = require('../internals/is-callable');
var classofRaw = require('../internals/classof-raw');
var wellKnownSymbol = require('../internals/well-known-symbol');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var Object = global.Object;
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function() {
    return arguments;
}()) == 'Arguments';
// fallback for IE11 Script Access Denied error
var tryGet = function(it, key) {
    try {
        return it[key];
    } catch (error) {
    }
};
// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
    var O, tag, result;
    return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};

},{"../internals/global":"jxPDA","../internals/to-string-tag-support":"g8wEl","../internals/is-callable":"kPhuP","../internals/classof-raw":"A9m3U","../internals/well-known-symbol":"5C8sm"}],"g8wEl":[function(require,module,exports) {
var wellKnownSymbol = require('../internals/well-known-symbol');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {
};
test[TO_STRING_TAG] = 'z';
module.exports = String(test) === '[object z]';

},{"../internals/well-known-symbol":"5C8sm"}],"1As5O":[function(require,module,exports) {
/* global ActiveXObject -- old IE, WSH */ var anObject = require('../internals/an-object');
var definePropertiesModule = require('../internals/object-define-properties');
var enumBugKeys = require('../internals/enum-bug-keys');
var hiddenKeys = require('../internals/hidden-keys');
var html = require('../internals/html');
var documentCreateElement = require('../internals/document-create-element');
var sharedKey = require('../internals/shared-key');
var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');
var EmptyConstructor = function() {
};
var scriptTag = function(content) {
    return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};
// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function(activeXDocument1) {
    activeXDocument1.write(scriptTag(''));
    activeXDocument1.close();
    var temp = activeXDocument1.parentWindow.Object;
    activeXDocument1 = null; // avoid memory leak
    return temp;
};
// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function() {
    // Thrash, waste and sodomy: IE GC bug
    var iframe = documentCreateElement('iframe');
    var JS = 'java' + SCRIPT + ':';
    var iframeDocument;
    iframe.style.display = 'none';
    html.appendChild(iframe);
    // https://github.com/zloirock/core-js/issues/475
    iframe.src = String(JS);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(scriptTag('document.F=Object'));
    iframeDocument.close();
    return iframeDocument.F;
};
// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function() {
    try {
        activeXDocument = new ActiveXObject('htmlfile');
    } catch (error) {
    }
    NullProtoObject = typeof document != 'undefined' ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) // old IE
     : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument); // WSH
    var length = enumBugKeys.length;
    while(length--)delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
    return NullProtoObject();
};
hiddenKeys[IE_PROTO] = true;
// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
module.exports = Object.create || function create(O, Properties) {
    var result;
    if (O !== null) {
        EmptyConstructor[PROTOTYPE] = anObject(O);
        result = new EmptyConstructor();
        EmptyConstructor[PROTOTYPE] = null;
        // add "__proto__" for Object.getPrototypeOf polyfill
        result[IE_PROTO] = O;
    } else result = NullProtoObject();
    return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
};

},{"../internals/an-object":"1LIz9","../internals/object-define-properties":"8PPlc","../internals/enum-bug-keys":"a0vpC","../internals/hidden-keys":"lHxXS","../internals/html":"fFwbI","../internals/document-create-element":"jKd7d","../internals/shared-key":"oNjWG"}],"8PPlc":[function(require,module,exports) {
var DESCRIPTORS = require('../internals/descriptors');
var V8_PROTOTYPE_DEFINE_BUG = require('../internals/v8-prototype-define-bug');
var definePropertyModule = require('../internals/object-define-property');
var anObject = require('../internals/an-object');
var toIndexedObject = require('../internals/to-indexed-object');
var objectKeys = require('../internals/object-keys');
// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject(O);
    var props = toIndexedObject(Properties);
    var keys = objectKeys(Properties);
    var length = keys.length;
    var index = 0;
    var key;
    while(length > index)definePropertyModule.f(O, key = keys[index++], props[key]);
    return O;
};

},{"../internals/descriptors":"6ZLib","../internals/v8-prototype-define-bug":"cQXpv","../internals/object-define-property":"bauTd","../internals/an-object":"1LIz9","../internals/to-indexed-object":"8ueFu","../internals/object-keys":"9bK4Y"}],"9bK4Y":[function(require,module,exports) {
var internalObjectKeys = require('../internals/object-keys-internal');
var enumBugKeys = require('../internals/enum-bug-keys');
// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
    return internalObjectKeys(O, enumBugKeys);
};

},{"../internals/object-keys-internal":"3Jr1l","../internals/enum-bug-keys":"a0vpC"}],"fFwbI":[function(require,module,exports) {
var getBuiltIn = require('../internals/get-built-in');
module.exports = getBuiltIn('document', 'documentElement');

},{"../internals/get-built-in":"78arb"}],"7r5nw":[function(require,module,exports) {
/* eslint-disable es/no-object-getownpropertynames -- safe */ var classof = require('../internals/classof-raw');
var toIndexedObject = require('../internals/to-indexed-object');
var $getOwnPropertyNames = require('../internals/object-get-own-property-names').f;
var arraySlice = require('../internals/array-slice-simple');
var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
var getWindowNames = function(it) {
    try {
        return $getOwnPropertyNames(it);
    } catch (error) {
        return arraySlice(windowNames);
    }
};
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
module.exports.f = function getOwnPropertyNames(it) {
    return windowNames && classof(it) == 'Window' ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject(it));
};

},{"../internals/classof-raw":"A9m3U","../internals/to-indexed-object":"8ueFu","../internals/object-get-own-property-names":"evqXT","../internals/array-slice-simple":"bYLId"}],"bYLId":[function(require,module,exports) {
var global = require('../internals/global');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var createProperty = require('../internals/create-property');
var Array = global.Array;
var max = Math.max;
module.exports = function(O, start, end) {
    var length = lengthOfArrayLike(O);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    var result = Array(max(fin - k, 0));
    for(var n = 0; k < fin; k++, n++)createProperty(result, n, O[k]);
    result.length = n;
    return result;
};

},{"../internals/global":"jxPDA","../internals/to-absolute-index":"dDgEq","../internals/length-of-array-like":"afDy6","../internals/create-property":"a2n8E"}],"a2n8E":[function(require,module,exports) {
'use strict';
var toPropertyKey = require('../internals/to-property-key');
var definePropertyModule = require('../internals/object-define-property');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
module.exports = function(object, key, value) {
    var propertyKey = toPropertyKey(key);
    if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
    else object[propertyKey] = value;
};

},{"../internals/to-property-key":"bMDpS","../internals/object-define-property":"bauTd","../internals/create-property-descriptor":"ermgb"}],"bI1dk":[function(require,module,exports) {
var uncurryThis = require('../internals/function-uncurry-this');
module.exports = uncurryThis([].slice);

},{"../internals/function-uncurry-this":"jJnXC"}],"cvrEK":[function(require,module,exports) {
var wellKnownSymbol = require('../internals/well-known-symbol');
exports.f = wellKnownSymbol;

},{"../internals/well-known-symbol":"5C8sm"}],"iX7WZ":[function(require,module,exports) {
var path = require('../internals/path');
var hasOwn = require('../internals/has-own-property');
var wrappedWellKnownSymbolModule = require('../internals/well-known-symbol-wrapped');
var defineProperty = require('../internals/object-define-property').f;
module.exports = function(NAME) {
    var Symbol = path.Symbol || (path.Symbol = {
    });
    if (!hasOwn(Symbol, NAME)) defineProperty(Symbol, NAME, {
        value: wrappedWellKnownSymbolModule.f(NAME)
    });
};

},{"../internals/path":"f1yhZ","../internals/has-own-property":"3ZdUC","../internals/well-known-symbol-wrapped":"cvrEK","../internals/object-define-property":"bauTd"}],"f1yhZ":[function(require,module,exports) {
var global = require('../internals/global');
module.exports = global;

},{"../internals/global":"jxPDA"}],"9arwS":[function(require,module,exports) {
var defineProperty = require('../internals/object-define-property').f;
var hasOwn = require('../internals/has-own-property');
var wellKnownSymbol = require('../internals/well-known-symbol');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
module.exports = function(target, TAG, STATIC) {
    if (target && !STATIC) target = target.prototype;
    if (target && !hasOwn(target, TO_STRING_TAG)) defineProperty(target, TO_STRING_TAG, {
        configurable: true,
        value: TAG
    });
};

},{"../internals/object-define-property":"bauTd","../internals/has-own-property":"3ZdUC","../internals/well-known-symbol":"5C8sm"}],"8a6lB":[function(require,module,exports) {
var bind = require('../internals/function-bind-context');
var uncurryThis = require('../internals/function-uncurry-this');
var IndexedObject = require('../internals/indexed-object');
var toObject = require('../internals/to-object');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var arraySpeciesCreate = require('../internals/array-species-create');
var push = uncurryThis([].push);
// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
var createMethod = function(TYPE) {
    var IS_MAP = TYPE == 1;
    var IS_FILTER = TYPE == 2;
    var IS_SOME = TYPE == 3;
    var IS_EVERY = TYPE == 4;
    var IS_FIND_INDEX = TYPE == 6;
    var IS_FILTER_REJECT = TYPE == 7;
    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    return function($this, callbackfn, that, specificCreate) {
        var O = toObject($this);
        var self = IndexedObject(O);
        var boundFunction = bind(callbackfn, that);
        var length = lengthOfArrayLike(self);
        var index = 0;
        var create = specificCreate || arraySpeciesCreate;
        var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
        var value, result;
        for(; length > index; index++)if (NO_HOLES || index in self) {
            value = self[index];
            result = boundFunction(value, index, O);
            if (TYPE) {
                if (IS_MAP) target[index] = result; // map
                else if (result) switch(TYPE){
                    case 3:
                        return true; // some
                    case 5:
                        return value; // find
                    case 6:
                        return index; // findIndex
                    case 2:
                        push(target, value); // filter
                }
                else switch(TYPE){
                    case 4:
                        return false; // every
                    case 7:
                        push(target, value); // filterReject
                }
            }
        }
        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
    };
};
module.exports = {
    // `Array.prototype.forEach` method
    // https://tc39.es/ecma262/#sec-array.prototype.foreach
    forEach: createMethod(0),
    // `Array.prototype.map` method
    // https://tc39.es/ecma262/#sec-array.prototype.map
    map: createMethod(1),
    // `Array.prototype.filter` method
    // https://tc39.es/ecma262/#sec-array.prototype.filter
    filter: createMethod(2),
    // `Array.prototype.some` method
    // https://tc39.es/ecma262/#sec-array.prototype.some
    some: createMethod(3),
    // `Array.prototype.every` method
    // https://tc39.es/ecma262/#sec-array.prototype.every
    every: createMethod(4),
    // `Array.prototype.find` method
    // https://tc39.es/ecma262/#sec-array.prototype.find
    find: createMethod(5),
    // `Array.prototype.findIndex` method
    // https://tc39.es/ecma262/#sec-array.prototype.findIndex
    findIndex: createMethod(6),
    // `Array.prototype.filterReject` method
    // https://github.com/tc39/proposal-array-filtering
    filterReject: createMethod(7)
};

},{"../internals/function-bind-context":"kZubc","../internals/function-uncurry-this":"jJnXC","../internals/indexed-object":"e5ccT","../internals/to-object":"eEdae","../internals/length-of-array-like":"afDy6","../internals/array-species-create":"dEli4"}],"kZubc":[function(require,module,exports) {
var uncurryThis = require('../internals/function-uncurry-this');
var aCallable = require('../internals/a-callable');
var NATIVE_BIND = require('../internals/function-bind-native');
var bind = uncurryThis(uncurryThis.bind);
// optional / simple context binding
module.exports = function(fn, that) {
    aCallable(fn);
    return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function() {
        return fn.apply(that, arguments);
    };
};

},{"../internals/function-uncurry-this":"jJnXC","../internals/a-callable":"83opn","../internals/function-bind-native":"7GJc3"}],"dEli4":[function(require,module,exports) {
var arraySpeciesConstructor = require('../internals/array-species-constructor');
// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function(originalArray, length) {
    return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};

},{"../internals/array-species-constructor":"8YJbm"}],"8YJbm":[function(require,module,exports) {
var global = require('../internals/global');
var isArray = require('../internals/is-array');
var isConstructor = require('../internals/is-constructor');
var isObject = require('../internals/is-object');
var wellKnownSymbol = require('../internals/well-known-symbol');
var SPECIES = wellKnownSymbol('species');
var Array = global.Array;
// a part of `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function(originalArray) {
    var C;
    if (isArray(originalArray)) {
        C = originalArray.constructor;
        // cross-realm fallback
        if (isConstructor(C) && (C === Array || isArray(C.prototype))) C = undefined;
        else if (isObject(C)) {
            C = C[SPECIES];
            if (C === null) C = undefined;
        }
    }
    return C === undefined ? Array : C;
};

},{"../internals/global":"jxPDA","../internals/is-array":"gN5mt","../internals/is-constructor":"iNoNi","../internals/is-object":"dplrD","../internals/well-known-symbol":"5C8sm"}],"iNoNi":[function(require,module,exports) {
var uncurryThis = require('../internals/function-uncurry-this');
var fails = require('../internals/fails');
var isCallable = require('../internals/is-callable');
var classof = require('../internals/classof');
var getBuiltIn = require('../internals/get-built-in');
var inspectSource = require('../internals/inspect-source');
var noop = function() {
};
var empty = [];
var construct = getBuiltIn('Reflect', 'construct');
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec = uncurryThis(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);
var isConstructorModern = function isConstructor(argument) {
    if (!isCallable(argument)) return false;
    try {
        construct(noop, empty, argument);
        return true;
    } catch (error) {
        return false;
    }
};
var isConstructorLegacy = function isConstructor(argument) {
    if (!isCallable(argument)) return false;
    switch(classof(argument)){
        case 'AsyncFunction':
        case 'GeneratorFunction':
        case 'AsyncGeneratorFunction':
            return false;
    }
    try {
        // we can't check .prototype since constructors produced by .bind haven't it
        // `Function#toString` throws on some built-it function in some legacy engines
        // (for example, `DOMQuad` and similar in FF41-)
        return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
    } catch (error) {
        return true;
    }
};
isConstructorLegacy.sham = true;
// `IsConstructor` abstract operation
// https://tc39.es/ecma262/#sec-isconstructor
module.exports = !construct || fails(function() {
    var called;
    return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
        called = true;
    }) || called;
}) ? isConstructorLegacy : isConstructorModern;

},{"../internals/function-uncurry-this":"jJnXC","../internals/fails":"8IfZQ","../internals/is-callable":"kPhuP","../internals/classof":"kJ8JQ","../internals/get-built-in":"78arb","../internals/inspect-source":"7DOzX"}],"TdRlp":[function(require,module,exports) {
// `Symbol.prototype.description` getter
// https://tc39.es/ecma262/#sec-symbol.prototype.description
'use strict';
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var global = require('../internals/global');
var uncurryThis = require('../internals/function-uncurry-this');
var hasOwn = require('../internals/has-own-property');
var isCallable = require('../internals/is-callable');
var isPrototypeOf = require('../internals/object-is-prototype-of');
var toString = require('../internals/to-string');
var defineProperty = require('../internals/object-define-property').f;
var copyConstructorProperties = require('../internals/copy-constructor-properties');
var NativeSymbol = global.Symbol;
var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;
if (DESCRIPTORS && isCallable(NativeSymbol) && (!('description' in SymbolPrototype) || // Safari 12 bug
NativeSymbol().description !== undefined)) {
    var EmptyStringDescriptionStore = {
    };
    // wrap Symbol constructor for correct work with undefined description
    var SymbolWrapper = function Symbol() {
        var description = arguments.length < 1 || arguments[0] === undefined ? undefined : toString(arguments[0]);
        var result = isPrototypeOf(SymbolPrototype, this) ? new NativeSymbol(description) : description === undefined ? NativeSymbol() : NativeSymbol(description);
        if (description === '') EmptyStringDescriptionStore[result] = true;
        return result;
    };
    copyConstructorProperties(SymbolWrapper, NativeSymbol);
    SymbolWrapper.prototype = SymbolPrototype;
    SymbolPrototype.constructor = SymbolWrapper;
    var NATIVE_SYMBOL = String(NativeSymbol('test')) == 'Symbol(test)';
    var symbolToString = uncurryThis(SymbolPrototype.toString);
    var symbolValueOf = uncurryThis(SymbolPrototype.valueOf);
    var regexp = /^Symbol\((.*)\)[^)]+$/;
    var replace = uncurryThis(''.replace);
    var stringSlice = uncurryThis(''.slice);
    defineProperty(SymbolPrototype, 'description', {
        configurable: true,
        get: function description() {
            var symbol = symbolValueOf(this);
            var string = symbolToString(symbol);
            if (hasOwn(EmptyStringDescriptionStore, symbol)) return '';
            var desc = NATIVE_SYMBOL ? stringSlice(string, 7, -1) : replace(string, regexp, '$1');
            return desc === '' ? undefined : desc;
        }
    });
    $({
        global: true,
        forced: true
    }, {
        Symbol: SymbolWrapper
    });
}

},{"../internals/export":"8yfGv","../internals/descriptors":"6ZLib","../internals/global":"jxPDA","../internals/function-uncurry-this":"jJnXC","../internals/has-own-property":"3ZdUC","../internals/is-callable":"kPhuP","../internals/object-is-prototype-of":"fyf1A","../internals/to-string":"4cTlm","../internals/object-define-property":"bauTd","../internals/copy-constructor-properties":"bCh2q"}],"ihdMq":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.asyncIterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.asynciterator
defineWellKnownSymbol('asyncIterator');

},{"../internals/define-well-known-symbol":"iX7WZ"}],"9Mkmh":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.hasInstance` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.hasinstance
defineWellKnownSymbol('hasInstance');

},{"../internals/define-well-known-symbol":"iX7WZ"}],"9wmiv":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.isConcatSpreadable` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.isconcatspreadable
defineWellKnownSymbol('isConcatSpreadable');

},{"../internals/define-well-known-symbol":"iX7WZ"}],"2mIbY":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.iterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.iterator
defineWellKnownSymbol('iterator');

},{"../internals/define-well-known-symbol":"iX7WZ"}],"44uyZ":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.match` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.match
defineWellKnownSymbol('match');

},{"../internals/define-well-known-symbol":"iX7WZ"}],"kVLfA":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.matchAll` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.matchall
defineWellKnownSymbol('matchAll');

},{"../internals/define-well-known-symbol":"iX7WZ"}],"6HjgK":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.replace` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.replace
defineWellKnownSymbol('replace');

},{"../internals/define-well-known-symbol":"iX7WZ"}],"689vN":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.search` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.search
defineWellKnownSymbol('search');

},{"../internals/define-well-known-symbol":"iX7WZ"}],"4nGCq":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.species` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.species
defineWellKnownSymbol('species');

},{"../internals/define-well-known-symbol":"iX7WZ"}],"5f6H5":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.split` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.split
defineWellKnownSymbol('split');

},{"../internals/define-well-known-symbol":"iX7WZ"}],"eh2Ju":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.toPrimitive` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.toprimitive
defineWellKnownSymbol('toPrimitive');

},{"../internals/define-well-known-symbol":"iX7WZ"}],"eTBog":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.toStringTag` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.tostringtag
defineWellKnownSymbol('toStringTag');

},{"../internals/define-well-known-symbol":"iX7WZ"}],"ljFuZ":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.unscopables` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.unscopables
defineWellKnownSymbol('unscopables');

},{"../internals/define-well-known-symbol":"iX7WZ"}],"aqHio":[function(require,module,exports) {
/* eslint-disable no-unused-vars -- required for functions `.length` */ var $ = require('../internals/export');
var global = require('../internals/global');
var apply = require('../internals/function-apply');
var wrapErrorConstructorWithCause = require('../internals/wrap-error-constructor-with-cause');
var WEB_ASSEMBLY = 'WebAssembly';
var WebAssembly = global[WEB_ASSEMBLY];
var FORCED = Error('e', {
    cause: 7
}).cause !== 7;
var exportGlobalErrorCauseWrapper = function(ERROR_NAME, wrapper) {
    var O = {
    };
    O[ERROR_NAME] = wrapErrorConstructorWithCause(ERROR_NAME, wrapper, FORCED);
    $({
        global: true,
        forced: FORCED
    }, O);
};
var exportWebAssemblyErrorCauseWrapper = function(ERROR_NAME, wrapper) {
    if (WebAssembly && WebAssembly[ERROR_NAME]) {
        var O = {
        };
        O[ERROR_NAME] = wrapErrorConstructorWithCause(WEB_ASSEMBLY + '.' + ERROR_NAME, wrapper, FORCED);
        $({
            target: WEB_ASSEMBLY,
            stat: true,
            forced: FORCED
        }, O);
    }
};
// https://github.com/tc39/proposal-error-cause
exportGlobalErrorCauseWrapper('Error', function(init) {
    return function Error(message) {
        return apply(init, this, arguments);
    };
});
exportGlobalErrorCauseWrapper('EvalError', function(init) {
    return function EvalError(message) {
        return apply(init, this, arguments);
    };
});
exportGlobalErrorCauseWrapper('RangeError', function(init) {
    return function RangeError(message) {
        return apply(init, this, arguments);
    };
});
exportGlobalErrorCauseWrapper('ReferenceError', function(init) {
    return function ReferenceError(message) {
        return apply(init, this, arguments);
    };
});
exportGlobalErrorCauseWrapper('SyntaxError', function(init) {
    return function SyntaxError(message) {
        return apply(init, this, arguments);
    };
});
exportGlobalErrorCauseWrapper('TypeError', function(init) {
    return function TypeError(message) {
        return apply(init, this, arguments);
    };
});
exportGlobalErrorCauseWrapper('URIError', function(init) {
    return function URIError(message) {
        return apply(init, this, arguments);
    };
});
exportWebAssemblyErrorCauseWrapper('CompileError', function(init) {
    return function CompileError(message) {
        return apply(init, this, arguments);
    };
});
exportWebAssemblyErrorCauseWrapper('LinkError', function(init) {
    return function LinkError(message) {
        return apply(init, this, arguments);
    };
});
exportWebAssemblyErrorCauseWrapper('RuntimeError', function(init) {
    return function RuntimeError(message) {
        return apply(init, this, arguments);
    };
});

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/function-apply":"206oi","../internals/wrap-error-constructor-with-cause":"AFcuB"}],"AFcuB":[function(require,module,exports) {
'use strict';
var getBuiltIn = require('../internals/get-built-in');
var hasOwn = require('../internals/has-own-property');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var isPrototypeOf = require('../internals/object-is-prototype-of');
var setPrototypeOf = require('../internals/object-set-prototype-of');
var copyConstructorProperties = require('../internals/copy-constructor-properties');
var inheritIfRequired = require('../internals/inherit-if-required');
var normalizeStringArgument = require('../internals/normalize-string-argument');
var installErrorCause = require('../internals/install-error-cause');
var clearErrorStack = require('../internals/clear-error-stack');
var ERROR_STACK_INSTALLABLE = require('../internals/error-stack-installable');
var IS_PURE = require('../internals/is-pure');
module.exports = function(FULL_NAME, wrapper, FORCED, IS_AGGREGATE_ERROR) {
    var OPTIONS_POSITION = IS_AGGREGATE_ERROR ? 2 : 1;
    var path = FULL_NAME.split('.');
    var ERROR_NAME = path[path.length - 1];
    var OriginalError = getBuiltIn.apply(null, path);
    if (!OriginalError) return;
    var OriginalErrorPrototype = OriginalError.prototype;
    // V8 9.3- bug https://bugs.chromium.org/p/v8/issues/detail?id=12006
    if (!IS_PURE && hasOwn(OriginalErrorPrototype, 'cause')) delete OriginalErrorPrototype.cause;
    if (!FORCED) return OriginalError;
    var BaseError = getBuiltIn('Error');
    var WrappedError = wrapper(function(a, b) {
        var message = normalizeStringArgument(IS_AGGREGATE_ERROR ? b : a, undefined);
        var result = IS_AGGREGATE_ERROR ? new OriginalError(a) : new OriginalError();
        if (message !== undefined) createNonEnumerableProperty(result, 'message', message);
        if (ERROR_STACK_INSTALLABLE) createNonEnumerableProperty(result, 'stack', clearErrorStack(result.stack, 2));
        if (this && isPrototypeOf(OriginalErrorPrototype, this)) inheritIfRequired(result, this, WrappedError);
        if (arguments.length > OPTIONS_POSITION) installErrorCause(result, arguments[OPTIONS_POSITION]);
        return result;
    });
    WrappedError.prototype = OriginalErrorPrototype;
    if (ERROR_NAME !== 'Error') {
        if (setPrototypeOf) setPrototypeOf(WrappedError, BaseError);
        else copyConstructorProperties(WrappedError, BaseError, {
            name: true
        });
    }
    copyConstructorProperties(WrappedError, OriginalError);
    if (!IS_PURE) try {
        // Safari 13- bug: WebAssembly errors does not have a proper `.name`
        if (OriginalErrorPrototype.name !== ERROR_NAME) createNonEnumerableProperty(OriginalErrorPrototype, 'name', ERROR_NAME);
        OriginalErrorPrototype.constructor = WrappedError;
    } catch (error) {
    }
    return WrappedError;
};

},{"../internals/get-built-in":"78arb","../internals/has-own-property":"3ZdUC","../internals/create-non-enumerable-property":"6Z1es","../internals/object-is-prototype-of":"fyf1A","../internals/object-set-prototype-of":"lb6rR","../internals/copy-constructor-properties":"bCh2q","../internals/inherit-if-required":"kXY2O","../internals/normalize-string-argument":"1P71G","../internals/install-error-cause":"fRdzI","../internals/clear-error-stack":"etw2G","../internals/error-stack-installable":"81LgE","../internals/is-pure":"6Bbq0"}],"lb6rR":[function(require,module,exports) {
/* eslint-disable no-proto -- safe */ var uncurryThis = require('../internals/function-uncurry-this');
var anObject = require('../internals/an-object');
var aPossiblePrototype = require('../internals/a-possible-prototype');
// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ('__proto__' in {
} ? (function() {
    var CORRECT_SETTER = false;
    var test = {
    };
    var setter;
    try {
        // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
        setter = uncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);
        setter(test, []);
        CORRECT_SETTER = test instanceof Array;
    } catch (error) {
    }
    return function setPrototypeOf(O, proto) {
        anObject(O);
        aPossiblePrototype(proto);
        if (CORRECT_SETTER) setter(O, proto);
        else O.__proto__ = proto;
        return O;
    };
})() : undefined);

},{"../internals/function-uncurry-this":"jJnXC","../internals/an-object":"1LIz9","../internals/a-possible-prototype":"fVs6e"}],"fVs6e":[function(require,module,exports) {
var global = require('../internals/global');
var isCallable = require('../internals/is-callable');
var String = global.String;
var TypeError = global.TypeError;
module.exports = function(argument) {
    if (typeof argument == 'object' || isCallable(argument)) return argument;
    throw TypeError("Can't set " + String(argument) + ' as a prototype');
};

},{"../internals/global":"jxPDA","../internals/is-callable":"kPhuP"}],"kXY2O":[function(require,module,exports) {
var isCallable = require('../internals/is-callable');
var isObject = require('../internals/is-object');
var setPrototypeOf = require('../internals/object-set-prototype-of');
// makes subclassing work correct for wrapped built-ins
module.exports = function($this, dummy, Wrapper) {
    var NewTarget, NewTargetPrototype;
    if (// it can work only with native `setPrototypeOf`
    setPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    isCallable(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) setPrototypeOf($this, NewTargetPrototype);
    return $this;
};

},{"../internals/is-callable":"kPhuP","../internals/is-object":"dplrD","../internals/object-set-prototype-of":"lb6rR"}],"1P71G":[function(require,module,exports) {
var toString = require('../internals/to-string');
module.exports = function(argument, $default) {
    return argument === undefined ? arguments.length < 2 ? '' : $default : toString(argument);
};

},{"../internals/to-string":"4cTlm"}],"fRdzI":[function(require,module,exports) {
var isObject = require('../internals/is-object');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
// `InstallErrorCause` abstract operation
// https://tc39.es/proposal-error-cause/#sec-errorobjects-install-error-cause
module.exports = function(O, options) {
    if (isObject(options) && 'cause' in options) createNonEnumerableProperty(O, 'cause', options.cause);
};

},{"../internals/is-object":"dplrD","../internals/create-non-enumerable-property":"6Z1es"}],"etw2G":[function(require,module,exports) {
var uncurryThis = require('../internals/function-uncurry-this');
var replace = uncurryThis(''.replace);
var TEST = function(arg) {
    return String(Error(arg).stack);
}('zxcasd');
var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
module.exports = function(stack, dropEntries) {
    if (IS_V8_OR_CHAKRA_STACK && typeof stack == 'string') while(dropEntries--)stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, '');
    return stack;
};

},{"../internals/function-uncurry-this":"jJnXC"}],"81LgE":[function(require,module,exports) {
var fails = require('../internals/fails');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
module.exports = !fails(function() {
    var error = Error('a');
    if (!('stack' in error)) return true;
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty(error, 'stack', createPropertyDescriptor(1, 7));
    return error.stack !== 7;
});

},{"../internals/fails":"8IfZQ","../internals/create-property-descriptor":"ermgb"}],"dJ5Ap":[function(require,module,exports) {
var redefine = require('../internals/redefine');
var errorToString = require('../internals/error-to-string');
var ErrorPrototype = Error.prototype;
// `Error.prototype.toString` method fix
// https://tc39.es/ecma262/#sec-error.prototype.tostring
if (ErrorPrototype.toString !== errorToString) redefine(ErrorPrototype, 'toString', errorToString);

},{"../internals/redefine":"kxbj8","../internals/error-to-string":"eMkvz"}],"eMkvz":[function(require,module,exports) {
'use strict';
var DESCRIPTORS = require('../internals/descriptors');
var fails = require('../internals/fails');
var anObject = require('../internals/an-object');
var create = require('../internals/object-create');
var normalizeStringArgument = require('../internals/normalize-string-argument');
var nativeErrorToString = Error.prototype.toString;
var INCORRECT_TO_STRING = fails(function() {
    if (DESCRIPTORS) {
        // Chrome 32- incorrectly call accessor
        // eslint-disable-next-line es/no-object-defineproperty -- safe
        var object = create(Object.defineProperty({
        }, 'name', {
            get: function() {
                return this === object;
            }
        }));
        if (nativeErrorToString.call(object) !== 'true') return true;
    }
    // FF10- does not properly handle non-strings
    return nativeErrorToString.call({
        message: 1,
        name: 2
    }) !== '2: 1' || nativeErrorToString.call({
    }) !== 'Error';
});
module.exports = INCORRECT_TO_STRING ? function toString() {
    var O = anObject(this);
    var name = normalizeStringArgument(O.name, 'Error');
    var message = normalizeStringArgument(O.message);
    return !name ? message : !message ? name : name + ': ' + message;
} : nativeErrorToString;

},{"../internals/descriptors":"6ZLib","../internals/fails":"8IfZQ","../internals/an-object":"1LIz9","../internals/object-create":"1As5O","../internals/normalize-string-argument":"1P71G"}],"j0Eys":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var global = require('../internals/global');
var isPrototypeOf = require('../internals/object-is-prototype-of');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var setPrototypeOf = require('../internals/object-set-prototype-of');
var copyConstructorProperties = require('../internals/copy-constructor-properties');
var create = require('../internals/object-create');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var clearErrorStack = require('../internals/clear-error-stack');
var installErrorCause = require('../internals/install-error-cause');
var iterate = require('../internals/iterate');
var normalizeStringArgument = require('../internals/normalize-string-argument');
var wellKnownSymbol = require('../internals/well-known-symbol');
var ERROR_STACK_INSTALLABLE = require('../internals/error-stack-installable');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var Error = global.Error;
var push = [].push;
var $AggregateError = function AggregateError(errors, message /* , options */ ) {
    var options = arguments.length > 2 ? arguments[2] : undefined;
    var isInstance = isPrototypeOf(AggregateErrorPrototype, this);
    var that;
    if (setPrototypeOf) that = setPrototypeOf(new Error(), isInstance ? getPrototypeOf(this) : AggregateErrorPrototype);
    else {
        that = isInstance ? this : create(AggregateErrorPrototype);
        createNonEnumerableProperty(that, TO_STRING_TAG, 'Error');
    }
    if (message !== undefined) createNonEnumerableProperty(that, 'message', normalizeStringArgument(message));
    if (ERROR_STACK_INSTALLABLE) createNonEnumerableProperty(that, 'stack', clearErrorStack(that.stack, 1));
    installErrorCause(that, options);
    var errorsArray = [];
    iterate(errors, push, {
        that: errorsArray
    });
    createNonEnumerableProperty(that, 'errors', errorsArray);
    return that;
};
if (setPrototypeOf) setPrototypeOf($AggregateError, Error);
else copyConstructorProperties($AggregateError, Error, {
    name: true
});
var AggregateErrorPrototype = $AggregateError.prototype = create(Error.prototype, {
    constructor: createPropertyDescriptor(1, $AggregateError),
    message: createPropertyDescriptor(1, ''),
    name: createPropertyDescriptor(1, 'AggregateError')
});
// `AggregateError` constructor
// https://tc39.es/ecma262/#sec-aggregate-error-constructor
$({
    global: true
}, {
    AggregateError: $AggregateError
});

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/object-is-prototype-of":"fyf1A","../internals/object-get-prototype-of":"lBy7h","../internals/object-set-prototype-of":"lb6rR","../internals/copy-constructor-properties":"bCh2q","../internals/object-create":"1As5O","../internals/create-non-enumerable-property":"6Z1es","../internals/create-property-descriptor":"ermgb","../internals/clear-error-stack":"etw2G","../internals/install-error-cause":"fRdzI","../internals/iterate":"fTyka","../internals/normalize-string-argument":"1P71G","../internals/well-known-symbol":"5C8sm","../internals/error-stack-installable":"81LgE"}],"lBy7h":[function(require,module,exports) {
var global = require('../internals/global');
var hasOwn = require('../internals/has-own-property');
var isCallable = require('../internals/is-callable');
var toObject = require('../internals/to-object');
var sharedKey = require('../internals/shared-key');
var CORRECT_PROTOTYPE_GETTER = require('../internals/correct-prototype-getter');
var IE_PROTO = sharedKey('IE_PROTO');
var Object = global.Object;
var ObjectPrototype = Object.prototype;
// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function(O) {
    var object = toObject(O);
    if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
    var constructor = object.constructor;
    if (isCallable(constructor) && object instanceof constructor) return constructor.prototype;
    return object instanceof Object ? ObjectPrototype : null;
};

},{"../internals/global":"jxPDA","../internals/has-own-property":"3ZdUC","../internals/is-callable":"kPhuP","../internals/to-object":"eEdae","../internals/shared-key":"oNjWG","../internals/correct-prototype-getter":"5LqOC"}],"5LqOC":[function(require,module,exports) {
var fails = require('../internals/fails');
module.exports = !fails(function() {
    function F() {
    }
    F.prototype.constructor = null;
    // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
    return Object.getPrototypeOf(new F()) !== F.prototype;
});

},{"../internals/fails":"8IfZQ"}],"fTyka":[function(require,module,exports) {
var global = require('../internals/global');
var bind = require('../internals/function-bind-context');
var call = require('../internals/function-call');
var anObject = require('../internals/an-object');
var tryToString = require('../internals/try-to-string');
var isArrayIteratorMethod = require('../internals/is-array-iterator-method');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var isPrototypeOf = require('../internals/object-is-prototype-of');
var getIterator = require('../internals/get-iterator');
var getIteratorMethod = require('../internals/get-iterator-method');
var iteratorClose = require('../internals/iterator-close');
var TypeError = global.TypeError;
var Result = function(stopped, result) {
    this.stopped = stopped;
    this.result = result;
};
var ResultPrototype = Result.prototype;
module.exports = function(iterable, unboundFunction, options) {
    var that = options && options.that;
    var AS_ENTRIES = !!(options && options.AS_ENTRIES);
    var IS_ITERATOR = !!(options && options.IS_ITERATOR);
    var INTERRUPTED = !!(options && options.INTERRUPTED);
    var fn = bind(unboundFunction, that);
    var iterator, iterFn, index, length, result, next, step;
    var stop = function(condition) {
        if (iterator) iteratorClose(iterator, 'normal', condition);
        return new Result(true, condition);
    };
    var callFn = function(value) {
        if (AS_ENTRIES) {
            anObject(value);
            return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
        }
        return INTERRUPTED ? fn(value, stop) : fn(value);
    };
    if (IS_ITERATOR) iterator = iterable;
    else {
        iterFn = getIteratorMethod(iterable);
        if (!iterFn) throw TypeError(tryToString(iterable) + ' is not iterable');
        // optimisation for array iterators
        if (isArrayIteratorMethod(iterFn)) {
            for(index = 0, length = lengthOfArrayLike(iterable); length > index; index++){
                result = callFn(iterable[index]);
                if (result && isPrototypeOf(ResultPrototype, result)) return result;
            }
            return new Result(false);
        }
        iterator = getIterator(iterable, iterFn);
    }
    next = iterator.next;
    while(!(step = call(next, iterator)).done){
        try {
            result = callFn(step.value);
        } catch (error) {
            iteratorClose(iterator, 'throw', error);
        }
        if (typeof result == 'object' && result && isPrototypeOf(ResultPrototype, result)) return result;
    }
    return new Result(false);
};

},{"../internals/global":"jxPDA","../internals/function-bind-context":"kZubc","../internals/function-call":"jhLed","../internals/an-object":"1LIz9","../internals/try-to-string":"1hxsu","../internals/is-array-iterator-method":"7ORJD","../internals/length-of-array-like":"afDy6","../internals/object-is-prototype-of":"fyf1A","../internals/get-iterator":"dQrLE","../internals/get-iterator-method":"5CTSY","../internals/iterator-close":"cwu4L"}],"7ORJD":[function(require,module,exports) {
var wellKnownSymbol = require('../internals/well-known-symbol');
var Iterators = require('../internals/iterators');
var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;
// check on default Array iterator
module.exports = function(it) {
    return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};

},{"../internals/well-known-symbol":"5C8sm","../internals/iterators":"nPOBX"}],"nPOBX":[function(require,module,exports) {
module.exports = {
};

},{}],"dQrLE":[function(require,module,exports) {
var global = require('../internals/global');
var call = require('../internals/function-call');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
var tryToString = require('../internals/try-to-string');
var getIteratorMethod = require('../internals/get-iterator-method');
var TypeError = global.TypeError;
module.exports = function(argument, usingIterator) {
    var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
    if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
    throw TypeError(tryToString(argument) + ' is not iterable');
};

},{"../internals/global":"jxPDA","../internals/function-call":"jhLed","../internals/a-callable":"83opn","../internals/an-object":"1LIz9","../internals/try-to-string":"1hxsu","../internals/get-iterator-method":"5CTSY"}],"5CTSY":[function(require,module,exports) {
var classof = require('../internals/classof');
var getMethod = require('../internals/get-method');
var Iterators = require('../internals/iterators');
var wellKnownSymbol = require('../internals/well-known-symbol');
var ITERATOR = wellKnownSymbol('iterator');
module.exports = function(it) {
    if (it != undefined) return getMethod(it, ITERATOR) || getMethod(it, '@@iterator') || Iterators[classof(it)];
};

},{"../internals/classof":"kJ8JQ","../internals/get-method":"hEJ6b","../internals/iterators":"nPOBX","../internals/well-known-symbol":"5C8sm"}],"cwu4L":[function(require,module,exports) {
var call = require('../internals/function-call');
var anObject = require('../internals/an-object');
var getMethod = require('../internals/get-method');
module.exports = function(iterator, kind, value) {
    var innerResult, innerError;
    anObject(iterator);
    try {
        innerResult = getMethod(iterator, 'return');
        if (!innerResult) {
            if (kind === 'throw') throw value;
            return value;
        }
        innerResult = call(innerResult, iterator);
    } catch (error) {
        innerError = true;
        innerResult = error;
    }
    if (kind === 'throw') throw value;
    if (innerError) throw innerResult;
    anObject(innerResult);
    return value;
};

},{"../internals/function-call":"jhLed","../internals/an-object":"1LIz9","../internals/get-method":"hEJ6b"}],"hF3Zy":[function(require,module,exports) {
var $ = require('../internals/export');
var getBuiltIn = require('../internals/get-built-in');
var apply = require('../internals/function-apply');
var fails = require('../internals/fails');
var wrapErrorConstructorWithCause = require('../internals/wrap-error-constructor-with-cause');
var AGGREGATE_ERROR = 'AggregateError';
var $AggregateError = getBuiltIn(AGGREGATE_ERROR);
var FORCED = !fails(function() {
    return $AggregateError([
        1
    ]).errors[0] !== 1;
}) && fails(function() {
    return $AggregateError([
        1
    ], AGGREGATE_ERROR, {
        cause: 7
    }).cause !== 7;
});
// https://github.com/tc39/proposal-error-cause
$({
    global: true,
    forced: FORCED
}, {
    AggregateError: wrapErrorConstructorWithCause(AGGREGATE_ERROR, function(init) {
        // eslint-disable-next-line no-unused-vars -- required for functions `.length`
        return function AggregateError(errors, message) {
            return apply(init, this, arguments);
        };
    }, FORCED, true)
});

},{"../internals/export":"8yfGv","../internals/get-built-in":"78arb","../internals/function-apply":"206oi","../internals/fails":"8IfZQ","../internals/wrap-error-constructor-with-cause":"AFcuB"}],"jo7av":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var toObject = require('../internals/to-object');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
var addToUnscopables = require('../internals/add-to-unscopables');
// `Array.prototype.at` method
// https://github.com/tc39/proposal-relative-indexing-method
$({
    target: 'Array',
    proto: true
}, {
    at: function at(index) {
        var O = toObject(this);
        var len = lengthOfArrayLike(O);
        var relativeIndex = toIntegerOrInfinity(index);
        var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
        return k < 0 || k >= len ? undefined : O[k];
    }
});
addToUnscopables('at');

},{"../internals/export":"8yfGv","../internals/to-object":"eEdae","../internals/length-of-array-like":"afDy6","../internals/to-integer-or-infinity":"aqyxv","../internals/add-to-unscopables":"icGQt"}],"icGQt":[function(require,module,exports) {
var wellKnownSymbol = require('../internals/well-known-symbol');
var create = require('../internals/object-create');
var definePropertyModule = require('../internals/object-define-property');
var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;
// Array.prototype[@@unscopables]
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
});
// add a key to Array.prototype[@@unscopables]
module.exports = function(key) {
    ArrayPrototype[UNSCOPABLES][key] = true;
};

},{"../internals/well-known-symbol":"5C8sm","../internals/object-create":"1As5O","../internals/object-define-property":"bauTd"}],"hZv4u":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var global = require('../internals/global');
var fails = require('../internals/fails');
var isArray = require('../internals/is-array');
var isObject = require('../internals/is-object');
var toObject = require('../internals/to-object');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var createProperty = require('../internals/create-property');
var arraySpeciesCreate = require('../internals/array-species-create');
var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');
var wellKnownSymbol = require('../internals/well-known-symbol');
var V8_VERSION = require('../internals/engine-v8-version');
var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
var MAX_SAFE_INTEGER = 9007199254740991;
var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';
var TypeError = global.TypeError;
// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {
    var array = [];
    array[IS_CONCAT_SPREADABLE] = false;
    return array.concat()[0] !== array;
});
var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');
var isConcatSpreadable = function(O) {
    if (!isObject(O)) return false;
    var spreadable = O[IS_CONCAT_SPREADABLE];
    return spreadable !== undefined ? !!spreadable : isArray(O);
};
var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;
// `Array.prototype.concat` method
// https://tc39.es/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
$({
    target: 'Array',
    proto: true,
    forced: FORCED
}, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    concat: function concat(arg) {
        var O = toObject(this);
        var A = arraySpeciesCreate(O, 0);
        var n = 0;
        var i, k, length, len, E;
        for(i = -1, length = arguments.length; i < length; i++){
            E = i === -1 ? O : arguments[i];
            if (isConcatSpreadable(E)) {
                len = lengthOfArrayLike(E);
                if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                for(k = 0; k < len; k++, n++)if (k in E) createProperty(A, n, E[k]);
            } else {
                if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                createProperty(A, n++, E);
            }
        }
        A.length = n;
        return A;
    }
});

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/fails":"8IfZQ","../internals/is-array":"gN5mt","../internals/is-object":"dplrD","../internals/to-object":"eEdae","../internals/length-of-array-like":"afDy6","../internals/create-property":"a2n8E","../internals/array-species-create":"dEli4","../internals/array-method-has-species-support":"j18gH","../internals/well-known-symbol":"5C8sm","../internals/engine-v8-version":"9gYOM"}],"j18gH":[function(require,module,exports) {
var fails = require('../internals/fails');
var wellKnownSymbol = require('../internals/well-known-symbol');
var V8_VERSION = require('../internals/engine-v8-version');
var SPECIES = wellKnownSymbol('species');
module.exports = function(METHOD_NAME) {
    // We can't use this feature detection in V8 since it causes
    // deoptimization and serious performance degradation
    // https://github.com/zloirock/core-js/issues/677
    return V8_VERSION >= 51 || !fails(function() {
        var array = [];
        var constructor = array.constructor = {
        };
        constructor[SPECIES] = function() {
            return {
                foo: 1
            };
        };
        return array[METHOD_NAME](Boolean).foo !== 1;
    });
};

},{"../internals/fails":"8IfZQ","../internals/well-known-symbol":"5C8sm","../internals/engine-v8-version":"9gYOM"}],"lpZOH":[function(require,module,exports) {
var $ = require('../internals/export');
var copyWithin = require('../internals/array-copy-within');
var addToUnscopables = require('../internals/add-to-unscopables');
// `Array.prototype.copyWithin` method
// https://tc39.es/ecma262/#sec-array.prototype.copywithin
$({
    target: 'Array',
    proto: true
}, {
    copyWithin: copyWithin
});
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('copyWithin');

},{"../internals/export":"8yfGv","../internals/array-copy-within":"cxbSj","../internals/add-to-unscopables":"icGQt"}],"cxbSj":[function(require,module,exports) {
'use strict';
var toObject = require('../internals/to-object');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var min = Math.min;
// `Array.prototype.copyWithin` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.copywithin
// eslint-disable-next-line es/no-array-prototype-copywithin -- safe
module.exports = [].copyWithin || function copyWithin(target /* = 0 */ , start /* = 0, end = @length */ ) {
    var O = toObject(this);
    var len = lengthOfArrayLike(O);
    var to = toAbsoluteIndex(target, len);
    var from = toAbsoluteIndex(start, len);
    var end = arguments.length > 2 ? arguments[2] : undefined;
    var count = min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
    var inc = 1;
    if (from < to && to < from + count) {
        inc = -1;
        from += count - 1;
        to += count - 1;
    }
    while(count-- > 0){
        if (from in O) O[to] = O[from];
        else delete O[to];
        to += inc;
        from += inc;
    }
    return O;
};

},{"../internals/to-object":"eEdae","../internals/to-absolute-index":"dDgEq","../internals/length-of-array-like":"afDy6"}],"7h9iA":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $every = require('../internals/array-iteration').every;
var arrayMethodIsStrict = require('../internals/array-method-is-strict');
var STRICT_METHOD = arrayMethodIsStrict('every');
// `Array.prototype.every` method
// https://tc39.es/ecma262/#sec-array.prototype.every
$({
    target: 'Array',
    proto: true,
    forced: !STRICT_METHOD
}, {
    every: function every(callbackfn /* , thisArg */ ) {
        return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
});

},{"../internals/export":"8yfGv","../internals/array-iteration":"8a6lB","../internals/array-method-is-strict":"ilytn"}],"ilytn":[function(require,module,exports) {
'use strict';
var fails = require('../internals/fails');
module.exports = function(METHOD_NAME, argument) {
    var method = [][METHOD_NAME];
    return !!method && fails(function() {
        // eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing
        method.call(null, argument || function() {
            throw 1;
        }, 1);
    });
};

},{"../internals/fails":"8IfZQ"}],"8QWQB":[function(require,module,exports) {
var $ = require('../internals/export');
var fill = require('../internals/array-fill');
var addToUnscopables = require('../internals/add-to-unscopables');
// `Array.prototype.fill` method
// https://tc39.es/ecma262/#sec-array.prototype.fill
$({
    target: 'Array',
    proto: true
}, {
    fill: fill
});
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('fill');

},{"../internals/export":"8yfGv","../internals/array-fill":"fYphv","../internals/add-to-unscopables":"icGQt"}],"fYphv":[function(require,module,exports) {
'use strict';
var toObject = require('../internals/to-object');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var lengthOfArrayLike = require('../internals/length-of-array-like');
// `Array.prototype.fill` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.fill
module.exports = function fill(value /* , start = 0, end = @length */ ) {
    var O = toObject(this);
    var length = lengthOfArrayLike(O);
    var argumentsLength = arguments.length;
    var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
    var end = argumentsLength > 2 ? arguments[2] : undefined;
    var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
    while(endPos > index)O[index++] = value;
    return O;
};

},{"../internals/to-object":"eEdae","../internals/to-absolute-index":"dDgEq","../internals/length-of-array-like":"afDy6"}],"6MJ0X":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $filter = require('../internals/array-iteration').filter;
var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');
var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');
// `Array.prototype.filter` method
// https://tc39.es/ecma262/#sec-array.prototype.filter
// with adding support of @@species
$({
    target: 'Array',
    proto: true,
    forced: !HAS_SPECIES_SUPPORT
}, {
    filter: function filter(callbackfn /* , thisArg */ ) {
        return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
});

},{"../internals/export":"8yfGv","../internals/array-iteration":"8a6lB","../internals/array-method-has-species-support":"j18gH"}],"8KdiF":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $find = require('../internals/array-iteration').find;
var addToUnscopables = require('../internals/add-to-unscopables');
var FIND = 'find';
var SKIPS_HOLES = true;
// Shouldn't skip holes
if (FIND in []) Array(1)[FIND](function() {
    SKIPS_HOLES = false;
});
// `Array.prototype.find` method
// https://tc39.es/ecma262/#sec-array.prototype.find
$({
    target: 'Array',
    proto: true,
    forced: SKIPS_HOLES
}, {
    find: function find(callbackfn /* , that = undefined */ ) {
        return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
});
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND);

},{"../internals/export":"8yfGv","../internals/array-iteration":"8a6lB","../internals/add-to-unscopables":"icGQt"}],"c2wrk":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $findIndex = require('../internals/array-iteration').findIndex;
var addToUnscopables = require('../internals/add-to-unscopables');
var FIND_INDEX = 'findIndex';
var SKIPS_HOLES = true;
// Shouldn't skip holes
if (FIND_INDEX in []) Array(1)[FIND_INDEX](function() {
    SKIPS_HOLES = false;
});
// `Array.prototype.findIndex` method
// https://tc39.es/ecma262/#sec-array.prototype.findindex
$({
    target: 'Array',
    proto: true,
    forced: SKIPS_HOLES
}, {
    findIndex: function findIndex(callbackfn /* , that = undefined */ ) {
        return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
});
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND_INDEX);

},{"../internals/export":"8yfGv","../internals/array-iteration":"8a6lB","../internals/add-to-unscopables":"icGQt"}],"iXBaL":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var flattenIntoArray = require('../internals/flatten-into-array');
var toObject = require('../internals/to-object');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
var arraySpeciesCreate = require('../internals/array-species-create');
// `Array.prototype.flat` method
// https://tc39.es/ecma262/#sec-array.prototype.flat
$({
    target: 'Array',
    proto: true
}, {
    flat: function flat() {
        var depthArg = arguments.length ? arguments[0] : undefined;
        var O = toObject(this);
        var sourceLen = lengthOfArrayLike(O);
        var A = arraySpeciesCreate(O, 0);
        A.length = flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toIntegerOrInfinity(depthArg));
        return A;
    }
});

},{"../internals/export":"8yfGv","../internals/flatten-into-array":"jUXPH","../internals/to-object":"eEdae","../internals/length-of-array-like":"afDy6","../internals/to-integer-or-infinity":"aqyxv","../internals/array-species-create":"dEli4"}],"jUXPH":[function(require,module,exports) {
'use strict';
var global = require('../internals/global');
var isArray = require('../internals/is-array');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var bind = require('../internals/function-bind-context');
var TypeError = global.TypeError;
// `FlattenIntoArray` abstract operation
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var flattenIntoArray = function(target, original, source, sourceLen, start, depth, mapper, thisArg) {
    var targetIndex = start;
    var sourceIndex = 0;
    var mapFn = mapper ? bind(mapper, thisArg) : false;
    var element, elementLen;
    while(sourceIndex < sourceLen){
        if (sourceIndex in source) {
            element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
            if (depth > 0 && isArray(element)) {
                elementLen = lengthOfArrayLike(element);
                targetIndex = flattenIntoArray(target, original, element, elementLen, targetIndex, depth - 1) - 1;
            } else {
                if (targetIndex >= 9007199254740991) throw TypeError('Exceed the acceptable array length');
                target[targetIndex] = element;
            }
            targetIndex++;
        }
        sourceIndex++;
    }
    return targetIndex;
};
module.exports = flattenIntoArray;

},{"../internals/global":"jxPDA","../internals/is-array":"gN5mt","../internals/length-of-array-like":"afDy6","../internals/function-bind-context":"kZubc"}],"6XfAZ":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var flattenIntoArray = require('../internals/flatten-into-array');
var aCallable = require('../internals/a-callable');
var toObject = require('../internals/to-object');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var arraySpeciesCreate = require('../internals/array-species-create');
// `Array.prototype.flatMap` method
// https://tc39.es/ecma262/#sec-array.prototype.flatmap
$({
    target: 'Array',
    proto: true
}, {
    flatMap: function flatMap(callbackfn /* , thisArg */ ) {
        var O = toObject(this);
        var sourceLen = lengthOfArrayLike(O);
        var A;
        aCallable(callbackfn);
        A = arraySpeciesCreate(O, 0);
        A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        return A;
    }
});

},{"../internals/export":"8yfGv","../internals/flatten-into-array":"jUXPH","../internals/a-callable":"83opn","../internals/to-object":"eEdae","../internals/length-of-array-like":"afDy6","../internals/array-species-create":"dEli4"}],"4BjMF":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var forEach = require('../internals/array-for-each');
// `Array.prototype.forEach` method
// https://tc39.es/ecma262/#sec-array.prototype.foreach
// eslint-disable-next-line es/no-array-prototype-foreach -- safe
$({
    target: 'Array',
    proto: true,
    forced: [].forEach != forEach
}, {
    forEach: forEach
});

},{"../internals/export":"8yfGv","../internals/array-for-each":"aAPs6"}],"aAPs6":[function(require,module,exports) {
'use strict';
var $forEach = require('../internals/array-iteration').forEach;
var arrayMethodIsStrict = require('../internals/array-method-is-strict');
var STRICT_METHOD = arrayMethodIsStrict('forEach');
// `Array.prototype.forEach` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.foreach
module.exports = !STRICT_METHOD ? function forEach(callbackfn /* , thisArg */ ) {
    return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
// eslint-disable-next-line es/no-array-prototype-foreach -- safe
} : [].forEach;

},{"../internals/array-iteration":"8a6lB","../internals/array-method-is-strict":"ilytn"}],"6k4iU":[function(require,module,exports) {
var $ = require('../internals/export');
var from = require('../internals/array-from');
var checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');
var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
    // eslint-disable-next-line es/no-array-from -- required for testing
    Array.from(iterable);
});
// `Array.from` method
// https://tc39.es/ecma262/#sec-array.from
$({
    target: 'Array',
    stat: true,
    forced: INCORRECT_ITERATION
}, {
    from: from
});

},{"../internals/export":"8yfGv","../internals/array-from":"feEcT","../internals/check-correctness-of-iteration":"788V9"}],"feEcT":[function(require,module,exports) {
'use strict';
var global = require('../internals/global');
var bind = require('../internals/function-bind-context');
var call = require('../internals/function-call');
var toObject = require('../internals/to-object');
var callWithSafeIterationClosing = require('../internals/call-with-safe-iteration-closing');
var isArrayIteratorMethod = require('../internals/is-array-iterator-method');
var isConstructor = require('../internals/is-constructor');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var createProperty = require('../internals/create-property');
var getIterator = require('../internals/get-iterator');
var getIteratorMethod = require('../internals/get-iterator-method');
var Array = global.Array;
// `Array.from` method implementation
// https://tc39.es/ecma262/#sec-array.from
module.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */ ) {
    var O = toObject(arrayLike);
    var IS_CONSTRUCTOR = isConstructor(this);
    var argumentsLength = arguments.length;
    var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined);
    var iteratorMethod = getIteratorMethod(O);
    var index = 0;
    var length, result, step, iterator, next, value;
    // if the target is not iterable or it's an array with the default iterator - use a simple case
    if (iteratorMethod && !(this == Array && isArrayIteratorMethod(iteratorMethod))) {
        iterator = getIterator(O, iteratorMethod);
        next = iterator.next;
        result = IS_CONSTRUCTOR ? new this() : [];
        for(; !(step = call(next, iterator)).done; index++){
            value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [
                step.value,
                index
            ], true) : step.value;
            createProperty(result, index, value);
        }
    } else {
        length = lengthOfArrayLike(O);
        result = IS_CONSTRUCTOR ? new this(length) : Array(length);
        for(; length > index; index++){
            value = mapping ? mapfn(O[index], index) : O[index];
            createProperty(result, index, value);
        }
    }
    result.length = index;
    return result;
};

},{"../internals/global":"jxPDA","../internals/function-bind-context":"kZubc","../internals/function-call":"jhLed","../internals/to-object":"eEdae","../internals/call-with-safe-iteration-closing":"b1Dt0","../internals/is-array-iterator-method":"7ORJD","../internals/is-constructor":"iNoNi","../internals/length-of-array-like":"afDy6","../internals/create-property":"a2n8E","../internals/get-iterator":"dQrLE","../internals/get-iterator-method":"5CTSY"}],"b1Dt0":[function(require,module,exports) {
var anObject = require('../internals/an-object');
var iteratorClose = require('../internals/iterator-close');
// call something on iterator step with safe closing on error
module.exports = function(iterator, fn, value, ENTRIES) {
    try {
        return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
    } catch (error) {
        iteratorClose(iterator, 'throw', error);
    }
};

},{"../internals/an-object":"1LIz9","../internals/iterator-close":"cwu4L"}],"788V9":[function(require,module,exports) {
var wellKnownSymbol = require('../internals/well-known-symbol');
var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;
try {
    var called = 0;
    var iteratorWithReturn = {
        next: function() {
            return {
                done: !!called++
            };
        },
        'return': function() {
            SAFE_CLOSING = true;
        }
    };
    iteratorWithReturn[ITERATOR] = function() {
        return this;
    };
    // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
    Array.from(iteratorWithReturn, function() {
        throw 2;
    });
} catch (error) {
}
module.exports = function(exec, SKIP_CLOSING) {
    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
    var ITERATION_SUPPORT = false;
    try {
        var object = {
        };
        object[ITERATOR] = function() {
            return {
                next: function() {
                    return {
                        done: ITERATION_SUPPORT = true
                    };
                }
            };
        };
        exec(object);
    } catch (error) {
    }
    return ITERATION_SUPPORT;
};

},{"../internals/well-known-symbol":"5C8sm"}],"2opYk":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $includes = require('../internals/array-includes').includes;
var addToUnscopables = require('../internals/add-to-unscopables');
// `Array.prototype.includes` method
// https://tc39.es/ecma262/#sec-array.prototype.includes
$({
    target: 'Array',
    proto: true
}, {
    includes: function includes(el /* , fromIndex = 0 */ ) {
        return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
    }
});
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('includes');

},{"../internals/export":"8yfGv","../internals/array-includes":"SXf52","../internals/add-to-unscopables":"icGQt"}],"fclII":[function(require,module,exports) {
'use strict';
/* eslint-disable es/no-array-prototype-indexof -- required for testing */ var $ = require('../internals/export');
var uncurryThis = require('../internals/function-uncurry-this');
var $IndexOf = require('../internals/array-includes').indexOf;
var arrayMethodIsStrict = require('../internals/array-method-is-strict');
var un$IndexOf = uncurryThis([].indexOf);
var NEGATIVE_ZERO = !!un$IndexOf && 1 / un$IndexOf([
    1
], 1, -0) < 0;
var STRICT_METHOD = arrayMethodIsStrict('indexOf');
// `Array.prototype.indexOf` method
// https://tc39.es/ecma262/#sec-array.prototype.indexof
$({
    target: 'Array',
    proto: true,
    forced: NEGATIVE_ZERO || !STRICT_METHOD
}, {
    indexOf: function indexOf(searchElement /* , fromIndex = 0 */ ) {
        var fromIndex = arguments.length > 1 ? arguments[1] : undefined;
        return NEGATIVE_ZERO ? un$IndexOf(this, searchElement, fromIndex) || 0 : $IndexOf(this, searchElement, fromIndex);
    }
});

},{"../internals/export":"8yfGv","../internals/function-uncurry-this":"jJnXC","../internals/array-includes":"SXf52","../internals/array-method-is-strict":"ilytn"}],"8Ekd6":[function(require,module,exports) {
var $ = require('../internals/export');
var isArray = require('../internals/is-array');
// `Array.isArray` method
// https://tc39.es/ecma262/#sec-array.isarray
$({
    target: 'Array',
    stat: true
}, {
    isArray: isArray
});

},{"../internals/export":"8yfGv","../internals/is-array":"gN5mt"}],"bLuDU":[function(require,module,exports) {
'use strict';
var toIndexedObject = require('../internals/to-indexed-object');
var addToUnscopables = require('../internals/add-to-unscopables');
var Iterators = require('../internals/iterators');
var InternalStateModule = require('../internals/internal-state');
var defineProperty = require('../internals/object-define-property').f;
var defineIterator = require('../internals/define-iterator');
var IS_PURE = require('../internals/is-pure');
var DESCRIPTORS = require('../internals/descriptors');
var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
// `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function(iterated, kind) {
    setInternalState(this, {
        type: ARRAY_ITERATOR,
        target: toIndexedObject(iterated),
        index: 0,
        kind: kind // kind
    });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function() {
    var state = getInternalState(this);
    var target = state.target;
    var kind = state.kind;
    var index = state.index++;
    if (!target || index >= target.length) {
        state.target = undefined;
        return {
            value: undefined,
            done: true
        };
    }
    if (kind == 'keys') return {
        value: index,
        done: false
    };
    if (kind == 'values') return {
        value: target[index],
        done: false
    };
    return {
        value: [
            index,
            target[index]
        ],
        done: false
    };
}, 'values');
// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject
var values = Iterators.Arguments = Iterators.Array;
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');
// V8 ~ Chrome 45- bug
if (!IS_PURE && DESCRIPTORS && values.name !== 'values') try {
    defineProperty(values, 'name', {
        value: 'values'
    });
} catch (error) {
}

},{"../internals/to-indexed-object":"8ueFu","../internals/add-to-unscopables":"icGQt","../internals/iterators":"nPOBX","../internals/internal-state":"i6AaM","../internals/object-define-property":"bauTd","../internals/define-iterator":"3Ugai","../internals/is-pure":"6Bbq0","../internals/descriptors":"6ZLib"}],"3Ugai":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var call = require('../internals/function-call');
var IS_PURE = require('../internals/is-pure');
var FunctionName = require('../internals/function-name');
var isCallable = require('../internals/is-callable');
var createIteratorConstructor = require('../internals/create-iterator-constructor');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var setPrototypeOf = require('../internals/object-set-prototype-of');
var setToStringTag = require('../internals/set-to-string-tag');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var redefine = require('../internals/redefine');
var wellKnownSymbol = require('../internals/well-known-symbol');
var Iterators = require('../internals/iterators');
var IteratorsCore = require('../internals/iterators-core');
var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';
var returnThis = function() {
    return this;
};
module.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
    createIteratorConstructor(IteratorConstructor, NAME, next);
    var getIterationMethod = function(KIND) {
        if (KIND === DEFAULT && defaultIterator) return defaultIterator;
        if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
        switch(KIND){
            case KEYS:
                return function keys() {
                    return new IteratorConstructor(this, KIND);
                };
            case VALUES:
                return function values() {
                    return new IteratorConstructor(this, KIND);
                };
            case ENTRIES:
                return function entries() {
                    return new IteratorConstructor(this, KIND);
                };
        }
        return function() {
            return new IteratorConstructor(this);
        };
    };
    var TO_STRING_TAG = NAME + ' Iterator';
    var INCORRECT_VALUES_NAME = false;
    var IterablePrototype = Iterable.prototype;
    var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
    var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
    var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
    var CurrentIteratorPrototype, methods, KEY;
    // fix native
    if (anyNativeIterator) {
        CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
        if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
            if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
                if (setPrototypeOf) setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
                else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) redefine(CurrentIteratorPrototype, ITERATOR, returnThis);
            }
            // Set @@toStringTag to native iterators
            setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
            if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
        }
    }
    // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
    if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
        if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) createNonEnumerableProperty(IterablePrototype, 'name', VALUES);
        else {
            INCORRECT_VALUES_NAME = true;
            defaultIterator = function values() {
                return call(nativeIterator, this);
            };
        }
    }
    // export additional methods
    if (DEFAULT) {
        methods = {
            values: getIterationMethod(VALUES),
            keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
            entries: getIterationMethod(ENTRIES)
        };
        if (FORCED) {
            for(KEY in methods)if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) redefine(IterablePrototype, KEY, methods[KEY]);
        } else $({
            target: NAME,
            proto: true,
            forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
        }, methods);
    }
    // define iterator
    if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) redefine(IterablePrototype, ITERATOR, defaultIterator, {
        name: DEFAULT
    });
    Iterators[NAME] = defaultIterator;
    return methods;
};

},{"../internals/export":"8yfGv","../internals/function-call":"jhLed","../internals/is-pure":"6Bbq0","../internals/function-name":"6v6mP","../internals/is-callable":"kPhuP","../internals/create-iterator-constructor":"1fB00","../internals/object-get-prototype-of":"lBy7h","../internals/object-set-prototype-of":"lb6rR","../internals/set-to-string-tag":"9arwS","../internals/create-non-enumerable-property":"6Z1es","../internals/redefine":"kxbj8","../internals/well-known-symbol":"5C8sm","../internals/iterators":"nPOBX","../internals/iterators-core":"gL68y"}],"1fB00":[function(require,module,exports) {
'use strict';
var IteratorPrototype = require('../internals/iterators-core').IteratorPrototype;
var create = require('../internals/object-create');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var setToStringTag = require('../internals/set-to-string-tag');
var Iterators = require('../internals/iterators');
var returnThis = function() {
    return this;
};
module.exports = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
    var TO_STRING_TAG = NAME + ' Iterator';
    IteratorConstructor.prototype = create(IteratorPrototype, {
        next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next)
    });
    setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
    Iterators[TO_STRING_TAG] = returnThis;
    return IteratorConstructor;
};

},{"../internals/iterators-core":"gL68y","../internals/object-create":"1As5O","../internals/create-property-descriptor":"ermgb","../internals/set-to-string-tag":"9arwS","../internals/iterators":"nPOBX"}],"gL68y":[function(require,module,exports) {
'use strict';
var fails = require('../internals/fails');
var isCallable = require('../internals/is-callable');
var create = require('../internals/object-create');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var redefine = require('../internals/redefine');
var wellKnownSymbol = require('../internals/well-known-symbol');
var IS_PURE = require('../internals/is-pure');
var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;
// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
/* eslint-disable es/no-array-prototype-keys -- safe */ if ([].keys) {
    arrayIterator = [].keys();
    // Safari 8 has buggy iterators w/o `next`
    if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
    else {
        PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
        if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
    }
}
var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function() {
    var test = {
    };
    // FF44- legacy iterators case
    return IteratorPrototype[ITERATOR].call(test) !== test;
});
if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {
};
else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);
// `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
if (!isCallable(IteratorPrototype[ITERATOR])) redefine(IteratorPrototype, ITERATOR, function() {
    return this;
});
module.exports = {
    IteratorPrototype: IteratorPrototype,
    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};

},{"../internals/fails":"8IfZQ","../internals/is-callable":"kPhuP","../internals/object-create":"1As5O","../internals/object-get-prototype-of":"lBy7h","../internals/redefine":"kxbj8","../internals/well-known-symbol":"5C8sm","../internals/is-pure":"6Bbq0"}],"7ggFm":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var uncurryThis = require('../internals/function-uncurry-this');
var IndexedObject = require('../internals/indexed-object');
var toIndexedObject = require('../internals/to-indexed-object');
var arrayMethodIsStrict = require('../internals/array-method-is-strict');
var un$Join = uncurryThis([].join);
var ES3_STRINGS = IndexedObject != Object;
var STRICT_METHOD = arrayMethodIsStrict('join', ',');
// `Array.prototype.join` method
// https://tc39.es/ecma262/#sec-array.prototype.join
$({
    target: 'Array',
    proto: true,
    forced: ES3_STRINGS || !STRICT_METHOD
}, {
    join: function join(separator) {
        return un$Join(toIndexedObject(this), separator === undefined ? ',' : separator);
    }
});

},{"../internals/export":"8yfGv","../internals/function-uncurry-this":"jJnXC","../internals/indexed-object":"e5ccT","../internals/to-indexed-object":"8ueFu","../internals/array-method-is-strict":"ilytn"}],"9cdXg":[function(require,module,exports) {
var $ = require('../internals/export');
var lastIndexOf = require('../internals/array-last-index-of');
// `Array.prototype.lastIndexOf` method
// https://tc39.es/ecma262/#sec-array.prototype.lastindexof
// eslint-disable-next-line es/no-array-prototype-lastindexof -- required for testing
$({
    target: 'Array',
    proto: true,
    forced: lastIndexOf !== [].lastIndexOf
}, {
    lastIndexOf: lastIndexOf
});

},{"../internals/export":"8yfGv","../internals/array-last-index-of":"dcOLl"}],"dcOLl":[function(require,module,exports) {
'use strict';
/* eslint-disable es/no-array-prototype-lastindexof -- safe */ var apply = require('../internals/function-apply');
var toIndexedObject = require('../internals/to-indexed-object');
var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var arrayMethodIsStrict = require('../internals/array-method-is-strict');
var min = Math.min;
var $lastIndexOf = [].lastIndexOf;
var NEGATIVE_ZERO = !!$lastIndexOf && 1 / [
    1
].lastIndexOf(1, -0) < 0;
var STRICT_METHOD = arrayMethodIsStrict('lastIndexOf');
var FORCED = NEGATIVE_ZERO || !STRICT_METHOD;
// `Array.prototype.lastIndexOf` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.lastindexof
module.exports = FORCED ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */ ) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return apply($lastIndexOf, this, arguments) || 0;
    var O = toIndexedObject(this);
    var length = lengthOfArrayLike(O);
    var index = length - 1;
    if (arguments.length > 1) index = min(index, toIntegerOrInfinity(arguments[1]));
    if (index < 0) index = length + index;
    for(; index >= 0; index--)if (index in O && O[index] === searchElement) return index || 0;
    return -1;
} : $lastIndexOf;

},{"../internals/function-apply":"206oi","../internals/to-indexed-object":"8ueFu","../internals/to-integer-or-infinity":"aqyxv","../internals/length-of-array-like":"afDy6","../internals/array-method-is-strict":"ilytn"}],"i0aqD":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $map = require('../internals/array-iteration').map;
var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');
var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');
// `Array.prototype.map` method
// https://tc39.es/ecma262/#sec-array.prototype.map
// with adding support of @@species
$({
    target: 'Array',
    proto: true,
    forced: !HAS_SPECIES_SUPPORT
}, {
    map: function map(callbackfn /* , thisArg */ ) {
        return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
});

},{"../internals/export":"8yfGv","../internals/array-iteration":"8a6lB","../internals/array-method-has-species-support":"j18gH"}],"9zSOw":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var global = require('../internals/global');
var fails = require('../internals/fails');
var isConstructor = require('../internals/is-constructor');
var createProperty = require('../internals/create-property');
var Array = global.Array;
var ISNT_GENERIC = fails(function() {
    function F() {
    }
    return !(Array.of.call(F) instanceof F);
});
// `Array.of` method
// https://tc39.es/ecma262/#sec-array.of
// WebKit Array.of isn't generic
$({
    target: 'Array',
    stat: true,
    forced: ISNT_GENERIC
}, {
    of: function of() {
        var index = 0;
        var argumentsLength = arguments.length;
        var result = new (isConstructor(this) ? this : Array)(argumentsLength);
        while(argumentsLength > index)createProperty(result, index, arguments[index++]);
        result.length = argumentsLength;
        return result;
    }
});

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/fails":"8IfZQ","../internals/is-constructor":"iNoNi","../internals/create-property":"a2n8E"}],"8W8UG":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $reduce = require('../internals/array-reduce').left;
var arrayMethodIsStrict = require('../internals/array-method-is-strict');
var CHROME_VERSION = require('../internals/engine-v8-version');
var IS_NODE = require('../internals/engine-is-node');
var STRICT_METHOD = arrayMethodIsStrict('reduce');
// Chrome 80-82 has a critical bug
// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982
var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
// `Array.prototype.reduce` method
// https://tc39.es/ecma262/#sec-array.prototype.reduce
$({
    target: 'Array',
    proto: true,
    forced: !STRICT_METHOD || CHROME_BUG
}, {
    reduce: function reduce(callbackfn /* , initialValue */ ) {
        var length = arguments.length;
        return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : undefined);
    }
});

},{"../internals/export":"8yfGv","../internals/array-reduce":"j7uXX","../internals/array-method-is-strict":"ilytn","../internals/engine-v8-version":"9gYOM","../internals/engine-is-node":"jwobg"}],"j7uXX":[function(require,module,exports) {
var global = require('../internals/global');
var aCallable = require('../internals/a-callable');
var toObject = require('../internals/to-object');
var IndexedObject = require('../internals/indexed-object');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var TypeError = global.TypeError;
// `Array.prototype.{ reduce, reduceRight }` methods implementation
var createMethod = function(IS_RIGHT) {
    return function(that, callbackfn, argumentsLength, memo) {
        aCallable(callbackfn);
        var O = toObject(that);
        var self = IndexedObject(O);
        var length = lengthOfArrayLike(O);
        var index = IS_RIGHT ? length - 1 : 0;
        var i = IS_RIGHT ? -1 : 1;
        if (argumentsLength < 2) while(true){
            if (index in self) {
                memo = self[index];
                index += i;
                break;
            }
            index += i;
            if (IS_RIGHT ? index < 0 : length <= index) throw TypeError('Reduce of empty array with no initial value');
        }
        for(; IS_RIGHT ? index >= 0 : length > index; index += i)if (index in self) memo = callbackfn(memo, self[index], index, O);
        return memo;
    };
};
module.exports = {
    // `Array.prototype.reduce` method
    // https://tc39.es/ecma262/#sec-array.prototype.reduce
    left: createMethod(false),
    // `Array.prototype.reduceRight` method
    // https://tc39.es/ecma262/#sec-array.prototype.reduceright
    right: createMethod(true)
};

},{"../internals/global":"jxPDA","../internals/a-callable":"83opn","../internals/to-object":"eEdae","../internals/indexed-object":"e5ccT","../internals/length-of-array-like":"afDy6"}],"jwobg":[function(require,module,exports) {
var classof = require('../internals/classof-raw');
var global = require('../internals/global');
module.exports = classof(global.process) == 'process';

},{"../internals/classof-raw":"A9m3U","../internals/global":"jxPDA"}],"9rWU2":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $reduceRight = require('../internals/array-reduce').right;
var arrayMethodIsStrict = require('../internals/array-method-is-strict');
var CHROME_VERSION = require('../internals/engine-v8-version');
var IS_NODE = require('../internals/engine-is-node');
var STRICT_METHOD = arrayMethodIsStrict('reduceRight');
// Chrome 80-82 has a critical bug
// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982
var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
// `Array.prototype.reduceRight` method
// https://tc39.es/ecma262/#sec-array.prototype.reduceright
$({
    target: 'Array',
    proto: true,
    forced: !STRICT_METHOD || CHROME_BUG
}, {
    reduceRight: function reduceRight(callbackfn /* , initialValue */ ) {
        return $reduceRight(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
    }
});

},{"../internals/export":"8yfGv","../internals/array-reduce":"j7uXX","../internals/array-method-is-strict":"ilytn","../internals/engine-v8-version":"9gYOM","../internals/engine-is-node":"jwobg"}],"9QaOG":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var uncurryThis = require('../internals/function-uncurry-this');
var isArray = require('../internals/is-array');
var un$Reverse = uncurryThis([].reverse);
var test = [
    1,
    2
];
// `Array.prototype.reverse` method
// https://tc39.es/ecma262/#sec-array.prototype.reverse
// fix for Safari 12.0 bug
// https://bugs.webkit.org/show_bug.cgi?id=188794
$({
    target: 'Array',
    proto: true,
    forced: String(test) === String(test.reverse())
}, {
    reverse: function reverse() {
        // eslint-disable-next-line no-self-assign -- dirty hack
        if (isArray(this)) this.length = this.length;
        return un$Reverse(this);
    }
});

},{"../internals/export":"8yfGv","../internals/function-uncurry-this":"jJnXC","../internals/is-array":"gN5mt"}],"4FAgT":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var global = require('../internals/global');
var isArray = require('../internals/is-array');
var isConstructor = require('../internals/is-constructor');
var isObject = require('../internals/is-object');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var toIndexedObject = require('../internals/to-indexed-object');
var createProperty = require('../internals/create-property');
var wellKnownSymbol = require('../internals/well-known-symbol');
var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');
var un$Slice = require('../internals/array-slice');
var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');
var SPECIES = wellKnownSymbol('species');
var Array = global.Array;
var max = Math.max;
// `Array.prototype.slice` method
// https://tc39.es/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects
$({
    target: 'Array',
    proto: true,
    forced: !HAS_SPECIES_SUPPORT
}, {
    slice: function slice(start, end) {
        var O = toIndexedObject(this);
        var length = lengthOfArrayLike(O);
        var k = toAbsoluteIndex(start, length);
        var fin = toAbsoluteIndex(end === undefined ? length : end, length);
        // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
        var Constructor, result, n;
        if (isArray(O)) {
            Constructor = O.constructor;
            // cross-realm fallback
            if (isConstructor(Constructor) && (Constructor === Array || isArray(Constructor.prototype))) Constructor = undefined;
            else if (isObject(Constructor)) {
                Constructor = Constructor[SPECIES];
                if (Constructor === null) Constructor = undefined;
            }
            if (Constructor === Array || Constructor === undefined) return un$Slice(O, k, fin);
        }
        result = new (Constructor === undefined ? Array : Constructor)(max(fin - k, 0));
        for(n = 0; k < fin; k++, n++)if (k in O) createProperty(result, n, O[k]);
        result.length = n;
        return result;
    }
});

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/is-array":"gN5mt","../internals/is-constructor":"iNoNi","../internals/is-object":"dplrD","../internals/to-absolute-index":"dDgEq","../internals/length-of-array-like":"afDy6","../internals/to-indexed-object":"8ueFu","../internals/create-property":"a2n8E","../internals/well-known-symbol":"5C8sm","../internals/array-method-has-species-support":"j18gH","../internals/array-slice":"bI1dk"}],"1kmsQ":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $some = require('../internals/array-iteration').some;
var arrayMethodIsStrict = require('../internals/array-method-is-strict');
var STRICT_METHOD = arrayMethodIsStrict('some');
// `Array.prototype.some` method
// https://tc39.es/ecma262/#sec-array.prototype.some
$({
    target: 'Array',
    proto: true,
    forced: !STRICT_METHOD
}, {
    some: function some(callbackfn /* , thisArg */ ) {
        return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
});

},{"../internals/export":"8yfGv","../internals/array-iteration":"8a6lB","../internals/array-method-is-strict":"ilytn"}],"6yZcJ":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var uncurryThis = require('../internals/function-uncurry-this');
var aCallable = require('../internals/a-callable');
var toObject = require('../internals/to-object');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var toString = require('../internals/to-string');
var fails = require('../internals/fails');
var internalSort = require('../internals/array-sort');
var arrayMethodIsStrict = require('../internals/array-method-is-strict');
var FF = require('../internals/engine-ff-version');
var IE_OR_EDGE = require('../internals/engine-is-ie-or-edge');
var V8 = require('../internals/engine-v8-version');
var WEBKIT = require('../internals/engine-webkit-version');
var test = [];
var un$Sort = uncurryThis(test.sort);
var push = uncurryThis(test.push);
// IE8-
var FAILS_ON_UNDEFINED = fails(function() {
    test.sort(undefined);
});
// V8 bug
var FAILS_ON_NULL = fails(function() {
    test.sort(null);
});
// Old WebKit
var STRICT_METHOD = arrayMethodIsStrict('sort');
var STABLE_SORT = !fails(function() {
    // feature detection can be too slow, so check engines versions
    if (V8) return V8 < 70;
    if (FF && FF > 3) return;
    if (IE_OR_EDGE) return true;
    if (WEBKIT) return WEBKIT < 603;
    var result = '';
    var code, chr, value, index;
    // generate an array with more 512 elements (Chakra and old V8 fails only in this case)
    for(code = 65; code < 76; code++){
        chr = String.fromCharCode(code);
        switch(code){
            case 66:
            case 69:
            case 70:
            case 72:
                value = 3;
                break;
            case 68:
            case 71:
                value = 4;
                break;
            default:
                value = 2;
        }
        for(index = 0; index < 47; index++)test.push({
            k: chr + index,
            v: value
        });
    }
    test.sort(function(a, b) {
        return b.v - a.v;
    });
    for(index = 0; index < test.length; index++){
        chr = test[index].k.charAt(0);
        if (result.charAt(result.length - 1) !== chr) result += chr;
    }
    return result !== 'DGBEFHACIJK';
});
var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;
var getSortCompare = function(comparefn) {
    return function(x, y) {
        if (y === undefined) return -1;
        if (x === undefined) return 1;
        if (comparefn !== undefined) return +comparefn(x, y) || 0;
        return toString(x) > toString(y) ? 1 : -1;
    };
};
// `Array.prototype.sort` method
// https://tc39.es/ecma262/#sec-array.prototype.sort
$({
    target: 'Array',
    proto: true,
    forced: FORCED
}, {
    sort: function sort(comparefn) {
        if (comparefn !== undefined) aCallable(comparefn);
        var array = toObject(this);
        if (STABLE_SORT) return comparefn === undefined ? un$Sort(array) : un$Sort(array, comparefn);
        var items = [];
        var arrayLength = lengthOfArrayLike(array);
        var itemsLength, index;
        for(index = 0; index < arrayLength; index++)if (index in array) push(items, array[index]);
        internalSort(items, getSortCompare(comparefn));
        itemsLength = items.length;
        index = 0;
        while(index < itemsLength)array[index] = items[index++];
        while(index < arrayLength)delete array[index++];
        return array;
    }
});

},{"../internals/export":"8yfGv","../internals/function-uncurry-this":"jJnXC","../internals/a-callable":"83opn","../internals/to-object":"eEdae","../internals/length-of-array-like":"afDy6","../internals/to-string":"4cTlm","../internals/fails":"8IfZQ","../internals/array-sort":"ik2R5","../internals/array-method-is-strict":"ilytn","../internals/engine-ff-version":"kOv6x","../internals/engine-is-ie-or-edge":"kQ3dM","../internals/engine-v8-version":"9gYOM","../internals/engine-webkit-version":"a5m5j"}],"ik2R5":[function(require,module,exports) {
var arraySlice = require('../internals/array-slice-simple');
var floor = Math.floor;
var mergeSort = function(array, comparefn) {
    var length = array.length;
    var middle = floor(length / 2);
    return length < 8 ? insertionSort(array, comparefn) : merge(array, mergeSort(arraySlice(array, 0, middle), comparefn), mergeSort(arraySlice(array, middle), comparefn), comparefn);
};
var insertionSort = function(array, comparefn) {
    var length = array.length;
    var i = 1;
    var element, j;
    while(i < length){
        j = i;
        element = array[i];
        while(j && comparefn(array[j - 1], element) > 0)array[j] = array[--j];
        if (j !== i++) array[j] = element;
    }
    return array;
};
var merge = function(array, left, right, comparefn) {
    var llength = left.length;
    var rlength = right.length;
    var lindex = 0;
    var rindex = 0;
    while(lindex < llength || rindex < rlength)array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];
    return array;
};
module.exports = mergeSort;

},{"../internals/array-slice-simple":"bYLId"}],"kOv6x":[function(require,module,exports) {
var userAgent = require('../internals/engine-user-agent');
var firefox = userAgent.match(/firefox\/(\d+)/i);
module.exports = !!firefox && +firefox[1];

},{"../internals/engine-user-agent":"boFeV"}],"kQ3dM":[function(require,module,exports) {
var UA = require('../internals/engine-user-agent');
module.exports = /MSIE|Trident/.test(UA);

},{"../internals/engine-user-agent":"boFeV"}],"a5m5j":[function(require,module,exports) {
var userAgent = require('../internals/engine-user-agent');
var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);
module.exports = !!webkit && +webkit[1];

},{"../internals/engine-user-agent":"boFeV"}],"59wEf":[function(require,module,exports) {
var setSpecies = require('../internals/set-species');
// `Array[@@species]` getter
// https://tc39.es/ecma262/#sec-get-array-@@species
setSpecies('Array');

},{"../internals/set-species":"hBKMQ"}],"hBKMQ":[function(require,module,exports) {
'use strict';
var getBuiltIn = require('../internals/get-built-in');
var definePropertyModule = require('../internals/object-define-property');
var wellKnownSymbol = require('../internals/well-known-symbol');
var DESCRIPTORS = require('../internals/descriptors');
var SPECIES = wellKnownSymbol('species');
module.exports = function(CONSTRUCTOR_NAME) {
    var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
    var defineProperty = definePropertyModule.f;
    if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) defineProperty(Constructor, SPECIES, {
        configurable: true,
        get: function() {
            return this;
        }
    });
};

},{"../internals/get-built-in":"78arb","../internals/object-define-property":"bauTd","../internals/well-known-symbol":"5C8sm","../internals/descriptors":"6ZLib"}],"fFvxO":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var global = require('../internals/global');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var toObject = require('../internals/to-object');
var arraySpeciesCreate = require('../internals/array-species-create');
var createProperty = require('../internals/create-property');
var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');
var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');
var TypeError = global.TypeError;
var max = Math.max;
var min = Math.min;
var MAX_SAFE_INTEGER = 9007199254740991;
var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';
// `Array.prototype.splice` method
// https://tc39.es/ecma262/#sec-array.prototype.splice
// with adding support of @@species
$({
    target: 'Array',
    proto: true,
    forced: !HAS_SPECIES_SUPPORT
}, {
    splice: function splice(start, deleteCount /* , ...items */ ) {
        var O = toObject(this);
        var len = lengthOfArrayLike(O);
        var actualStart = toAbsoluteIndex(start, len);
        var argumentsLength = arguments.length;
        var insertCount, actualDeleteCount, A, k, from, to;
        if (argumentsLength === 0) insertCount = actualDeleteCount = 0;
        else if (argumentsLength === 1) {
            insertCount = 0;
            actualDeleteCount = len - actualStart;
        } else {
            insertCount = argumentsLength - 2;
            actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
        }
        if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
        A = arraySpeciesCreate(O, actualDeleteCount);
        for(k = 0; k < actualDeleteCount; k++){
            from = actualStart + k;
            if (from in O) createProperty(A, k, O[from]);
        }
        A.length = actualDeleteCount;
        if (insertCount < actualDeleteCount) {
            for(k = actualStart; k < len - actualDeleteCount; k++){
                from = k + actualDeleteCount;
                to = k + insertCount;
                if (from in O) O[to] = O[from];
                else delete O[to];
            }
            for(k = len; k > len - actualDeleteCount + insertCount; k--)delete O[k - 1];
        } else if (insertCount > actualDeleteCount) for(k = len - actualDeleteCount; k > actualStart; k--){
            from = k + actualDeleteCount - 1;
            to = k + insertCount - 1;
            if (from in O) O[to] = O[from];
            else delete O[to];
        }
        for(k = 0; k < insertCount; k++)O[k + actualStart] = arguments[k + 2];
        O.length = len - actualDeleteCount + insertCount;
        return A;
    }
});

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/to-absolute-index":"dDgEq","../internals/to-integer-or-infinity":"aqyxv","../internals/length-of-array-like":"afDy6","../internals/to-object":"eEdae","../internals/array-species-create":"dEli4","../internals/create-property":"a2n8E","../internals/array-method-has-species-support":"j18gH"}],"kxzUm":[function(require,module,exports) {
// this method was added to unscopables after implementation
// in popular engines, so it's moved to a separate module
var addToUnscopables = require('../internals/add-to-unscopables');
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('flat');

},{"../internals/add-to-unscopables":"icGQt"}],"fWXha":[function(require,module,exports) {
// this method was added to unscopables after implementation
// in popular engines, so it's moved to a separate module
var addToUnscopables = require('../internals/add-to-unscopables');
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('flatMap');

},{"../internals/add-to-unscopables":"icGQt"}],"iMKfl":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var global = require('../internals/global');
var arrayBufferModule = require('../internals/array-buffer');
var setSpecies = require('../internals/set-species');
var ARRAY_BUFFER = 'ArrayBuffer';
var ArrayBuffer = arrayBufferModule[ARRAY_BUFFER];
var NativeArrayBuffer = global[ARRAY_BUFFER];
// `ArrayBuffer` constructor
// https://tc39.es/ecma262/#sec-arraybuffer-constructor
$({
    global: true,
    forced: NativeArrayBuffer !== ArrayBuffer
}, {
    ArrayBuffer: ArrayBuffer
});
setSpecies(ARRAY_BUFFER);

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/array-buffer":"eiDN2","../internals/set-species":"hBKMQ"}],"eiDN2":[function(require,module,exports) {
'use strict';
var global = require('../internals/global');
var uncurryThis = require('../internals/function-uncurry-this');
var DESCRIPTORS = require('../internals/descriptors');
var NATIVE_ARRAY_BUFFER = require('../internals/array-buffer-native');
var FunctionName = require('../internals/function-name');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var redefineAll = require('../internals/redefine-all');
var fails = require('../internals/fails');
var anInstance = require('../internals/an-instance');
var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
var toLength = require('../internals/to-length');
var toIndex = require('../internals/to-index');
var IEEE754 = require('../internals/ieee754');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var setPrototypeOf = require('../internals/object-set-prototype-of');
var getOwnPropertyNames = require('../internals/object-get-own-property-names').f;
var defineProperty = require('../internals/object-define-property').f;
var arrayFill = require('../internals/array-fill');
var arraySlice = require('../internals/array-slice-simple');
var setToStringTag = require('../internals/set-to-string-tag');
var InternalStateModule = require('../internals/internal-state');
var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length';
var WRONG_INDEX = 'Wrong index';
var NativeArrayBuffer = global[ARRAY_BUFFER];
var $ArrayBuffer = NativeArrayBuffer;
var ArrayBufferPrototype = $ArrayBuffer && $ArrayBuffer[PROTOTYPE];
var $DataView = global[DATA_VIEW];
var DataViewPrototype = $DataView && $DataView[PROTOTYPE];
var ObjectPrototype = Object.prototype;
var Array = global.Array;
var RangeError = global.RangeError;
var fill = uncurryThis(arrayFill);
var reverse = uncurryThis([].reverse);
var packIEEE754 = IEEE754.pack;
var unpackIEEE754 = IEEE754.unpack;
var packInt8 = function(number) {
    return [
        number & 255
    ];
};
var packInt16 = function(number) {
    return [
        number & 255,
        number >> 8 & 255
    ];
};
var packInt32 = function(number) {
    return [
        number & 255,
        number >> 8 & 255,
        number >> 16 & 255,
        number >> 24 & 255
    ];
};
var unpackInt32 = function(buffer) {
    return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
};
var packFloat32 = function(number) {
    return packIEEE754(number, 23, 4);
};
var packFloat64 = function(number) {
    return packIEEE754(number, 52, 8);
};
var addGetter = function(Constructor, key1) {
    defineProperty(Constructor[PROTOTYPE], key1, {
        get: function() {
            return getInternalState(this)[key1];
        }
    });
};
var get = function(view, count, index, isLittleEndian) {
    var intIndex = toIndex(index);
    var store = getInternalState(view);
    if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
    var bytes = getInternalState(store.buffer).bytes;
    var start = intIndex + store.byteOffset;
    var pack = arraySlice(bytes, start, start + count);
    return isLittleEndian ? pack : reverse(pack);
};
var set = function(view, count, index, conversion, value, isLittleEndian) {
    var intIndex = toIndex(index);
    var store = getInternalState(view);
    if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
    var bytes = getInternalState(store.buffer).bytes;
    var start = intIndex + store.byteOffset;
    var pack = conversion(+value);
    for(var i = 0; i < count; i++)bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
};
if (!NATIVE_ARRAY_BUFFER) {
    $ArrayBuffer = function ArrayBuffer(length) {
        anInstance(this, ArrayBufferPrototype);
        var byteLength = toIndex(length);
        setInternalState(this, {
            bytes: fill(Array(byteLength), 0),
            byteLength: byteLength
        });
        if (!DESCRIPTORS) this.byteLength = byteLength;
    };
    ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE];
    $DataView = function DataView(buffer, byteOffset, byteLength) {
        anInstance(this, DataViewPrototype);
        anInstance(buffer, ArrayBufferPrototype);
        var bufferLength = getInternalState(buffer).byteLength;
        var offset = toIntegerOrInfinity(byteOffset);
        if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset');
        byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
        if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
        setInternalState(this, {
            buffer: buffer,
            byteLength: byteLength,
            byteOffset: offset
        });
        if (!DESCRIPTORS) {
            this.buffer = buffer;
            this.byteLength = byteLength;
            this.byteOffset = offset;
        }
    };
    DataViewPrototype = $DataView[PROTOTYPE];
    if (DESCRIPTORS) {
        addGetter($ArrayBuffer, 'byteLength');
        addGetter($DataView, 'buffer');
        addGetter($DataView, 'byteLength');
        addGetter($DataView, 'byteOffset');
    }
    redefineAll(DataViewPrototype, {
        getInt8: function getInt8(byteOffset) {
            return get(this, 1, byteOffset)[0] << 24 >> 24;
        },
        getUint8: function getUint8(byteOffset) {
            return get(this, 1, byteOffset)[0];
        },
        getInt16: function getInt16(byteOffset /* , littleEndian */ ) {
            var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
            return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
        },
        getUint16: function getUint16(byteOffset /* , littleEndian */ ) {
            var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
            return bytes[1] << 8 | bytes[0];
        },
        getInt32: function getInt32(byteOffset /* , littleEndian */ ) {
            return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
        },
        getUint32: function getUint32(byteOffset /* , littleEndian */ ) {
            return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
        },
        getFloat32: function getFloat32(byteOffset /* , littleEndian */ ) {
            return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
        },
        getFloat64: function getFloat64(byteOffset /* , littleEndian */ ) {
            return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
        },
        setInt8: function setInt8(byteOffset, value) {
            set(this, 1, byteOffset, packInt8, value);
        },
        setUint8: function setUint8(byteOffset, value) {
            set(this, 1, byteOffset, packInt8, value);
        },
        setInt16: function setInt16(byteOffset, value /* , littleEndian */ ) {
            set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
        },
        setUint16: function setUint16(byteOffset, value /* , littleEndian */ ) {
            set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
        },
        setInt32: function setInt32(byteOffset, value /* , littleEndian */ ) {
            set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
        },
        setUint32: function setUint32(byteOffset, value /* , littleEndian */ ) {
            set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
        },
        setFloat32: function setFloat32(byteOffset, value /* , littleEndian */ ) {
            set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
        },
        setFloat64: function setFloat64(byteOffset, value /* , littleEndian */ ) {
            set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
        }
    });
} else {
    var INCORRECT_ARRAY_BUFFER_NAME = PROPER_FUNCTION_NAME && NativeArrayBuffer.name !== ARRAY_BUFFER;
    /* eslint-disable no-new -- required for testing */ if (!fails(function() {
        NativeArrayBuffer(1);
    }) || !fails(function() {
        new NativeArrayBuffer(-1);
    }) || fails(function() {
        new NativeArrayBuffer();
        new NativeArrayBuffer(1.5);
        new NativeArrayBuffer(NaN);
        return INCORRECT_ARRAY_BUFFER_NAME && !CONFIGURABLE_FUNCTION_NAME;
    })) {
        /* eslint-enable no-new -- required for testing */ $ArrayBuffer = function ArrayBuffer(length) {
            anInstance(this, ArrayBufferPrototype);
            return new NativeArrayBuffer(toIndex(length));
        };
        $ArrayBuffer[PROTOTYPE] = ArrayBufferPrototype;
        for(var keys = getOwnPropertyNames(NativeArrayBuffer), j = 0, key; keys.length > j;)if (!((key = keys[j++]) in $ArrayBuffer)) createNonEnumerableProperty($ArrayBuffer, key, NativeArrayBuffer[key]);
        ArrayBufferPrototype.constructor = $ArrayBuffer;
    } else if (INCORRECT_ARRAY_BUFFER_NAME && CONFIGURABLE_FUNCTION_NAME) createNonEnumerableProperty(NativeArrayBuffer, 'name', ARRAY_BUFFER);
    // WebKit bug - the same parent prototype for typed arrays and data view
    if (setPrototypeOf && getPrototypeOf(DataViewPrototype) !== ObjectPrototype) setPrototypeOf(DataViewPrototype, ObjectPrototype);
    // iOS Safari 7.x bug
    var testView = new $DataView(new $ArrayBuffer(2));
    var $setInt8 = uncurryThis(DataViewPrototype.setInt8);
    testView.setInt8(0, 2147483648);
    testView.setInt8(1, 2147483649);
    if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll(DataViewPrototype, {
        setInt8: function setInt8(byteOffset, value) {
            $setInt8(this, byteOffset, value << 24 >> 24);
        },
        setUint8: function setUint8(byteOffset, value) {
            $setInt8(this, byteOffset, value << 24 >> 24);
        }
    }, {
        unsafe: true
    });
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
module.exports = {
    ArrayBuffer: $ArrayBuffer,
    DataView: $DataView
};

},{"../internals/global":"jxPDA","../internals/function-uncurry-this":"jJnXC","../internals/descriptors":"6ZLib","../internals/array-buffer-native":"dLO44","../internals/function-name":"6v6mP","../internals/create-non-enumerable-property":"6Z1es","../internals/redefine-all":"ch5Rt","../internals/fails":"8IfZQ","../internals/an-instance":"2zeQg","../internals/to-integer-or-infinity":"aqyxv","../internals/to-length":"bMgmi","../internals/to-index":"2hEQ4","../internals/ieee754":"lAfRV","../internals/object-get-prototype-of":"lBy7h","../internals/object-set-prototype-of":"lb6rR","../internals/object-get-own-property-names":"evqXT","../internals/object-define-property":"bauTd","../internals/array-fill":"fYphv","../internals/array-slice-simple":"bYLId","../internals/set-to-string-tag":"9arwS","../internals/internal-state":"i6AaM"}],"dLO44":[function(require,module,exports) {
// eslint-disable-next-line es/no-typed-arrays -- safe
module.exports = typeof ArrayBuffer != 'undefined' && typeof DataView != 'undefined';

},{}],"ch5Rt":[function(require,module,exports) {
var redefine = require('../internals/redefine');
module.exports = function(target, src, options) {
    for(var key in src)redefine(target, key, src[key], options);
    return target;
};

},{"../internals/redefine":"kxbj8"}],"2zeQg":[function(require,module,exports) {
var global = require('../internals/global');
var isPrototypeOf = require('../internals/object-is-prototype-of');
var TypeError = global.TypeError;
module.exports = function(it, Prototype) {
    if (isPrototypeOf(Prototype, it)) return it;
    throw TypeError('Incorrect invocation');
};

},{"../internals/global":"jxPDA","../internals/object-is-prototype-of":"fyf1A"}],"2hEQ4":[function(require,module,exports) {
var global = require('../internals/global');
var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
var toLength = require('../internals/to-length');
var RangeError = global.RangeError;
// `ToIndex` abstract operation
// https://tc39.es/ecma262/#sec-toindex
module.exports = function(it) {
    if (it === undefined) return 0;
    var number = toIntegerOrInfinity(it);
    var length = toLength(number);
    if (number !== length) throw RangeError('Wrong length or index');
    return length;
};

},{"../internals/global":"jxPDA","../internals/to-integer-or-infinity":"aqyxv","../internals/to-length":"bMgmi"}],"lAfRV":[function(require,module,exports) {
// IEEE754 conversions based on https://github.com/feross/ieee754
var global = require('../internals/global');
var Array = global.Array;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var pack = function(number, mantissaLength, bytes) {
    var buffer = Array(bytes);
    var exponentLength = bytes * 8 - mantissaLength - 1;
    var eMax = (1 << exponentLength) - 1;
    var eBias = eMax >> 1;
    var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
    var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
    var index = 0;
    var exponent, mantissa, c;
    number = abs(number);
    // eslint-disable-next-line no-self-compare -- NaN check
    if (number != number || number === Infinity) {
        // eslint-disable-next-line no-self-compare -- NaN check
        mantissa = number != number ? 1 : 0;
        exponent = eMax;
    } else {
        exponent = floor(log(number) / LN2);
        c = pow(2, -exponent);
        if (number * c < 1) {
            exponent--;
            c *= 2;
        }
        if (exponent + eBias >= 1) number += rt / c;
        else number += rt * pow(2, 1 - eBias);
        if (number * c >= 2) {
            exponent++;
            c /= 2;
        }
        if (exponent + eBias >= eMax) {
            mantissa = 0;
            exponent = eMax;
        } else if (exponent + eBias >= 1) {
            mantissa = (number * c - 1) * pow(2, mantissaLength);
            exponent = exponent + eBias;
        } else {
            mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
            exponent = 0;
        }
    }
    while(mantissaLength >= 8){
        buffer[index++] = mantissa & 255;
        mantissa /= 256;
        mantissaLength -= 8;
    }
    exponent = exponent << mantissaLength | mantissa;
    exponentLength += mantissaLength;
    while(exponentLength > 0){
        buffer[index++] = exponent & 255;
        exponent /= 256;
        exponentLength -= 8;
    }
    buffer[--index] |= sign * 128;
    return buffer;
};
var unpack = function(buffer, mantissaLength) {
    var bytes = buffer.length;
    var exponentLength = bytes * 8 - mantissaLength - 1;
    var eMax = (1 << exponentLength) - 1;
    var eBias = eMax >> 1;
    var nBits = exponentLength - 7;
    var index = bytes - 1;
    var sign = buffer[index--];
    var exponent = sign & 127;
    var mantissa;
    sign >>= 7;
    while(nBits > 0){
        exponent = exponent * 256 + buffer[index--];
        nBits -= 8;
    }
    mantissa = exponent & (1 << -nBits) - 1;
    exponent >>= -nBits;
    nBits += mantissaLength;
    while(nBits > 0){
        mantissa = mantissa * 256 + buffer[index--];
        nBits -= 8;
    }
    if (exponent === 0) exponent = 1 - eBias;
    else if (exponent === eMax) return mantissa ? NaN : sign ? -Infinity : Infinity;
    else {
        mantissa = mantissa + pow(2, mantissaLength);
        exponent = exponent - eBias;
    }
    return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
};
module.exports = {
    pack: pack,
    unpack: unpack
};

},{"../internals/global":"jxPDA"}],"6Wt3y":[function(require,module,exports) {
var $ = require('../internals/export');
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
// `ArrayBuffer.isView` method
// https://tc39.es/ecma262/#sec-arraybuffer.isview
$({
    target: 'ArrayBuffer',
    stat: true,
    forced: !NATIVE_ARRAY_BUFFER_VIEWS
}, {
    isView: ArrayBufferViewCore.isView
});

},{"../internals/export":"8yfGv","../internals/array-buffer-view-core":"7PXuA"}],"7PXuA":[function(require,module,exports) {
'use strict';
var NATIVE_ARRAY_BUFFER = require('../internals/array-buffer-native');
var DESCRIPTORS = require('../internals/descriptors');
var global = require('../internals/global');
var isCallable = require('../internals/is-callable');
var isObject = require('../internals/is-object');
var hasOwn = require('../internals/has-own-property');
var classof = require('../internals/classof');
var tryToString = require('../internals/try-to-string');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var redefine = require('../internals/redefine');
var defineProperty = require('../internals/object-define-property').f;
var isPrototypeOf = require('../internals/object-is-prototype-of');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var setPrototypeOf = require('../internals/object-set-prototype-of');
var wellKnownSymbol = require('../internals/well-known-symbol');
var uid = require('../internals/uid');
var Int8Array = global.Int8Array;
var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
var Uint8ClampedArray = global.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
var TypedArray = Int8Array && getPrototypeOf(Int8Array);
var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
var ObjectPrototype = Object.prototype;
var TypeError = global.TypeError;
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
var TYPED_ARRAY_CONSTRUCTOR = uid('TYPED_ARRAY_CONSTRUCTOR');
// Fixing native typed arrays in Opera Presto crashes the browser, see #595
var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== 'Opera';
var TYPED_ARRAY_TAG_REQUIRED = false;
var NAME, Constructor, Prototype;
var TypedArrayConstructorsList = {
    Int8Array: 1,
    Uint8Array: 1,
    Uint8ClampedArray: 1,
    Int16Array: 2,
    Uint16Array: 2,
    Int32Array: 4,
    Uint32Array: 4,
    Float32Array: 4,
    Float64Array: 8
};
var BigIntArrayConstructorsList = {
    BigInt64Array: 8,
    BigUint64Array: 8
};
var isView = function isView(it) {
    if (!isObject(it)) return false;
    var klass = classof(it);
    return klass === 'DataView' || hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
};
var isTypedArray = function(it) {
    if (!isObject(it)) return false;
    var klass = classof(it);
    return hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
};
var aTypedArray = function(it) {
    if (isTypedArray(it)) return it;
    throw TypeError('Target is not a typed array');
};
var aTypedArrayConstructor = function(C) {
    if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C))) return C;
    throw TypeError(tryToString(C) + ' is not a typed array constructor');
};
var exportTypedArrayMethod = function(KEY, property, forced, options) {
    if (!DESCRIPTORS) return;
    if (forced) for(var ARRAY in TypedArrayConstructorsList){
        var TypedArrayConstructor = global[ARRAY];
        if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY)) try {
            delete TypedArrayConstructor.prototype[KEY];
        } catch (error) {
            // old WebKit bug - some methods are non-configurable
            try {
                TypedArrayConstructor.prototype[KEY] = property;
            } catch (error2) {
            }
        }
    }
    if (!TypedArrayPrototype[KEY] || forced) redefine(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);
};
var exportTypedArrayStaticMethod = function(KEY, property, forced) {
    var ARRAY, TypedArrayConstructor;
    if (!DESCRIPTORS) return;
    if (setPrototypeOf) {
        if (forced) for(ARRAY in TypedArrayConstructorsList){
            TypedArrayConstructor = global[ARRAY];
            if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY)) try {
                delete TypedArrayConstructor[KEY];
            } catch (error) {
            }
        }
        if (!TypedArray[KEY] || forced) // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
        try {
            return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
        } catch (error) {
        }
        else return;
    }
    for(ARRAY in TypedArrayConstructorsList){
        TypedArrayConstructor = global[ARRAY];
        if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) redefine(TypedArrayConstructor, KEY, property);
    }
};
for(NAME in TypedArrayConstructorsList){
    Constructor = global[NAME];
    Prototype = Constructor && Constructor.prototype;
    if (Prototype) createNonEnumerableProperty(Prototype, TYPED_ARRAY_CONSTRUCTOR, Constructor);
    else NATIVE_ARRAY_BUFFER_VIEWS = false;
}
for(NAME in BigIntArrayConstructorsList){
    Constructor = global[NAME];
    Prototype = Constructor && Constructor.prototype;
    if (Prototype) createNonEnumerableProperty(Prototype, TYPED_ARRAY_CONSTRUCTOR, Constructor);
}
// WebKit bug - typed arrays constructors prototype is Object.prototype
if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
    // eslint-disable-next-line no-shadow -- safe
    TypedArray = function TypedArray() {
        throw TypeError('Incorrect invocation');
    };
    if (NATIVE_ARRAY_BUFFER_VIEWS) {
        for(NAME in TypedArrayConstructorsList)if (global[NAME]) setPrototypeOf(global[NAME], TypedArray);
    }
}
if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
    TypedArrayPrototype = TypedArray.prototype;
    if (NATIVE_ARRAY_BUFFER_VIEWS) {
        for(NAME in TypedArrayConstructorsList)if (global[NAME]) setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);
    }
}
// WebKit bug - one more object in Uint8ClampedArray prototype chain
if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {
    TYPED_ARRAY_TAG_REQUIRED = true;
    defineProperty(TypedArrayPrototype, TO_STRING_TAG, {
        get: function() {
            return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
        }
    });
    for(NAME in TypedArrayConstructorsList)if (global[NAME]) createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);
}
module.exports = {
    NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
    TYPED_ARRAY_CONSTRUCTOR: TYPED_ARRAY_CONSTRUCTOR,
    TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,
    aTypedArray: aTypedArray,
    aTypedArrayConstructor: aTypedArrayConstructor,
    exportTypedArrayMethod: exportTypedArrayMethod,
    exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
    isView: isView,
    isTypedArray: isTypedArray,
    TypedArray: TypedArray,
    TypedArrayPrototype: TypedArrayPrototype
};

},{"../internals/array-buffer-native":"dLO44","../internals/descriptors":"6ZLib","../internals/global":"jxPDA","../internals/is-callable":"kPhuP","../internals/is-object":"dplrD","../internals/has-own-property":"3ZdUC","../internals/classof":"kJ8JQ","../internals/try-to-string":"1hxsu","../internals/create-non-enumerable-property":"6Z1es","../internals/redefine":"kxbj8","../internals/object-define-property":"bauTd","../internals/object-is-prototype-of":"fyf1A","../internals/object-get-prototype-of":"lBy7h","../internals/object-set-prototype-of":"lb6rR","../internals/well-known-symbol":"5C8sm","../internals/uid":"eMBx9"}],"aTGHe":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var uncurryThis = require('../internals/function-uncurry-this');
var fails = require('../internals/fails');
var ArrayBufferModule = require('../internals/array-buffer');
var anObject = require('../internals/an-object');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var toLength = require('../internals/to-length');
var speciesConstructor = require('../internals/species-constructor');
var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
var DataView = ArrayBufferModule.DataView;
var DataViewPrototype = DataView.prototype;
var un$ArrayBufferSlice = uncurryThis(ArrayBuffer.prototype.slice);
var getUint8 = uncurryThis(DataViewPrototype.getUint8);
var setUint8 = uncurryThis(DataViewPrototype.setUint8);
var INCORRECT_SLICE = fails(function() {
    return !new ArrayBuffer(2).slice(1, undefined).byteLength;
});
// `ArrayBuffer.prototype.slice` method
// https://tc39.es/ecma262/#sec-arraybuffer.prototype.slice
$({
    target: 'ArrayBuffer',
    proto: true,
    unsafe: true,
    forced: INCORRECT_SLICE
}, {
    slice: function slice(start, end) {
        if (un$ArrayBufferSlice && end === undefined) return un$ArrayBufferSlice(anObject(this), start); // FF fix
        var length = anObject(this).byteLength;
        var first = toAbsoluteIndex(start, length);
        var fin = toAbsoluteIndex(end === undefined ? length : end, length);
        var result = new (speciesConstructor(this, ArrayBuffer))(toLength(fin - first));
        var viewSource = new DataView(this);
        var viewTarget = new DataView(result);
        var index = 0;
        while(first < fin)setUint8(viewTarget, index++, getUint8(viewSource, first++));
        return result;
    }
});

},{"../internals/export":"8yfGv","../internals/function-uncurry-this":"jJnXC","../internals/fails":"8IfZQ","../internals/array-buffer":"eiDN2","../internals/an-object":"1LIz9","../internals/to-absolute-index":"dDgEq","../internals/to-length":"bMgmi","../internals/species-constructor":"hqPl9"}],"hqPl9":[function(require,module,exports) {
var anObject = require('../internals/an-object');
var aConstructor = require('../internals/a-constructor');
var wellKnownSymbol = require('../internals/well-known-symbol');
var SPECIES = wellKnownSymbol('species');
// `SpeciesConstructor` abstract operation
// https://tc39.es/ecma262/#sec-speciesconstructor
module.exports = function(O, defaultConstructor) {
    var C = anObject(O).constructor;
    var S;
    return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aConstructor(S);
};

},{"../internals/an-object":"1LIz9","../internals/a-constructor":"1DOBp","../internals/well-known-symbol":"5C8sm"}],"1DOBp":[function(require,module,exports) {
var global = require('../internals/global');
var isConstructor = require('../internals/is-constructor');
var tryToString = require('../internals/try-to-string');
var TypeError = global.TypeError;
// `Assert: IsConstructor(argument) is true`
module.exports = function(argument) {
    if (isConstructor(argument)) return argument;
    throw TypeError(tryToString(argument) + ' is not a constructor');
};

},{"../internals/global":"jxPDA","../internals/is-constructor":"iNoNi","../internals/try-to-string":"1hxsu"}],"14b9P":[function(require,module,exports) {
var $ = require('../internals/export');
var ArrayBufferModule = require('../internals/array-buffer');
var NATIVE_ARRAY_BUFFER = require('../internals/array-buffer-native');
// `DataView` constructor
// https://tc39.es/ecma262/#sec-dataview-constructor
$({
    global: true,
    forced: !NATIVE_ARRAY_BUFFER
}, {
    DataView: ArrayBufferModule.DataView
});

},{"../internals/export":"8yfGv","../internals/array-buffer":"eiDN2","../internals/array-buffer-native":"dLO44"}],"DuEIw":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var uncurryThis = require('../internals/function-uncurry-this');
var fails = require('../internals/fails');
var FORCED = fails(function() {
    return new Date(1600000000000).getYear() !== 120;
});
var getFullYear = uncurryThis(Date.prototype.getFullYear);
// `Date.prototype.getYear` method
// https://tc39.es/ecma262/#sec-date.prototype.getyear
$({
    target: 'Date',
    proto: true,
    forced: FORCED
}, {
    getYear: function getYear() {
        return getFullYear(this) - 1900;
    }
});

},{"../internals/export":"8yfGv","../internals/function-uncurry-this":"jJnXC","../internals/fails":"8IfZQ"}],"2eHz3":[function(require,module,exports) {
var $ = require('../internals/export');
var global = require('../internals/global');
var uncurryThis = require('../internals/function-uncurry-this');
var Date = global.Date;
var getTime = uncurryThis(Date.prototype.getTime);
// `Date.now` method
// https://tc39.es/ecma262/#sec-date.now
$({
    target: 'Date',
    stat: true
}, {
    now: function now() {
        return getTime(new Date());
    }
});

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/function-uncurry-this":"jJnXC"}],"jQnkS":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var uncurryThis = require('../internals/function-uncurry-this');
var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
var DatePrototype = Date.prototype;
var getTime = uncurryThis(DatePrototype.getTime);
var setFullYear = uncurryThis(DatePrototype.setFullYear);
// `Date.prototype.setYear` method
// https://tc39.es/ecma262/#sec-date.prototype.setyear
$({
    target: 'Date',
    proto: true
}, {
    setYear: function setYear(year) {
        // validate
        getTime(this);
        var yi = toIntegerOrInfinity(year);
        var yyyy = 0 <= yi && yi <= 99 ? yi + 1900 : yi;
        return setFullYear(this, yyyy);
    }
});

},{"../internals/export":"8yfGv","../internals/function-uncurry-this":"jJnXC","../internals/to-integer-or-infinity":"aqyxv"}],"2bG0B":[function(require,module,exports) {
var $ = require('../internals/export');
// `Date.prototype.toGMTString` method
// https://tc39.es/ecma262/#sec-date.prototype.togmtstring
$({
    target: 'Date',
    proto: true
}, {
    toGMTString: Date.prototype.toUTCString
});

},{"../internals/export":"8yfGv"}],"72zEL":[function(require,module,exports) {
var $ = require('../internals/export');
var toISOString = require('../internals/date-to-iso-string');
// `Date.prototype.toISOString` method
// https://tc39.es/ecma262/#sec-date.prototype.toisostring
// PhantomJS / old WebKit has a broken implementations
$({
    target: 'Date',
    proto: true,
    forced: Date.prototype.toISOString !== toISOString
}, {
    toISOString: toISOString
});

},{"../internals/export":"8yfGv","../internals/date-to-iso-string":"bie7R"}],"bie7R":[function(require,module,exports) {
'use strict';
var global = require('../internals/global');
var uncurryThis = require('../internals/function-uncurry-this');
var fails = require('../internals/fails');
var padStart = require('../internals/string-pad').start;
var RangeError = global.RangeError;
var abs = Math.abs;
var DatePrototype = Date.prototype;
var n$DateToISOString = DatePrototype.toISOString;
var getTime = uncurryThis(DatePrototype.getTime);
var getUTCDate = uncurryThis(DatePrototype.getUTCDate);
var getUTCFullYear = uncurryThis(DatePrototype.getUTCFullYear);
var getUTCHours = uncurryThis(DatePrototype.getUTCHours);
var getUTCMilliseconds = uncurryThis(DatePrototype.getUTCMilliseconds);
var getUTCMinutes = uncurryThis(DatePrototype.getUTCMinutes);
var getUTCMonth = uncurryThis(DatePrototype.getUTCMonth);
var getUTCSeconds = uncurryThis(DatePrototype.getUTCSeconds);
// `Date.prototype.toISOString` method implementation
// https://tc39.es/ecma262/#sec-date.prototype.toisostring
// PhantomJS / old WebKit fails here:
module.exports = fails(function() {
    return n$DateToISOString.call(new Date(-50000000000000 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function() {
    n$DateToISOString.call(new Date(NaN));
}) ? function toISOString() {
    if (!isFinite(getTime(this))) throw RangeError('Invalid time value');
    var date = this;
    var year = getUTCFullYear(date);
    var milliseconds = getUTCMilliseconds(date);
    var sign = year < 0 ? '-' : year > 9999 ? '+' : '';
    return sign + padStart(abs(year), sign ? 6 : 4, 0) + '-' + padStart(getUTCMonth(date) + 1, 2, 0) + '-' + padStart(getUTCDate(date), 2, 0) + 'T' + padStart(getUTCHours(date), 2, 0) + ':' + padStart(getUTCMinutes(date), 2, 0) + ':' + padStart(getUTCSeconds(date), 2, 0) + '.' + padStart(milliseconds, 3, 0) + 'Z';
} : n$DateToISOString;

},{"../internals/global":"jxPDA","../internals/function-uncurry-this":"jJnXC","../internals/fails":"8IfZQ","../internals/string-pad":"2xP44"}],"2xP44":[function(require,module,exports) {
// https://github.com/tc39/proposal-string-pad-start-end
var uncurryThis = require('../internals/function-uncurry-this');
var toLength = require('../internals/to-length');
var toString = require('../internals/to-string');
var $repeat = require('../internals/string-repeat');
var requireObjectCoercible = require('../internals/require-object-coercible');
var repeat = uncurryThis($repeat);
var stringSlice = uncurryThis(''.slice);
var ceil = Math.ceil;
// `String.prototype.{ padStart, padEnd }` methods implementation
var createMethod = function(IS_END) {
    return function($this, maxLength, fillString) {
        var S = toString(requireObjectCoercible($this));
        var intMaxLength = toLength(maxLength);
        var stringLength = S.length;
        var fillStr = fillString === undefined ? ' ' : toString(fillString);
        var fillLen, stringFiller;
        if (intMaxLength <= stringLength || fillStr == '') return S;
        fillLen = intMaxLength - stringLength;
        stringFiller = repeat(fillStr, ceil(fillLen / fillStr.length));
        if (stringFiller.length > fillLen) stringFiller = stringSlice(stringFiller, 0, fillLen);
        return IS_END ? S + stringFiller : stringFiller + S;
    };
};
module.exports = {
    // `String.prototype.padStart` method
    // https://tc39.es/ecma262/#sec-string.prototype.padstart
    start: createMethod(false),
    // `String.prototype.padEnd` method
    // https://tc39.es/ecma262/#sec-string.prototype.padend
    end: createMethod(true)
};

},{"../internals/function-uncurry-this":"jJnXC","../internals/to-length":"bMgmi","../internals/to-string":"4cTlm","../internals/string-repeat":"4Md87","../internals/require-object-coercible":"3Qlyo"}],"4Md87":[function(require,module,exports) {
'use strict';
var global = require('../internals/global');
var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
var toString = require('../internals/to-string');
var requireObjectCoercible = require('../internals/require-object-coercible');
var RangeError = global.RangeError;
// `String.prototype.repeat` method implementation
// https://tc39.es/ecma262/#sec-string.prototype.repeat
module.exports = function repeat(count) {
    var str = toString(requireObjectCoercible(this));
    var result = '';
    var n = toIntegerOrInfinity(count);
    if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');
    for(; n > 0; (n >>>= 1) && (str += str))if (n & 1) result += str;
    return result;
};

},{"../internals/global":"jxPDA","../internals/to-integer-or-infinity":"aqyxv","../internals/to-string":"4cTlm","../internals/require-object-coercible":"3Qlyo"}],"k6wIs":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var fails = require('../internals/fails');
var toObject = require('../internals/to-object');
var toPrimitive = require('../internals/to-primitive');
var FORCED = fails(function() {
    return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({
        toISOString: function() {
            return 1;
        }
    }) !== 1;
});
// `Date.prototype.toJSON` method
// https://tc39.es/ecma262/#sec-date.prototype.tojson
$({
    target: 'Date',
    proto: true,
    forced: FORCED
}, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    toJSON: function toJSON(key) {
        var O = toObject(this);
        var pv = toPrimitive(O, 'number');
        return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
    }
});

},{"../internals/export":"8yfGv","../internals/fails":"8IfZQ","../internals/to-object":"eEdae","../internals/to-primitive":"ilNgA"}],"1hEtM":[function(require,module,exports) {
var hasOwn = require('../internals/has-own-property');
var redefine = require('../internals/redefine');
var dateToPrimitive = require('../internals/date-to-primitive');
var wellKnownSymbol = require('../internals/well-known-symbol');
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var DatePrototype = Date.prototype;
// `Date.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-date.prototype-@@toprimitive
if (!hasOwn(DatePrototype, TO_PRIMITIVE)) redefine(DatePrototype, TO_PRIMITIVE, dateToPrimitive);

},{"../internals/has-own-property":"3ZdUC","../internals/redefine":"kxbj8","../internals/date-to-primitive":"iXBHK","../internals/well-known-symbol":"5C8sm"}],"iXBHK":[function(require,module,exports) {
'use strict';
var global = require('../internals/global');
var anObject = require('../internals/an-object');
var ordinaryToPrimitive = require('../internals/ordinary-to-primitive');
var TypeError = global.TypeError;
// `Date.prototype[@@toPrimitive](hint)` method implementation
// https://tc39.es/ecma262/#sec-date.prototype-@@toprimitive
module.exports = function(hint) {
    anObject(this);
    if (hint === 'string' || hint === 'default') hint = 'string';
    else if (hint !== 'number') throw TypeError('Incorrect hint');
    return ordinaryToPrimitive(this, hint);
};

},{"../internals/global":"jxPDA","../internals/an-object":"1LIz9","../internals/ordinary-to-primitive":"fsThT"}],"i9lAX":[function(require,module,exports) {
var uncurryThis = require('../internals/function-uncurry-this');
var redefine = require('../internals/redefine');
var DatePrototype = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var un$DateToString = uncurryThis(DatePrototype[TO_STRING]);
var getTime = uncurryThis(DatePrototype.getTime);
// `Date.prototype.toString` method
// https://tc39.es/ecma262/#sec-date.prototype.tostring
if (String(new Date(NaN)) != INVALID_DATE) redefine(DatePrototype, TO_STRING, function toString() {
    var value = getTime(this);
    // eslint-disable-next-line no-self-compare -- NaN check
    return value === value ? un$DateToString(this) : INVALID_DATE;
});

},{"../internals/function-uncurry-this":"jJnXC","../internals/redefine":"kxbj8"}],"k9DQ7":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var uncurryThis = require('../internals/function-uncurry-this');
var toString = require('../internals/to-string');
var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var exec = uncurryThis(/./.exec);
var numberToString = uncurryThis(1..toString);
var toUpperCase = uncurryThis(''.toUpperCase);
var raw = /[\w*+\-./@]/;
var hex = function(code, length) {
    var result = numberToString(code, 16);
    while(result.length < length)result = '0' + result;
    return result;
};
// `escape` method
// https://tc39.es/ecma262/#sec-escape-string
$({
    global: true
}, {
    escape: function escape(string) {
        var str = toString(string);
        var result = '';
        var length = str.length;
        var index = 0;
        var chr, code;
        while(index < length){
            chr = charAt(str, index++);
            if (exec(raw, chr)) result += chr;
            else {
                code = charCodeAt(chr, 0);
                if (code < 256) result += '%' + hex(code, 2);
                else result += '%u' + toUpperCase(hex(code, 4));
            }
        }
        return result;
    }
});

},{"../internals/export":"8yfGv","../internals/function-uncurry-this":"jJnXC","../internals/to-string":"4cTlm"}],"8v673":[function(require,module,exports) {
var $ = require('../internals/export');
var bind = require('../internals/function-bind');
// `Function.prototype.bind` method
// https://tc39.es/ecma262/#sec-function.prototype.bind
$({
    target: 'Function',
    proto: true,
    forced: Function.bind !== bind
}, {
    bind: bind
});

},{"../internals/export":"8yfGv","../internals/function-bind":"heTXz"}],"heTXz":[function(require,module,exports) {
'use strict';
var global = require('../internals/global');
var uncurryThis = require('../internals/function-uncurry-this');
var aCallable = require('../internals/a-callable');
var isObject = require('../internals/is-object');
var hasOwn = require('../internals/has-own-property');
var arraySlice = require('../internals/array-slice');
var NATIVE_BIND = require('../internals/function-bind-native');
var Function = global.Function;
var concat = uncurryThis([].concat);
var join = uncurryThis([].join);
var factories = {
};
var construct = function(C, argsLength, args) {
    if (!hasOwn(factories, argsLength)) {
        for(var list = [], i = 0; i < argsLength; i++)list[i] = 'a[' + i + ']';
        factories[argsLength] = Function('C,a', 'return new C(' + join(list, ',') + ')');
    }
    return factories[argsLength](C, args);
};
// `Function.prototype.bind` method implementation
// https://tc39.es/ecma262/#sec-function.prototype.bind
module.exports = NATIVE_BIND ? Function.bind : function bind(that /* , ...args */ ) {
    var F = aCallable(this);
    var Prototype = F.prototype;
    var partArgs = arraySlice(arguments, 1);
    var boundFunction = function bound() {
        var args = concat(partArgs, arraySlice(arguments));
        return this instanceof boundFunction ? construct(F, args.length, args) : F.apply(that, args);
    };
    if (isObject(Prototype)) boundFunction.prototype = Prototype;
    return boundFunction;
};

},{"../internals/global":"jxPDA","../internals/function-uncurry-this":"jJnXC","../internals/a-callable":"83opn","../internals/is-object":"dplrD","../internals/has-own-property":"3ZdUC","../internals/array-slice":"bI1dk","../internals/function-bind-native":"7GJc3"}],"cmqa2":[function(require,module,exports) {
'use strict';
var isCallable = require('../internals/is-callable');
var isObject = require('../internals/is-object');
var definePropertyModule = require('../internals/object-define-property');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var wellKnownSymbol = require('../internals/well-known-symbol');
var HAS_INSTANCE = wellKnownSymbol('hasInstance');
var FunctionPrototype = Function.prototype;
// `Function.prototype[@@hasInstance]` method
// https://tc39.es/ecma262/#sec-function.prototype-@@hasinstance
if (!(HAS_INSTANCE in FunctionPrototype)) definePropertyModule.f(FunctionPrototype, HAS_INSTANCE, {
    value: function(O) {
        if (!isCallable(this) || !isObject(O)) return false;
        var P = this.prototype;
        if (!isObject(P)) return O instanceof this;
        // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
        while(O = getPrototypeOf(O))if (P === O) return true;
        return false;
    }
});

},{"../internals/is-callable":"kPhuP","../internals/is-object":"dplrD","../internals/object-define-property":"bauTd","../internals/object-get-prototype-of":"lBy7h","../internals/well-known-symbol":"5C8sm"}],"kYqsO":[function(require,module,exports) {
var DESCRIPTORS = require('../internals/descriptors');
var FUNCTION_NAME_EXISTS = require('../internals/function-name').EXISTS;
var uncurryThis = require('../internals/function-uncurry-this');
var defineProperty = require('../internals/object-define-property').f;
var FunctionPrototype = Function.prototype;
var functionToString = uncurryThis(FunctionPrototype.toString);
var nameRE = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/;
var regExpExec = uncurryThis(nameRE.exec);
var NAME = 'name';
// Function instances `.name` property
// https://tc39.es/ecma262/#sec-function-instances-name
if (DESCRIPTORS && !FUNCTION_NAME_EXISTS) defineProperty(FunctionPrototype, NAME, {
    configurable: true,
    get: function() {
        try {
            return regExpExec(nameRE, functionToString(this))[1];
        } catch (error) {
            return '';
        }
    }
});

},{"../internals/descriptors":"6ZLib","../internals/function-name":"6v6mP","../internals/function-uncurry-this":"jJnXC","../internals/object-define-property":"bauTd"}],"3I5ZQ":[function(require,module,exports) {
var $ = require('../internals/export');
var global = require('../internals/global');
// `globalThis` object
// https://tc39.es/ecma262/#sec-globalthis
$({
    global: true
}, {
    globalThis: global
});

},{"../internals/export":"8yfGv","../internals/global":"jxPDA"}],"6eewm":[function(require,module,exports) {
var $ = require('../internals/export');
var global = require('../internals/global');
var getBuiltIn = require('../internals/get-built-in');
var apply = require('../internals/function-apply');
var uncurryThis = require('../internals/function-uncurry-this');
var fails = require('../internals/fails');
var Array = global.Array;
var $stringify = getBuiltIn('JSON', 'stringify');
var exec = uncurryThis(/./.exec);
var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var replace = uncurryThis(''.replace);
var numberToString = uncurryThis(1..toString);
var tester = /[\uD800-\uDFFF]/g;
var low = /^[\uD800-\uDBFF]$/;
var hi = /^[\uDC00-\uDFFF]$/;
var fix = function(match, offset, string) {
    var prev = charAt(string, offset - 1);
    var next = charAt(string, offset + 1);
    if (exec(low, match) && !exec(hi, next) || exec(hi, match) && !exec(low, prev)) return '\\u' + numberToString(charCodeAt(match, 0), 16);
    return match;
};
var FORCED = fails(function() {
    return $stringify('\uDF06\uD834') !== '"\\udf06\\ud834"' || $stringify('\uDEAD') !== '"\\udead"';
});
if ($stringify) // `JSON.stringify` method
// https://tc39.es/ecma262/#sec-json.stringify
// https://github.com/tc39/proposal-well-formed-stringify
$({
    target: 'JSON',
    stat: true,
    forced: FORCED
}, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify(it, replacer, space) {
        for(var i = 0, l = arguments.length, args = Array(l); i < l; i++)args[i] = arguments[i];
        var result = apply($stringify, null, args);
        return typeof result == 'string' ? replace(result, tester, fix) : result;
    }
});

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/get-built-in":"78arb","../internals/function-apply":"206oi","../internals/function-uncurry-this":"jJnXC","../internals/fails":"8IfZQ"}],"fVE60":[function(require,module,exports) {
var global = require('../internals/global');
var setToStringTag = require('../internals/set-to-string-tag');
// JSON[@@toStringTag] property
// https://tc39.es/ecma262/#sec-json-@@tostringtag
setToStringTag(global.JSON, 'JSON', true);

},{"../internals/global":"jxPDA","../internals/set-to-string-tag":"9arwS"}],"ayxWX":[function(require,module,exports) {
'use strict';
var collection = require('../internals/collection');
var collectionStrong = require('../internals/collection-strong');
// `Map` constructor
// https://tc39.es/ecma262/#sec-map-objects
collection('Map', function(init) {
    return function Map() {
        return init(this, arguments.length ? arguments[0] : undefined);
    };
}, collectionStrong);

},{"../internals/collection":"g8aLF","../internals/collection-strong":"lnvQ9"}],"g8aLF":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var global = require('../internals/global');
var uncurryThis = require('../internals/function-uncurry-this');
var isForced = require('../internals/is-forced');
var redefine = require('../internals/redefine');
var InternalMetadataModule = require('../internals/internal-metadata');
var iterate = require('../internals/iterate');
var anInstance = require('../internals/an-instance');
var isCallable = require('../internals/is-callable');
var isObject = require('../internals/is-object');
var fails = require('../internals/fails');
var checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');
var setToStringTag = require('../internals/set-to-string-tag');
var inheritIfRequired = require('../internals/inherit-if-required');
module.exports = function(CONSTRUCTOR_NAME, wrapper, common) {
    var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
    var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
    var ADDER = IS_MAP ? 'set' : 'add';
    var NativeConstructor = global[CONSTRUCTOR_NAME];
    var NativePrototype = NativeConstructor && NativeConstructor.prototype;
    var Constructor = NativeConstructor;
    var exported = {
    };
    var fixMethod = function(KEY) {
        var uncurriedNativeMethod = uncurryThis(NativePrototype[KEY]);
        redefine(NativePrototype, KEY, KEY == 'add' ? function add(value) {
            uncurriedNativeMethod(this, value === 0 ? 0 : value);
            return this;
        } : KEY == 'delete' ? function(key) {
            return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
        } : KEY == 'get' ? function get(key) {
            return IS_WEAK && !isObject(key) ? undefined : uncurriedNativeMethod(this, key === 0 ? 0 : key);
        } : KEY == 'has' ? function has(key) {
            return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
        } : function set(key, value) {
            uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
            return this;
        });
    };
    var REPLACE = isForced(CONSTRUCTOR_NAME, !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function() {
        new NativeConstructor().entries().next();
    })));
    if (REPLACE) {
        // create collection constructor
        Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
        InternalMetadataModule.enable();
    } else if (isForced(CONSTRUCTOR_NAME, true)) {
        var instance = new Constructor();
        // early implementations not supports chaining
        var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {
        } : -0, 1) != instance;
        // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
        var THROWS_ON_PRIMITIVES = fails(function() {
            instance.has(1);
        });
        // most early implementations doesn't supports iterables, most modern - not close it correctly
        // eslint-disable-next-line no-new -- required for testing
        var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function(iterable) {
            new NativeConstructor(iterable);
        });
        // for early implementations -0 and +0 not the same
        var BUGGY_ZERO = !IS_WEAK && fails(function() {
            // V8 ~ Chromium 42- fails only with 5+ elements
            var $instance = new NativeConstructor();
            var index = 5;
            while(index--)$instance[ADDER](index, index);
            return !$instance.has(-0);
        });
        if (!ACCEPT_ITERABLES) {
            Constructor = wrapper(function(dummy, iterable) {
                anInstance(dummy, NativePrototype);
                var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
                if (iterable != undefined) iterate(iterable, that[ADDER], {
                    that: that,
                    AS_ENTRIES: IS_MAP
                });
                return that;
            });
            Constructor.prototype = NativePrototype;
            NativePrototype.constructor = Constructor;
        }
        if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
            fixMethod('delete');
            fixMethod('has');
            IS_MAP && fixMethod('get');
        }
        if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
        // weak collections should not contains .clear method
        if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
    }
    exported[CONSTRUCTOR_NAME] = Constructor;
    $({
        global: true,
        forced: Constructor != NativeConstructor
    }, exported);
    setToStringTag(Constructor, CONSTRUCTOR_NAME);
    if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
    return Constructor;
};

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/function-uncurry-this":"jJnXC","../internals/is-forced":"eTyNf","../internals/redefine":"kxbj8","../internals/internal-metadata":"fD10R","../internals/iterate":"fTyka","../internals/an-instance":"2zeQg","../internals/is-callable":"kPhuP","../internals/is-object":"dplrD","../internals/fails":"8IfZQ","../internals/check-correctness-of-iteration":"788V9","../internals/set-to-string-tag":"9arwS","../internals/inherit-if-required":"kXY2O"}],"fD10R":[function(require,module,exports) {
var $ = require('../internals/export');
var uncurryThis = require('../internals/function-uncurry-this');
var hiddenKeys = require('../internals/hidden-keys');
var isObject = require('../internals/is-object');
var hasOwn = require('../internals/has-own-property');
var defineProperty = require('../internals/object-define-property').f;
var getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');
var getOwnPropertyNamesExternalModule = require('../internals/object-get-own-property-names-external');
var isExtensible = require('../internals/object-is-extensible');
var uid = require('../internals/uid');
var FREEZING = require('../internals/freezing');
var REQUIRED = false;
var METADATA = uid('meta');
var id = 0;
var setMetadata = function(it) {
    defineProperty(it, METADATA, {
        value: {
            objectID: 'O' + id++,
            weakData: {
            } // weak collections IDs
        }
    });
};
var fastKey = function(it, create) {
    // return a primitive with prefix
    if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
    if (!hasOwn(it, METADATA)) {
        // can't set metadata to uncaught frozen object
        if (!isExtensible(it)) return 'F';
        // not necessary to add metadata
        if (!create) return 'E';
        // add missing metadata
        setMetadata(it);
    // return object ID
    }
    return it[METADATA].objectID;
};
var getWeakData = function(it, create) {
    if (!hasOwn(it, METADATA)) {
        // can't set metadata to uncaught frozen object
        if (!isExtensible(it)) return true;
        // not necessary to add metadata
        if (!create) return false;
        // add missing metadata
        setMetadata(it);
    // return the store of weak collections IDs
    }
    return it[METADATA].weakData;
};
// add metadata on freeze-family methods calling
var onFreeze = function(it) {
    if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn(it, METADATA)) setMetadata(it);
    return it;
};
var enable = function() {
    meta.enable = function() {
    };
    REQUIRED = true;
    var getOwnPropertyNames = getOwnPropertyNamesModule.f;
    var splice = uncurryThis([].splice);
    var test = {
    };
    test[METADATA] = 1;
    // prevent exposing of metadata key
    if (getOwnPropertyNames(test).length) {
        getOwnPropertyNamesModule.f = function(it) {
            var result = getOwnPropertyNames(it);
            for(var i = 0, length = result.length; i < length; i++)if (result[i] === METADATA) {
                splice(result, i, 1);
                break;
            }
            return result;
        };
        $({
            target: 'Object',
            stat: true,
            forced: true
        }, {
            getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
        });
    }
};
var meta = module.exports = {
    enable: enable,
    fastKey: fastKey,
    getWeakData: getWeakData,
    onFreeze: onFreeze
};
hiddenKeys[METADATA] = true;

},{"../internals/export":"8yfGv","../internals/function-uncurry-this":"jJnXC","../internals/hidden-keys":"lHxXS","../internals/is-object":"dplrD","../internals/has-own-property":"3ZdUC","../internals/object-define-property":"bauTd","../internals/object-get-own-property-names":"evqXT","../internals/object-get-own-property-names-external":"7r5nw","../internals/object-is-extensible":"eApj6","../internals/uid":"eMBx9","../internals/freezing":"5dl3e"}],"eApj6":[function(require,module,exports) {
var fails = require('../internals/fails');
var isObject = require('../internals/is-object');
var classof = require('../internals/classof-raw');
var ARRAY_BUFFER_NON_EXTENSIBLE = require('../internals/array-buffer-non-extensible');
// eslint-disable-next-line es/no-object-isextensible -- safe
var $isExtensible = Object.isExtensible;
var FAILS_ON_PRIMITIVES = fails(function() {
    $isExtensible(1);
});
// `Object.isExtensible` method
// https://tc39.es/ecma262/#sec-object.isextensible
module.exports = FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE ? function isExtensible(it) {
    if (!isObject(it)) return false;
    if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) == 'ArrayBuffer') return false;
    return $isExtensible ? $isExtensible(it) : true;
} : $isExtensible;

},{"../internals/fails":"8IfZQ","../internals/is-object":"dplrD","../internals/classof-raw":"A9m3U","../internals/array-buffer-non-extensible":"9fgu5"}],"9fgu5":[function(require,module,exports) {
// FF26- bug: ArrayBuffers are non-extensible, but Object.isExtensible does not report it
var fails = require('../internals/fails');
module.exports = fails(function() {
    if (typeof ArrayBuffer == 'function') {
        var buffer = new ArrayBuffer(8);
        // eslint-disable-next-line es/no-object-isextensible, es/no-object-defineproperty -- safe
        if (Object.isExtensible(buffer)) Object.defineProperty(buffer, 'a', {
            value: 8
        });
    }
});

},{"../internals/fails":"8IfZQ"}],"5dl3e":[function(require,module,exports) {
var fails = require('../internals/fails');
module.exports = !fails(function() {
    // eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing
    return Object.isExtensible(Object.preventExtensions({
    }));
});

},{"../internals/fails":"8IfZQ"}],"lnvQ9":[function(require,module,exports) {
'use strict';
var defineProperty = require('../internals/object-define-property').f;
var create = require('../internals/object-create');
var redefineAll = require('../internals/redefine-all');
var bind = require('../internals/function-bind-context');
var anInstance = require('../internals/an-instance');
var iterate = require('../internals/iterate');
var defineIterator = require('../internals/define-iterator');
var setSpecies = require('../internals/set-species');
var DESCRIPTORS = require('../internals/descriptors');
var fastKey = require('../internals/internal-metadata').fastKey;
var InternalStateModule = require('../internals/internal-state');
var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;
module.exports = {
    getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
        var Constructor = wrapper(function(that, iterable) {
            anInstance(that, Prototype);
            setInternalState(that, {
                type: CONSTRUCTOR_NAME,
                index: create(null),
                first: undefined,
                last: undefined,
                size: 0
            });
            if (!DESCRIPTORS) that.size = 0;
            if (iterable != undefined) iterate(iterable, that[ADDER], {
                that: that,
                AS_ENTRIES: IS_MAP
            });
        });
        var Prototype = Constructor.prototype;
        var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
        var define = function(that, key, value) {
            var state = getInternalState(that);
            var entry = getEntry(that, key);
            var previous, index;
            // change existing entry
            if (entry) entry.value = value;
            else {
                state.last = entry = {
                    index: index = fastKey(key, true),
                    key: key,
                    value: value,
                    previous: previous = state.last,
                    next: undefined,
                    removed: false
                };
                if (!state.first) state.first = entry;
                if (previous) previous.next = entry;
                if (DESCRIPTORS) state.size++;
                else that.size++;
                // add to index
                if (index !== 'F') state.index[index] = entry;
            }
            return that;
        };
        var getEntry = function(that, key) {
            var state = getInternalState(that);
            // fast case
            var index = fastKey(key);
            var entry;
            if (index !== 'F') return state.index[index];
            // frozen object case
            for(entry = state.first; entry; entry = entry.next){
                if (entry.key == key) return entry;
            }
        };
        redefineAll(Prototype, {
            // `{ Map, Set }.prototype.clear()` methods
            // https://tc39.es/ecma262/#sec-map.prototype.clear
            // https://tc39.es/ecma262/#sec-set.prototype.clear
            clear: function clear() {
                var that = this;
                var state = getInternalState(that);
                var data = state.index;
                var entry = state.first;
                while(entry){
                    entry.removed = true;
                    if (entry.previous) entry.previous = entry.previous.next = undefined;
                    delete data[entry.index];
                    entry = entry.next;
                }
                state.first = state.last = undefined;
                if (DESCRIPTORS) state.size = 0;
                else that.size = 0;
            },
            // `{ Map, Set }.prototype.delete(key)` methods
            // https://tc39.es/ecma262/#sec-map.prototype.delete
            // https://tc39.es/ecma262/#sec-set.prototype.delete
            'delete': function(key) {
                var that = this;
                var state = getInternalState(that);
                var entry = getEntry(that, key);
                if (entry) {
                    var next = entry.next;
                    var prev = entry.previous;
                    delete state.index[entry.index];
                    entry.removed = true;
                    if (prev) prev.next = next;
                    if (next) next.previous = prev;
                    if (state.first == entry) state.first = next;
                    if (state.last == entry) state.last = prev;
                    if (DESCRIPTORS) state.size--;
                    else that.size--;
                }
                return !!entry;
            },
            // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
            // https://tc39.es/ecma262/#sec-map.prototype.foreach
            // https://tc39.es/ecma262/#sec-set.prototype.foreach
            forEach: function forEach(callbackfn /* , that = undefined */ ) {
                var state = getInternalState(this);
                var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
                var entry;
                while(entry = entry ? entry.next : state.first){
                    boundFunction(entry.value, entry.key, this);
                    // revert to the last existing entry
                    while(entry && entry.removed)entry = entry.previous;
                }
            },
            // `{ Map, Set}.prototype.has(key)` methods
            // https://tc39.es/ecma262/#sec-map.prototype.has
            // https://tc39.es/ecma262/#sec-set.prototype.has
            has: function has(key) {
                return !!getEntry(this, key);
            }
        });
        redefineAll(Prototype, IS_MAP ? {
            // `Map.prototype.get(key)` method
            // https://tc39.es/ecma262/#sec-map.prototype.get
            get: function get(key) {
                var entry = getEntry(this, key);
                return entry && entry.value;
            },
            // `Map.prototype.set(key, value)` method
            // https://tc39.es/ecma262/#sec-map.prototype.set
            set: function set(key, value) {
                return define(this, key === 0 ? 0 : key, value);
            }
        } : {
            // `Set.prototype.add(value)` method
            // https://tc39.es/ecma262/#sec-set.prototype.add
            add: function add(value) {
                return define(this, value = value === 0 ? 0 : value, value);
            }
        });
        if (DESCRIPTORS) defineProperty(Prototype, 'size', {
            get: function() {
                return getInternalState(this).size;
            }
        });
        return Constructor;
    },
    setStrong: function(Constructor, CONSTRUCTOR_NAME, IS_MAP) {
        var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
        var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
        var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
        // `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods
        // https://tc39.es/ecma262/#sec-map.prototype.entries
        // https://tc39.es/ecma262/#sec-map.prototype.keys
        // https://tc39.es/ecma262/#sec-map.prototype.values
        // https://tc39.es/ecma262/#sec-map.prototype-@@iterator
        // https://tc39.es/ecma262/#sec-set.prototype.entries
        // https://tc39.es/ecma262/#sec-set.prototype.keys
        // https://tc39.es/ecma262/#sec-set.prototype.values
        // https://tc39.es/ecma262/#sec-set.prototype-@@iterator
        defineIterator(Constructor, CONSTRUCTOR_NAME, function(iterated, kind) {
            setInternalState(this, {
                type: ITERATOR_NAME,
                target: iterated,
                state: getInternalCollectionState(iterated),
                kind: kind,
                last: undefined
            });
        }, function() {
            var state = getInternalIteratorState(this);
            var kind = state.kind;
            var entry = state.last;
            // revert to the last existing entry
            while(entry && entry.removed)entry = entry.previous;
            // get next entry
            if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
                // or finish the iteration
                state.target = undefined;
                return {
                    value: undefined,
                    done: true
                };
            }
            // return step by kind
            if (kind == 'keys') return {
                value: entry.key,
                done: false
            };
            if (kind == 'values') return {
                value: entry.value,
                done: false
            };
            return {
                value: [
                    entry.key,
                    entry.value
                ],
                done: false
            };
        }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);
        // `{ Map, Set }.prototype[@@species]` accessors
        // https://tc39.es/ecma262/#sec-get-map-@@species
        // https://tc39.es/ecma262/#sec-get-set-@@species
        setSpecies(CONSTRUCTOR_NAME);
    }
};

},{"../internals/object-define-property":"bauTd","../internals/object-create":"1As5O","../internals/redefine-all":"ch5Rt","../internals/function-bind-context":"kZubc","../internals/an-instance":"2zeQg","../internals/iterate":"fTyka","../internals/define-iterator":"3Ugai","../internals/set-species":"hBKMQ","../internals/descriptors":"6ZLib","../internals/internal-metadata":"fD10R","../internals/internal-state":"i6AaM"}],"1v5kF":[function(require,module,exports) {
var $ = require('../internals/export');
var log1p = require('../internals/math-log1p');
// eslint-disable-next-line es/no-math-acosh -- required for testing
var $acosh = Math.acosh;
var log = Math.log;
var sqrt = Math.sqrt;
var LN2 = Math.LN2;
var FORCED = !$acosh || Math.floor($acosh(Number.MAX_VALUE)) != 710 || $acosh(Infinity) != Infinity;
// `Math.acosh` method
// https://tc39.es/ecma262/#sec-math.acosh
$({
    target: 'Math',
    stat: true,
    forced: FORCED
}, {
    acosh: function acosh(x) {
        return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? log(x) + LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
    }
});

},{"../internals/export":"8yfGv","../internals/math-log1p":"9aqHG"}],"9aqHG":[function(require,module,exports) {
var log = Math.log;
// `Math.log1p` method implementation
// https://tc39.es/ecma262/#sec-math.log1p
// eslint-disable-next-line es/no-math-log1p -- safe
module.exports = Math.log1p || function log1p(x) {
    return (x = +x) > -0.00000001 && x < 0.00000001 ? x - x * x / 2 : log(1 + x);
};

},{}],"eSOGV":[function(require,module,exports) {
var $ = require('../internals/export');
// eslint-disable-next-line es/no-math-asinh -- required for testing
var $asinh = Math.asinh;
var log = Math.log;
var sqrt = Math.sqrt;
function asinh(x) {
    return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log(x + sqrt(x * x + 1));
}
// `Math.asinh` method
// https://tc39.es/ecma262/#sec-math.asinh
// Tor Browser bug: Math.asinh(0) -> -0
$({
    target: 'Math',
    stat: true,
    forced: !($asinh && 1 / $asinh(0) > 0)
}, {
    asinh: asinh
});

},{"../internals/export":"8yfGv"}],"iqYu2":[function(require,module,exports) {
var $ = require('../internals/export');
// eslint-disable-next-line es/no-math-atanh -- required for testing
var $atanh = Math.atanh;
var log = Math.log;
// `Math.atanh` method
// https://tc39.es/ecma262/#sec-math.atanh
// Tor Browser bug: Math.atanh(-0) -> 0
$({
    target: 'Math',
    stat: true,
    forced: !($atanh && 1 / $atanh(-0) < 0)
}, {
    atanh: function atanh(x) {
        return (x = +x) == 0 ? x : log((1 + x) / (1 - x)) / 2;
    }
});

},{"../internals/export":"8yfGv"}],"7NViC":[function(require,module,exports) {
var $ = require('../internals/export');
var sign = require('../internals/math-sign');
var abs = Math.abs;
var pow = Math.pow;
// `Math.cbrt` method
// https://tc39.es/ecma262/#sec-math.cbrt
$({
    target: 'Math',
    stat: true
}, {
    cbrt: function cbrt(x) {
        return sign(x = +x) * pow(abs(x), 1 / 3);
    }
});

},{"../internals/export":"8yfGv","../internals/math-sign":"b45UK"}],"b45UK":[function(require,module,exports) {
// `Math.sign` method implementation
// https://tc39.es/ecma262/#sec-math.sign
// eslint-disable-next-line es/no-math-sign -- safe
module.exports = Math.sign || function sign(x) {
    // eslint-disable-next-line no-self-compare -- NaN check
    return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

},{}],"iOLyn":[function(require,module,exports) {
var $ = require('../internals/export');
var floor = Math.floor;
var log = Math.log;
var LOG2E = Math.LOG2E;
// `Math.clz32` method
// https://tc39.es/ecma262/#sec-math.clz32
$({
    target: 'Math',
    stat: true
}, {
    clz32: function clz32(x) {
        return (x >>>= 0) ? 31 - floor(log(x + 0.5) * LOG2E) : 32;
    }
});

},{"../internals/export":"8yfGv"}],"aCMZ8":[function(require,module,exports) {
var $ = require('../internals/export');
var expm1 = require('../internals/math-expm1');
// eslint-disable-next-line es/no-math-cosh -- required for testing
var $cosh = Math.cosh;
var abs = Math.abs;
var E = Math.E;
// `Math.cosh` method
// https://tc39.es/ecma262/#sec-math.cosh
$({
    target: 'Math',
    stat: true,
    forced: !$cosh || $cosh(710) === Infinity
}, {
    cosh: function cosh(x) {
        var t = expm1(abs(x) - 1) + 1;
        return (t + 1 / (t * E * E)) * (E / 2);
    }
});

},{"../internals/export":"8yfGv","../internals/math-expm1":"lw06Q"}],"lw06Q":[function(require,module,exports) {
// eslint-disable-next-line es/no-math-expm1 -- safe
var $expm1 = Math.expm1;
var exp = Math.exp;
// `Math.expm1` method implementation
// https://tc39.es/ecma262/#sec-math.expm1
module.exports = !$expm1 || $expm1(10) > 22025.465794806718 || $expm1(10) < 22025.465794806718 || $expm1(-0.00000000000000002) != -0.00000000000000002 ? function expm1(x) {
    return (x = +x) == 0 ? x : x > -0.000001 && x < 0.000001 ? x + x * x / 2 : exp(x) - 1;
} : $expm1;

},{}],"Rejd3":[function(require,module,exports) {
var $ = require('../internals/export');
var expm1 = require('../internals/math-expm1');
// `Math.expm1` method
// https://tc39.es/ecma262/#sec-math.expm1
// eslint-disable-next-line es/no-math-expm1 -- required for testing
$({
    target: 'Math',
    stat: true,
    forced: expm1 != Math.expm1
}, {
    expm1: expm1
});

},{"../internals/export":"8yfGv","../internals/math-expm1":"lw06Q"}],"aHwOt":[function(require,module,exports) {
var $ = require('../internals/export');
var fround = require('../internals/math-fround');
// `Math.fround` method
// https://tc39.es/ecma262/#sec-math.fround
$({
    target: 'Math',
    stat: true
}, {
    fround: fround
});

},{"../internals/export":"8yfGv","../internals/math-fround":"4x3OH"}],"4x3OH":[function(require,module,exports) {
var sign = require('../internals/math-sign');
var abs = Math.abs;
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);
var roundTiesToEven = function(n) {
    return n + 1 / EPSILON - 1 / EPSILON;
};
// `Math.fround` method implementation
// https://tc39.es/ecma262/#sec-math.fround
// eslint-disable-next-line es/no-math-fround -- safe
module.exports = Math.fround || function fround(x) {
    var $abs = abs(x);
    var $sign = sign(x);
    var a, result;
    if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
    a = (1 + EPSILON32 / EPSILON) * $abs;
    result = a - (a - $abs);
    // eslint-disable-next-line no-self-compare -- NaN check
    if (result > MAX32 || result != result) return $sign * Infinity;
    return $sign * result;
};

},{"../internals/math-sign":"b45UK"}],"fCCrs":[function(require,module,exports) {
var $ = require('../internals/export');
// eslint-disable-next-line es/no-math-hypot -- required for testing
var $hypot = Math.hypot;
var abs = Math.abs;
var sqrt = Math.sqrt;
// Chrome 77 bug
// https://bugs.chromium.org/p/v8/issues/detail?id=9546
var BUGGY = !!$hypot && $hypot(Infinity, NaN) !== Infinity;
// `Math.hypot` method
// https://tc39.es/ecma262/#sec-math.hypot
$({
    target: 'Math',
    stat: true,
    forced: BUGGY
}, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    hypot: function hypot(value1, value2) {
        var sum = 0;
        var i = 0;
        var aLen = arguments.length;
        var larg = 0;
        var arg, div;
        while(i < aLen){
            arg = abs(arguments[i++]);
            if (larg < arg) {
                div = larg / arg;
                sum = sum * div * div + 1;
                larg = arg;
            } else if (arg > 0) {
                div = arg / larg;
                sum += div * div;
            } else sum += arg;
        }
        return larg === Infinity ? Infinity : larg * sqrt(sum);
    }
});

},{"../internals/export":"8yfGv"}],"gLxis":[function(require,module,exports) {
var $ = require('../internals/export');
var fails = require('../internals/fails');
// eslint-disable-next-line es/no-math-imul -- required for testing
var $imul = Math.imul;
var FORCED = fails(function() {
    return $imul(4294967295, 5) != -5 || $imul.length != 2;
});
// `Math.imul` method
// https://tc39.es/ecma262/#sec-math.imul
// some WebKit versions fails with big numbers, some has wrong arity
$({
    target: 'Math',
    stat: true,
    forced: FORCED
}, {
    imul: function imul(x, y) {
        var UINT16 = 65535;
        var xn = +x;
        var yn = +y;
        var xl = UINT16 & xn;
        var yl = UINT16 & yn;
        return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
    }
});

},{"../internals/export":"8yfGv","../internals/fails":"8IfZQ"}],"7LS2V":[function(require,module,exports) {
var $ = require('../internals/export');
var log10 = require('../internals/math-log10');
// `Math.log10` method
// https://tc39.es/ecma262/#sec-math.log10
$({
    target: 'Math',
    stat: true
}, {
    log10: log10
});

},{"../internals/export":"8yfGv","../internals/math-log10":"8rmai"}],"8rmai":[function(require,module,exports) {
var log = Math.log;
var LOG10E = Math.LOG10E;
// eslint-disable-next-line es/no-math-log10 -- safe
module.exports = Math.log10 || function log10(x) {
    return log(x) * LOG10E;
};

},{}],"k96xt":[function(require,module,exports) {
var $ = require('../internals/export');
var log1p = require('../internals/math-log1p');
// `Math.log1p` method
// https://tc39.es/ecma262/#sec-math.log1p
$({
    target: 'Math',
    stat: true
}, {
    log1p: log1p
});

},{"../internals/export":"8yfGv","../internals/math-log1p":"9aqHG"}],"3Uu1S":[function(require,module,exports) {
var $ = require('../internals/export');
var log = Math.log;
var LN2 = Math.LN2;
// `Math.log2` method
// https://tc39.es/ecma262/#sec-math.log2
$({
    target: 'Math',
    stat: true
}, {
    log2: function log2(x) {
        return log(x) / LN2;
    }
});

},{"../internals/export":"8yfGv"}],"8oTXY":[function(require,module,exports) {
var $ = require('../internals/export');
var sign = require('../internals/math-sign');
// `Math.sign` method
// https://tc39.es/ecma262/#sec-math.sign
$({
    target: 'Math',
    stat: true
}, {
    sign: sign
});

},{"../internals/export":"8yfGv","../internals/math-sign":"b45UK"}],"NNqsf":[function(require,module,exports) {
var $ = require('../internals/export');
var fails = require('../internals/fails');
var expm1 = require('../internals/math-expm1');
var abs = Math.abs;
var exp = Math.exp;
var E = Math.E;
var FORCED = fails(function() {
    // eslint-disable-next-line es/no-math-sinh -- required for testing
    return Math.sinh(-0.00000000000000002) != -0.00000000000000002;
});
// `Math.sinh` method
// https://tc39.es/ecma262/#sec-math.sinh
// V8 near Chromium 38 has a problem with very small numbers
$({
    target: 'Math',
    stat: true,
    forced: FORCED
}, {
    sinh: function sinh(x) {
        return abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (E / 2);
    }
});

},{"../internals/export":"8yfGv","../internals/fails":"8IfZQ","../internals/math-expm1":"lw06Q"}],"c0L87":[function(require,module,exports) {
var $ = require('../internals/export');
var expm1 = require('../internals/math-expm1');
var exp = Math.exp;
// `Math.tanh` method
// https://tc39.es/ecma262/#sec-math.tanh
$({
    target: 'Math',
    stat: true
}, {
    tanh: function tanh(x) {
        var a = expm1(x = +x);
        var b = expm1(-x);
        return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
    }
});

},{"../internals/export":"8yfGv","../internals/math-expm1":"lw06Q"}],"eGSGW":[function(require,module,exports) {
var setToStringTag = require('../internals/set-to-string-tag');
// Math[@@toStringTag] property
// https://tc39.es/ecma262/#sec-math-@@tostringtag
setToStringTag(Math, 'Math', true);

},{"../internals/set-to-string-tag":"9arwS"}],"3G59j":[function(require,module,exports) {
var $ = require('../internals/export');
var ceil = Math.ceil;
var floor = Math.floor;
// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
$({
    target: 'Math',
    stat: true
}, {
    trunc: function trunc(it) {
        return (it > 0 ? floor : ceil)(it);
    }
});

},{"../internals/export":"8yfGv"}],"1GiiH":[function(require,module,exports) {
'use strict';
var DESCRIPTORS = require('../internals/descriptors');
var global = require('../internals/global');
var uncurryThis = require('../internals/function-uncurry-this');
var isForced = require('../internals/is-forced');
var redefine = require('../internals/redefine');
var hasOwn = require('../internals/has-own-property');
var inheritIfRequired = require('../internals/inherit-if-required');
var isPrototypeOf = require('../internals/object-is-prototype-of');
var isSymbol = require('../internals/is-symbol');
var toPrimitive = require('../internals/to-primitive');
var fails = require('../internals/fails');
var getOwnPropertyNames = require('../internals/object-get-own-property-names').f;
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
var defineProperty = require('../internals/object-define-property').f;
var thisNumberValue = require('../internals/this-number-value');
var trim = require('../internals/string-trim').trim;
var NUMBER = 'Number';
var NativeNumber = global[NUMBER];
var NumberPrototype = NativeNumber.prototype;
var TypeError = global.TypeError;
var arraySlice = uncurryThis(''.slice);
var charCodeAt = uncurryThis(''.charCodeAt);
// `ToNumeric` abstract operation
// https://tc39.es/ecma262/#sec-tonumeric
var toNumeric = function(value) {
    var primValue = toPrimitive(value, 'number');
    return typeof primValue == 'bigint' ? primValue : toNumber(primValue);
};
// `ToNumber` abstract operation
// https://tc39.es/ecma262/#sec-tonumber
var toNumber = function(argument) {
    var it = toPrimitive(argument, 'number');
    var first, third, radix, maxCode, digits, length, index, code;
    if (isSymbol(it)) throw TypeError('Cannot convert a Symbol value to a number');
    if (typeof it == 'string' && it.length > 2) {
        it = trim(it);
        first = charCodeAt(it, 0);
        if (first === 43 || first === 45) {
            third = charCodeAt(it, 2);
            if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
        } else if (first === 48) {
            switch(charCodeAt(it, 1)){
                case 66:
                case 98:
                    radix = 2;
                    maxCode = 49;
                    break; // fast equal of /^0b[01]+$/i
                case 79:
                case 111:
                    radix = 8;
                    maxCode = 55;
                    break; // fast equal of /^0o[0-7]+$/i
                default:
                    return +it;
            }
            digits = arraySlice(it, 2);
            length = digits.length;
            for(index = 0; index < length; index++){
                code = charCodeAt(digits, index);
                // parseInt parses a string to a first unavailable symbol
                // but ToNumber should return NaN if a string contains unavailable symbols
                if (code < 48 || code > maxCode) return NaN;
            }
            return parseInt(digits, radix);
        }
    }
    return +it;
};
// `Number` constructor
// https://tc39.es/ecma262/#sec-number-constructor
if (isForced(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
    var NumberWrapper = function Number(value) {
        var n = arguments.length < 1 ? 0 : NativeNumber(toNumeric(value));
        var dummy = this;
        // check on 1..constructor(foo) case
        return isPrototypeOf(NumberPrototype, dummy) && fails(function() {
            thisNumberValue(dummy);
        }) ? inheritIfRequired(Object(n), dummy, NumberWrapper) : n;
    };
    for(var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : // ES3:
    "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(','), j = 0, key; keys.length > j; j++)if (hasOwn(NativeNumber, key = keys[j]) && !hasOwn(NumberWrapper, key)) defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));
    NumberWrapper.prototype = NumberPrototype;
    NumberPrototype.constructor = NumberWrapper;
    redefine(global, NUMBER, NumberWrapper);
}

},{"../internals/descriptors":"6ZLib","../internals/global":"jxPDA","../internals/function-uncurry-this":"jJnXC","../internals/is-forced":"eTyNf","../internals/redefine":"kxbj8","../internals/has-own-property":"3ZdUC","../internals/inherit-if-required":"kXY2O","../internals/object-is-prototype-of":"fyf1A","../internals/is-symbol":"imyt8","../internals/to-primitive":"ilNgA","../internals/fails":"8IfZQ","../internals/object-get-own-property-names":"evqXT","../internals/object-get-own-property-descriptor":"1gCBk","../internals/object-define-property":"bauTd","../internals/this-number-value":"ljIQn","../internals/string-trim":"6sOY8"}],"ljIQn":[function(require,module,exports) {
var uncurryThis = require('../internals/function-uncurry-this');
// `thisNumberValue` abstract operation
// https://tc39.es/ecma262/#sec-thisnumbervalue
module.exports = uncurryThis(1..valueOf);

},{"../internals/function-uncurry-this":"jJnXC"}],"6sOY8":[function(require,module,exports) {
var uncurryThis = require('../internals/function-uncurry-this');
var requireObjectCoercible = require('../internals/require-object-coercible');
var toString = require('../internals/to-string');
var whitespaces = require('../internals/whitespaces');
var replace = uncurryThis(''.replace);
var whitespace = '[' + whitespaces + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$');
// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod = function(TYPE) {
    return function($this) {
        var string = toString(requireObjectCoercible($this));
        if (TYPE & 1) string = replace(string, ltrim, '');
        if (TYPE & 2) string = replace(string, rtrim, '');
        return string;
    };
};
module.exports = {
    // `String.prototype.{ trimLeft, trimStart }` methods
    // https://tc39.es/ecma262/#sec-string.prototype.trimstart
    start: createMethod(1),
    // `String.prototype.{ trimRight, trimEnd }` methods
    // https://tc39.es/ecma262/#sec-string.prototype.trimend
    end: createMethod(2),
    // `String.prototype.trim` method
    // https://tc39.es/ecma262/#sec-string.prototype.trim
    trim: createMethod(3)
};

},{"../internals/function-uncurry-this":"jJnXC","../internals/require-object-coercible":"3Qlyo","../internals/to-string":"4cTlm","../internals/whitespaces":"ddvZW"}],"ddvZW":[function(require,module,exports) {
// a string of all valid unicode whitespaces
module.exports = "\t\n\v\f\r \xa0              　\u2028\u2029﻿";

},{}],"gBHjr":[function(require,module,exports) {
var $ = require('../internals/export');
// `Number.EPSILON` constant
// https://tc39.es/ecma262/#sec-number.epsilon
$({
    target: 'Number',
    stat: true
}, {
    EPSILON: Math.pow(2, -52)
});

},{"../internals/export":"8yfGv"}],"ihkUc":[function(require,module,exports) {
var $ = require('../internals/export');
var numberIsFinite = require('../internals/number-is-finite');
// `Number.isFinite` method
// https://tc39.es/ecma262/#sec-number.isfinite
$({
    target: 'Number',
    stat: true
}, {
    isFinite: numberIsFinite
});

},{"../internals/export":"8yfGv","../internals/number-is-finite":"d2LZ1"}],"d2LZ1":[function(require,module,exports) {
var global = require('../internals/global');
var globalIsFinite = global.isFinite;
// `Number.isFinite` method
// https://tc39.es/ecma262/#sec-number.isfinite
// eslint-disable-next-line es/no-number-isfinite -- safe
module.exports = Number.isFinite || function isFinite(it) {
    return typeof it == 'number' && globalIsFinite(it);
};

},{"../internals/global":"jxPDA"}],"26hJ1":[function(require,module,exports) {
var $ = require('../internals/export');
var isIntegralNumber = require('../internals/is-integral-number');
// `Number.isInteger` method
// https://tc39.es/ecma262/#sec-number.isinteger
$({
    target: 'Number',
    stat: true
}, {
    isInteger: isIntegralNumber
});

},{"../internals/export":"8yfGv","../internals/is-integral-number":"aJg8G"}],"aJg8G":[function(require,module,exports) {
var isObject = require('../internals/is-object');
var floor = Math.floor;
// `IsIntegralNumber` abstract operation
// https://tc39.es/ecma262/#sec-isintegralnumber
// eslint-disable-next-line es/no-number-isinteger -- safe
module.exports = Number.isInteger || function isInteger(it) {
    return !isObject(it) && isFinite(it) && floor(it) === it;
};

},{"../internals/is-object":"dplrD"}],"byONP":[function(require,module,exports) {
var $ = require('../internals/export');
// `Number.isNaN` method
// https://tc39.es/ecma262/#sec-number.isnan
$({
    target: 'Number',
    stat: true
}, {
    isNaN: function isNaN(number) {
        // eslint-disable-next-line no-self-compare -- NaN check
        return number != number;
    }
});

},{"../internals/export":"8yfGv"}],"5upSm":[function(require,module,exports) {
var $ = require('../internals/export');
var isIntegralNumber = require('../internals/is-integral-number');
var abs = Math.abs;
// `Number.isSafeInteger` method
// https://tc39.es/ecma262/#sec-number.issafeinteger
$({
    target: 'Number',
    stat: true
}, {
    isSafeInteger: function isSafeInteger(number) {
        return isIntegralNumber(number) && abs(number) <= 9007199254740991;
    }
});

},{"../internals/export":"8yfGv","../internals/is-integral-number":"aJg8G"}],"cSyXk":[function(require,module,exports) {
var $ = require('../internals/export');
// `Number.MAX_SAFE_INTEGER` constant
// https://tc39.es/ecma262/#sec-number.max_safe_integer
$({
    target: 'Number',
    stat: true
}, {
    MAX_SAFE_INTEGER: 9007199254740991
});

},{"../internals/export":"8yfGv"}],"6iXsJ":[function(require,module,exports) {
var $ = require('../internals/export');
// `Number.MIN_SAFE_INTEGER` constant
// https://tc39.es/ecma262/#sec-number.min_safe_integer
$({
    target: 'Number',
    stat: true
}, {
    MIN_SAFE_INTEGER: -9007199254740991
});

},{"../internals/export":"8yfGv"}],"9ZUeM":[function(require,module,exports) {
var $ = require('../internals/export');
var parseFloat = require('../internals/number-parse-float');
// `Number.parseFloat` method
// https://tc39.es/ecma262/#sec-number.parseFloat
// eslint-disable-next-line es/no-number-parsefloat -- required for testing
$({
    target: 'Number',
    stat: true,
    forced: Number.parseFloat != parseFloat
}, {
    parseFloat: parseFloat
});

},{"../internals/export":"8yfGv","../internals/number-parse-float":"JGeMe"}],"JGeMe":[function(require,module,exports) {
var global = require('../internals/global');
var fails = require('../internals/fails');
var uncurryThis = require('../internals/function-uncurry-this');
var toString = require('../internals/to-string');
var trim = require('../internals/string-trim').trim;
var whitespaces = require('../internals/whitespaces');
var charAt = uncurryThis(''.charAt);
var n$ParseFloat = global.parseFloat;
var Symbol = global.Symbol;
var ITERATOR = Symbol && Symbol.iterator;
var FORCED = 1 / n$ParseFloat(whitespaces + '-0') !== -Infinity || ITERATOR && !fails(function() {
    n$ParseFloat(Object(ITERATOR));
});
// `parseFloat` method
// https://tc39.es/ecma262/#sec-parsefloat-string
module.exports = FORCED ? function parseFloat(string) {
    var trimmedString = trim(toString(string));
    var result = n$ParseFloat(trimmedString);
    return result === 0 && charAt(trimmedString, 0) == '-' ? -0 : result;
} : n$ParseFloat;

},{"../internals/global":"jxPDA","../internals/fails":"8IfZQ","../internals/function-uncurry-this":"jJnXC","../internals/to-string":"4cTlm","../internals/string-trim":"6sOY8","../internals/whitespaces":"ddvZW"}],"bbKgY":[function(require,module,exports) {
var $ = require('../internals/export');
var parseInt = require('../internals/number-parse-int');
// `Number.parseInt` method
// https://tc39.es/ecma262/#sec-number.parseint
// eslint-disable-next-line es/no-number-parseint -- required for testing
$({
    target: 'Number',
    stat: true,
    forced: Number.parseInt != parseInt
}, {
    parseInt: parseInt
});

},{"../internals/export":"8yfGv","../internals/number-parse-int":"6rlJ1"}],"6rlJ1":[function(require,module,exports) {
var global = require('../internals/global');
var fails = require('../internals/fails');
var uncurryThis = require('../internals/function-uncurry-this');
var toString = require('../internals/to-string');
var trim = require('../internals/string-trim').trim;
var whitespaces = require('../internals/whitespaces');
var $parseInt = global.parseInt;
var Symbol = global.Symbol;
var ITERATOR = Symbol && Symbol.iterator;
var hex = /^[+-]?0x/i;
var exec = uncurryThis(hex.exec);
var FORCED = $parseInt(whitespaces + '08') !== 8 || $parseInt(whitespaces + '0x16') !== 22 || ITERATOR && !fails(function() {
    $parseInt(Object(ITERATOR));
});
// `parseInt` method
// https://tc39.es/ecma262/#sec-parseint-string-radix
module.exports = FORCED ? function parseInt(string, radix) {
    var S = trim(toString(string));
    return $parseInt(S, radix >>> 0 || (exec(hex, S) ? 16 : 10));
} : $parseInt;

},{"../internals/global":"jxPDA","../internals/fails":"8IfZQ","../internals/function-uncurry-this":"jJnXC","../internals/to-string":"4cTlm","../internals/string-trim":"6sOY8","../internals/whitespaces":"ddvZW"}],"kVrcj":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var global = require('../internals/global');
var uncurryThis = require('../internals/function-uncurry-this');
var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
var thisNumberValue = require('../internals/this-number-value');
var $repeat = require('../internals/string-repeat');
var log10 = require('../internals/math-log10');
var fails = require('../internals/fails');
var RangeError = global.RangeError;
var String = global.String;
var isFinite = global.isFinite;
var abs = Math.abs;
var floor = Math.floor;
var pow = Math.pow;
var round = Math.round;
var un$ToExponential = uncurryThis(1..toExponential);
var repeat = uncurryThis($repeat);
var stringSlice = uncurryThis(''.slice);
// Edge 17-
var ROUNDS_PROPERLY = un$ToExponential(-0.000000000069, 4) === '-6.9000e-11' && un$ToExponential(1.255, 2) === '1.25e+0' && un$ToExponential(12345, 3) === '1.235e+4' && un$ToExponential(25, 0) === '3e+1';
// IE8-
var THROWS_ON_INFINITY_FRACTION = fails(function() {
    un$ToExponential(1, Infinity);
}) && fails(function() {
    un$ToExponential(1, -Infinity);
});
// Safari <11 && FF <50
var PROPER_NON_FINITE_THIS_CHECK = !fails(function() {
    un$ToExponential(Infinity, Infinity);
}) && !fails(function() {
    un$ToExponential(NaN, Infinity);
});
var FORCED = !ROUNDS_PROPERLY || !THROWS_ON_INFINITY_FRACTION || !PROPER_NON_FINITE_THIS_CHECK;
// `Number.prototype.toExponential` method
// https://tc39.es/ecma262/#sec-number.prototype.toexponential
$({
    target: 'Number',
    proto: true,
    forced: FORCED
}, {
    toExponential: function toExponential(fractionDigits) {
        var x = thisNumberValue(this);
        if (fractionDigits === undefined) return un$ToExponential(x);
        var f = toIntegerOrInfinity(fractionDigits);
        if (!isFinite(x)) return String(x);
        // TODO: ES2018 increased the maximum number of fraction digits to 100, need to improve the implementation
        if (f < 0 || f > 20) throw RangeError('Incorrect fraction digits');
        if (ROUNDS_PROPERLY) return un$ToExponential(x, f);
        var s = '';
        var m = '';
        var e = 0;
        var c = '';
        var d = '';
        if (x < 0) {
            s = '-';
            x = -x;
        }
        if (x === 0) {
            e = 0;
            m = repeat('0', f + 1);
        } else {
            // this block is based on https://gist.github.com/SheetJSDev/1100ad56b9f856c95299ed0e068eea08
            // TODO: improve accuracy with big fraction digits
            var l = log10(x);
            e = floor(l);
            var n = 0;
            var w = pow(10, e - f);
            n = round(x / w);
            if (2 * x >= (2 * n + 1) * w) n += 1;
            if (n >= pow(10, f + 1)) {
                n /= 10;
                e += 1;
            }
            m = String(n);
        }
        if (f !== 0) m = stringSlice(m, 0, 1) + '.' + stringSlice(m, 1);
        if (e === 0) {
            c = '+';
            d = '0';
        } else {
            c = e > 0 ? '+' : '-';
            d = String(abs(e));
        }
        m += 'e' + c + d;
        return s + m;
    }
});

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/function-uncurry-this":"jJnXC","../internals/to-integer-or-infinity":"aqyxv","../internals/this-number-value":"ljIQn","../internals/string-repeat":"4Md87","../internals/math-log10":"8rmai","../internals/fails":"8IfZQ"}],"9LVCp":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var global = require('../internals/global');
var uncurryThis = require('../internals/function-uncurry-this');
var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
var thisNumberValue = require('../internals/this-number-value');
var $repeat = require('../internals/string-repeat');
var fails = require('../internals/fails');
var RangeError = global.RangeError;
var String = global.String;
var floor = Math.floor;
var repeat = uncurryThis($repeat);
var stringSlice = uncurryThis(''.slice);
var un$ToFixed = uncurryThis(1..toFixed);
var pow = function(x, n, acc) {
    return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function(x) {
    var n = 0;
    var x2 = x;
    while(x2 >= 4096){
        n += 12;
        x2 /= 4096;
    }
    while(x2 >= 2){
        n += 1;
        x2 /= 2;
    }
    return n;
};
var multiply = function(data, n, c) {
    var index = -1;
    var c2 = c;
    while(++index < 6){
        c2 += n * data[index];
        data[index] = c2 % 10000000;
        c2 = floor(c2 / 10000000);
    }
};
var divide = function(data, n) {
    var index = 6;
    var c = 0;
    while(--index >= 0){
        c += data[index];
        data[index] = floor(c / n);
        c = c % n * 10000000;
    }
};
var dataToString = function(data) {
    var index = 6;
    var s = '';
    while(--index >= 0)if (s !== '' || index === 0 || data[index] !== 0) {
        var t = String(data[index]);
        s = s === '' ? t : s + repeat('0', 7 - t.length) + t;
    }
    return s;
};
var FORCED = fails(function() {
    return un$ToFixed(0.00008, 3) !== '0.000' || un$ToFixed(0.9, 0) !== '1' || un$ToFixed(1.255, 2) !== '1.25' || un$ToFixed(1000000000000000100, 0) !== '1000000000000000128';
}) || !fails(function() {
    // V8 ~ Android 4.3-
    un$ToFixed({
    });
});
// `Number.prototype.toFixed` method
// https://tc39.es/ecma262/#sec-number.prototype.tofixed
$({
    target: 'Number',
    proto: true,
    forced: FORCED
}, {
    toFixed: function toFixed(fractionDigits) {
        var number = thisNumberValue(this);
        var fractDigits = toIntegerOrInfinity(fractionDigits);
        var data = [
            0,
            0,
            0,
            0,
            0,
            0
        ];
        var sign = '';
        var result = '0';
        var e, z, j, k;
        // TODO: ES2018 increased the maximum number of fraction digits to 100, need to improve the implementation
        if (fractDigits < 0 || fractDigits > 20) throw RangeError('Incorrect fraction digits');
        // eslint-disable-next-line no-self-compare -- NaN check
        if (number != number) return 'NaN';
        if (number <= -1000000000000000000000 || number >= 1000000000000000000000) return String(number);
        if (number < 0) {
            sign = '-';
            number = -number;
        }
        if (number > 0.000000000000000000001) {
            e = log(number * pow(2, 69, 1)) - 69;
            z = e < 0 ? number * pow(2, -e, 1) : number / pow(2, e, 1);
            z *= 4503599627370496;
            e = 52 - e;
            if (e > 0) {
                multiply(data, 0, z);
                j = fractDigits;
                while(j >= 7){
                    multiply(data, 10000000, 0);
                    j -= 7;
                }
                multiply(data, pow(10, j, 1), 0);
                j = e - 1;
                while(j >= 23){
                    divide(data, 8388608);
                    j -= 23;
                }
                divide(data, 1 << j);
                multiply(data, 1, 1);
                divide(data, 2);
                result = dataToString(data);
            } else {
                multiply(data, 0, z);
                multiply(data, 1 << -e, 0);
                result = dataToString(data) + repeat('0', fractDigits);
            }
        }
        if (fractDigits > 0) {
            k = result.length;
            result = sign + (k <= fractDigits ? '0.' + repeat('0', fractDigits - k) + result : stringSlice(result, 0, k - fractDigits) + '.' + stringSlice(result, k - fractDigits));
        } else result = sign + result;
        return result;
    }
});

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/function-uncurry-this":"jJnXC","../internals/to-integer-or-infinity":"aqyxv","../internals/this-number-value":"ljIQn","../internals/string-repeat":"4Md87","../internals/fails":"8IfZQ"}],"eheVs":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var uncurryThis = require('../internals/function-uncurry-this');
var fails = require('../internals/fails');
var thisNumberValue = require('../internals/this-number-value');
var un$ToPrecision = uncurryThis(1..toPrecision);
var FORCED = fails(function() {
    // IE7-
    return un$ToPrecision(1, undefined) !== '1';
}) || !fails(function() {
    // V8 ~ Android 4.3-
    un$ToPrecision({
    });
});
// `Number.prototype.toPrecision` method
// https://tc39.es/ecma262/#sec-number.prototype.toprecision
$({
    target: 'Number',
    proto: true,
    forced: FORCED
}, {
    toPrecision: function toPrecision(precision) {
        return precision === undefined ? un$ToPrecision(thisNumberValue(this)) : un$ToPrecision(thisNumberValue(this), precision);
    }
});

},{"../internals/export":"8yfGv","../internals/function-uncurry-this":"jJnXC","../internals/fails":"8IfZQ","../internals/this-number-value":"ljIQn"}],"d9U4P":[function(require,module,exports) {
var $ = require('../internals/export');
var assign = require('../internals/object-assign');
// `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign
// eslint-disable-next-line es/no-object-assign -- required for testing
$({
    target: 'Object',
    stat: true,
    forced: Object.assign !== assign
}, {
    assign: assign
});

},{"../internals/export":"8yfGv","../internals/object-assign":"aXKvb"}],"aXKvb":[function(require,module,exports) {
'use strict';
var DESCRIPTORS = require('../internals/descriptors');
var uncurryThis = require('../internals/function-uncurry-this');
var call = require('../internals/function-call');
var fails = require('../internals/fails');
var objectKeys = require('../internals/object-keys');
var getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');
var propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');
var toObject = require('../internals/to-object');
var IndexedObject = require('../internals/indexed-object');
// eslint-disable-next-line es/no-object-assign -- safe
var $assign = Object.assign;
// eslint-disable-next-line es/no-object-defineproperty -- required for testing
var defineProperty = Object.defineProperty;
var concat = uncurryThis([].concat);
// `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign
module.exports = !$assign || fails(function() {
    // should have correct order of operations (Edge bug)
    if (DESCRIPTORS && $assign({
        b: 1
    }, $assign(defineProperty({
    }, 'a', {
        enumerable: true,
        get: function() {
            defineProperty(this, 'b', {
                value: 3,
                enumerable: false
            });
        }
    }), {
        b: 2
    })).b !== 1) return true;
    // should work with symbols and should have deterministic property order (V8 bug)
    var A = {
    };
    var B = {
    };
    // eslint-disable-next-line es/no-symbol -- safe
    var symbol = Symbol();
    var alphabet = 'abcdefghijklmnopqrst';
    A[symbol] = 7;
    alphabet.split('').forEach(function(chr) {
        B[chr] = chr;
    });
    return $assign({
    }, A)[symbol] != 7 || objectKeys($assign({
    }, B)).join('') != alphabet;
}) ? function assign(target, source) {
    var T = toObject(target);
    var argumentsLength = arguments.length;
    var index = 1;
    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    var propertyIsEnumerable = propertyIsEnumerableModule.f;
    while(argumentsLength > index){
        var S = IndexedObject(arguments[index++]);
        var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);
        var length = keys.length;
        var j = 0;
        var key;
        while(length > j){
            key = keys[j++];
            if (!DESCRIPTORS || call(propertyIsEnumerable, S, key)) T[key] = S[key];
        }
    }
    return T;
} : $assign;

},{"../internals/descriptors":"6ZLib","../internals/function-uncurry-this":"jJnXC","../internals/function-call":"jhLed","../internals/fails":"8IfZQ","../internals/object-keys":"9bK4Y","../internals/object-get-own-property-symbols":"dBB9V","../internals/object-property-is-enumerable":"bz2pv","../internals/to-object":"eEdae","../internals/indexed-object":"e5ccT"}],"2OzxE":[function(require,module,exports) {
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var create = require('../internals/object-create');
// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
$({
    target: 'Object',
    stat: true,
    sham: !DESCRIPTORS
}, {
    create: create
});

},{"../internals/export":"8yfGv","../internals/descriptors":"6ZLib","../internals/object-create":"1As5O"}],"rUotD":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var FORCED = require('../internals/object-prototype-accessors-forced');
var aCallable = require('../internals/a-callable');
var toObject = require('../internals/to-object');
var definePropertyModule = require('../internals/object-define-property');
// `Object.prototype.__defineGetter__` method
// https://tc39.es/ecma262/#sec-object.prototype.__defineGetter__
if (DESCRIPTORS) $({
    target: 'Object',
    proto: true,
    forced: FORCED
}, {
    __defineGetter__: function __defineGetter__(P, getter) {
        definePropertyModule.f(toObject(this), P, {
            get: aCallable(getter),
            enumerable: true,
            configurable: true
        });
    }
});

},{"../internals/export":"8yfGv","../internals/descriptors":"6ZLib","../internals/object-prototype-accessors-forced":"lsfAm","../internals/a-callable":"83opn","../internals/to-object":"eEdae","../internals/object-define-property":"bauTd"}],"lsfAm":[function(require,module,exports) {
'use strict';
var IS_PURE = require('../internals/is-pure');
var global = require('../internals/global');
var fails = require('../internals/fails');
var WEBKIT = require('../internals/engine-webkit-version');
// Forced replacement object prototype accessors methods
module.exports = IS_PURE || !fails(function() {
    // This feature detection crashes old WebKit
    // https://github.com/zloirock/core-js/issues/232
    if (WEBKIT && WEBKIT < 535) return;
    var key = Math.random();
    // In FF throws only define methods
    // eslint-disable-next-line no-undef, no-useless-call -- required for testing
    __defineSetter__.call(null, key, function() {
    });
    delete global[key];
});

},{"../internals/is-pure":"6Bbq0","../internals/global":"jxPDA","../internals/fails":"8IfZQ","../internals/engine-webkit-version":"a5m5j"}],"7N8aI":[function(require,module,exports) {
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var defineProperties = require('../internals/object-define-properties').f;
// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
$({
    target: 'Object',
    stat: true,
    forced: Object.defineProperties !== defineProperties,
    sham: !DESCRIPTORS
}, {
    defineProperties: defineProperties
});

},{"../internals/export":"8yfGv","../internals/descriptors":"6ZLib","../internals/object-define-properties":"8PPlc"}],"43HUr":[function(require,module,exports) {
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var defineProperty = require('../internals/object-define-property').f;
// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
// eslint-disable-next-line es/no-object-defineproperty -- safe
$({
    target: 'Object',
    stat: true,
    forced: Object.defineProperty !== defineProperty,
    sham: !DESCRIPTORS
}, {
    defineProperty: defineProperty
});

},{"../internals/export":"8yfGv","../internals/descriptors":"6ZLib","../internals/object-define-property":"bauTd"}],"6pPBW":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var FORCED = require('../internals/object-prototype-accessors-forced');
var aCallable = require('../internals/a-callable');
var toObject = require('../internals/to-object');
var definePropertyModule = require('../internals/object-define-property');
// `Object.prototype.__defineSetter__` method
// https://tc39.es/ecma262/#sec-object.prototype.__defineSetter__
if (DESCRIPTORS) $({
    target: 'Object',
    proto: true,
    forced: FORCED
}, {
    __defineSetter__: function __defineSetter__(P, setter) {
        definePropertyModule.f(toObject(this), P, {
            set: aCallable(setter),
            enumerable: true,
            configurable: true
        });
    }
});

},{"../internals/export":"8yfGv","../internals/descriptors":"6ZLib","../internals/object-prototype-accessors-forced":"lsfAm","../internals/a-callable":"83opn","../internals/to-object":"eEdae","../internals/object-define-property":"bauTd"}],"65Ttp":[function(require,module,exports) {
var $ = require('../internals/export');
var $entries = require('../internals/object-to-array').entries;
// `Object.entries` method
// https://tc39.es/ecma262/#sec-object.entries
$({
    target: 'Object',
    stat: true
}, {
    entries: function entries(O) {
        return $entries(O);
    }
});

},{"../internals/export":"8yfGv","../internals/object-to-array":"62cY3"}],"62cY3":[function(require,module,exports) {
var DESCRIPTORS = require('../internals/descriptors');
var uncurryThis = require('../internals/function-uncurry-this');
var objectKeys = require('../internals/object-keys');
var toIndexedObject = require('../internals/to-indexed-object');
var $propertyIsEnumerable = require('../internals/object-property-is-enumerable').f;
var propertyIsEnumerable = uncurryThis($propertyIsEnumerable);
var push = uncurryThis([].push);
// `Object.{ entries, values }` methods implementation
var createMethod = function(TO_ENTRIES) {
    return function(it) {
        var O = toIndexedObject(it);
        var keys = objectKeys(O);
        var length = keys.length;
        var i = 0;
        var result = [];
        var key;
        while(length > i){
            key = keys[i++];
            if (!DESCRIPTORS || propertyIsEnumerable(O, key)) push(result, TO_ENTRIES ? [
                key,
                O[key]
            ] : O[key]);
        }
        return result;
    };
};
module.exports = {
    // `Object.entries` method
    // https://tc39.es/ecma262/#sec-object.entries
    entries: createMethod(true),
    // `Object.values` method
    // https://tc39.es/ecma262/#sec-object.values
    values: createMethod(false)
};

},{"../internals/descriptors":"6ZLib","../internals/function-uncurry-this":"jJnXC","../internals/object-keys":"9bK4Y","../internals/to-indexed-object":"8ueFu","../internals/object-property-is-enumerable":"bz2pv"}],"95squ":[function(require,module,exports) {
var $ = require('../internals/export');
var FREEZING = require('../internals/freezing');
var fails = require('../internals/fails');
var isObject = require('../internals/is-object');
var onFreeze = require('../internals/internal-metadata').onFreeze;
// eslint-disable-next-line es/no-object-freeze -- safe
var $freeze = Object.freeze;
var FAILS_ON_PRIMITIVES = fails(function() {
    $freeze(1);
});
// `Object.freeze` method
// https://tc39.es/ecma262/#sec-object.freeze
$({
    target: 'Object',
    stat: true,
    forced: FAILS_ON_PRIMITIVES,
    sham: !FREEZING
}, {
    freeze: function freeze(it) {
        return $freeze && isObject(it) ? $freeze(onFreeze(it)) : it;
    }
});

},{"../internals/export":"8yfGv","../internals/freezing":"5dl3e","../internals/fails":"8IfZQ","../internals/is-object":"dplrD","../internals/internal-metadata":"fD10R"}],"Hyj7V":[function(require,module,exports) {
var $ = require('../internals/export');
var iterate = require('../internals/iterate');
var createProperty = require('../internals/create-property');
// `Object.fromEntries` method
// https://github.com/tc39/proposal-object-from-entries
$({
    target: 'Object',
    stat: true
}, {
    fromEntries: function fromEntries(iterable) {
        var obj = {
        };
        iterate(iterable, function(k, v) {
            createProperty(obj, k, v);
        }, {
            AS_ENTRIES: true
        });
        return obj;
    }
});

},{"../internals/export":"8yfGv","../internals/iterate":"fTyka","../internals/create-property":"a2n8E"}],"ktsyI":[function(require,module,exports) {
var $ = require('../internals/export');
var fails = require('../internals/fails');
var toIndexedObject = require('../internals/to-indexed-object');
var nativeGetOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
var DESCRIPTORS = require('../internals/descriptors');
var FAILS_ON_PRIMITIVES = fails(function() {
    nativeGetOwnPropertyDescriptor(1);
});
var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;
// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
$({
    target: 'Object',
    stat: true,
    forced: FORCED,
    sham: !DESCRIPTORS
}, {
    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
        return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
    }
});

},{"../internals/export":"8yfGv","../internals/fails":"8IfZQ","../internals/to-indexed-object":"8ueFu","../internals/object-get-own-property-descriptor":"1gCBk","../internals/descriptors":"6ZLib"}],"kDpK6":[function(require,module,exports) {
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var ownKeys = require('../internals/own-keys');
var toIndexedObject = require('../internals/to-indexed-object');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
var createProperty = require('../internals/create-property');
// `Object.getOwnPropertyDescriptors` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
$({
    target: 'Object',
    stat: true,
    sham: !DESCRIPTORS
}, {
    getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
        var O = toIndexedObject(object);
        var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
        var keys = ownKeys(O);
        var result = {
        };
        var index = 0;
        var key, descriptor;
        while(keys.length > index){
            descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
            if (descriptor !== undefined) createProperty(result, key, descriptor);
        }
        return result;
    }
});

},{"../internals/export":"8yfGv","../internals/descriptors":"6ZLib","../internals/own-keys":"e0KjM","../internals/to-indexed-object":"8ueFu","../internals/object-get-own-property-descriptor":"1gCBk","../internals/create-property":"a2n8E"}],"bf1Ns":[function(require,module,exports) {
var $ = require('../internals/export');
var fails = require('../internals/fails');
var getOwnPropertyNames = require('../internals/object-get-own-property-names-external').f;
// eslint-disable-next-line es/no-object-getownpropertynames -- required for testing
var FAILS_ON_PRIMITIVES = fails(function() {
    return !Object.getOwnPropertyNames(1);
});
// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
$({
    target: 'Object',
    stat: true,
    forced: FAILS_ON_PRIMITIVES
}, {
    getOwnPropertyNames: getOwnPropertyNames
});

},{"../internals/export":"8yfGv","../internals/fails":"8IfZQ","../internals/object-get-own-property-names-external":"7r5nw"}],"lrIcR":[function(require,module,exports) {
var $ = require('../internals/export');
var fails = require('../internals/fails');
var toObject = require('../internals/to-object');
var nativeGetPrototypeOf = require('../internals/object-get-prototype-of');
var CORRECT_PROTOTYPE_GETTER = require('../internals/correct-prototype-getter');
var FAILS_ON_PRIMITIVES = fails(function() {
    nativeGetPrototypeOf(1);
});
// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
$({
    target: 'Object',
    stat: true,
    forced: FAILS_ON_PRIMITIVES,
    sham: !CORRECT_PROTOTYPE_GETTER
}, {
    getPrototypeOf: function getPrototypeOf(it) {
        return nativeGetPrototypeOf(toObject(it));
    }
});

},{"../internals/export":"8yfGv","../internals/fails":"8IfZQ","../internals/to-object":"eEdae","../internals/object-get-prototype-of":"lBy7h","../internals/correct-prototype-getter":"5LqOC"}],"fwKd5":[function(require,module,exports) {
var $ = require('../internals/export');
var hasOwn = require('../internals/has-own-property');
// `Object.hasOwn` method
// https://github.com/tc39/proposal-accessible-object-hasownproperty
$({
    target: 'Object',
    stat: true
}, {
    hasOwn: hasOwn
});

},{"../internals/export":"8yfGv","../internals/has-own-property":"3ZdUC"}],"AZbGS":[function(require,module,exports) {
var $ = require('../internals/export');
var is = require('../internals/same-value');
// `Object.is` method
// https://tc39.es/ecma262/#sec-object.is
$({
    target: 'Object',
    stat: true
}, {
    is: is
});

},{"../internals/export":"8yfGv","../internals/same-value":"hePMR"}],"hePMR":[function(require,module,exports) {
// `SameValue` abstract operation
// https://tc39.es/ecma262/#sec-samevalue
// eslint-disable-next-line es/no-object-is -- safe
module.exports = Object.is || function is(x, y) {
    // eslint-disable-next-line no-self-compare -- NaN check
    return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

},{}],"8opwh":[function(require,module,exports) {
var $ = require('../internals/export');
var $isExtensible = require('../internals/object-is-extensible');
// `Object.isExtensible` method
// https://tc39.es/ecma262/#sec-object.isextensible
// eslint-disable-next-line es/no-object-isextensible -- safe
$({
    target: 'Object',
    stat: true,
    forced: Object.isExtensible !== $isExtensible
}, {
    isExtensible: $isExtensible
});

},{"../internals/export":"8yfGv","../internals/object-is-extensible":"eApj6"}],"c0NSD":[function(require,module,exports) {
var $ = require('../internals/export');
var fails = require('../internals/fails');
var isObject = require('../internals/is-object');
var classof = require('../internals/classof-raw');
var ARRAY_BUFFER_NON_EXTENSIBLE = require('../internals/array-buffer-non-extensible');
// eslint-disable-next-line es/no-object-isfrozen -- safe
var $isFrozen = Object.isFrozen;
var FAILS_ON_PRIMITIVES = fails(function() {
    $isFrozen(1);
});
// `Object.isFrozen` method
// https://tc39.es/ecma262/#sec-object.isfrozen
$({
    target: 'Object',
    stat: true,
    forced: FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE
}, {
    isFrozen: function isFrozen(it) {
        if (!isObject(it)) return true;
        if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) == 'ArrayBuffer') return true;
        return $isFrozen ? $isFrozen(it) : false;
    }
});

},{"../internals/export":"8yfGv","../internals/fails":"8IfZQ","../internals/is-object":"dplrD","../internals/classof-raw":"A9m3U","../internals/array-buffer-non-extensible":"9fgu5"}],"ku0Er":[function(require,module,exports) {
var $ = require('../internals/export');
var fails = require('../internals/fails');
var isObject = require('../internals/is-object');
var classof = require('../internals/classof-raw');
var ARRAY_BUFFER_NON_EXTENSIBLE = require('../internals/array-buffer-non-extensible');
// eslint-disable-next-line es/no-object-issealed -- safe
var $isSealed = Object.isSealed;
var FAILS_ON_PRIMITIVES = fails(function() {
    $isSealed(1);
});
// `Object.isSealed` method
// https://tc39.es/ecma262/#sec-object.issealed
$({
    target: 'Object',
    stat: true,
    forced: FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE
}, {
    isSealed: function isSealed(it) {
        if (!isObject(it)) return true;
        if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) == 'ArrayBuffer') return true;
        return $isSealed ? $isSealed(it) : false;
    }
});

},{"../internals/export":"8yfGv","../internals/fails":"8IfZQ","../internals/is-object":"dplrD","../internals/classof-raw":"A9m3U","../internals/array-buffer-non-extensible":"9fgu5"}],"5whyw":[function(require,module,exports) {
var $ = require('../internals/export');
var toObject = require('../internals/to-object');
var nativeKeys = require('../internals/object-keys');
var fails = require('../internals/fails');
var FAILS_ON_PRIMITIVES = fails(function() {
    nativeKeys(1);
});
// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
$({
    target: 'Object',
    stat: true,
    forced: FAILS_ON_PRIMITIVES
}, {
    keys: function keys(it) {
        return nativeKeys(toObject(it));
    }
});

},{"../internals/export":"8yfGv","../internals/to-object":"eEdae","../internals/object-keys":"9bK4Y","../internals/fails":"8IfZQ"}],"daJYk":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var FORCED = require('../internals/object-prototype-accessors-forced');
var toObject = require('../internals/to-object');
var toPropertyKey = require('../internals/to-property-key');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
// `Object.prototype.__lookupGetter__` method
// https://tc39.es/ecma262/#sec-object.prototype.__lookupGetter__
if (DESCRIPTORS) $({
    target: 'Object',
    proto: true,
    forced: FORCED
}, {
    __lookupGetter__: function __lookupGetter__(P) {
        var O = toObject(this);
        var key = toPropertyKey(P);
        var desc;
        do {
            if (desc = getOwnPropertyDescriptor(O, key)) return desc.get;
        }while (O = getPrototypeOf(O))
    }
});

},{"../internals/export":"8yfGv","../internals/descriptors":"6ZLib","../internals/object-prototype-accessors-forced":"lsfAm","../internals/to-object":"eEdae","../internals/to-property-key":"bMDpS","../internals/object-get-prototype-of":"lBy7h","../internals/object-get-own-property-descriptor":"1gCBk"}],"hW914":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var FORCED = require('../internals/object-prototype-accessors-forced');
var toObject = require('../internals/to-object');
var toPropertyKey = require('../internals/to-property-key');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
// `Object.prototype.__lookupSetter__` method
// https://tc39.es/ecma262/#sec-object.prototype.__lookupSetter__
if (DESCRIPTORS) $({
    target: 'Object',
    proto: true,
    forced: FORCED
}, {
    __lookupSetter__: function __lookupSetter__(P) {
        var O = toObject(this);
        var key = toPropertyKey(P);
        var desc;
        do {
            if (desc = getOwnPropertyDescriptor(O, key)) return desc.set;
        }while (O = getPrototypeOf(O))
    }
});

},{"../internals/export":"8yfGv","../internals/descriptors":"6ZLib","../internals/object-prototype-accessors-forced":"lsfAm","../internals/to-object":"eEdae","../internals/to-property-key":"bMDpS","../internals/object-get-prototype-of":"lBy7h","../internals/object-get-own-property-descriptor":"1gCBk"}],"lgjwP":[function(require,module,exports) {
var $ = require('../internals/export');
var isObject = require('../internals/is-object');
var onFreeze = require('../internals/internal-metadata').onFreeze;
var FREEZING = require('../internals/freezing');
var fails = require('../internals/fails');
// eslint-disable-next-line es/no-object-preventextensions -- safe
var $preventExtensions = Object.preventExtensions;
var FAILS_ON_PRIMITIVES = fails(function() {
    $preventExtensions(1);
});
// `Object.preventExtensions` method
// https://tc39.es/ecma262/#sec-object.preventextensions
$({
    target: 'Object',
    stat: true,
    forced: FAILS_ON_PRIMITIVES,
    sham: !FREEZING
}, {
    preventExtensions: function preventExtensions(it) {
        return $preventExtensions && isObject(it) ? $preventExtensions(onFreeze(it)) : it;
    }
});

},{"../internals/export":"8yfGv","../internals/is-object":"dplrD","../internals/internal-metadata":"fD10R","../internals/freezing":"5dl3e","../internals/fails":"8IfZQ"}],"iSUTX":[function(require,module,exports) {
var $ = require('../internals/export');
var isObject = require('../internals/is-object');
var onFreeze = require('../internals/internal-metadata').onFreeze;
var FREEZING = require('../internals/freezing');
var fails = require('../internals/fails');
// eslint-disable-next-line es/no-object-seal -- safe
var $seal = Object.seal;
var FAILS_ON_PRIMITIVES = fails(function() {
    $seal(1);
});
// `Object.seal` method
// https://tc39.es/ecma262/#sec-object.seal
$({
    target: 'Object',
    stat: true,
    forced: FAILS_ON_PRIMITIVES,
    sham: !FREEZING
}, {
    seal: function seal(it) {
        return $seal && isObject(it) ? $seal(onFreeze(it)) : it;
    }
});

},{"../internals/export":"8yfGv","../internals/is-object":"dplrD","../internals/internal-metadata":"fD10R","../internals/freezing":"5dl3e","../internals/fails":"8IfZQ"}],"5guzB":[function(require,module,exports) {
var $ = require('../internals/export');
var setPrototypeOf = require('../internals/object-set-prototype-of');
// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
$({
    target: 'Object',
    stat: true
}, {
    setPrototypeOf: setPrototypeOf
});

},{"../internals/export":"8yfGv","../internals/object-set-prototype-of":"lb6rR"}],"wRGKV":[function(require,module,exports) {
var TO_STRING_TAG_SUPPORT = require('../internals/to-string-tag-support');
var redefine = require('../internals/redefine');
var toString = require('../internals/object-to-string');
// `Object.prototype.toString` method
// https://tc39.es/ecma262/#sec-object.prototype.tostring
if (!TO_STRING_TAG_SUPPORT) redefine(Object.prototype, 'toString', toString, {
    unsafe: true
});

},{"../internals/to-string-tag-support":"g8wEl","../internals/redefine":"kxbj8","../internals/object-to-string":"hEWlD"}],"hEWlD":[function(require,module,exports) {
'use strict';
var TO_STRING_TAG_SUPPORT = require('../internals/to-string-tag-support');
var classof = require('../internals/classof');
// `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? ({
}).toString : function toString() {
    return '[object ' + classof(this) + ']';
};

},{"../internals/to-string-tag-support":"g8wEl","../internals/classof":"kJ8JQ"}],"8yXbZ":[function(require,module,exports) {
var $ = require('../internals/export');
var $values = require('../internals/object-to-array').values;
// `Object.values` method
// https://tc39.es/ecma262/#sec-object.values
$({
    target: 'Object',
    stat: true
}, {
    values: function values(O) {
        return $values(O);
    }
});

},{"../internals/export":"8yfGv","../internals/object-to-array":"62cY3"}],"8K5Js":[function(require,module,exports) {
var $ = require('../internals/export');
var $parseFloat = require('../internals/number-parse-float');
// `parseFloat` method
// https://tc39.es/ecma262/#sec-parsefloat-string
$({
    global: true,
    forced: parseFloat != $parseFloat
}, {
    parseFloat: $parseFloat
});

},{"../internals/export":"8yfGv","../internals/number-parse-float":"JGeMe"}],"8F8si":[function(require,module,exports) {
var $ = require('../internals/export');
var $parseInt = require('../internals/number-parse-int');
// `parseInt` method
// https://tc39.es/ecma262/#sec-parseint-string-radix
$({
    global: true,
    forced: parseInt != $parseInt
}, {
    parseInt: $parseInt
});

},{"../internals/export":"8yfGv","../internals/number-parse-int":"6rlJ1"}],"8nMUv":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var global = require('../internals/global');
var getBuiltIn = require('../internals/get-built-in');
var call = require('../internals/function-call');
var NativePromise = require('../internals/native-promise-constructor');
var redefine = require('../internals/redefine');
var redefineAll = require('../internals/redefine-all');
var setPrototypeOf = require('../internals/object-set-prototype-of');
var setToStringTag = require('../internals/set-to-string-tag');
var setSpecies = require('../internals/set-species');
var aCallable = require('../internals/a-callable');
var isCallable = require('../internals/is-callable');
var isObject = require('../internals/is-object');
var anInstance = require('../internals/an-instance');
var inspectSource = require('../internals/inspect-source');
var iterate = require('../internals/iterate');
var checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');
var speciesConstructor = require('../internals/species-constructor');
var task = require('../internals/task').set;
var microtask = require('../internals/microtask');
var promiseResolve = require('../internals/promise-resolve');
var hostReportErrors = require('../internals/host-report-errors');
var newPromiseCapabilityModule = require('../internals/new-promise-capability');
var perform = require('../internals/perform');
var Queue = require('../internals/queue');
var InternalStateModule = require('../internals/internal-state');
var isForced = require('../internals/is-forced');
var wellKnownSymbol = require('../internals/well-known-symbol');
var IS_BROWSER = require('../internals/engine-is-browser');
var IS_NODE = require('../internals/engine-is-node');
var V8_VERSION = require('../internals/engine-v8-version');
var SPECIES = wellKnownSymbol('species');
var PROMISE = 'Promise';
var getInternalState = InternalStateModule.getterFor(PROMISE);
var setInternalState = InternalStateModule.set;
var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
var NativePromisePrototype = NativePromise && NativePromise.prototype;
var PromiseConstructor = NativePromise;
var PromisePrototype = NativePromisePrototype;
var TypeError = global.TypeError;
var document = global.document;
var process = global.process;
var newPromiseCapability = newPromiseCapabilityModule.f;
var newGenericPromiseCapability = newPromiseCapability;
var DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);
var NATIVE_REJECTION_EVENT = isCallable(global.PromiseRejectionEvent);
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var SUBCLASSING = false;
var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
var FORCED = isForced(PROMISE, function() {
    var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(PromiseConstructor);
    var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(PromiseConstructor);
    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // We can't detect it synchronously, so just check versions
    if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;
    // We need Promise#finally in the pure version for preventing prototype pollution
    if (IS_PURE && !PromisePrototype['finally']) return true;
    // We can't use @@species feature detection in V8 since it causes
    // deoptimization and performance degradation
    // https://github.com/zloirock/core-js/issues/679
    if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) return false;
    // Detect correctness of subclassing with @@species support
    var promise = new PromiseConstructor(function(resolve) {
        resolve(1);
    });
    var FakePromise = function(exec) {
        exec(function() {
        }, function() {
        });
    };
    var constructor = promise.constructor = {
    };
    constructor[SPECIES] = FakePromise;
    SUBCLASSING = promise.then(function() {
    }) instanceof FakePromise;
    if (!SUBCLASSING) return true;
    // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_REJECTION_EVENT;
});
var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function(iterable) {
    PromiseConstructor.all(iterable)['catch'](function() {
    });
});
// helpers
var isThenable = function(it) {
    var then;
    return isObject(it) && isCallable(then = it.then) ? then : false;
};
var callReaction = function(reaction, state) {
    var value = state.value;
    var ok = state.state == FULFILLED;
    var handler = ok ? reaction.ok : reaction.fail;
    var resolve = reaction.resolve;
    var reject = reaction.reject;
    var domain = reaction.domain;
    var result, then, exited;
    try {
        if (handler) {
            if (!ok) {
                if (state.rejection === UNHANDLED) onHandleUnhandled(state);
                state.rejection = HANDLED;
            }
            if (handler === true) result = value;
            else {
                if (domain) domain.enter();
                result = handler(value); // can throw
                if (domain) {
                    domain.exit();
                    exited = true;
                }
            }
            if (result === reaction.promise) reject(TypeError('Promise-chain cycle'));
            else if (then = isThenable(result)) call(then, result, resolve, reject);
            else resolve(result);
        } else reject(value);
    } catch (error) {
        if (domain && !exited) domain.exit();
        reject(error);
    }
};
var notify = function(state, isReject) {
    if (state.notified) return;
    state.notified = true;
    microtask(function() {
        var reactions = state.reactions;
        var reaction;
        while(reaction = reactions.get())callReaction(reaction, state);
        state.notified = false;
        if (isReject && !state.rejection) onUnhandled(state);
    });
};
var dispatchEvent = function(name, promise, reason) {
    var event, handler;
    if (DISPATCH_EVENT) {
        event = document.createEvent('Event');
        event.promise = promise;
        event.reason = reason;
        event.initEvent(name, false, true);
        global.dispatchEvent(event);
    } else event = {
        promise: promise,
        reason: reason
    };
    if (!NATIVE_REJECTION_EVENT && (handler = global['on' + name])) handler(event);
    else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};
var onUnhandled = function(state) {
    call(task, global, function() {
        var promise = state.facade;
        var value = state.value;
        var IS_UNHANDLED = isUnhandled(state);
        var result;
        if (IS_UNHANDLED) {
            result = perform(function() {
                if (IS_NODE) process.emit('unhandledRejection', value, promise);
                else dispatchEvent(UNHANDLED_REJECTION, promise, value);
            });
            // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
            state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
            if (result.error) throw result.value;
        }
    });
};
var isUnhandled = function(state) {
    return state.rejection !== HANDLED && !state.parent;
};
var onHandleUnhandled = function(state) {
    call(task, global, function() {
        var promise = state.facade;
        if (IS_NODE) process.emit('rejectionHandled', promise);
        else dispatchEvent(REJECTION_HANDLED, promise, state.value);
    });
};
var bind = function(fn, state, unwrap) {
    return function(value) {
        fn(state, value, unwrap);
    };
};
var internalReject = function(state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    state.value = value;
    state.state = REJECTED;
    notify(state, true);
};
var internalResolve = function(state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    try {
        if (state.facade === value) throw TypeError("Promise can't be resolved itself");
        var then = isThenable(value);
        if (then) microtask(function() {
            var wrapper = {
                done: false
            };
            try {
                call(then, value, bind(internalResolve, wrapper, state), bind(internalReject, wrapper, state));
            } catch (error) {
                internalReject(wrapper, error, state);
            }
        });
        else {
            state.value = value;
            state.state = FULFILLED;
            notify(state, false);
        }
    } catch (error) {
        internalReject({
            done: false
        }, error, state);
    }
};
// constructor polyfill
if (FORCED) {
    // 25.4.3.1 Promise(executor)
    PromiseConstructor = function Promise(executor) {
        anInstance(this, PromisePrototype);
        aCallable(executor);
        call(Internal, this);
        var state = getInternalState(this);
        try {
            executor(bind(internalResolve, state), bind(internalReject, state));
        } catch (error) {
            internalReject(state, error);
        }
    };
    PromisePrototype = PromiseConstructor.prototype;
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    Internal = function Promise(executor) {
        setInternalState(this, {
            type: PROMISE,
            done: false,
            notified: false,
            parent: false,
            reactions: new Queue(),
            rejection: false,
            state: PENDING,
            value: undefined
        });
    };
    Internal.prototype = redefineAll(PromisePrototype, {
        // `Promise.prototype.then` method
        // https://tc39.es/ecma262/#sec-promise.prototype.then
        // eslint-disable-next-line unicorn/no-thenable -- safe
        then: function then(onFulfilled, onRejected) {
            var state = getInternalPromiseState(this);
            var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
            state.parent = true;
            reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
            reaction.fail = isCallable(onRejected) && onRejected;
            reaction.domain = IS_NODE ? process.domain : undefined;
            if (state.state == PENDING) state.reactions.add(reaction);
            else microtask(function() {
                callReaction(reaction, state);
            });
            return reaction.promise;
        },
        // `Promise.prototype.catch` method
        // https://tc39.es/ecma262/#sec-promise.prototype.catch
        'catch': function(onRejected) {
            return this.then(undefined, onRejected);
        }
    });
    OwnPromiseCapability = function() {
        var promise = new Internal();
        var state = getInternalState(promise);
        this.promise = promise;
        this.resolve = bind(internalResolve, state);
        this.reject = bind(internalReject, state);
    };
    newPromiseCapabilityModule.f = newPromiseCapability = function(C) {
        return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
    };
    if (!IS_PURE && isCallable(NativePromise) && NativePromisePrototype !== Object.prototype) {
        nativeThen = NativePromisePrototype.then;
        if (!SUBCLASSING) {
            // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs
            redefine(NativePromisePrototype, 'then', function then(onFulfilled, onRejected) {
                var that = this;
                return new PromiseConstructor(function(resolve, reject) {
                    call(nativeThen, that, resolve, reject);
                }).then(onFulfilled, onRejected);
            // https://github.com/zloirock/core-js/issues/640
            }, {
                unsafe: true
            });
            // makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`
            redefine(NativePromisePrototype, 'catch', PromisePrototype['catch'], {
                unsafe: true
            });
        }
        // make `.constructor === Promise` work for native promise-based APIs
        try {
            delete NativePromisePrototype.constructor;
        } catch (error) {
        }
        // make `instanceof Promise` work for native promise-based APIs
        if (setPrototypeOf) setPrototypeOf(NativePromisePrototype, PromisePrototype);
    }
}
$({
    global: true,
    wrap: true,
    forced: FORCED
}, {
    Promise: PromiseConstructor
});
setToStringTag(PromiseConstructor, PROMISE, false, true);
setSpecies(PROMISE);
PromiseWrapper = getBuiltIn(PROMISE);
// statics
$({
    target: PROMISE,
    stat: true,
    forced: FORCED
}, {
    // `Promise.reject` method
    // https://tc39.es/ecma262/#sec-promise.reject
    reject: function reject(r) {
        var capability = newPromiseCapability(this);
        call(capability.reject, undefined, r);
        return capability.promise;
    }
});
$({
    target: PROMISE,
    stat: true,
    forced: IS_PURE || FORCED
}, {
    // `Promise.resolve` method
    // https://tc39.es/ecma262/#sec-promise.resolve
    resolve: function resolve(x) {
        return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
    }
});
$({
    target: PROMISE,
    stat: true,
    forced: INCORRECT_ITERATION
}, {
    // `Promise.all` method
    // https://tc39.es/ecma262/#sec-promise.all
    all: function all(iterable) {
        var C = this;
        var capability = newPromiseCapability(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function() {
            var $promiseResolve = aCallable(C.resolve);
            var values = [];
            var counter = 0;
            var remaining = 1;
            iterate(iterable, function(promise) {
                var index = counter++;
                var alreadyCalled = false;
                remaining++;
                call($promiseResolve, C, promise).then(function(value) {
                    if (alreadyCalled) return;
                    alreadyCalled = true;
                    values[index] = value;
                    --remaining || resolve(values);
                }, reject);
            });
            --remaining || resolve(values);
        });
        if (result.error) reject(result.value);
        return capability.promise;
    },
    // `Promise.race` method
    // https://tc39.es/ecma262/#sec-promise.race
    race: function race(iterable) {
        var C = this;
        var capability = newPromiseCapability(C);
        var reject = capability.reject;
        var result = perform(function() {
            var $promiseResolve = aCallable(C.resolve);
            iterate(iterable, function(promise) {
                call($promiseResolve, C, promise).then(capability.resolve, reject);
            });
        });
        if (result.error) reject(result.value);
        return capability.promise;
    }
});

},{"../internals/export":"8yfGv","../internals/is-pure":"6Bbq0","../internals/global":"jxPDA","../internals/get-built-in":"78arb","../internals/function-call":"jhLed","../internals/native-promise-constructor":"1Z5Jd","../internals/redefine":"kxbj8","../internals/redefine-all":"ch5Rt","../internals/object-set-prototype-of":"lb6rR","../internals/set-to-string-tag":"9arwS","../internals/set-species":"hBKMQ","../internals/a-callable":"83opn","../internals/is-callable":"kPhuP","../internals/is-object":"dplrD","../internals/an-instance":"2zeQg","../internals/inspect-source":"7DOzX","../internals/iterate":"fTyka","../internals/check-correctness-of-iteration":"788V9","../internals/species-constructor":"hqPl9","../internals/task":"5TiiK","../internals/microtask":"hWCOJ","../internals/promise-resolve":"1RiLv","../internals/host-report-errors":"99n7W","../internals/new-promise-capability":"1jyVt","../internals/perform":"1r4qC","../internals/queue":"l57RT","../internals/internal-state":"i6AaM","../internals/is-forced":"eTyNf","../internals/well-known-symbol":"5C8sm","../internals/engine-is-browser":"QRSRy","../internals/engine-is-node":"jwobg","../internals/engine-v8-version":"9gYOM"}],"1Z5Jd":[function(require,module,exports) {
var global = require('../internals/global');
module.exports = global.Promise;

},{"../internals/global":"jxPDA"}],"5TiiK":[function(require,module,exports) {
var global = require('../internals/global');
var apply = require('../internals/function-apply');
var bind = require('../internals/function-bind-context');
var isCallable = require('../internals/is-callable');
var hasOwn = require('../internals/has-own-property');
var fails = require('../internals/fails');
var html = require('../internals/html');
var arraySlice = require('../internals/array-slice');
var createElement = require('../internals/document-create-element');
var IS_IOS = require('../internals/engine-is-ios');
var IS_NODE = require('../internals/engine-is-node');
var set = global.setImmediate;
var clear = global.clearImmediate;
var process = global.process;
var Dispatch = global.Dispatch;
var Function = global.Function;
var MessageChannel = global.MessageChannel;
var String = global.String;
var counter = 0;
var queue = {
};
var ONREADYSTATECHANGE = 'onreadystatechange';
var location, defer, channel, port;
try {
    // Deno throws a ReferenceError on `location` access without `--location` flag
    location = global.location;
} catch (error) {
}
var run = function(id) {
    if (hasOwn(queue, id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
    }
};
var runner = function(id) {
    return function() {
        run(id);
    };
};
var listener = function(event) {
    run(event.data);
};
var post = function(id) {
    // old engines have not location.origin
    global.postMessage(String(id), location.protocol + '//' + location.host);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
    set = function setImmediate(fn) {
        var args = arraySlice(arguments, 1);
        queue[++counter] = function() {
            apply(isCallable(fn) ? fn : Function(fn), undefined, args);
        };
        defer(counter);
        return counter;
    };
    clear = function clearImmediate(id) {
        delete queue[id];
    };
    // Node.js 0.8-
    if (IS_NODE) defer = function(id) {
        process.nextTick(runner(id));
    };
    else if (Dispatch && Dispatch.now) defer = function(id) {
        Dispatch.now(runner(id));
    };
    else if (MessageChannel && !IS_IOS) {
        channel = new MessageChannel();
        port = channel.port2;
        channel.port1.onmessage = listener;
        defer = bind(port.postMessage, port);
    // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
    } else if (global.addEventListener && isCallable(global.postMessage) && !global.importScripts && location && location.protocol !== 'file:' && !fails(post)) {
        defer = post;
        global.addEventListener('message', listener, false);
    // IE8-
    } else if (ONREADYSTATECHANGE in createElement('script')) defer = function(id) {
        html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function() {
            html.removeChild(this);
            run(id);
        };
    };
    else defer = function(id) {
        setTimeout(runner(id), 0);
    };
}
module.exports = {
    set: set,
    clear: clear
};

},{"../internals/global":"jxPDA","../internals/function-apply":"206oi","../internals/function-bind-context":"kZubc","../internals/is-callable":"kPhuP","../internals/has-own-property":"3ZdUC","../internals/fails":"8IfZQ","../internals/html":"fFwbI","../internals/array-slice":"bI1dk","../internals/document-create-element":"jKd7d","../internals/engine-is-ios":"kaA8e","../internals/engine-is-node":"jwobg"}],"kaA8e":[function(require,module,exports) {
var userAgent = require('../internals/engine-user-agent');
module.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);

},{"../internals/engine-user-agent":"boFeV"}],"hWCOJ":[function(require,module,exports) {
var global = require('../internals/global');
var bind = require('../internals/function-bind-context');
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
var macrotask = require('../internals/task').set;
var IS_IOS = require('../internals/engine-is-ios');
var IS_IOS_PEBBLE = require('../internals/engine-is-ios-pebble');
var IS_WEBOS_WEBKIT = require('../internals/engine-is-webos-webkit');
var IS_NODE = require('../internals/engine-is-node');
var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
var document = global.document;
var process = global.process;
var Promise = global.Promise;
// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask');
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
var flush, head, last, notify, toggle, node, promise, then;
// modern engines have queueMicrotask method
if (!queueMicrotask) {
    flush = function() {
        var parent, fn;
        if (IS_NODE && (parent = process.domain)) parent.exit();
        while(head){
            fn = head.fn;
            head = head.next;
            try {
                fn();
            } catch (error) {
                if (head) notify();
                else last = undefined;
                throw error;
            }
        }
        last = undefined;
        if (parent) parent.enter();
    };
    // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
    // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
    if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document) {
        toggle = true;
        node = document.createTextNode('');
        new MutationObserver(flush).observe(node, {
            characterData: true
        });
        notify = function() {
            node.data = toggle = !toggle;
        };
    // environments with maybe non-completely correct, but existent Promise
    } else if (!IS_IOS_PEBBLE && Promise && Promise.resolve) {
        // Promise.resolve without an argument throws an error in LG WebOS 2
        promise = Promise.resolve(undefined);
        // workaround of WebKit ~ iOS Safari 10.1 bug
        promise.constructor = Promise;
        then = bind(promise.then, promise);
        notify = function() {
            then(flush);
        };
    // Node.js without promises
    } else if (IS_NODE) notify = function() {
        process.nextTick(flush);
    };
    else {
        // strange IE + webpack dev server bug - use .bind(global)
        macrotask = bind(macrotask, global);
        notify = function() {
            macrotask(flush);
        };
    }
}
module.exports = queueMicrotask || function(fn) {
    var task = {
        fn: fn,
        next: undefined
    };
    if (last) last.next = task;
    if (!head) {
        head = task;
        notify();
    }
    last = task;
};

},{"../internals/global":"jxPDA","../internals/function-bind-context":"kZubc","../internals/object-get-own-property-descriptor":"1gCBk","../internals/task":"5TiiK","../internals/engine-is-ios":"kaA8e","../internals/engine-is-ios-pebble":"2LHWP","../internals/engine-is-webos-webkit":"l4D6v","../internals/engine-is-node":"jwobg"}],"2LHWP":[function(require,module,exports) {
var userAgent = require('../internals/engine-user-agent');
var global = require('../internals/global');
module.exports = /ipad|iphone|ipod/i.test(userAgent) && global.Pebble !== undefined;

},{"../internals/engine-user-agent":"boFeV","../internals/global":"jxPDA"}],"l4D6v":[function(require,module,exports) {
var userAgent = require('../internals/engine-user-agent');
module.exports = /web0s(?!.*chrome)/i.test(userAgent);

},{"../internals/engine-user-agent":"boFeV"}],"1RiLv":[function(require,module,exports) {
var anObject = require('../internals/an-object');
var isObject = require('../internals/is-object');
var newPromiseCapability = require('../internals/new-promise-capability');
module.exports = function(C, x) {
    anObject(C);
    if (isObject(x) && x.constructor === C) return x;
    var promiseCapability = newPromiseCapability.f(C);
    var resolve = promiseCapability.resolve;
    resolve(x);
    return promiseCapability.promise;
};

},{"../internals/an-object":"1LIz9","../internals/is-object":"dplrD","../internals/new-promise-capability":"1jyVt"}],"1jyVt":[function(require,module,exports) {
'use strict';
var aCallable = require('../internals/a-callable');
var PromiseCapability = function(C) {
    var resolve, reject;
    this.promise = new C(function($$resolve, $$reject) {
        if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
        resolve = $$resolve;
        reject = $$reject;
    });
    this.resolve = aCallable(resolve);
    this.reject = aCallable(reject);
};
// `NewPromiseCapability` abstract operation
// https://tc39.es/ecma262/#sec-newpromisecapability
module.exports.f = function(C) {
    return new PromiseCapability(C);
};

},{"../internals/a-callable":"83opn"}],"99n7W":[function(require,module,exports) {
var global = require('../internals/global');
module.exports = function(a, b) {
    var console = global.console;
    if (console && console.error) arguments.length == 1 ? console.error(a) : console.error(a, b);
};

},{"../internals/global":"jxPDA"}],"1r4qC":[function(require,module,exports) {
module.exports = function(exec) {
    try {
        return {
            error: false,
            value: exec()
        };
    } catch (error) {
        return {
            error: true,
            value: error
        };
    }
};

},{}],"l57RT":[function(require,module,exports) {
var Queue = function() {
    this.head = null;
    this.tail = null;
};
Queue.prototype = {
    add: function(item) {
        var entry = {
            item: item,
            next: null
        };
        if (this.head) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
    },
    get: function() {
        var entry = this.head;
        if (entry) {
            this.head = entry.next;
            if (this.tail === entry) this.tail = null;
            return entry.item;
        }
    }
};
module.exports = Queue;

},{}],"QRSRy":[function(require,module,exports) {
module.exports = typeof window == 'object';

},{}],"drqVJ":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var call = require('../internals/function-call');
var aCallable = require('../internals/a-callable');
var newPromiseCapabilityModule = require('../internals/new-promise-capability');
var perform = require('../internals/perform');
var iterate = require('../internals/iterate');
// `Promise.allSettled` method
// https://tc39.es/ecma262/#sec-promise.allsettled
$({
    target: 'Promise',
    stat: true
}, {
    allSettled: function allSettled(iterable) {
        var C = this;
        var capability = newPromiseCapabilityModule.f(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function() {
            var promiseResolve = aCallable(C.resolve);
            var values = [];
            var counter = 0;
            var remaining = 1;
            iterate(iterable, function(promise) {
                var index = counter++;
                var alreadyCalled = false;
                remaining++;
                call(promiseResolve, C, promise).then(function(value) {
                    if (alreadyCalled) return;
                    alreadyCalled = true;
                    values[index] = {
                        status: 'fulfilled',
                        value: value
                    };
                    --remaining || resolve(values);
                }, function(error) {
                    if (alreadyCalled) return;
                    alreadyCalled = true;
                    values[index] = {
                        status: 'rejected',
                        reason: error
                    };
                    --remaining || resolve(values);
                });
            });
            --remaining || resolve(values);
        });
        if (result.error) reject(result.value);
        return capability.promise;
    }
});

},{"../internals/export":"8yfGv","../internals/function-call":"jhLed","../internals/a-callable":"83opn","../internals/new-promise-capability":"1jyVt","../internals/perform":"1r4qC","../internals/iterate":"fTyka"}],"6J3yz":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var aCallable = require('../internals/a-callable');
var getBuiltIn = require('../internals/get-built-in');
var call = require('../internals/function-call');
var newPromiseCapabilityModule = require('../internals/new-promise-capability');
var perform = require('../internals/perform');
var iterate = require('../internals/iterate');
var PROMISE_ANY_ERROR = 'No one promise resolved';
// `Promise.any` method
// https://tc39.es/ecma262/#sec-promise.any
$({
    target: 'Promise',
    stat: true
}, {
    any: function any(iterable) {
        var C = this;
        var AggregateError = getBuiltIn('AggregateError');
        var capability = newPromiseCapabilityModule.f(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function() {
            var promiseResolve = aCallable(C.resolve);
            var errors = [];
            var counter = 0;
            var remaining = 1;
            var alreadyResolved = false;
            iterate(iterable, function(promise) {
                var index = counter++;
                var alreadyRejected = false;
                remaining++;
                call(promiseResolve, C, promise).then(function(value) {
                    if (alreadyRejected || alreadyResolved) return;
                    alreadyResolved = true;
                    resolve(value);
                }, function(error) {
                    if (alreadyRejected || alreadyResolved) return;
                    alreadyRejected = true;
                    errors[index] = error;
                    --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
                });
            });
            --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
        });
        if (result.error) reject(result.value);
        return capability.promise;
    }
});

},{"../internals/export":"8yfGv","../internals/a-callable":"83opn","../internals/get-built-in":"78arb","../internals/function-call":"jhLed","../internals/new-promise-capability":"1jyVt","../internals/perform":"1r4qC","../internals/iterate":"fTyka"}],"knKVr":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var NativePromise = require('../internals/native-promise-constructor');
var fails = require('../internals/fails');
var getBuiltIn = require('../internals/get-built-in');
var isCallable = require('../internals/is-callable');
var speciesConstructor = require('../internals/species-constructor');
var promiseResolve = require('../internals/promise-resolve');
var redefine = require('../internals/redefine');
// Safari bug https://bugs.webkit.org/show_bug.cgi?id=200829
var NON_GENERIC = !!NativePromise && fails(function() {
    // eslint-disable-next-line unicorn/no-thenable -- required for testing
    NativePromise.prototype['finally'].call({
        then: function() {
        }
    }, function() {
    });
});
// `Promise.prototype.finally` method
// https://tc39.es/ecma262/#sec-promise.prototype.finally
$({
    target: 'Promise',
    proto: true,
    real: true,
    forced: NON_GENERIC
}, {
    'finally': function(onFinally) {
        var C = speciesConstructor(this, getBuiltIn('Promise'));
        var isFunction = isCallable(onFinally);
        return this.then(isFunction ? function(x) {
            return promiseResolve(C, onFinally()).then(function() {
                return x;
            });
        } : onFinally, isFunction ? function(e) {
            return promiseResolve(C, onFinally()).then(function() {
                throw e;
            });
        } : onFinally);
    }
});
// makes sure that native promise-based APIs `Promise#finally` properly works with patched `Promise#then`
if (!IS_PURE && isCallable(NativePromise)) {
    var method = getBuiltIn('Promise').prototype['finally'];
    if (NativePromise.prototype['finally'] !== method) redefine(NativePromise.prototype, 'finally', method, {
        unsafe: true
    });
}

},{"../internals/export":"8yfGv","../internals/is-pure":"6Bbq0","../internals/native-promise-constructor":"1Z5Jd","../internals/fails":"8IfZQ","../internals/get-built-in":"78arb","../internals/is-callable":"kPhuP","../internals/species-constructor":"hqPl9","../internals/promise-resolve":"1RiLv","../internals/redefine":"kxbj8"}],"jKk5w":[function(require,module,exports) {
var $ = require('../internals/export');
var functionApply = require('../internals/function-apply');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
var fails = require('../internals/fails');
// MS Edge argumentsList argument is optional
var OPTIONAL_ARGUMENTS_LIST = !fails(function() {
    // eslint-disable-next-line es/no-reflect -- required for testing
    Reflect.apply(function() {
    });
});
// `Reflect.apply` method
// https://tc39.es/ecma262/#sec-reflect.apply
$({
    target: 'Reflect',
    stat: true,
    forced: OPTIONAL_ARGUMENTS_LIST
}, {
    apply: function apply(target, thisArgument, argumentsList) {
        return functionApply(aCallable(target), thisArgument, anObject(argumentsList));
    }
});

},{"../internals/export":"8yfGv","../internals/function-apply":"206oi","../internals/a-callable":"83opn","../internals/an-object":"1LIz9","../internals/fails":"8IfZQ"}],"c6DZw":[function(require,module,exports) {
var $ = require('../internals/export');
var getBuiltIn = require('../internals/get-built-in');
var apply = require('../internals/function-apply');
var bind = require('../internals/function-bind');
var aConstructor = require('../internals/a-constructor');
var anObject = require('../internals/an-object');
var isObject = require('../internals/is-object');
var create = require('../internals/object-create');
var fails = require('../internals/fails');
var nativeConstruct = getBuiltIn('Reflect', 'construct');
var ObjectPrototype = Object.prototype;
var push = [].push;
// `Reflect.construct` method
// https://tc39.es/ecma262/#sec-reflect.construct
// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function() {
    function F() {
    }
    return !(nativeConstruct(function() {
    }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function() {
    nativeConstruct(function() {
    });
});
var FORCED = NEW_TARGET_BUG || ARGS_BUG;
$({
    target: 'Reflect',
    stat: true,
    forced: FORCED,
    sham: FORCED
}, {
    construct: function construct(Target, args /* , newTarget */ ) {
        aConstructor(Target);
        anObject(args);
        var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);
        if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
        if (Target == newTarget) {
            // w/o altered newTarget, optimization for 0-4 arguments
            switch(args.length){
                case 0:
                    return new Target();
                case 1:
                    return new Target(args[0]);
                case 2:
                    return new Target(args[0], args[1]);
                case 3:
                    return new Target(args[0], args[1], args[2]);
                case 4:
                    return new Target(args[0], args[1], args[2], args[3]);
            }
            // w/o altered newTarget, lot of arguments case
            var $args = [
                null
            ];
            apply(push, $args, args);
            return new (apply(bind, Target, $args))();
        }
        // with altered newTarget, not support built-in constructors
        var proto = newTarget.prototype;
        var instance = create(isObject(proto) ? proto : ObjectPrototype);
        var result = apply(Target, instance, args);
        return isObject(result) ? result : instance;
    }
});

},{"../internals/export":"8yfGv","../internals/get-built-in":"78arb","../internals/function-apply":"206oi","../internals/function-bind":"heTXz","../internals/a-constructor":"1DOBp","../internals/an-object":"1LIz9","../internals/is-object":"dplrD","../internals/object-create":"1As5O","../internals/fails":"8IfZQ"}],"bYULV":[function(require,module,exports) {
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var anObject = require('../internals/an-object');
var toPropertyKey = require('../internals/to-property-key');
var definePropertyModule = require('../internals/object-define-property');
var fails = require('../internals/fails');
// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
var ERROR_INSTEAD_OF_FALSE = fails(function() {
    // eslint-disable-next-line es/no-reflect -- required for testing
    Reflect.defineProperty(definePropertyModule.f({
    }, 1, {
        value: 1
    }), 1, {
        value: 2
    });
});
// `Reflect.defineProperty` method
// https://tc39.es/ecma262/#sec-reflect.defineproperty
$({
    target: 'Reflect',
    stat: true,
    forced: ERROR_INSTEAD_OF_FALSE,
    sham: !DESCRIPTORS
}, {
    defineProperty: function defineProperty(target, propertyKey, attributes) {
        anObject(target);
        var key = toPropertyKey(propertyKey);
        anObject(attributes);
        try {
            definePropertyModule.f(target, key, attributes);
            return true;
        } catch (error) {
            return false;
        }
    }
});

},{"../internals/export":"8yfGv","../internals/descriptors":"6ZLib","../internals/an-object":"1LIz9","../internals/to-property-key":"bMDpS","../internals/object-define-property":"bauTd","../internals/fails":"8IfZQ"}],"iz4MV":[function(require,module,exports) {
var $ = require('../internals/export');
var anObject = require('../internals/an-object');
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
// `Reflect.deleteProperty` method
// https://tc39.es/ecma262/#sec-reflect.deleteproperty
$({
    target: 'Reflect',
    stat: true
}, {
    deleteProperty: function deleteProperty(target, propertyKey) {
        var descriptor = getOwnPropertyDescriptor(anObject(target), propertyKey);
        return descriptor && !descriptor.configurable ? false : delete target[propertyKey];
    }
});

},{"../internals/export":"8yfGv","../internals/an-object":"1LIz9","../internals/object-get-own-property-descriptor":"1gCBk"}],"k2Fmj":[function(require,module,exports) {
var $ = require('../internals/export');
var call = require('../internals/function-call');
var isObject = require('../internals/is-object');
var anObject = require('../internals/an-object');
var isDataDescriptor = require('../internals/is-data-descriptor');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
var getPrototypeOf = require('../internals/object-get-prototype-of');
// `Reflect.get` method
// https://tc39.es/ecma262/#sec-reflect.get
function get(target, propertyKey /* , receiver */ ) {
    var receiver = arguments.length < 3 ? target : arguments[2];
    var descriptor, prototype;
    if (anObject(target) === receiver) return target[propertyKey];
    descriptor = getOwnPropertyDescriptorModule.f(target, propertyKey);
    if (descriptor) return isDataDescriptor(descriptor) ? descriptor.value : descriptor.get === undefined ? undefined : call(descriptor.get, receiver);
    if (isObject(prototype = getPrototypeOf(target))) return get(prototype, propertyKey, receiver);
}
$({
    target: 'Reflect',
    stat: true
}, {
    get: get
});

},{"../internals/export":"8yfGv","../internals/function-call":"jhLed","../internals/is-object":"dplrD","../internals/an-object":"1LIz9","../internals/is-data-descriptor":"fHYTD","../internals/object-get-own-property-descriptor":"1gCBk","../internals/object-get-prototype-of":"lBy7h"}],"fHYTD":[function(require,module,exports) {
var hasOwn = require('../internals/has-own-property');
module.exports = function(descriptor) {
    return descriptor !== undefined && (hasOwn(descriptor, 'value') || hasOwn(descriptor, 'writable'));
};

},{"../internals/has-own-property":"3ZdUC"}],"aepGb":[function(require,module,exports) {
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var anObject = require('../internals/an-object');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
// `Reflect.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-reflect.getownpropertydescriptor
$({
    target: 'Reflect',
    stat: true,
    sham: !DESCRIPTORS
}, {
    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
        return getOwnPropertyDescriptorModule.f(anObject(target), propertyKey);
    }
});

},{"../internals/export":"8yfGv","../internals/descriptors":"6ZLib","../internals/an-object":"1LIz9","../internals/object-get-own-property-descriptor":"1gCBk"}],"azie1":[function(require,module,exports) {
var $ = require('../internals/export');
var anObject = require('../internals/an-object');
var objectGetPrototypeOf = require('../internals/object-get-prototype-of');
var CORRECT_PROTOTYPE_GETTER = require('../internals/correct-prototype-getter');
// `Reflect.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-reflect.getprototypeof
$({
    target: 'Reflect',
    stat: true,
    sham: !CORRECT_PROTOTYPE_GETTER
}, {
    getPrototypeOf: function getPrototypeOf(target) {
        return objectGetPrototypeOf(anObject(target));
    }
});

},{"../internals/export":"8yfGv","../internals/an-object":"1LIz9","../internals/object-get-prototype-of":"lBy7h","../internals/correct-prototype-getter":"5LqOC"}],"hIAaJ":[function(require,module,exports) {
var $ = require('../internals/export');
// `Reflect.has` method
// https://tc39.es/ecma262/#sec-reflect.has
$({
    target: 'Reflect',
    stat: true
}, {
    has: function has(target, propertyKey) {
        return propertyKey in target;
    }
});

},{"../internals/export":"8yfGv"}],"75Mar":[function(require,module,exports) {
var $ = require('../internals/export');
var anObject = require('../internals/an-object');
var $isExtensible = require('../internals/object-is-extensible');
// `Reflect.isExtensible` method
// https://tc39.es/ecma262/#sec-reflect.isextensible
$({
    target: 'Reflect',
    stat: true
}, {
    isExtensible: function isExtensible(target) {
        anObject(target);
        return $isExtensible(target);
    }
});

},{"../internals/export":"8yfGv","../internals/an-object":"1LIz9","../internals/object-is-extensible":"eApj6"}],"ayzfz":[function(require,module,exports) {
var $ = require('../internals/export');
var ownKeys = require('../internals/own-keys');
// `Reflect.ownKeys` method
// https://tc39.es/ecma262/#sec-reflect.ownkeys
$({
    target: 'Reflect',
    stat: true
}, {
    ownKeys: ownKeys
});

},{"../internals/export":"8yfGv","../internals/own-keys":"e0KjM"}],"lp3Ou":[function(require,module,exports) {
var $ = require('../internals/export');
var getBuiltIn = require('../internals/get-built-in');
var anObject = require('../internals/an-object');
var FREEZING = require('../internals/freezing');
// `Reflect.preventExtensions` method
// https://tc39.es/ecma262/#sec-reflect.preventextensions
$({
    target: 'Reflect',
    stat: true,
    sham: !FREEZING
}, {
    preventExtensions: function preventExtensions(target) {
        anObject(target);
        try {
            var objectPreventExtensions = getBuiltIn('Object', 'preventExtensions');
            if (objectPreventExtensions) objectPreventExtensions(target);
            return true;
        } catch (error) {
            return false;
        }
    }
});

},{"../internals/export":"8yfGv","../internals/get-built-in":"78arb","../internals/an-object":"1LIz9","../internals/freezing":"5dl3e"}],"4NxGA":[function(require,module,exports) {
var $ = require('../internals/export');
var call = require('../internals/function-call');
var anObject = require('../internals/an-object');
var isObject = require('../internals/is-object');
var isDataDescriptor = require('../internals/is-data-descriptor');
var fails = require('../internals/fails');
var definePropertyModule = require('../internals/object-define-property');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
// `Reflect.set` method
// https://tc39.es/ecma262/#sec-reflect.set
function set(target, propertyKey, V /* , receiver */ ) {
    var receiver = arguments.length < 4 ? target : arguments[3];
    var ownDescriptor = getOwnPropertyDescriptorModule.f(anObject(target), propertyKey);
    var existingDescriptor, prototype, setter;
    if (!ownDescriptor) {
        if (isObject(prototype = getPrototypeOf(target))) return set(prototype, propertyKey, V, receiver);
        ownDescriptor = createPropertyDescriptor(0);
    }
    if (isDataDescriptor(ownDescriptor)) {
        if (ownDescriptor.writable === false || !isObject(receiver)) return false;
        if (existingDescriptor = getOwnPropertyDescriptorModule.f(receiver, propertyKey)) {
            if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
            existingDescriptor.value = V;
            definePropertyModule.f(receiver, propertyKey, existingDescriptor);
        } else definePropertyModule.f(receiver, propertyKey, createPropertyDescriptor(0, V));
    } else {
        setter = ownDescriptor.set;
        if (setter === undefined) return false;
        call(setter, receiver, V);
    }
    return true;
}
// MS Edge 17-18 Reflect.set allows setting the property to object
// with non-writable property on the prototype
var MS_EDGE_BUG = fails(function() {
    var Constructor = function() {
    };
    var object = definePropertyModule.f(new Constructor(), 'a', {
        configurable: true
    });
    // eslint-disable-next-line es/no-reflect -- required for testing
    return Reflect.set(Constructor.prototype, 'a', 1, object) !== false;
});
$({
    target: 'Reflect',
    stat: true,
    forced: MS_EDGE_BUG
}, {
    set: set
});

},{"../internals/export":"8yfGv","../internals/function-call":"jhLed","../internals/an-object":"1LIz9","../internals/is-object":"dplrD","../internals/is-data-descriptor":"fHYTD","../internals/fails":"8IfZQ","../internals/object-define-property":"bauTd","../internals/object-get-own-property-descriptor":"1gCBk","../internals/object-get-prototype-of":"lBy7h","../internals/create-property-descriptor":"ermgb"}],"xbAth":[function(require,module,exports) {
var $ = require('../internals/export');
var anObject = require('../internals/an-object');
var aPossiblePrototype = require('../internals/a-possible-prototype');
var objectSetPrototypeOf = require('../internals/object-set-prototype-of');
// `Reflect.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-reflect.setprototypeof
if (objectSetPrototypeOf) $({
    target: 'Reflect',
    stat: true
}, {
    setPrototypeOf: function setPrototypeOf(target, proto) {
        anObject(target);
        aPossiblePrototype(proto);
        try {
            objectSetPrototypeOf(target, proto);
            return true;
        } catch (error) {
            return false;
        }
    }
});

},{"../internals/export":"8yfGv","../internals/an-object":"1LIz9","../internals/a-possible-prototype":"fVs6e","../internals/object-set-prototype-of":"lb6rR"}],"52bAT":[function(require,module,exports) {
var $ = require('../internals/export');
var global = require('../internals/global');
var setToStringTag = require('../internals/set-to-string-tag');
$({
    global: true
}, {
    Reflect: {
    }
});
// Reflect[@@toStringTag] property
// https://tc39.es/ecma262/#sec-reflect-@@tostringtag
setToStringTag(global.Reflect, 'Reflect', true);

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/set-to-string-tag":"9arwS"}],"hhsNe":[function(require,module,exports) {
var DESCRIPTORS = require('../internals/descriptors');
var global = require('../internals/global');
var uncurryThis = require('../internals/function-uncurry-this');
var isForced = require('../internals/is-forced');
var inheritIfRequired = require('../internals/inherit-if-required');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var defineProperty = require('../internals/object-define-property').f;
var getOwnPropertyNames = require('../internals/object-get-own-property-names').f;
var isPrototypeOf = require('../internals/object-is-prototype-of');
var isRegExp = require('../internals/is-regexp');
var toString = require('../internals/to-string');
var regExpFlags = require('../internals/regexp-flags');
var stickyHelpers = require('../internals/regexp-sticky-helpers');
var redefine = require('../internals/redefine');
var fails = require('../internals/fails');
var hasOwn = require('../internals/has-own-property');
var enforceInternalState = require('../internals/internal-state').enforce;
var setSpecies = require('../internals/set-species');
var wellKnownSymbol = require('../internals/well-known-symbol');
var UNSUPPORTED_DOT_ALL = require('../internals/regexp-unsupported-dot-all');
var UNSUPPORTED_NCG = require('../internals/regexp-unsupported-ncg');
var MATCH = wellKnownSymbol('match');
var NativeRegExp = global.RegExp;
var RegExpPrototype = NativeRegExp.prototype;
var SyntaxError = global.SyntaxError;
var getFlags = uncurryThis(regExpFlags);
var exec = uncurryThis(RegExpPrototype.exec);
var charAt = uncurryThis(''.charAt);
var replace = uncurryThis(''.replace);
var stringIndexOf = uncurryThis(''.indexOf);
var stringSlice = uncurryThis(''.slice);
// TODO: Use only propper RegExpIdentifierName
var IS_NCG = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/;
var re1 = /a/g;
var re2 = /a/g;
// "new" should create a new object, old webkit bug
var CORRECT_NEW = new NativeRegExp(re1) !== re1;
var MISSED_STICKY = stickyHelpers.MISSED_STICKY;
var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
var BASE_FORCED = DESCRIPTORS && (!CORRECT_NEW || MISSED_STICKY || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG || fails(function() {
    re2[MATCH] = false;
    // RegExp constructor can alter flags and IsRegExp works correct with @@match
    return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
}));
var handleDotAll = function(string) {
    var length = string.length;
    var index1 = 0;
    var result = '';
    var brackets = false;
    var chr;
    for(; index1 <= length; index1++){
        chr = charAt(string, index1);
        if (chr === '\\') {
            result += chr + charAt(string, ++index1);
            continue;
        }
        if (!brackets && chr === '.') result += '[\\s\\S]';
        else {
            if (chr === '[') brackets = true;
            else if (chr === ']') brackets = false;
            result += chr;
        }
    }
    return result;
};
var handleNCG = function(string) {
    var length = string.length;
    var index2 = 0;
    var result = '';
    var named = [];
    var names = {
    };
    var brackets = false;
    var ncg = false;
    var groupid = 0;
    var groupname = '';
    var chr;
    for(; index2 <= length; index2++){
        chr = charAt(string, index2);
        if (chr === '\\') chr = chr + charAt(string, ++index2);
        else if (chr === ']') brackets = false;
        else if (!brackets) switch(true){
            case chr === '[':
                brackets = true;
                break;
            case chr === '(':
                if (exec(IS_NCG, stringSlice(string, index2 + 1))) {
                    index2 += 2;
                    ncg = true;
                }
                result += chr;
                groupid++;
                continue;
            case chr === '>' && ncg:
                if (groupname === '' || hasOwn(names, groupname)) throw new SyntaxError('Invalid capture group name');
                names[groupname] = true;
                named[named.length] = [
                    groupname,
                    groupid
                ];
                ncg = false;
                groupname = '';
                continue;
        }
        if (ncg) groupname += chr;
        else result += chr;
    }
    return [
        result,
        named
    ];
};
// `RegExp` constructor
// https://tc39.es/ecma262/#sec-regexp-constructor
if (isForced('RegExp', BASE_FORCED)) {
    var RegExpWrapper = function RegExp(pattern, flags) {
        var thisIsRegExp = isPrototypeOf(RegExpPrototype, this);
        var patternIsRegExp = isRegExp(pattern);
        var flagsAreUndefined = flags === undefined;
        var groups = [];
        var rawPattern = pattern;
        var rawFlags, dotAll, sticky, handled, result, state;
        if (!thisIsRegExp && patternIsRegExp && flagsAreUndefined && pattern.constructor === RegExpWrapper) return pattern;
        if (patternIsRegExp || isPrototypeOf(RegExpPrototype, pattern)) {
            pattern = pattern.source;
            if (flagsAreUndefined) flags = 'flags' in rawPattern ? rawPattern.flags : getFlags(rawPattern);
        }
        pattern = pattern === undefined ? '' : toString(pattern);
        flags = flags === undefined ? '' : toString(flags);
        rawPattern = pattern;
        if (UNSUPPORTED_DOT_ALL && 'dotAll' in re1) {
            dotAll = !!flags && stringIndexOf(flags, 's') > -1;
            if (dotAll) flags = replace(flags, /s/g, '');
        }
        rawFlags = flags;
        if (MISSED_STICKY && 'sticky' in re1) {
            sticky = !!flags && stringIndexOf(flags, 'y') > -1;
            if (sticky && UNSUPPORTED_Y) flags = replace(flags, /y/g, '');
        }
        if (UNSUPPORTED_NCG) {
            handled = handleNCG(pattern);
            pattern = handled[0];
            groups = handled[1];
        }
        result = inheritIfRequired(NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);
        if (dotAll || sticky || groups.length) {
            state = enforceInternalState(result);
            if (dotAll) {
                state.dotAll = true;
                state.raw = RegExpWrapper(handleDotAll(pattern), rawFlags);
            }
            if (sticky) state.sticky = true;
            if (groups.length) state.groups = groups;
        }
        if (pattern !== rawPattern) try {
            // fails in old engines, but we have no alternatives for unsupported regex syntax
            createNonEnumerableProperty(result, 'source', rawPattern === '' ? '(?:)' : rawPattern);
        } catch (error) {
        }
        return result;
    };
    var proxy = function(key) {
        key in RegExpWrapper || defineProperty(RegExpWrapper, key, {
            configurable: true,
            get: function() {
                return NativeRegExp[key];
            },
            set: function(it) {
                NativeRegExp[key] = it;
            }
        });
    };
    for(var keys = getOwnPropertyNames(NativeRegExp), index = 0; keys.length > index;)proxy(keys[index++]);
    RegExpPrototype.constructor = RegExpWrapper;
    RegExpWrapper.prototype = RegExpPrototype;
    redefine(global, 'RegExp', RegExpWrapper);
}
// https://tc39.es/ecma262/#sec-get-regexp-@@species
setSpecies('RegExp');

},{"../internals/descriptors":"6ZLib","../internals/global":"jxPDA","../internals/function-uncurry-this":"jJnXC","../internals/is-forced":"eTyNf","../internals/inherit-if-required":"kXY2O","../internals/create-non-enumerable-property":"6Z1es","../internals/object-define-property":"bauTd","../internals/object-get-own-property-names":"evqXT","../internals/object-is-prototype-of":"fyf1A","../internals/is-regexp":"lV2Ye","../internals/to-string":"4cTlm","../internals/regexp-flags":"4QDzk","../internals/regexp-sticky-helpers":"801yY","../internals/redefine":"kxbj8","../internals/fails":"8IfZQ","../internals/has-own-property":"3ZdUC","../internals/internal-state":"i6AaM","../internals/set-species":"hBKMQ","../internals/well-known-symbol":"5C8sm","../internals/regexp-unsupported-dot-all":"kpGJO","../internals/regexp-unsupported-ncg":"1ugKh"}],"lV2Ye":[function(require,module,exports) {
var isObject = require('../internals/is-object');
var classof = require('../internals/classof-raw');
var wellKnownSymbol = require('../internals/well-known-symbol');
var MATCH = wellKnownSymbol('match');
// `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp
module.exports = function(it) {
    var isRegExp;
    return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
};

},{"../internals/is-object":"dplrD","../internals/classof-raw":"A9m3U","../internals/well-known-symbol":"5C8sm"}],"4QDzk":[function(require,module,exports) {
'use strict';
var anObject = require('../internals/an-object');
// `RegExp.prototype.flags` getter implementation
// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
module.exports = function() {
    var that = anObject(this);
    var result = '';
    if (that.global) result += 'g';
    if (that.ignoreCase) result += 'i';
    if (that.multiline) result += 'm';
    if (that.dotAll) result += 's';
    if (that.unicode) result += 'u';
    if (that.sticky) result += 'y';
    return result;
};

},{"../internals/an-object":"1LIz9"}],"801yY":[function(require,module,exports) {
var fails = require('../internals/fails');
var global = require('../internals/global');
// babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
var $RegExp = global.RegExp;
var UNSUPPORTED_Y = fails(function() {
    var re = $RegExp('a', 'y');
    re.lastIndex = 2;
    return re.exec('abcd') != null;
});
// UC Browser bug
// https://github.com/zloirock/core-js/issues/1008
var MISSED_STICKY = UNSUPPORTED_Y || fails(function() {
    return !$RegExp('a', 'y').sticky;
});
var BROKEN_CARET = UNSUPPORTED_Y || fails(function() {
    // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
    var re = $RegExp('^r', 'gy');
    re.lastIndex = 2;
    return re.exec('str') != null;
});
module.exports = {
    BROKEN_CARET: BROKEN_CARET,
    MISSED_STICKY: MISSED_STICKY,
    UNSUPPORTED_Y: UNSUPPORTED_Y
};

},{"../internals/fails":"8IfZQ","../internals/global":"jxPDA"}],"kpGJO":[function(require,module,exports) {
var fails = require('../internals/fails');
var global = require('../internals/global');
// babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError
var $RegExp = global.RegExp;
module.exports = fails(function() {
    var re = $RegExp('.', 's');
    return !(re.dotAll && re.exec('\n') && re.flags === 's');
});

},{"../internals/fails":"8IfZQ","../internals/global":"jxPDA"}],"1ugKh":[function(require,module,exports) {
var fails = require('../internals/fails');
var global = require('../internals/global');
// babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError
var $RegExp = global.RegExp;
module.exports = fails(function() {
    var re = $RegExp('(?<a>b)', 'g');
    return re.exec('b').groups.a !== 'b' || 'b'.replace(re, '$<a>c') !== 'bc';
});

},{"../internals/fails":"8IfZQ","../internals/global":"jxPDA"}],"3shaH":[function(require,module,exports) {
var global = require('../internals/global');
var DESCRIPTORS = require('../internals/descriptors');
var UNSUPPORTED_DOT_ALL = require('../internals/regexp-unsupported-dot-all');
var classof = require('../internals/classof-raw');
var defineProperty = require('../internals/object-define-property').f;
var getInternalState = require('../internals/internal-state').get;
var RegExpPrototype = RegExp.prototype;
var TypeError = global.TypeError;
// `RegExp.prototype.dotAll` getter
// https://tc39.es/ecma262/#sec-get-regexp.prototype.dotall
if (DESCRIPTORS && UNSUPPORTED_DOT_ALL) defineProperty(RegExpPrototype, 'dotAll', {
    configurable: true,
    get: function() {
        if (this === RegExpPrototype) return undefined;
        // We can't use InternalStateModule.getterFor because
        // we don't add metadata for regexps created by a literal.
        if (classof(this) === 'RegExp') return !!getInternalState(this).dotAll;
        throw TypeError('Incompatible receiver, RegExp required');
    }
});

},{"../internals/global":"jxPDA","../internals/descriptors":"6ZLib","../internals/regexp-unsupported-dot-all":"kpGJO","../internals/classof-raw":"A9m3U","../internals/object-define-property":"bauTd","../internals/internal-state":"i6AaM"}],"1vrnL":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var exec = require('../internals/regexp-exec');
// `RegExp.prototype.exec` method
// https://tc39.es/ecma262/#sec-regexp.prototype.exec
$({
    target: 'RegExp',
    proto: true,
    forced: /./.exec !== exec
}, {
    exec: exec
});

},{"../internals/export":"8yfGv","../internals/regexp-exec":"aEWJp"}],"aEWJp":[function(require,module,exports) {
'use strict';
/* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */ /* eslint-disable regexp/no-useless-quantifier -- testing */ var call = require('../internals/function-call');
var uncurryThis = require('../internals/function-uncurry-this');
var toString = require('../internals/to-string');
var regexpFlags = require('../internals/regexp-flags');
var stickyHelpers = require('../internals/regexp-sticky-helpers');
var shared = require('../internals/shared');
var create = require('../internals/object-create');
var getInternalState = require('../internals/internal-state').get;
var UNSUPPORTED_DOT_ALL = require('../internals/regexp-unsupported-dot-all');
var UNSUPPORTED_NCG = require('../internals/regexp-unsupported-ncg');
var nativeReplace = shared('native-string-replace', String.prototype.replace);
var nativeExec = RegExp.prototype.exec;
var patchedExec = nativeExec;
var charAt = uncurryThis(''.charAt);
var indexOf = uncurryThis(''.indexOf);
var replace = uncurryThis(''.replace);
var stringSlice = uncurryThis(''.slice);
var UPDATES_LAST_INDEX_WRONG = function() {
    var re1 = /a/;
    var re2 = /b*/g;
    call(nativeExec, re1, 'a');
    call(nativeExec, re2, 'a');
    return re1.lastIndex !== 0 || re2.lastIndex !== 0;
}();
var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;
// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
if (PATCH) patchedExec = function exec(string) {
    var re = this;
    var state = getInternalState(re);
    var str = toString(string);
    var raw = state.raw;
    var result, reCopy, lastIndex, match, i, object, group;
    if (raw) {
        raw.lastIndex = re.lastIndex;
        result = call(patchedExec, raw, str);
        re.lastIndex = raw.lastIndex;
        return result;
    }
    var groups = state.groups;
    var sticky = UNSUPPORTED_Y && re.sticky;
    var flags = call(regexpFlags, re);
    var source = re.source;
    var charsAdded = 0;
    var strCopy = str;
    if (sticky) {
        flags = replace(flags, 'y', '');
        if (indexOf(flags, 'g') === -1) flags += 'g';
        strCopy = stringSlice(str, re.lastIndex);
        // Support anchored sticky behavior.
        if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt(str, re.lastIndex - 1) !== '\n')) {
            source = '(?: ' + source + ')';
            strCopy = ' ' + strCopy;
            charsAdded++;
        }
        // ^(? + rx + ) is needed, in combination with some str slicing, to
        // simulate the 'y' flag.
        reCopy = new RegExp('^(?:' + source + ')', flags);
    }
    if (NPCG_INCLUDED) reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
    match = call(nativeExec, sticky ? reCopy : re, strCopy);
    if (sticky) {
        if (match) {
            match.input = stringSlice(match.input, charsAdded);
            match[0] = stringSlice(match[0], charsAdded);
            match.index = re.lastIndex;
            re.lastIndex += match[0].length;
        } else re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match) re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    if (NPCG_INCLUDED && match && match.length > 1) // Fix browsers whose `exec` methods don't consistently return `undefined`
    // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
    call(nativeReplace, match[0], reCopy, function() {
        for(i = 1; i < arguments.length - 2; i++)if (arguments[i] === undefined) match[i] = undefined;
    });
    if (match && groups) {
        match.groups = object = create(null);
        for(i = 0; i < groups.length; i++){
            group = groups[i];
            object[group[0]] = match[group[1]];
        }
    }
    return match;
};
module.exports = patchedExec;

},{"../internals/function-call":"jhLed","../internals/function-uncurry-this":"jJnXC","../internals/to-string":"4cTlm","../internals/regexp-flags":"4QDzk","../internals/regexp-sticky-helpers":"801yY","../internals/shared":"7VLeP","../internals/object-create":"1As5O","../internals/internal-state":"i6AaM","../internals/regexp-unsupported-dot-all":"kpGJO","../internals/regexp-unsupported-ncg":"1ugKh"}],"6Ugwt":[function(require,module,exports) {
var DESCRIPTORS = require('../internals/descriptors');
var objectDefinePropertyModule = require('../internals/object-define-property');
var regExpFlags = require('../internals/regexp-flags');
var fails = require('../internals/fails');
var RegExpPrototype = RegExp.prototype;
var FORCED = DESCRIPTORS && fails(function() {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    return Object.getOwnPropertyDescriptor(RegExpPrototype, 'flags').get.call({
        dotAll: true,
        sticky: true
    }) !== 'sy';
});
// `RegExp.prototype.flags` getter
// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
if (FORCED) objectDefinePropertyModule.f(RegExpPrototype, 'flags', {
    configurable: true,
    get: regExpFlags
});

},{"../internals/descriptors":"6ZLib","../internals/object-define-property":"bauTd","../internals/regexp-flags":"4QDzk","../internals/fails":"8IfZQ"}],"fBzp5":[function(require,module,exports) {
var global = require('../internals/global');
var DESCRIPTORS = require('../internals/descriptors');
var MISSED_STICKY = require('../internals/regexp-sticky-helpers').MISSED_STICKY;
var classof = require('../internals/classof-raw');
var defineProperty = require('../internals/object-define-property').f;
var getInternalState = require('../internals/internal-state').get;
var RegExpPrototype = RegExp.prototype;
var TypeError = global.TypeError;
// `RegExp.prototype.sticky` getter
// https://tc39.es/ecma262/#sec-get-regexp.prototype.sticky
if (DESCRIPTORS && MISSED_STICKY) defineProperty(RegExpPrototype, 'sticky', {
    configurable: true,
    get: function() {
        if (this === RegExpPrototype) return undefined;
        // We can't use InternalStateModule.getterFor because
        // we don't add metadata for regexps created by a literal.
        if (classof(this) === 'RegExp') return !!getInternalState(this).sticky;
        throw TypeError('Incompatible receiver, RegExp required');
    }
});

},{"../internals/global":"jxPDA","../internals/descriptors":"6ZLib","../internals/regexp-sticky-helpers":"801yY","../internals/classof-raw":"A9m3U","../internals/object-define-property":"bauTd","../internals/internal-state":"i6AaM"}],"7KtW6":[function(require,module,exports) {
'use strict';
// TODO: Remove from `core-js@4` since it's moved to entry points
require('../modules/es.regexp.exec');
var $ = require('../internals/export');
var global = require('../internals/global');
var call = require('../internals/function-call');
var uncurryThis = require('../internals/function-uncurry-this');
var isCallable = require('../internals/is-callable');
var isObject = require('../internals/is-object');
var DELEGATES_TO_EXEC = function() {
    var execCalled = false;
    var re = /[ac]/;
    re.exec = function() {
        execCalled = true;
        return /./.exec.apply(this, arguments);
    };
    return re.test('abc') === true && execCalled;
}();
var Error = global.Error;
var un$Test = uncurryThis(/./.test);
// `RegExp.prototype.test` method
// https://tc39.es/ecma262/#sec-regexp.prototype.test
$({
    target: 'RegExp',
    proto: true,
    forced: !DELEGATES_TO_EXEC
}, {
    test: function(str) {
        var exec = this.exec;
        if (!isCallable(exec)) return un$Test(this, str);
        var result = call(exec, this, str);
        if (result !== null && !isObject(result)) throw new Error('RegExp exec method returned something other than an Object or null');
        return !!result;
    }
});

},{"../modules/es.regexp.exec":"1vrnL","../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/function-call":"jhLed","../internals/function-uncurry-this":"jJnXC","../internals/is-callable":"kPhuP","../internals/is-object":"dplrD"}],"dhZg0":[function(require,module,exports) {
'use strict';
var uncurryThis = require('../internals/function-uncurry-this');
var PROPER_FUNCTION_NAME = require('../internals/function-name').PROPER;
var redefine = require('../internals/redefine');
var anObject = require('../internals/an-object');
var isPrototypeOf = require('../internals/object-is-prototype-of');
var $toString = require('../internals/to-string');
var fails = require('../internals/fails');
var regExpFlags = require('../internals/regexp-flags');
var TO_STRING = 'toString';
var RegExpPrototype = RegExp.prototype;
var n$ToString = RegExpPrototype[TO_STRING];
var getFlags = uncurryThis(regExpFlags);
var NOT_GENERIC = fails(function() {
    return n$ToString.call({
        source: 'a',
        flags: 'b'
    }) != '/a/b';
});
// FF44- RegExp#toString has a wrong name
var INCORRECT_NAME = PROPER_FUNCTION_NAME && n$ToString.name != TO_STRING;
// `RegExp.prototype.toString` method
// https://tc39.es/ecma262/#sec-regexp.prototype.tostring
if (NOT_GENERIC || INCORRECT_NAME) redefine(RegExp.prototype, TO_STRING, function toString() {
    var R = anObject(this);
    var p = $toString(R.source);
    var rf = R.flags;
    var f = $toString(rf === undefined && isPrototypeOf(RegExpPrototype, R) && !('flags' in RegExpPrototype) ? getFlags(R) : rf);
    return '/' + p + '/' + f;
}, {
    unsafe: true
});

},{"../internals/function-uncurry-this":"jJnXC","../internals/function-name":"6v6mP","../internals/redefine":"kxbj8","../internals/an-object":"1LIz9","../internals/object-is-prototype-of":"fyf1A","../internals/to-string":"4cTlm","../internals/fails":"8IfZQ","../internals/regexp-flags":"4QDzk"}],"8dCmg":[function(require,module,exports) {
'use strict';
var collection = require('../internals/collection');
var collectionStrong = require('../internals/collection-strong');
// `Set` constructor
// https://tc39.es/ecma262/#sec-set-objects
collection('Set', function(init) {
    return function Set() {
        return init(this, arguments.length ? arguments[0] : undefined);
    };
}, collectionStrong);

},{"../internals/collection":"g8aLF","../internals/collection-strong":"lnvQ9"}],"hbXFo":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var uncurryThis = require('../internals/function-uncurry-this');
var requireObjectCoercible = require('../internals/require-object-coercible');
var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
var toString = require('../internals/to-string');
var fails = require('../internals/fails');
var charAt = uncurryThis(''.charAt);
var FORCED = fails(function() {
    return '𠮷'.at(-2) !== '\uD842';
});
// `String.prototype.at` method
// https://github.com/tc39/proposal-relative-indexing-method
$({
    target: 'String',
    proto: true,
    forced: FORCED
}, {
    at: function at(index) {
        var S = toString(requireObjectCoercible(this));
        var len = S.length;
        var relativeIndex = toIntegerOrInfinity(index);
        var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
        return k < 0 || k >= len ? undefined : charAt(S, k);
    }
});

},{"../internals/export":"8yfGv","../internals/function-uncurry-this":"jJnXC","../internals/require-object-coercible":"3Qlyo","../internals/to-integer-or-infinity":"aqyxv","../internals/to-string":"4cTlm","../internals/fails":"8IfZQ"}],"4sQAm":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var codeAt = require('../internals/string-multibyte').codeAt;
// `String.prototype.codePointAt` method
// https://tc39.es/ecma262/#sec-string.prototype.codepointat
$({
    target: 'String',
    proto: true
}, {
    codePointAt: function codePointAt(pos) {
        return codeAt(this, pos);
    }
});

},{"../internals/export":"8yfGv","../internals/string-multibyte":"a9S4J"}],"a9S4J":[function(require,module,exports) {
var uncurryThis = require('../internals/function-uncurry-this');
var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
var toString = require('../internals/to-string');
var requireObjectCoercible = require('../internals/require-object-coercible');
var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var stringSlice = uncurryThis(''.slice);
var createMethod = function(CONVERT_TO_STRING) {
    return function($this, pos) {
        var S = toString(requireObjectCoercible($this));
        var position = toIntegerOrInfinity(pos);
        var size = S.length;
        var first, second;
        if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
        first = charCodeAt(S, position);
        return first < 55296 || first > 56319 || position + 1 === size || (second = charCodeAt(S, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt(S, position) : first : CONVERT_TO_STRING ? stringSlice(S, position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
    };
};
module.exports = {
    // `String.prototype.codePointAt` method
    // https://tc39.es/ecma262/#sec-string.prototype.codepointat
    codeAt: createMethod(false),
    // `String.prototype.at` method
    // https://github.com/mathiasbynens/String.prototype.at
    charAt: createMethod(true)
};

},{"../internals/function-uncurry-this":"jJnXC","../internals/to-integer-or-infinity":"aqyxv","../internals/to-string":"4cTlm","../internals/require-object-coercible":"3Qlyo"}],"jWSjD":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var uncurryThis = require('../internals/function-uncurry-this');
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
var toLength = require('../internals/to-length');
var toString = require('../internals/to-string');
var notARegExp = require('../internals/not-a-regexp');
var requireObjectCoercible = require('../internals/require-object-coercible');
var correctIsRegExpLogic = require('../internals/correct-is-regexp-logic');
var IS_PURE = require('../internals/is-pure');
// eslint-disable-next-line es/no-string-prototype-endswith -- safe
var un$EndsWith = uncurryThis(''.endsWith);
var slice = uncurryThis(''.slice);
var min = Math.min;
var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('endsWith');
// https://github.com/zloirock/core-js/pull/702
var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
    var descriptor = getOwnPropertyDescriptor(String.prototype, 'endsWith');
    return descriptor && !descriptor.writable;
}();
// `String.prototype.endsWith` method
// https://tc39.es/ecma262/#sec-string.prototype.endswith
$({
    target: 'String',
    proto: true,
    forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC
}, {
    endsWith: function endsWith(searchString /* , endPosition = @length */ ) {
        var that = toString(requireObjectCoercible(this));
        notARegExp(searchString);
        var endPosition = arguments.length > 1 ? arguments[1] : undefined;
        var len = that.length;
        var end = endPosition === undefined ? len : min(toLength(endPosition), len);
        var search = toString(searchString);
        return un$EndsWith ? un$EndsWith(that, search, end) : slice(that, end - search.length, end) === search;
    }
});

},{"../internals/export":"8yfGv","../internals/function-uncurry-this":"jJnXC","../internals/object-get-own-property-descriptor":"1gCBk","../internals/to-length":"bMgmi","../internals/to-string":"4cTlm","../internals/not-a-regexp":"hJJXZ","../internals/require-object-coercible":"3Qlyo","../internals/correct-is-regexp-logic":"aNJkR","../internals/is-pure":"6Bbq0"}],"hJJXZ":[function(require,module,exports) {
var global = require('../internals/global');
var isRegExp = require('../internals/is-regexp');
var TypeError = global.TypeError;
module.exports = function(it) {
    if (isRegExp(it)) throw TypeError("The method doesn't accept regular expressions");
    return it;
};

},{"../internals/global":"jxPDA","../internals/is-regexp":"lV2Ye"}],"aNJkR":[function(require,module,exports) {
var wellKnownSymbol = require('../internals/well-known-symbol');
var MATCH = wellKnownSymbol('match');
module.exports = function(METHOD_NAME) {
    var regexp = /./;
    try {
        '/./'[METHOD_NAME](regexp);
    } catch (error1) {
        try {
            regexp[MATCH] = false;
            return '/./'[METHOD_NAME](regexp);
        } catch (error2) {
        }
    }
    return false;
};

},{"../internals/well-known-symbol":"5C8sm"}],"3eS7x":[function(require,module,exports) {
var $ = require('../internals/export');
var global = require('../internals/global');
var uncurryThis = require('../internals/function-uncurry-this');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var RangeError = global.RangeError;
var fromCharCode = String.fromCharCode;
// eslint-disable-next-line es/no-string-fromcodepoint -- required for testing
var $fromCodePoint = String.fromCodePoint;
var join = uncurryThis([].join);
// length should be 1, old FF problem
var INCORRECT_LENGTH = !!$fromCodePoint && $fromCodePoint.length != 1;
// `String.fromCodePoint` method
// https://tc39.es/ecma262/#sec-string.fromcodepoint
$({
    target: 'String',
    stat: true,
    forced: INCORRECT_LENGTH
}, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    fromCodePoint: function fromCodePoint(x) {
        var elements = [];
        var length = arguments.length;
        var i = 0;
        var code;
        while(length > i){
            code = +arguments[i++];
            if (toAbsoluteIndex(code, 1114111) !== code) throw RangeError(code + ' is not a valid code point');
            elements[i] = code < 65536 ? fromCharCode(code) : fromCharCode(((code -= 65536) >> 10) + 55296, code % 1024 + 56320);
        }
        return join(elements, '');
    }
});

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/function-uncurry-this":"jJnXC","../internals/to-absolute-index":"dDgEq"}],"CsNki":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var uncurryThis = require('../internals/function-uncurry-this');
var notARegExp = require('../internals/not-a-regexp');
var requireObjectCoercible = require('../internals/require-object-coercible');
var toString = require('../internals/to-string');
var correctIsRegExpLogic = require('../internals/correct-is-regexp-logic');
var stringIndexOf = uncurryThis(''.indexOf);
// `String.prototype.includes` method
// https://tc39.es/ecma262/#sec-string.prototype.includes
$({
    target: 'String',
    proto: true,
    forced: !correctIsRegExpLogic('includes')
}, {
    includes: function includes(searchString /* , position = 0 */ ) {
        return !!~stringIndexOf(toString(requireObjectCoercible(this)), toString(notARegExp(searchString)), arguments.length > 1 ? arguments[1] : undefined);
    }
});

},{"../internals/export":"8yfGv","../internals/function-uncurry-this":"jJnXC","../internals/not-a-regexp":"hJJXZ","../internals/require-object-coercible":"3Qlyo","../internals/to-string":"4cTlm","../internals/correct-is-regexp-logic":"aNJkR"}],"b0sE2":[function(require,module,exports) {
'use strict';
var charAt = require('../internals/string-multibyte').charAt;
var toString = require('../internals/to-string');
var InternalStateModule = require('../internals/internal-state');
var defineIterator = require('../internals/define-iterator');
var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
// `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function(iterated) {
    setInternalState(this, {
        type: STRING_ITERATOR,
        string: toString(iterated),
        index: 0
    });
// `%StringIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
    var state = getInternalState(this);
    var string = state.string;
    var index = state.index;
    var point;
    if (index >= string.length) return {
        value: undefined,
        done: true
    };
    point = charAt(string, index);
    state.index += point.length;
    return {
        value: point,
        done: false
    };
});

},{"../internals/string-multibyte":"a9S4J","../internals/to-string":"4cTlm","../internals/internal-state":"i6AaM","../internals/define-iterator":"3Ugai"}],"d8k57":[function(require,module,exports) {
'use strict';
var call = require('../internals/function-call');
var fixRegExpWellKnownSymbolLogic = require('../internals/fix-regexp-well-known-symbol-logic');
var anObject = require('../internals/an-object');
var toLength = require('../internals/to-length');
var toString = require('../internals/to-string');
var requireObjectCoercible = require('../internals/require-object-coercible');
var getMethod = require('../internals/get-method');
var advanceStringIndex = require('../internals/advance-string-index');
var regExpExec = require('../internals/regexp-exec-abstract');
// @@match logic
fixRegExpWellKnownSymbolLogic('match', function(MATCH, nativeMatch, maybeCallNative) {
    return [
        // `String.prototype.match` method
        // https://tc39.es/ecma262/#sec-string.prototype.match
        function match(regexp) {
            var O = requireObjectCoercible(this);
            var matcher = regexp == undefined ? undefined : getMethod(regexp, MATCH);
            return matcher ? call(matcher, regexp, O) : new RegExp(regexp)[MATCH](toString(O));
        },
        // `RegExp.prototype[@@match]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
        function(string) {
            var rx = anObject(this);
            var S = toString(string);
            var res = maybeCallNative(nativeMatch, rx, S);
            if (res.done) return res.value;
            if (!rx.global) return regExpExec(rx, S);
            var fullUnicode = rx.unicode;
            rx.lastIndex = 0;
            var A = [];
            var n = 0;
            var result;
            while((result = regExpExec(rx, S)) !== null){
                var matchStr = toString(result[0]);
                A[n] = matchStr;
                if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
                n++;
            }
            return n === 0 ? null : A;
        }
    ];
});

},{"../internals/function-call":"jhLed","../internals/fix-regexp-well-known-symbol-logic":"kCD7W","../internals/an-object":"1LIz9","../internals/to-length":"bMgmi","../internals/to-string":"4cTlm","../internals/require-object-coercible":"3Qlyo","../internals/get-method":"hEJ6b","../internals/advance-string-index":"8P9Or","../internals/regexp-exec-abstract":"a6f8D"}],"kCD7W":[function(require,module,exports) {
'use strict';
// TODO: Remove from `core-js@4` since it's moved to entry points
require('../modules/es.regexp.exec');
var uncurryThis = require('../internals/function-uncurry-this');
var redefine = require('../internals/redefine');
var regexpExec = require('../internals/regexp-exec');
var fails = require('../internals/fails');
var wellKnownSymbol = require('../internals/well-known-symbol');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var SPECIES = wellKnownSymbol('species');
var RegExpPrototype = RegExp.prototype;
module.exports = function(KEY, exec, FORCED, SHAM) {
    var SYMBOL = wellKnownSymbol(KEY);
    var DELEGATES_TO_SYMBOL = !fails(function() {
        // String methods call symbol-named RegEp methods
        var O = {
        };
        O[SYMBOL] = function() {
            return 7;
        };
        return ''[KEY](O) != 7;
    });
    var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
        // Symbol-named RegExp methods call .exec
        var execCalled = false;
        var re = /a/;
        if (KEY === 'split') {
            // We can't use real regex here since it causes deoptimization
            // and serious performance degradation in V8
            // https://github.com/zloirock/core-js/issues/306
            re = {
            };
            // RegExp[@@split] doesn't call the regex's exec method, but first creates
            // a new one. We need to return the patched regex when creating the new one.
            re.constructor = {
            };
            re.constructor[SPECIES] = function() {
                return re;
            };
            re.flags = '';
            re[SYMBOL] = /./[SYMBOL];
        }
        re.exec = function() {
            execCalled = true;
            return null;
        };
        re[SYMBOL]('');
        return !execCalled;
    });
    if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED) {
        var uncurriedNativeRegExpMethod = uncurryThis(/./[SYMBOL]);
        var methods = exec(SYMBOL, ''[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
            var uncurriedNativeMethod = uncurryThis(nativeMethod);
            var $exec = regexp.exec;
            if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
                if (DELEGATES_TO_SYMBOL && !forceStringMethod) // The native String method already delegates to @@method (this
                // polyfilled function), leasing to infinite recursion.
                // We avoid it by directly calling the native @@method method.
                return {
                    done: true,
                    value: uncurriedNativeRegExpMethod(regexp, str, arg2)
                };
                return {
                    done: true,
                    value: uncurriedNativeMethod(str, regexp, arg2)
                };
            }
            return {
                done: false
            };
        });
        redefine(String.prototype, KEY, methods[0]);
        redefine(RegExpPrototype, SYMBOL, methods[1]);
    }
    if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], 'sham', true);
};

},{"../modules/es.regexp.exec":"1vrnL","../internals/function-uncurry-this":"jJnXC","../internals/redefine":"kxbj8","../internals/regexp-exec":"aEWJp","../internals/fails":"8IfZQ","../internals/well-known-symbol":"5C8sm","../internals/create-non-enumerable-property":"6Z1es"}],"8P9Or":[function(require,module,exports) {
'use strict';
var charAt = require('../internals/string-multibyte').charAt;
// `AdvanceStringIndex` abstract operation
// https://tc39.es/ecma262/#sec-advancestringindex
module.exports = function(S, index, unicode) {
    return index + (unicode ? charAt(S, index).length : 1);
};

},{"../internals/string-multibyte":"a9S4J"}],"a6f8D":[function(require,module,exports) {
var global = require('../internals/global');
var call = require('../internals/function-call');
var anObject = require('../internals/an-object');
var isCallable = require('../internals/is-callable');
var classof = require('../internals/classof-raw');
var regexpExec = require('../internals/regexp-exec');
var TypeError = global.TypeError;
// `RegExpExec` abstract operation
// https://tc39.es/ecma262/#sec-regexpexec
module.exports = function(R, S) {
    var exec = R.exec;
    if (isCallable(exec)) {
        var result = call(exec, R, S);
        if (result !== null) anObject(result);
        return result;
    }
    if (classof(R) === 'RegExp') return call(regexpExec, R, S);
    throw TypeError('RegExp#exec called on incompatible receiver');
};

},{"../internals/global":"jxPDA","../internals/function-call":"jhLed","../internals/an-object":"1LIz9","../internals/is-callable":"kPhuP","../internals/classof-raw":"A9m3U","../internals/regexp-exec":"aEWJp"}],"hNQS5":[function(require,module,exports) {
'use strict';
/* eslint-disable es/no-string-prototype-matchall -- safe */ var $ = require('../internals/export');
var global = require('../internals/global');
var call = require('../internals/function-call');
var uncurryThis = require('../internals/function-uncurry-this');
var createIteratorConstructor = require('../internals/create-iterator-constructor');
var requireObjectCoercible = require('../internals/require-object-coercible');
var toLength = require('../internals/to-length');
var toString = require('../internals/to-string');
var anObject = require('../internals/an-object');
var classof = require('../internals/classof-raw');
var isPrototypeOf = require('../internals/object-is-prototype-of');
var isRegExp = require('../internals/is-regexp');
var regExpFlags = require('../internals/regexp-flags');
var getMethod = require('../internals/get-method');
var redefine = require('../internals/redefine');
var fails = require('../internals/fails');
var wellKnownSymbol = require('../internals/well-known-symbol');
var speciesConstructor = require('../internals/species-constructor');
var advanceStringIndex = require('../internals/advance-string-index');
var regExpExec = require('../internals/regexp-exec-abstract');
var InternalStateModule = require('../internals/internal-state');
var IS_PURE = require('../internals/is-pure');
var MATCH_ALL = wellKnownSymbol('matchAll');
var REGEXP_STRING = 'RegExp String';
var REGEXP_STRING_ITERATOR = REGEXP_STRING + ' Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(REGEXP_STRING_ITERATOR);
var RegExpPrototype = RegExp.prototype;
var TypeError = global.TypeError;
var getFlags = uncurryThis(regExpFlags);
var stringIndexOf = uncurryThis(''.indexOf);
var un$MatchAll = uncurryThis(''.matchAll);
var WORKS_WITH_NON_GLOBAL_REGEX = !!un$MatchAll && !fails(function() {
    un$MatchAll('a', /./);
});
var $RegExpStringIterator = createIteratorConstructor(function RegExpStringIterator(regexp, string, $global, fullUnicode) {
    setInternalState(this, {
        type: REGEXP_STRING_ITERATOR,
        regexp: regexp,
        string: string,
        global: $global,
        unicode: fullUnicode,
        done: false
    });
}, REGEXP_STRING, function next() {
    var state = getInternalState(this);
    if (state.done) return {
        value: undefined,
        done: true
    };
    var R = state.regexp;
    var S = state.string;
    var match = regExpExec(R, S);
    if (match === null) return {
        value: undefined,
        done: state.done = true
    };
    if (state.global) {
        if (toString(match[0]) === '') R.lastIndex = advanceStringIndex(S, toLength(R.lastIndex), state.unicode);
        return {
            value: match,
            done: false
        };
    }
    state.done = true;
    return {
        value: match,
        done: false
    };
});
var $matchAll = function(string) {
    var R = anObject(this);
    var S = toString(string);
    var C, flagsValue, flags, matcher, $global, fullUnicode;
    C = speciesConstructor(R, RegExp);
    flagsValue = R.flags;
    if (flagsValue === undefined && isPrototypeOf(RegExpPrototype, R) && !('flags' in RegExpPrototype)) flagsValue = getFlags(R);
    flags = flagsValue === undefined ? '' : toString(flagsValue);
    matcher = new C(C === RegExp ? R.source : R, flags);
    $global = !!~stringIndexOf(flags, 'g');
    fullUnicode = !!~stringIndexOf(flags, 'u');
    matcher.lastIndex = toLength(R.lastIndex);
    return new $RegExpStringIterator(matcher, S, $global, fullUnicode);
};
// `String.prototype.matchAll` method
// https://tc39.es/ecma262/#sec-string.prototype.matchall
$({
    target: 'String',
    proto: true,
    forced: WORKS_WITH_NON_GLOBAL_REGEX
}, {
    matchAll: function matchAll(regexp) {
        var O = requireObjectCoercible(this);
        var flags, S, matcher, rx;
        if (regexp != null) {
            if (isRegExp(regexp)) {
                flags = toString(requireObjectCoercible('flags' in RegExpPrototype ? regexp.flags : getFlags(regexp)));
                if (!~stringIndexOf(flags, 'g')) throw TypeError('`.matchAll` does not allow non-global regexes');
            }
            if (WORKS_WITH_NON_GLOBAL_REGEX) return un$MatchAll(O, regexp);
            matcher = getMethod(regexp, MATCH_ALL);
            if (matcher === undefined && IS_PURE && classof(regexp) == 'RegExp') matcher = $matchAll;
            if (matcher) return call(matcher, regexp, O);
        } else if (WORKS_WITH_NON_GLOBAL_REGEX) return un$MatchAll(O, regexp);
        S = toString(O);
        rx = new RegExp(regexp, 'g');
        return IS_PURE ? call($matchAll, rx, S) : rx[MATCH_ALL](S);
    }
});
IS_PURE || MATCH_ALL in RegExpPrototype || redefine(RegExpPrototype, MATCH_ALL, $matchAll);

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/function-call":"jhLed","../internals/function-uncurry-this":"jJnXC","../internals/create-iterator-constructor":"1fB00","../internals/require-object-coercible":"3Qlyo","../internals/to-length":"bMgmi","../internals/to-string":"4cTlm","../internals/an-object":"1LIz9","../internals/classof-raw":"A9m3U","../internals/object-is-prototype-of":"fyf1A","../internals/is-regexp":"lV2Ye","../internals/regexp-flags":"4QDzk","../internals/get-method":"hEJ6b","../internals/redefine":"kxbj8","../internals/fails":"8IfZQ","../internals/well-known-symbol":"5C8sm","../internals/species-constructor":"hqPl9","../internals/advance-string-index":"8P9Or","../internals/regexp-exec-abstract":"a6f8D","../internals/internal-state":"i6AaM","../internals/is-pure":"6Bbq0"}],"93KvT":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $padEnd = require('../internals/string-pad').end;
var WEBKIT_BUG = require('../internals/string-pad-webkit-bug');
// `String.prototype.padEnd` method
// https://tc39.es/ecma262/#sec-string.prototype.padend
$({
    target: 'String',
    proto: true,
    forced: WEBKIT_BUG
}, {
    padEnd: function padEnd(maxLength /* , fillString = ' ' */ ) {
        return $padEnd(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
    }
});

},{"../internals/export":"8yfGv","../internals/string-pad":"2xP44","../internals/string-pad-webkit-bug":"HfKuT"}],"HfKuT":[function(require,module,exports) {
// https://github.com/zloirock/core-js/issues/280
var userAgent = require('../internals/engine-user-agent');
module.exports = /Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(userAgent);

},{"../internals/engine-user-agent":"boFeV"}],"iZS0g":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $padStart = require('../internals/string-pad').start;
var WEBKIT_BUG = require('../internals/string-pad-webkit-bug');
// `String.prototype.padStart` method
// https://tc39.es/ecma262/#sec-string.prototype.padstart
$({
    target: 'String',
    proto: true,
    forced: WEBKIT_BUG
}, {
    padStart: function padStart(maxLength /* , fillString = ' ' */ ) {
        return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
    }
});

},{"../internals/export":"8yfGv","../internals/string-pad":"2xP44","../internals/string-pad-webkit-bug":"HfKuT"}],"5GoQv":[function(require,module,exports) {
var $ = require('../internals/export');
var uncurryThis = require('../internals/function-uncurry-this');
var toIndexedObject = require('../internals/to-indexed-object');
var toObject = require('../internals/to-object');
var toString = require('../internals/to-string');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var push = uncurryThis([].push);
var join = uncurryThis([].join);
// `String.raw` method
// https://tc39.es/ecma262/#sec-string.raw
$({
    target: 'String',
    stat: true
}, {
    raw: function raw(template) {
        var rawTemplate = toIndexedObject(toObject(template).raw);
        var literalSegments = lengthOfArrayLike(rawTemplate);
        var argumentsLength = arguments.length;
        var elements = [];
        var i = 0;
        while(literalSegments > i){
            push(elements, toString(rawTemplate[i++]));
            if (i === literalSegments) return join(elements, '');
            if (i < argumentsLength) push(elements, toString(arguments[i]));
        }
    }
});

},{"../internals/export":"8yfGv","../internals/function-uncurry-this":"jJnXC","../internals/to-indexed-object":"8ueFu","../internals/to-object":"eEdae","../internals/to-string":"4cTlm","../internals/length-of-array-like":"afDy6"}],"eBErx":[function(require,module,exports) {
var $ = require('../internals/export');
var repeat = require('../internals/string-repeat');
// `String.prototype.repeat` method
// https://tc39.es/ecma262/#sec-string.prototype.repeat
$({
    target: 'String',
    proto: true
}, {
    repeat: repeat
});

},{"../internals/export":"8yfGv","../internals/string-repeat":"4Md87"}],"bbUl2":[function(require,module,exports) {
'use strict';
var apply = require('../internals/function-apply');
var call = require('../internals/function-call');
var uncurryThis = require('../internals/function-uncurry-this');
var fixRegExpWellKnownSymbolLogic = require('../internals/fix-regexp-well-known-symbol-logic');
var fails = require('../internals/fails');
var anObject = require('../internals/an-object');
var isCallable = require('../internals/is-callable');
var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
var toLength = require('../internals/to-length');
var toString = require('../internals/to-string');
var requireObjectCoercible = require('../internals/require-object-coercible');
var advanceStringIndex = require('../internals/advance-string-index');
var getMethod = require('../internals/get-method');
var getSubstitution = require('../internals/get-substitution');
var regExpExec = require('../internals/regexp-exec-abstract');
var wellKnownSymbol = require('../internals/well-known-symbol');
var REPLACE = wellKnownSymbol('replace');
var max = Math.max;
var min = Math.min;
var concat = uncurryThis([].concat);
var push = uncurryThis([].push);
var stringIndexOf = uncurryThis(''.indexOf);
var stringSlice = uncurryThis(''.slice);
var maybeToString = function(it) {
    return it === undefined ? it : String(it);
};
// IE <= 11 replaces $0 with the whole match, as if it was $&
// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
var REPLACE_KEEPS_$0 = function() {
    // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing
    return 'a'.replace(/./, '$0') === '$0';
}();
// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
    if (/./[REPLACE]) return /./[REPLACE]('a', '$0') === '';
    return false;
}();
var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
    var re = /./;
    re.exec = function() {
        var result = [];
        result.groups = {
            a: '7'
        };
        return result;
    };
    // eslint-disable-next-line regexp/no-useless-dollar-replacements -- false positive
    return ''.replace(re, '$<a>') !== '7';
});
// @@replace logic
fixRegExpWellKnownSymbolLogic('replace', function(_, nativeReplace, maybeCallNative) {
    var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';
    return [
        // `String.prototype.replace` method
        // https://tc39.es/ecma262/#sec-string.prototype.replace
        function replace(searchValue, replaceValue) {
            var O = requireObjectCoercible(this);
            var replacer = searchValue == undefined ? undefined : getMethod(searchValue, REPLACE);
            return replacer ? call(replacer, searchValue, O, replaceValue) : call(nativeReplace, toString(O), searchValue, replaceValue);
        },
        // `RegExp.prototype[@@replace]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
        function(string, replaceValue) {
            var rx = anObject(this);
            var S = toString(string);
            if (typeof replaceValue == 'string' && stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf(replaceValue, '$<') === -1) {
                var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
                if (res.done) return res.value;
            }
            var functionalReplace = isCallable(replaceValue);
            if (!functionalReplace) replaceValue = toString(replaceValue);
            var global = rx.global;
            if (global) {
                var fullUnicode = rx.unicode;
                rx.lastIndex = 0;
            }
            var results = [];
            while(true){
                var result = regExpExec(rx, S);
                if (result === null) break;
                push(results, result);
                if (!global) break;
                var matchStr = toString(result[0]);
                if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
            }
            var accumulatedResult = '';
            var nextSourcePosition = 0;
            for(var i = 0; i < results.length; i++){
                result = results[i];
                var matched = toString(result[0]);
                var position = max(min(toIntegerOrInfinity(result.index), S.length), 0);
                var captures = [];
                // NOTE: This is equivalent to
                //   captures = result.slice(1).map(maybeToString)
                // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
                // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
                // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
                for(var j = 1; j < result.length; j++)push(captures, maybeToString(result[j]));
                var namedCaptures = result.groups;
                if (functionalReplace) {
                    var replacerArgs = concat([
                        matched
                    ], captures, position, S);
                    if (namedCaptures !== undefined) push(replacerArgs, namedCaptures);
                    var replacement = toString(apply(replaceValue, undefined, replacerArgs));
                } else replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
                if (position >= nextSourcePosition) {
                    accumulatedResult += stringSlice(S, nextSourcePosition, position) + replacement;
                    nextSourcePosition = position + matched.length;
                }
            }
            return accumulatedResult + stringSlice(S, nextSourcePosition);
        }
    ];
}, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);

},{"../internals/function-apply":"206oi","../internals/function-call":"jhLed","../internals/function-uncurry-this":"jJnXC","../internals/fix-regexp-well-known-symbol-logic":"kCD7W","../internals/fails":"8IfZQ","../internals/an-object":"1LIz9","../internals/is-callable":"kPhuP","../internals/to-integer-or-infinity":"aqyxv","../internals/to-length":"bMgmi","../internals/to-string":"4cTlm","../internals/require-object-coercible":"3Qlyo","../internals/advance-string-index":"8P9Or","../internals/get-method":"hEJ6b","../internals/get-substitution":"bJykS","../internals/regexp-exec-abstract":"a6f8D","../internals/well-known-symbol":"5C8sm"}],"bJykS":[function(require,module,exports) {
var uncurryThis = require('../internals/function-uncurry-this');
var toObject = require('../internals/to-object');
var floor = Math.floor;
var charAt = uncurryThis(''.charAt);
var replace = uncurryThis(''.replace);
var stringSlice = uncurryThis(''.slice);
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
// `GetSubstitution` abstract operation
// https://tc39.es/ecma262/#sec-getsubstitution
module.exports = function(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
        namedCaptures = toObject(namedCaptures);
        symbols = SUBSTITUTION_SYMBOLS;
    }
    return replace(replacement, symbols, function(match, ch) {
        var capture;
        switch(charAt(ch, 0)){
            case '$':
                return '$';
            case '&':
                return matched;
            case '`':
                return stringSlice(str, 0, position);
            case "'":
                return stringSlice(str, tailPos);
            case '<':
                capture = namedCaptures[stringSlice(ch, 1, -1)];
                break;
            default:
                var n = +ch;
                if (n === 0) return match;
                if (n > m) {
                    var f = floor(n / 10);
                    if (f === 0) return match;
                    if (f <= m) return captures[f - 1] === undefined ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);
                    return match;
                }
                capture = captures[n - 1];
        }
        return capture === undefined ? '' : capture;
    });
};

},{"../internals/function-uncurry-this":"jJnXC","../internals/to-object":"eEdae"}],"3DDbg":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var global = require('../internals/global');
var call = require('../internals/function-call');
var uncurryThis = require('../internals/function-uncurry-this');
var requireObjectCoercible = require('../internals/require-object-coercible');
var isCallable = require('../internals/is-callable');
var isRegExp = require('../internals/is-regexp');
var toString = require('../internals/to-string');
var getMethod = require('../internals/get-method');
var regExpFlags = require('../internals/regexp-flags');
var getSubstitution = require('../internals/get-substitution');
var wellKnownSymbol = require('../internals/well-known-symbol');
var IS_PURE = require('../internals/is-pure');
var REPLACE = wellKnownSymbol('replace');
var RegExpPrototype = RegExp.prototype;
var TypeError = global.TypeError;
var getFlags = uncurryThis(regExpFlags);
var indexOf = uncurryThis(''.indexOf);
var replace = uncurryThis(''.replace);
var stringSlice = uncurryThis(''.slice);
var max = Math.max;
var stringIndexOf = function(string, searchValue, fromIndex) {
    if (fromIndex > string.length) return -1;
    if (searchValue === '') return fromIndex;
    return indexOf(string, searchValue, fromIndex);
};
// `String.prototype.replaceAll` method
// https://tc39.es/ecma262/#sec-string.prototype.replaceall
$({
    target: 'String',
    proto: true
}, {
    replaceAll: function replaceAll(searchValue, replaceValue) {
        var O = requireObjectCoercible(this);
        var IS_REG_EXP, flags, replacer, string, searchString, functionalReplace, searchLength, advanceBy, replacement;
        var position = 0;
        var endOfLastMatch = 0;
        var result = '';
        if (searchValue != null) {
            IS_REG_EXP = isRegExp(searchValue);
            if (IS_REG_EXP) {
                flags = toString(requireObjectCoercible('flags' in RegExpPrototype ? searchValue.flags : getFlags(searchValue)));
                if (!~indexOf(flags, 'g')) throw TypeError('`.replaceAll` does not allow non-global regexes');
            }
            replacer = getMethod(searchValue, REPLACE);
            if (replacer) return call(replacer, searchValue, O, replaceValue);
            else if (IS_PURE && IS_REG_EXP) return replace(toString(O), searchValue, replaceValue);
        }
        string = toString(O);
        searchString = toString(searchValue);
        functionalReplace = isCallable(replaceValue);
        if (!functionalReplace) replaceValue = toString(replaceValue);
        searchLength = searchString.length;
        advanceBy = max(1, searchLength);
        position = stringIndexOf(string, searchString, 0);
        while(position !== -1){
            replacement = functionalReplace ? toString(replaceValue(searchString, position, string)) : getSubstitution(searchString, string, position, [], undefined, replaceValue);
            result += stringSlice(string, endOfLastMatch, position) + replacement;
            endOfLastMatch = position + searchLength;
            position = stringIndexOf(string, searchString, position + advanceBy);
        }
        if (endOfLastMatch < string.length) result += stringSlice(string, endOfLastMatch);
        return result;
    }
});

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/function-call":"jhLed","../internals/function-uncurry-this":"jJnXC","../internals/require-object-coercible":"3Qlyo","../internals/is-callable":"kPhuP","../internals/is-regexp":"lV2Ye","../internals/to-string":"4cTlm","../internals/get-method":"hEJ6b","../internals/regexp-flags":"4QDzk","../internals/get-substitution":"bJykS","../internals/well-known-symbol":"5C8sm","../internals/is-pure":"6Bbq0"}],"aRDsg":[function(require,module,exports) {
'use strict';
var call = require('../internals/function-call');
var fixRegExpWellKnownSymbolLogic = require('../internals/fix-regexp-well-known-symbol-logic');
var anObject = require('../internals/an-object');
var requireObjectCoercible = require('../internals/require-object-coercible');
var sameValue = require('../internals/same-value');
var toString = require('../internals/to-string');
var getMethod = require('../internals/get-method');
var regExpExec = require('../internals/regexp-exec-abstract');
// @@search logic
fixRegExpWellKnownSymbolLogic('search', function(SEARCH, nativeSearch, maybeCallNative) {
    return [
        // `String.prototype.search` method
        // https://tc39.es/ecma262/#sec-string.prototype.search
        function search(regexp) {
            var O = requireObjectCoercible(this);
            var searcher = regexp == undefined ? undefined : getMethod(regexp, SEARCH);
            return searcher ? call(searcher, regexp, O) : new RegExp(regexp)[SEARCH](toString(O));
        },
        // `RegExp.prototype[@@search]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@search
        function(string) {
            var rx = anObject(this);
            var S = toString(string);
            var res = maybeCallNative(nativeSearch, rx, S);
            if (res.done) return res.value;
            var previousLastIndex = rx.lastIndex;
            if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
            var result = regExpExec(rx, S);
            if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
            return result === null ? -1 : result.index;
        }
    ];
});

},{"../internals/function-call":"jhLed","../internals/fix-regexp-well-known-symbol-logic":"kCD7W","../internals/an-object":"1LIz9","../internals/require-object-coercible":"3Qlyo","../internals/same-value":"hePMR","../internals/to-string":"4cTlm","../internals/get-method":"hEJ6b","../internals/regexp-exec-abstract":"a6f8D"}],"eWFDr":[function(require,module,exports) {
'use strict';
var apply = require('../internals/function-apply');
var call = require('../internals/function-call');
var uncurryThis = require('../internals/function-uncurry-this');
var fixRegExpWellKnownSymbolLogic = require('../internals/fix-regexp-well-known-symbol-logic');
var isRegExp = require('../internals/is-regexp');
var anObject = require('../internals/an-object');
var requireObjectCoercible = require('../internals/require-object-coercible');
var speciesConstructor = require('../internals/species-constructor');
var advanceStringIndex = require('../internals/advance-string-index');
var toLength = require('../internals/to-length');
var toString = require('../internals/to-string');
var getMethod = require('../internals/get-method');
var arraySlice = require('../internals/array-slice-simple');
var callRegExpExec = require('../internals/regexp-exec-abstract');
var regexpExec = require('../internals/regexp-exec');
var stickyHelpers = require('../internals/regexp-sticky-helpers');
var fails = require('../internals/fails');
var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
var MAX_UINT32 = 4294967295;
var min = Math.min;
var $push = [].push;
var exec = uncurryThis(/./.exec);
var push = uncurryThis($push);
var stringSlice = uncurryThis(''.slice);
// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
// Weex JS has frozen built-in prototypes, so use try / catch wrapper
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
    // eslint-disable-next-line regexp/no-empty-group -- required for testing
    var re = /(?:)/;
    var originalExec = re.exec;
    re.exec = function() {
        return originalExec.apply(this, arguments);
    };
    var result = 'ab'.split(re);
    return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
});
// @@split logic
fixRegExpWellKnownSymbolLogic('split', function(SPLIT, nativeSplit, maybeCallNative) {
    var internalSplit;
    if ('abbc'.split(/(b)*/)[1] == 'c' || // eslint-disable-next-line regexp/no-empty-group -- required for testing
    'test'.split(/(?:)/, -1).length != 4 || 'ab'.split(/(?:ab)*/).length != 2 || '.'.split(/(.?)(.?)/).length != 4 || // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
    '.'.split(/()()/).length > 1 || ''.split(/.?/).length) // based on es5-shim implementation, need to rework it
    internalSplit = function(separator, limit) {
        var string = toString(requireObjectCoercible(this));
        var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
        if (lim === 0) return [];
        if (separator === undefined) return [
            string
        ];
        // If `separator` is not a regex, use native split
        if (!isRegExp(separator)) return call(nativeSplit, string, separator, lim);
        var output = [];
        var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
        var lastLastIndex = 0;
        // Make `global` and avoid `lastIndex` issues by working with a copy
        var separatorCopy = new RegExp(separator.source, flags + 'g');
        var match, lastIndex, lastLength;
        while(match = call(regexpExec, separatorCopy, string)){
            lastIndex = separatorCopy.lastIndex;
            if (lastIndex > lastLastIndex) {
                push(output, stringSlice(string, lastLastIndex, match.index));
                if (match.length > 1 && match.index < string.length) apply($push, output, arraySlice(match, 1));
                lastLength = match[0].length;
                lastLastIndex = lastIndex;
                if (output.length >= lim) break;
            }
            if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
        }
        if (lastLastIndex === string.length) {
            if (lastLength || !exec(separatorCopy, '')) push(output, '');
        } else push(output, stringSlice(string, lastLastIndex));
        return output.length > lim ? arraySlice(output, 0, lim) : output;
    };
    else if ('0'.split(undefined, 0).length) internalSplit = function(separator, limit) {
        return separator === undefined && limit === 0 ? [] : call(nativeSplit, this, separator, limit);
    };
    else internalSplit = nativeSplit;
    return [
        // `String.prototype.split` method
        // https://tc39.es/ecma262/#sec-string.prototype.split
        function split(separator, limit) {
            var O = requireObjectCoercible(this);
            var splitter = separator == undefined ? undefined : getMethod(separator, SPLIT);
            return splitter ? call(splitter, separator, O, limit) : call(internalSplit, toString(O), separator, limit);
        },
        // `RegExp.prototype[@@split]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
        //
        // NOTE: This cannot be properly polyfilled in engines that don't support
        // the 'y' flag.
        function(string, limit) {
            var rx = anObject(this);
            var S = toString(string);
            var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);
            if (res.done) return res.value;
            var C = speciesConstructor(rx, RegExp);
            var unicodeMatching = rx.unicode;
            var flags = (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '') + (rx.unicode ? 'u' : '') + (UNSUPPORTED_Y ? 'g' : 'y');
            // ^(? + rx + ) is needed, in combination with some S slicing, to
            // simulate the 'y' flag.
            var splitter = new C(UNSUPPORTED_Y ? '^(?:' + rx.source + ')' : rx, flags);
            var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
            if (lim === 0) return [];
            if (S.length === 0) return callRegExpExec(splitter, S) === null ? [
                S
            ] : [];
            var p = 0;
            var q = 0;
            var A = [];
            while(q < S.length){
                splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
                var z = callRegExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S, q) : S);
                var e;
                if (z === null || (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p) q = advanceStringIndex(S, q, unicodeMatching);
                else {
                    push(A, stringSlice(S, p, q));
                    if (A.length === lim) return A;
                    for(var i = 1; i <= z.length - 1; i++){
                        push(A, z[i]);
                        if (A.length === lim) return A;
                    }
                    q = p = e;
                }
            }
            push(A, stringSlice(S, p));
            return A;
        }
    ];
}, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);

},{"../internals/function-apply":"206oi","../internals/function-call":"jhLed","../internals/function-uncurry-this":"jJnXC","../internals/fix-regexp-well-known-symbol-logic":"kCD7W","../internals/is-regexp":"lV2Ye","../internals/an-object":"1LIz9","../internals/require-object-coercible":"3Qlyo","../internals/species-constructor":"hqPl9","../internals/advance-string-index":"8P9Or","../internals/to-length":"bMgmi","../internals/to-string":"4cTlm","../internals/get-method":"hEJ6b","../internals/array-slice-simple":"bYLId","../internals/regexp-exec-abstract":"a6f8D","../internals/regexp-exec":"aEWJp","../internals/regexp-sticky-helpers":"801yY","../internals/fails":"8IfZQ"}],"eH6fZ":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var uncurryThis = require('../internals/function-uncurry-this');
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
var toLength = require('../internals/to-length');
var toString = require('../internals/to-string');
var notARegExp = require('../internals/not-a-regexp');
var requireObjectCoercible = require('../internals/require-object-coercible');
var correctIsRegExpLogic = require('../internals/correct-is-regexp-logic');
var IS_PURE = require('../internals/is-pure');
// eslint-disable-next-line es/no-string-prototype-startswith -- safe
var un$StartsWith = uncurryThis(''.startsWith);
var stringSlice = uncurryThis(''.slice);
var min = Math.min;
var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('startsWith');
// https://github.com/zloirock/core-js/pull/702
var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
    var descriptor = getOwnPropertyDescriptor(String.prototype, 'startsWith');
    return descriptor && !descriptor.writable;
}();
// `String.prototype.startsWith` method
// https://tc39.es/ecma262/#sec-string.prototype.startswith
$({
    target: 'String',
    proto: true,
    forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC
}, {
    startsWith: function startsWith(searchString /* , position = 0 */ ) {
        var that = toString(requireObjectCoercible(this));
        notARegExp(searchString);
        var index = toLength(min(arguments.length > 1 ? arguments[1] : undefined, that.length));
        var search = toString(searchString);
        return un$StartsWith ? un$StartsWith(that, search, index) : stringSlice(that, index, index + search.length) === search;
    }
});

},{"../internals/export":"8yfGv","../internals/function-uncurry-this":"jJnXC","../internals/object-get-own-property-descriptor":"1gCBk","../internals/to-length":"bMgmi","../internals/to-string":"4cTlm","../internals/not-a-regexp":"hJJXZ","../internals/require-object-coercible":"3Qlyo","../internals/correct-is-regexp-logic":"aNJkR","../internals/is-pure":"6Bbq0"}],"wWZGf":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var uncurryThis = require('../internals/function-uncurry-this');
var requireObjectCoercible = require('../internals/require-object-coercible');
var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
var toString = require('../internals/to-string');
var stringSlice = uncurryThis(''.slice);
var max = Math.max;
var min = Math.min;
// eslint-disable-next-line unicorn/prefer-string-slice -- required for testing
var FORCED = !''.substr || 'ab'.substr(-1) !== 'b';
// `String.prototype.substr` method
// https://tc39.es/ecma262/#sec-string.prototype.substr
$({
    target: 'String',
    proto: true,
    forced: FORCED
}, {
    substr: function substr(start, length) {
        var that = toString(requireObjectCoercible(this));
        var size = that.length;
        var intStart = toIntegerOrInfinity(start);
        var intLength, intEnd;
        if (intStart === Infinity) intStart = 0;
        if (intStart < 0) intStart = max(size + intStart, 0);
        intLength = length === undefined ? size : toIntegerOrInfinity(length);
        if (intLength <= 0 || intLength === Infinity) return '';
        intEnd = min(intStart + intLength, size);
        return intStart >= intEnd ? '' : stringSlice(that, intStart, intEnd);
    }
});

},{"../internals/export":"8yfGv","../internals/function-uncurry-this":"jJnXC","../internals/require-object-coercible":"3Qlyo","../internals/to-integer-or-infinity":"aqyxv","../internals/to-string":"4cTlm"}],"iHEeA":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $trim = require('../internals/string-trim').trim;
var forcedStringTrimMethod = require('../internals/string-trim-forced');
// `String.prototype.trim` method
// https://tc39.es/ecma262/#sec-string.prototype.trim
$({
    target: 'String',
    proto: true,
    forced: forcedStringTrimMethod('trim')
}, {
    trim: function trim() {
        return $trim(this);
    }
});

},{"../internals/export":"8yfGv","../internals/string-trim":"6sOY8","../internals/string-trim-forced":"icVcZ"}],"icVcZ":[function(require,module,exports) {
var PROPER_FUNCTION_NAME = require('../internals/function-name').PROPER;
var fails = require('../internals/fails');
var whitespaces = require('../internals/whitespaces');
var non = '\u200B\u0085\u180E';
// check that a method works with the correct list
// of whitespaces and has a correct name
module.exports = function(METHOD_NAME) {
    return fails(function() {
        return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME;
    });
};

},{"../internals/function-name":"6v6mP","../internals/fails":"8IfZQ","../internals/whitespaces":"ddvZW"}],"l55Rx":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $trimEnd = require('../internals/string-trim').end;
var forcedStringTrimMethod = require('../internals/string-trim-forced');
var FORCED = forcedStringTrimMethod('trimEnd');
var trimEnd = FORCED ? function trimEnd() {
    return $trimEnd(this);
// eslint-disable-next-line es/no-string-prototype-trimstart-trimend -- safe
} : ''.trimEnd;
// `String.prototype.{ trimEnd, trimRight }` methods
// https://tc39.es/ecma262/#sec-string.prototype.trimend
// https://tc39.es/ecma262/#String.prototype.trimright
$({
    target: 'String',
    proto: true,
    name: 'trimEnd',
    forced: FORCED
}, {
    trimEnd: trimEnd,
    trimRight: trimEnd
});

},{"../internals/export":"8yfGv","../internals/string-trim":"6sOY8","../internals/string-trim-forced":"icVcZ"}],"8F6Kw":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $trimStart = require('../internals/string-trim').start;
var forcedStringTrimMethod = require('../internals/string-trim-forced');
var FORCED = forcedStringTrimMethod('trimStart');
var trimStart = FORCED ? function trimStart() {
    return $trimStart(this);
// eslint-disable-next-line es/no-string-prototype-trimstart-trimend -- safe
} : ''.trimStart;
// `String.prototype.{ trimStart, trimLeft }` methods
// https://tc39.es/ecma262/#sec-string.prototype.trimstart
// https://tc39.es/ecma262/#String.prototype.trimleft
$({
    target: 'String',
    proto: true,
    name: 'trimStart',
    forced: FORCED
}, {
    trimStart: trimStart,
    trimLeft: trimStart
});

},{"../internals/export":"8yfGv","../internals/string-trim":"6sOY8","../internals/string-trim-forced":"icVcZ"}],"93wbJ":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/string-html-forced');
// `String.prototype.anchor` method
// https://tc39.es/ecma262/#sec-string.prototype.anchor
$({
    target: 'String',
    proto: true,
    forced: forcedStringHTMLMethod('anchor')
}, {
    anchor: function anchor(name) {
        return createHTML(this, 'a', 'name', name);
    }
});

},{"../internals/export":"8yfGv","../internals/create-html":"lBM3b","../internals/string-html-forced":"8VFV9"}],"lBM3b":[function(require,module,exports) {
var uncurryThis = require('../internals/function-uncurry-this');
var requireObjectCoercible = require('../internals/require-object-coercible');
var toString = require('../internals/to-string');
var quot = /"/g;
var replace = uncurryThis(''.replace);
// `CreateHTML` abstract operation
// https://tc39.es/ecma262/#sec-createhtml
module.exports = function(string, tag, attribute, value) {
    var S = toString(requireObjectCoercible(string));
    var p1 = '<' + tag;
    if (attribute !== '') p1 += ' ' + attribute + '="' + replace(toString(value), quot, '&quot;') + '"';
    return p1 + '>' + S + '</' + tag + '>';
};

},{"../internals/function-uncurry-this":"jJnXC","../internals/require-object-coercible":"3Qlyo","../internals/to-string":"4cTlm"}],"8VFV9":[function(require,module,exports) {
var fails = require('../internals/fails');
// check the existence of a method, lowercase
// of a tag and escaping quotes in arguments
module.exports = function(METHOD_NAME) {
    return fails(function() {
        var test = ''[METHOD_NAME]('"');
        return test !== test.toLowerCase() || test.split('"').length > 3;
    });
};

},{"../internals/fails":"8IfZQ"}],"46Sza":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/string-html-forced');
// `String.prototype.big` method
// https://tc39.es/ecma262/#sec-string.prototype.big
$({
    target: 'String',
    proto: true,
    forced: forcedStringHTMLMethod('big')
}, {
    big: function big() {
        return createHTML(this, 'big', '', '');
    }
});

},{"../internals/export":"8yfGv","../internals/create-html":"lBM3b","../internals/string-html-forced":"8VFV9"}],"eKWOl":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/string-html-forced');
// `String.prototype.blink` method
// https://tc39.es/ecma262/#sec-string.prototype.blink
$({
    target: 'String',
    proto: true,
    forced: forcedStringHTMLMethod('blink')
}, {
    blink: function blink() {
        return createHTML(this, 'blink', '', '');
    }
});

},{"../internals/export":"8yfGv","../internals/create-html":"lBM3b","../internals/string-html-forced":"8VFV9"}],"54FVv":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/string-html-forced');
// `String.prototype.bold` method
// https://tc39.es/ecma262/#sec-string.prototype.bold
$({
    target: 'String',
    proto: true,
    forced: forcedStringHTMLMethod('bold')
}, {
    bold: function bold() {
        return createHTML(this, 'b', '', '');
    }
});

},{"../internals/export":"8yfGv","../internals/create-html":"lBM3b","../internals/string-html-forced":"8VFV9"}],"9IBmc":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/string-html-forced');
// `String.prototype.fixed` method
// https://tc39.es/ecma262/#sec-string.prototype.fixed
$({
    target: 'String',
    proto: true,
    forced: forcedStringHTMLMethod('fixed')
}, {
    fixed: function fixed() {
        return createHTML(this, 'tt', '', '');
    }
});

},{"../internals/export":"8yfGv","../internals/create-html":"lBM3b","../internals/string-html-forced":"8VFV9"}],"84dI7":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/string-html-forced');
// `String.prototype.fontcolor` method
// https://tc39.es/ecma262/#sec-string.prototype.fontcolor
$({
    target: 'String',
    proto: true,
    forced: forcedStringHTMLMethod('fontcolor')
}, {
    fontcolor: function fontcolor(color) {
        return createHTML(this, 'font', 'color', color);
    }
});

},{"../internals/export":"8yfGv","../internals/create-html":"lBM3b","../internals/string-html-forced":"8VFV9"}],"39t2d":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/string-html-forced');
// `String.prototype.fontsize` method
// https://tc39.es/ecma262/#sec-string.prototype.fontsize
$({
    target: 'String',
    proto: true,
    forced: forcedStringHTMLMethod('fontsize')
}, {
    fontsize: function fontsize(size) {
        return createHTML(this, 'font', 'size', size);
    }
});

},{"../internals/export":"8yfGv","../internals/create-html":"lBM3b","../internals/string-html-forced":"8VFV9"}],"66Iat":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/string-html-forced');
// `String.prototype.italics` method
// https://tc39.es/ecma262/#sec-string.prototype.italics
$({
    target: 'String',
    proto: true,
    forced: forcedStringHTMLMethod('italics')
}, {
    italics: function italics() {
        return createHTML(this, 'i', '', '');
    }
});

},{"../internals/export":"8yfGv","../internals/create-html":"lBM3b","../internals/string-html-forced":"8VFV9"}],"3RAvD":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/string-html-forced');
// `String.prototype.link` method
// https://tc39.es/ecma262/#sec-string.prototype.link
$({
    target: 'String',
    proto: true,
    forced: forcedStringHTMLMethod('link')
}, {
    link: function link(url) {
        return createHTML(this, 'a', 'href', url);
    }
});

},{"../internals/export":"8yfGv","../internals/create-html":"lBM3b","../internals/string-html-forced":"8VFV9"}],"bZDHb":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/string-html-forced');
// `String.prototype.small` method
// https://tc39.es/ecma262/#sec-string.prototype.small
$({
    target: 'String',
    proto: true,
    forced: forcedStringHTMLMethod('small')
}, {
    small: function small() {
        return createHTML(this, 'small', '', '');
    }
});

},{"../internals/export":"8yfGv","../internals/create-html":"lBM3b","../internals/string-html-forced":"8VFV9"}],"31OJy":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/string-html-forced');
// `String.prototype.strike` method
// https://tc39.es/ecma262/#sec-string.prototype.strike
$({
    target: 'String',
    proto: true,
    forced: forcedStringHTMLMethod('strike')
}, {
    strike: function strike() {
        return createHTML(this, 'strike', '', '');
    }
});

},{"../internals/export":"8yfGv","../internals/create-html":"lBM3b","../internals/string-html-forced":"8VFV9"}],"aFIua":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/string-html-forced');
// `String.prototype.sub` method
// https://tc39.es/ecma262/#sec-string.prototype.sub
$({
    target: 'String',
    proto: true,
    forced: forcedStringHTMLMethod('sub')
}, {
    sub: function sub() {
        return createHTML(this, 'sub', '', '');
    }
});

},{"../internals/export":"8yfGv","../internals/create-html":"lBM3b","../internals/string-html-forced":"8VFV9"}],"3RzhA":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var createHTML = require('../internals/create-html');
var forcedStringHTMLMethod = require('../internals/string-html-forced');
// `String.prototype.sup` method
// https://tc39.es/ecma262/#sec-string.prototype.sup
$({
    target: 'String',
    proto: true,
    forced: forcedStringHTMLMethod('sup')
}, {
    sup: function sup() {
        return createHTML(this, 'sup', '', '');
    }
});

},{"../internals/export":"8yfGv","../internals/create-html":"lBM3b","../internals/string-html-forced":"8VFV9"}],"ep1pl":[function(require,module,exports) {
var createTypedArrayConstructor = require('../internals/typed-array-constructor');
// `Float32Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Float32', function(init) {
    return function Float32Array(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
    };
});

},{"../internals/typed-array-constructor":"jXkvM"}],"jXkvM":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var global = require('../internals/global');
var call = require('../internals/function-call');
var DESCRIPTORS = require('../internals/descriptors');
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require('../internals/typed-array-constructors-require-wrappers');
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var ArrayBufferModule = require('../internals/array-buffer');
var anInstance = require('../internals/an-instance');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var isIntegralNumber = require('../internals/is-integral-number');
var toLength = require('../internals/to-length');
var toIndex = require('../internals/to-index');
var toOffset = require('../internals/to-offset');
var toPropertyKey = require('../internals/to-property-key');
var hasOwn = require('../internals/has-own-property');
var classof = require('../internals/classof');
var isObject = require('../internals/is-object');
var isSymbol = require('../internals/is-symbol');
var create = require('../internals/object-create');
var isPrototypeOf = require('../internals/object-is-prototype-of');
var setPrototypeOf = require('../internals/object-set-prototype-of');
var getOwnPropertyNames = require('../internals/object-get-own-property-names').f;
var typedArrayFrom = require('../internals/typed-array-from');
var forEach = require('../internals/array-iteration').forEach;
var setSpecies = require('../internals/set-species');
var definePropertyModule = require('../internals/object-define-property');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
var InternalStateModule = require('../internals/internal-state');
var inheritIfRequired = require('../internals/inherit-if-required');
var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var round = Math.round;
var RangeError = global.RangeError;
var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
var ArrayBufferPrototype = ArrayBuffer.prototype;
var DataView = ArrayBufferModule.DataView;
var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
var TYPED_ARRAY_CONSTRUCTOR = ArrayBufferViewCore.TYPED_ARRAY_CONSTRUCTOR;
var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
var TypedArray = ArrayBufferViewCore.TypedArray;
var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var isTypedArray = ArrayBufferViewCore.isTypedArray;
var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
var WRONG_LENGTH = 'Wrong length';
var fromList = function(C, list) {
    aTypedArrayConstructor(C);
    var index = 0;
    var length = list.length;
    var result = new C(length);
    while(length > index)result[index] = list[index++];
    return result;
};
var addGetter = function(it, key) {
    nativeDefineProperty(it, key, {
        get: function() {
            return getInternalState(this)[key];
        }
    });
};
var isArrayBuffer = function(it) {
    var klass;
    return isPrototypeOf(ArrayBufferPrototype, it) || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
};
var isTypedArrayIndex = function(target, key) {
    return isTypedArray(target) && !isSymbol(key) && key in target && isIntegralNumber(+key) && key >= 0;
};
var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
    key = toPropertyKey(key);
    return isTypedArrayIndex(target, key) ? createPropertyDescriptor(2, target[key]) : nativeGetOwnPropertyDescriptor(target, key);
};
var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
    key = toPropertyKey(key);
    if (isTypedArrayIndex(target, key) && isObject(descriptor) && hasOwn(descriptor, 'value') && !hasOwn(descriptor, 'get') && !hasOwn(descriptor, 'set') && !descriptor.configurable && (!hasOwn(descriptor, 'writable') || descriptor.writable) && (!hasOwn(descriptor, 'enumerable') || descriptor.enumerable)) {
        target[key] = descriptor.value;
        return target;
    }
    return nativeDefineProperty(target, key, descriptor);
};
if (DESCRIPTORS) {
    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
        getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
        definePropertyModule.f = wrappedDefineProperty;
        addGetter(TypedArrayPrototype, 'buffer');
        addGetter(TypedArrayPrototype, 'byteOffset');
        addGetter(TypedArrayPrototype, 'byteLength');
        addGetter(TypedArrayPrototype, 'length');
    }
    $({
        target: 'Object',
        stat: true,
        forced: !NATIVE_ARRAY_BUFFER_VIEWS
    }, {
        getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
        defineProperty: wrappedDefineProperty
    });
    module.exports = function(TYPE, wrapper, CLAMPED) {
        var BYTES = TYPE.match(/\d+$/)[0] / 8;
        var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
        var GETTER = 'get' + TYPE;
        var SETTER = 'set' + TYPE;
        var NativeTypedArrayConstructor = global[CONSTRUCTOR_NAME];
        var TypedArrayConstructor = NativeTypedArrayConstructor;
        var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
        var exported = {
        };
        var getter = function(that, index) {
            var data = getInternalState(that);
            return data.view[GETTER](index * BYTES + data.byteOffset, true);
        };
        var setter = function(that, index, value) {
            var data = getInternalState(that);
            if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 255 ? 255 : value & 255;
            data.view[SETTER](index * BYTES + data.byteOffset, value, true);
        };
        var addElement = function(that, index) {
            nativeDefineProperty(that, index, {
                get: function() {
                    return getter(this, index);
                },
                set: function(value) {
                    return setter(this, index, value);
                },
                enumerable: true
            });
        };
        if (!NATIVE_ARRAY_BUFFER_VIEWS) {
            TypedArrayConstructor = wrapper(function(that, data, offset, $length) {
                anInstance(that, TypedArrayConstructorPrototype);
                var index = 0;
                var byteOffset = 0;
                var buffer, byteLength, length;
                if (!isObject(data)) {
                    length = toIndex(data);
                    byteLength = length * BYTES;
                    buffer = new ArrayBuffer(byteLength);
                } else if (isArrayBuffer(data)) {
                    buffer = data;
                    byteOffset = toOffset(offset, BYTES);
                    var $len = data.byteLength;
                    if ($length === undefined) {
                        if ($len % BYTES) throw RangeError(WRONG_LENGTH);
                        byteLength = $len - byteOffset;
                        if (byteLength < 0) throw RangeError(WRONG_LENGTH);
                    } else {
                        byteLength = toLength($length) * BYTES;
                        if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
                    }
                    length = byteLength / BYTES;
                } else if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
                else return call(typedArrayFrom, TypedArrayConstructor, data);
                setInternalState(that, {
                    buffer: buffer,
                    byteOffset: byteOffset,
                    byteLength: byteLength,
                    length: length,
                    view: new DataView(buffer)
                });
                while(index < length)addElement(that, index++);
            });
            if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
            TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
        } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
            TypedArrayConstructor = wrapper(function(dummy, data, typedArrayOffset, $length) {
                anInstance(dummy, TypedArrayConstructorPrototype);
                return inheritIfRequired(function() {
                    if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
                    if (isArrayBuffer(data)) return $length !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length) : typedArrayOffset !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES)) : new NativeTypedArrayConstructor(data);
                    if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
                    return call(typedArrayFrom, TypedArrayConstructor, data);
                }(), dummy, TypedArrayConstructor);
            });
            if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
            forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function(key) {
                if (!(key in TypedArrayConstructor)) createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
            });
            TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
        }
        if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
        createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_CONSTRUCTOR, TypedArrayConstructor);
        if (TYPED_ARRAY_TAG) createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
        exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;
        $({
            global: true,
            forced: TypedArrayConstructor != NativeTypedArrayConstructor,
            sham: !NATIVE_ARRAY_BUFFER_VIEWS
        }, exported);
        if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
        if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
        setSpecies(CONSTRUCTOR_NAME);
    };
} else module.exports = function() {
};

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/function-call":"jhLed","../internals/descriptors":"6ZLib","../internals/typed-array-constructors-require-wrappers":"gMlLy","../internals/array-buffer-view-core":"7PXuA","../internals/array-buffer":"eiDN2","../internals/an-instance":"2zeQg","../internals/create-property-descriptor":"ermgb","../internals/create-non-enumerable-property":"6Z1es","../internals/is-integral-number":"aJg8G","../internals/to-length":"bMgmi","../internals/to-index":"2hEQ4","../internals/to-offset":"5HTeY","../internals/to-property-key":"bMDpS","../internals/has-own-property":"3ZdUC","../internals/classof":"kJ8JQ","../internals/is-object":"dplrD","../internals/is-symbol":"imyt8","../internals/object-create":"1As5O","../internals/object-is-prototype-of":"fyf1A","../internals/object-set-prototype-of":"lb6rR","../internals/object-get-own-property-names":"evqXT","../internals/typed-array-from":"lTnsL","../internals/array-iteration":"8a6lB","../internals/set-species":"hBKMQ","../internals/object-define-property":"bauTd","../internals/object-get-own-property-descriptor":"1gCBk","../internals/internal-state":"i6AaM","../internals/inherit-if-required":"kXY2O"}],"gMlLy":[function(require,module,exports) {
/* eslint-disable no-new -- required for testing */ var global = require('../internals/global');
var fails = require('../internals/fails');
var checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');
var NATIVE_ARRAY_BUFFER_VIEWS = require('../internals/array-buffer-view-core').NATIVE_ARRAY_BUFFER_VIEWS;
var ArrayBuffer = global.ArrayBuffer;
var Int8Array = global.Int8Array;
module.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function() {
    Int8Array(1);
}) || !fails(function() {
    new Int8Array(-1);
}) || !checkCorrectnessOfIteration(function(iterable) {
    new Int8Array();
    new Int8Array(null);
    new Int8Array(1.5);
    new Int8Array(iterable);
}, true) || fails(function() {
    // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
    return new Int8Array(new ArrayBuffer(2), 1, undefined).length !== 1;
});

},{"../internals/global":"jxPDA","../internals/fails":"8IfZQ","../internals/check-correctness-of-iteration":"788V9","../internals/array-buffer-view-core":"7PXuA"}],"5HTeY":[function(require,module,exports) {
var global = require('../internals/global');
var toPositiveInteger = require('../internals/to-positive-integer');
var RangeError = global.RangeError;
module.exports = function(it, BYTES) {
    var offset = toPositiveInteger(it);
    if (offset % BYTES) throw RangeError('Wrong offset');
    return offset;
};

},{"../internals/global":"jxPDA","../internals/to-positive-integer":"ezIBe"}],"ezIBe":[function(require,module,exports) {
var global = require('../internals/global');
var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
var RangeError = global.RangeError;
module.exports = function(it) {
    var result = toIntegerOrInfinity(it);
    if (result < 0) throw RangeError("The argument can't be less than 0");
    return result;
};

},{"../internals/global":"jxPDA","../internals/to-integer-or-infinity":"aqyxv"}],"lTnsL":[function(require,module,exports) {
var bind = require('../internals/function-bind-context');
var call = require('../internals/function-call');
var aConstructor = require('../internals/a-constructor');
var toObject = require('../internals/to-object');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var getIterator = require('../internals/get-iterator');
var getIteratorMethod = require('../internals/get-iterator-method');
var isArrayIteratorMethod = require('../internals/is-array-iterator-method');
var aTypedArrayConstructor = require('../internals/array-buffer-view-core').aTypedArrayConstructor;
module.exports = function from(source /* , mapfn, thisArg */ ) {
    var C = aConstructor(this);
    var O = toObject(source);
    var argumentsLength = arguments.length;
    var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iteratorMethod = getIteratorMethod(O);
    var i, length, result, step, iterator, next;
    if (iteratorMethod && !isArrayIteratorMethod(iteratorMethod)) {
        iterator = getIterator(O, iteratorMethod);
        next = iterator.next;
        O = [];
        while(!(step = call(next, iterator)).done)O.push(step.value);
    }
    if (mapping && argumentsLength > 2) mapfn = bind(mapfn, arguments[2]);
    length = lengthOfArrayLike(O);
    result = new (aTypedArrayConstructor(C))(length);
    for(i = 0; length > i; i++)result[i] = mapping ? mapfn(O[i], i) : O[i];
    return result;
};

},{"../internals/function-bind-context":"kZubc","../internals/function-call":"jhLed","../internals/a-constructor":"1DOBp","../internals/to-object":"eEdae","../internals/length-of-array-like":"afDy6","../internals/get-iterator":"dQrLE","../internals/get-iterator-method":"5CTSY","../internals/is-array-iterator-method":"7ORJD","../internals/array-buffer-view-core":"7PXuA"}],"idfXY":[function(require,module,exports) {
var createTypedArrayConstructor = require('../internals/typed-array-constructor');
// `Float64Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Float64', function(init) {
    return function Float64Array(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
    };
});

},{"../internals/typed-array-constructor":"jXkvM"}],"kbnYC":[function(require,module,exports) {
var createTypedArrayConstructor = require('../internals/typed-array-constructor');
// `Int8Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Int8', function(init) {
    return function Int8Array(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
    };
});

},{"../internals/typed-array-constructor":"jXkvM"}],"46Ijs":[function(require,module,exports) {
var createTypedArrayConstructor = require('../internals/typed-array-constructor');
// `Int16Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Int16', function(init) {
    return function Int16Array(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
    };
});

},{"../internals/typed-array-constructor":"jXkvM"}],"l06wp":[function(require,module,exports) {
var createTypedArrayConstructor = require('../internals/typed-array-constructor');
// `Int32Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Int32', function(init) {
    return function Int32Array(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
    };
});

},{"../internals/typed-array-constructor":"jXkvM"}],"l5EEt":[function(require,module,exports) {
var createTypedArrayConstructor = require('../internals/typed-array-constructor');
// `Uint8Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Uint8', function(init) {
    return function Uint8Array(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
    };
});

},{"../internals/typed-array-constructor":"jXkvM"}],"cp2gb":[function(require,module,exports) {
var createTypedArrayConstructor = require('../internals/typed-array-constructor');
// `Uint8ClampedArray` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Uint8', function(init) {
    return function Uint8ClampedArray(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
    };
}, true);

},{"../internals/typed-array-constructor":"jXkvM"}],"gEEQI":[function(require,module,exports) {
var createTypedArrayConstructor = require('../internals/typed-array-constructor');
// `Uint16Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Uint16', function(init) {
    return function Uint16Array(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
    };
});

},{"../internals/typed-array-constructor":"jXkvM"}],"lm14q":[function(require,module,exports) {
var createTypedArrayConstructor = require('../internals/typed-array-constructor');
// `Uint32Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Uint32', function(init) {
    return function Uint32Array(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
    };
});

},{"../internals/typed-array-constructor":"jXkvM"}],"eSUgO":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.at` method
// https://github.com/tc39/proposal-relative-indexing-method
exportTypedArrayMethod('at', function at(index) {
    var O = aTypedArray(this);
    var len = lengthOfArrayLike(O);
    var relativeIndex = toIntegerOrInfinity(index);
    var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
    return k < 0 || k >= len ? undefined : O[k];
});

},{"../internals/array-buffer-view-core":"7PXuA","../internals/length-of-array-like":"afDy6","../internals/to-integer-or-infinity":"aqyxv"}],"gGJHn":[function(require,module,exports) {
'use strict';
var uncurryThis = require('../internals/function-uncurry-this');
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $ArrayCopyWithin = require('../internals/array-copy-within');
var u$ArrayCopyWithin = uncurryThis($ArrayCopyWithin);
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.copyWithin` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.copywithin
exportTypedArrayMethod('copyWithin', function copyWithin(target, start /* , end */ ) {
    return u$ArrayCopyWithin(aTypedArray(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
});

},{"../internals/function-uncurry-this":"jJnXC","../internals/array-buffer-view-core":"7PXuA","../internals/array-copy-within":"cxbSj"}],"hBvO4":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $every = require('../internals/array-iteration').every;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.every` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.every
exportTypedArrayMethod('every', function every(callbackfn /* , thisArg */ ) {
    return $every(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":"7PXuA","../internals/array-iteration":"8a6lB"}],"4utKX":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var call = require('../internals/function-call');
var $fill = require('../internals/array-fill');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.fill` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill
exportTypedArrayMethod('fill', function fill(value /* , start, end */ ) {
    var length = arguments.length;
    return call($fill, aTypedArray(this), value, length > 1 ? arguments[1] : undefined, length > 2 ? arguments[2] : undefined);
});

},{"../internals/array-buffer-view-core":"7PXuA","../internals/function-call":"jhLed","../internals/array-fill":"fYphv"}],"izheQ":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $filter = require('../internals/array-iteration').filter;
var fromSpeciesAndList = require('../internals/typed-array-from-species-and-list');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.filter` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.filter
exportTypedArrayMethod('filter', function filter(callbackfn /* , thisArg */ ) {
    var list = $filter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return fromSpeciesAndList(this, list);
});

},{"../internals/array-buffer-view-core":"7PXuA","../internals/array-iteration":"8a6lB","../internals/typed-array-from-species-and-list":"eF9eX"}],"eF9eX":[function(require,module,exports) {
var arrayFromConstructorAndList = require('../internals/array-from-constructor-and-list');
var typedArraySpeciesConstructor = require('../internals/typed-array-species-constructor');
module.exports = function(instance, list) {
    return arrayFromConstructorAndList(typedArraySpeciesConstructor(instance), list);
};

},{"../internals/array-from-constructor-and-list":"5X1AQ","../internals/typed-array-species-constructor":"b4oOp"}],"5X1AQ":[function(require,module,exports) {
var lengthOfArrayLike = require('../internals/length-of-array-like');
module.exports = function(Constructor, list) {
    var index = 0;
    var length = lengthOfArrayLike(list);
    var result = new Constructor(length);
    while(length > index)result[index] = list[index++];
    return result;
};

},{"../internals/length-of-array-like":"afDy6"}],"b4oOp":[function(require,module,exports) {
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var speciesConstructor = require('../internals/species-constructor');
var TYPED_ARRAY_CONSTRUCTOR = ArrayBufferViewCore.TYPED_ARRAY_CONSTRUCTOR;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
// a part of `TypedArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#typedarray-species-create
module.exports = function(originalArray) {
    return aTypedArrayConstructor(speciesConstructor(originalArray, originalArray[TYPED_ARRAY_CONSTRUCTOR]));
};

},{"../internals/array-buffer-view-core":"7PXuA","../internals/species-constructor":"hqPl9"}],"YMlI3":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $find = require('../internals/array-iteration').find;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.find` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.find
exportTypedArrayMethod('find', function find(predicate /* , thisArg */ ) {
    return $find(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":"7PXuA","../internals/array-iteration":"8a6lB"}],"aZxn3":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $findIndex = require('../internals/array-iteration').findIndex;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.findIndex` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.findindex
exportTypedArrayMethod('findIndex', function findIndex(predicate /* , thisArg */ ) {
    return $findIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":"7PXuA","../internals/array-iteration":"8a6lB"}],"jD85u":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $forEach = require('../internals/array-iteration').forEach;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.forEach` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.foreach
exportTypedArrayMethod('forEach', function forEach(callbackfn /* , thisArg */ ) {
    $forEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":"7PXuA","../internals/array-iteration":"8a6lB"}],"jlZLn":[function(require,module,exports) {
'use strict';
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require('../internals/typed-array-constructors-require-wrappers');
var exportTypedArrayStaticMethod = require('../internals/array-buffer-view-core').exportTypedArrayStaticMethod;
var typedArrayFrom = require('../internals/typed-array-from');
// `%TypedArray%.from` method
// https://tc39.es/ecma262/#sec-%typedarray%.from
exportTypedArrayStaticMethod('from', typedArrayFrom, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);

},{"../internals/typed-array-constructors-require-wrappers":"gMlLy","../internals/array-buffer-view-core":"7PXuA","../internals/typed-array-from":"lTnsL"}],"2gl1y":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $includes = require('../internals/array-includes').includes;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.includes` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.includes
exportTypedArrayMethod('includes', function includes(searchElement /* , fromIndex */ ) {
    return $includes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":"7PXuA","../internals/array-includes":"SXf52"}],"kXPbg":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $indexOf = require('../internals/array-includes').indexOf;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.indexOf` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.indexof
exportTypedArrayMethod('indexOf', function indexOf(searchElement /* , fromIndex */ ) {
    return $indexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":"7PXuA","../internals/array-includes":"SXf52"}],"jUDTl":[function(require,module,exports) {
'use strict';
var global = require('../internals/global');
var fails = require('../internals/fails');
var uncurryThis = require('../internals/function-uncurry-this');
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var ArrayIterators = require('../modules/es.array.iterator');
var wellKnownSymbol = require('../internals/well-known-symbol');
var ITERATOR = wellKnownSymbol('iterator');
var Uint8Array = global.Uint8Array;
var arrayValues = uncurryThis(ArrayIterators.values);
var arrayKeys = uncurryThis(ArrayIterators.keys);
var arrayEntries = uncurryThis(ArrayIterators.entries);
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var TypedArrayPrototype = Uint8Array && Uint8Array.prototype;
var GENERIC = !fails(function() {
    TypedArrayPrototype[ITERATOR].call([
        1
    ]);
});
var ITERATOR_IS_VALUES = !!TypedArrayPrototype && TypedArrayPrototype.values && TypedArrayPrototype[ITERATOR] === TypedArrayPrototype.values && TypedArrayPrototype.values.name === 'values';
var typedArrayValues = function values() {
    return arrayValues(aTypedArray(this));
};
// `%TypedArray%.prototype.entries` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.entries
exportTypedArrayMethod('entries', function entries() {
    return arrayEntries(aTypedArray(this));
}, GENERIC);
// `%TypedArray%.prototype.keys` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.keys
exportTypedArrayMethod('keys', function keys() {
    return arrayKeys(aTypedArray(this));
}, GENERIC);
// `%TypedArray%.prototype.values` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.values
exportTypedArrayMethod('values', typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, {
    name: 'values'
});
// `%TypedArray%.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype-@@iterator
exportTypedArrayMethod(ITERATOR, typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, {
    name: 'values'
});

},{"../internals/global":"jxPDA","../internals/fails":"8IfZQ","../internals/function-uncurry-this":"jJnXC","../internals/array-buffer-view-core":"7PXuA","../modules/es.array.iterator":"bLuDU","../internals/well-known-symbol":"5C8sm"}],"cMZaK":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var uncurryThis = require('../internals/function-uncurry-this');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $join = uncurryThis([].join);
// `%TypedArray%.prototype.join` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.join
exportTypedArrayMethod('join', function join(separator) {
    return $join(aTypedArray(this), separator);
});

},{"../internals/array-buffer-view-core":"7PXuA","../internals/function-uncurry-this":"jJnXC"}],"OvuT4":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var apply = require('../internals/function-apply');
var $lastIndexOf = require('../internals/array-last-index-of');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.lastIndexOf` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.lastindexof
exportTypedArrayMethod('lastIndexOf', function lastIndexOf(searchElement /* , fromIndex */ ) {
    var length = arguments.length;
    return apply($lastIndexOf, aTypedArray(this), length > 1 ? [
        searchElement,
        arguments[1]
    ] : [
        searchElement
    ]);
});

},{"../internals/array-buffer-view-core":"7PXuA","../internals/function-apply":"206oi","../internals/array-last-index-of":"dcOLl"}],"ePlyz":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $map = require('../internals/array-iteration').map;
var typedArraySpeciesConstructor = require('../internals/typed-array-species-constructor');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.map` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.map
exportTypedArrayMethod('map', function map(mapfn /* , thisArg */ ) {
    return $map(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function(O, length) {
        return new (typedArraySpeciesConstructor(O))(length);
    });
});

},{"../internals/array-buffer-view-core":"7PXuA","../internals/array-iteration":"8a6lB","../internals/typed-array-species-constructor":"b4oOp"}],"avnFD":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require('../internals/typed-array-constructors-require-wrappers');
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayStaticMethod = ArrayBufferViewCore.exportTypedArrayStaticMethod;
// `%TypedArray%.of` method
// https://tc39.es/ecma262/#sec-%typedarray%.of
exportTypedArrayStaticMethod('of', function of() {
    var index = 0;
    var length = arguments.length;
    var result = new (aTypedArrayConstructor(this))(length);
    while(length > index)result[index] = arguments[index++];
    return result;
}, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);

},{"../internals/array-buffer-view-core":"7PXuA","../internals/typed-array-constructors-require-wrappers":"gMlLy"}],"b0apc":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $reduce = require('../internals/array-reduce').left;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.reduce` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduce
exportTypedArrayMethod('reduce', function reduce(callbackfn /* , initialValue */ ) {
    var length = arguments.length;
    return $reduce(aTypedArray(this), callbackfn, length, length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":"7PXuA","../internals/array-reduce":"j7uXX"}],"4TSIU":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $reduceRight = require('../internals/array-reduce').right;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.reduceRicht` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduceright
exportTypedArrayMethod('reduceRight', function reduceRight(callbackfn /* , initialValue */ ) {
    var length = arguments.length;
    return $reduceRight(aTypedArray(this), callbackfn, length, length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":"7PXuA","../internals/array-reduce":"j7uXX"}],"iMuym":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var floor = Math.floor;
// `%TypedArray%.prototype.reverse` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reverse
exportTypedArrayMethod('reverse', function reverse() {
    var that = this;
    var length = aTypedArray(that).length;
    var middle = floor(length / 2);
    var index = 0;
    var value;
    while(index < middle){
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
    }
    return that;
});

},{"../internals/array-buffer-view-core":"7PXuA"}],"i2kBQ":[function(require,module,exports) {
'use strict';
var global = require('../internals/global');
var call = require('../internals/function-call');
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var toOffset = require('../internals/to-offset');
var toIndexedObject = require('../internals/to-object');
var fails = require('../internals/fails');
var RangeError = global.RangeError;
var Int8Array = global.Int8Array;
var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
var $set = Int8ArrayPrototype && Int8ArrayPrototype.set;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS = !fails(function() {
    // eslint-disable-next-line es/no-typed-arrays -- required for testing
    var array = new Uint8ClampedArray(2);
    call($set, array, {
        length: 1,
        0: 3
    }, 1);
    return array[1] !== 3;
});
// https://bugs.chromium.org/p/v8/issues/detail?id=11294 and other
var TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS && ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS && fails(function() {
    var array = new Int8Array(2);
    array.set(1);
    array.set('2', 1);
    return array[0] !== 0 || array[1] !== 2;
});
// `%TypedArray%.prototype.set` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.set
exportTypedArrayMethod('set', function set(arrayLike /* , offset */ ) {
    aTypedArray(this);
    var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
    var src = toIndexedObject(arrayLike);
    if (WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS) return call($set, this, src, offset);
    var length = this.length;
    var len = lengthOfArrayLike(src);
    var index = 0;
    if (len + offset > length) throw RangeError('Wrong length');
    while(index < len)this[offset + index] = src[index++];
}, !WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);

},{"../internals/global":"jxPDA","../internals/function-call":"jhLed","../internals/array-buffer-view-core":"7PXuA","../internals/length-of-array-like":"afDy6","../internals/to-offset":"5HTeY","../internals/to-object":"eEdae","../internals/fails":"8IfZQ"}],"h67Ud":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var typedArraySpeciesConstructor = require('../internals/typed-array-species-constructor');
var fails = require('../internals/fails');
var arraySlice = require('../internals/array-slice');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var FORCED = fails(function() {
    // eslint-disable-next-line es/no-typed-arrays -- required for testing
    new Int8Array(1).slice();
});
// `%TypedArray%.prototype.slice` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice
exportTypedArrayMethod('slice', function slice(start, end) {
    var list = arraySlice(aTypedArray(this), start, end);
    var C = typedArraySpeciesConstructor(this);
    var index = 0;
    var length = list.length;
    var result = new C(length);
    while(length > index)result[index] = list[index++];
    return result;
}, FORCED);

},{"../internals/array-buffer-view-core":"7PXuA","../internals/typed-array-species-constructor":"b4oOp","../internals/fails":"8IfZQ","../internals/array-slice":"bI1dk"}],"jZLEc":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $some = require('../internals/array-iteration').some;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.some` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.some
exportTypedArrayMethod('some', function some(callbackfn /* , thisArg */ ) {
    return $some(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":"7PXuA","../internals/array-iteration":"8a6lB"}],"a5k4K":[function(require,module,exports) {
'use strict';
var global = require('../internals/global');
var uncurryThis = require('../internals/function-uncurry-this');
var fails = require('../internals/fails');
var aCallable = require('../internals/a-callable');
var internalSort = require('../internals/array-sort');
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var FF = require('../internals/engine-ff-version');
var IE_OR_EDGE = require('../internals/engine-is-ie-or-edge');
var V8 = require('../internals/engine-v8-version');
var WEBKIT = require('../internals/engine-webkit-version');
var Array = global.Array;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var Uint16Array = global.Uint16Array;
var un$Sort = Uint16Array && uncurryThis(Uint16Array.prototype.sort);
// WebKit
var ACCEPT_INCORRECT_ARGUMENTS = !!un$Sort && !(fails(function() {
    un$Sort(new Uint16Array(2), null);
}) && fails(function() {
    un$Sort(new Uint16Array(2), {
    });
}));
var STABLE_SORT = !!un$Sort && !fails(function() {
    // feature detection can be too slow, so check engines versions
    if (V8) return V8 < 74;
    if (FF) return FF < 67;
    if (IE_OR_EDGE) return true;
    if (WEBKIT) return WEBKIT < 602;
    var array = new Uint16Array(516);
    var expected = Array(516);
    var index, mod;
    for(index = 0; index < 516; index++){
        mod = index % 4;
        array[index] = 515 - index;
        expected[index] = index - 2 * mod + 3;
    }
    un$Sort(array, function(a, b) {
        return (a / 4 | 0) - (b / 4 | 0);
    });
    for(index = 0; index < 516; index++){
        if (array[index] !== expected[index]) return true;
    }
});
var getSortCompare = function(comparefn) {
    return function(x, y) {
        if (comparefn !== undefined) return +comparefn(x, y) || 0;
        // eslint-disable-next-line no-self-compare -- NaN check
        if (y !== y) return -1;
        // eslint-disable-next-line no-self-compare -- NaN check
        if (x !== x) return 1;
        if (x === 0 && y === 0) return 1 / x > 0 && 1 / y < 0 ? 1 : -1;
        return x > y;
    };
};
// `%TypedArray%.prototype.sort` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort
exportTypedArrayMethod('sort', function sort(comparefn) {
    if (comparefn !== undefined) aCallable(comparefn);
    if (STABLE_SORT) return un$Sort(this, comparefn);
    return internalSort(aTypedArray(this), getSortCompare(comparefn));
}, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);

},{"../internals/global":"jxPDA","../internals/function-uncurry-this":"jJnXC","../internals/fails":"8IfZQ","../internals/a-callable":"83opn","../internals/array-sort":"ik2R5","../internals/array-buffer-view-core":"7PXuA","../internals/engine-ff-version":"kOv6x","../internals/engine-is-ie-or-edge":"kQ3dM","../internals/engine-v8-version":"9gYOM","../internals/engine-webkit-version":"a5m5j"}],"1curj":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var toLength = require('../internals/to-length');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var typedArraySpeciesConstructor = require('../internals/typed-array-species-constructor');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.subarray` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.subarray
exportTypedArrayMethod('subarray', function subarray(begin, end) {
    var O = aTypedArray(this);
    var length = O.length;
    var beginIndex = toAbsoluteIndex(begin, length);
    var C = typedArraySpeciesConstructor(O);
    return new C(O.buffer, O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex));
});

},{"../internals/array-buffer-view-core":"7PXuA","../internals/to-length":"bMgmi","../internals/to-absolute-index":"dDgEq","../internals/typed-array-species-constructor":"b4oOp"}],"9YOPt":[function(require,module,exports) {
'use strict';
var global = require('../internals/global');
var apply = require('../internals/function-apply');
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var fails = require('../internals/fails');
var arraySlice = require('../internals/array-slice');
var Int8Array = global.Int8Array;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $toLocaleString = [].toLocaleString;
// iOS Safari 6.x fails here
var TO_LOCALE_STRING_BUG = !!Int8Array && fails(function() {
    $toLocaleString.call(new Int8Array(1));
});
var FORCED = fails(function() {
    return [
        1,
        2
    ].toLocaleString() != new Int8Array([
        1,
        2
    ]).toLocaleString();
}) || !fails(function() {
    Int8Array.prototype.toLocaleString.call([
        1,
        2
    ]);
});
// `%TypedArray%.prototype.toLocaleString` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring
exportTypedArrayMethod('toLocaleString', function toLocaleString() {
    return apply($toLocaleString, TO_LOCALE_STRING_BUG ? arraySlice(aTypedArray(this)) : aTypedArray(this), arraySlice(arguments));
}, FORCED);

},{"../internals/global":"jxPDA","../internals/function-apply":"206oi","../internals/array-buffer-view-core":"7PXuA","../internals/fails":"8IfZQ","../internals/array-slice":"bI1dk"}],"fzEVR":[function(require,module,exports) {
'use strict';
var exportTypedArrayMethod = require('../internals/array-buffer-view-core').exportTypedArrayMethod;
var fails = require('../internals/fails');
var global = require('../internals/global');
var uncurryThis = require('../internals/function-uncurry-this');
var Uint8Array = global.Uint8Array;
var Uint8ArrayPrototype = Uint8Array && Uint8Array.prototype || {
};
var arrayToString = [].toString;
var join = uncurryThis([].join);
if (fails(function() {
    arrayToString.call({
    });
})) arrayToString = function toString() {
    return join(this);
};
var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString;
// `%TypedArray%.prototype.toString` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tostring
exportTypedArrayMethod('toString', arrayToString, IS_NOT_ARRAY_METHOD);

},{"../internals/array-buffer-view-core":"7PXuA","../internals/fails":"8IfZQ","../internals/global":"jxPDA","../internals/function-uncurry-this":"jJnXC"}],"gTLOR":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var uncurryThis = require('../internals/function-uncurry-this');
var toString = require('../internals/to-string');
var fromCharCode = String.fromCharCode;
var charAt = uncurryThis(''.charAt);
var exec = uncurryThis(/./.exec);
var stringSlice = uncurryThis(''.slice);
var hex2 = /^[\da-f]{2}$/i;
var hex4 = /^[\da-f]{4}$/i;
// `unescape` method
// https://tc39.es/ecma262/#sec-unescape-string
$({
    global: true
}, {
    unescape: function unescape(string) {
        var str = toString(string);
        var result = '';
        var length = str.length;
        var index = 0;
        var chr, part;
        while(index < length){
            chr = charAt(str, index++);
            if (chr === '%') {
                if (charAt(str, index) === 'u') {
                    part = stringSlice(str, index + 1, index + 5);
                    if (exec(hex4, part)) {
                        result += fromCharCode(parseInt(part, 16));
                        index += 5;
                        continue;
                    }
                } else {
                    part = stringSlice(str, index, index + 2);
                    if (exec(hex2, part)) {
                        result += fromCharCode(parseInt(part, 16));
                        index += 2;
                        continue;
                    }
                }
            }
            result += chr;
        }
        return result;
    }
});

},{"../internals/export":"8yfGv","../internals/function-uncurry-this":"jJnXC","../internals/to-string":"4cTlm"}],"lEfis":[function(require,module,exports) {
'use strict';
var global = require('../internals/global');
var uncurryThis = require('../internals/function-uncurry-this');
var redefineAll = require('../internals/redefine-all');
var InternalMetadataModule = require('../internals/internal-metadata');
var collection = require('../internals/collection');
var collectionWeak = require('../internals/collection-weak');
var isObject = require('../internals/is-object');
var isExtensible = require('../internals/object-is-extensible');
var enforceInternalState = require('../internals/internal-state').enforce;
var NATIVE_WEAK_MAP = require('../internals/native-weak-map');
var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var InternalWeakMap;
var wrapper = function(init) {
    return function WeakMap() {
        return init(this, arguments.length ? arguments[0] : undefined);
    };
};
// `WeakMap` constructor
// https://tc39.es/ecma262/#sec-weakmap-constructor
var $WeakMap = collection('WeakMap', wrapper, collectionWeak);
// IE11 WeakMap frozen keys fix
// We can't use feature detection because it crash some old IE builds
// https://github.com/zloirock/core-js/issues/485
if (NATIVE_WEAK_MAP && IS_IE11) {
    InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);
    InternalMetadataModule.enable();
    var WeakMapPrototype = $WeakMap.prototype;
    var nativeDelete = uncurryThis(WeakMapPrototype['delete']);
    var nativeHas = uncurryThis(WeakMapPrototype.has);
    var nativeGet = uncurryThis(WeakMapPrototype.get);
    var nativeSet = uncurryThis(WeakMapPrototype.set);
    redefineAll(WeakMapPrototype, {
        'delete': function(key) {
            if (isObject(key) && !isExtensible(key)) {
                var state = enforceInternalState(this);
                if (!state.frozen) state.frozen = new InternalWeakMap();
                return nativeDelete(this, key) || state.frozen['delete'](key);
            }
            return nativeDelete(this, key);
        },
        has: function has(key) {
            if (isObject(key) && !isExtensible(key)) {
                var state = enforceInternalState(this);
                if (!state.frozen) state.frozen = new InternalWeakMap();
                return nativeHas(this, key) || state.frozen.has(key);
            }
            return nativeHas(this, key);
        },
        get: function get(key) {
            if (isObject(key) && !isExtensible(key)) {
                var state = enforceInternalState(this);
                if (!state.frozen) state.frozen = new InternalWeakMap();
                return nativeHas(this, key) ? nativeGet(this, key) : state.frozen.get(key);
            }
            return nativeGet(this, key);
        },
        set: function set(key, value) {
            if (isObject(key) && !isExtensible(key)) {
                var state = enforceInternalState(this);
                if (!state.frozen) state.frozen = new InternalWeakMap();
                nativeHas(this, key) ? nativeSet(this, key, value) : state.frozen.set(key, value);
            } else nativeSet(this, key, value);
            return this;
        }
    });
}

},{"../internals/global":"jxPDA","../internals/function-uncurry-this":"jJnXC","../internals/redefine-all":"ch5Rt","../internals/internal-metadata":"fD10R","../internals/collection":"g8aLF","../internals/collection-weak":"jVw7W","../internals/is-object":"dplrD","../internals/object-is-extensible":"eApj6","../internals/internal-state":"i6AaM","../internals/native-weak-map":"3Q3X6"}],"jVw7W":[function(require,module,exports) {
'use strict';
var uncurryThis = require('../internals/function-uncurry-this');
var redefineAll = require('../internals/redefine-all');
var getWeakData = require('../internals/internal-metadata').getWeakData;
var anObject = require('../internals/an-object');
var isObject = require('../internals/is-object');
var anInstance = require('../internals/an-instance');
var iterate = require('../internals/iterate');
var ArrayIterationModule = require('../internals/array-iteration');
var hasOwn = require('../internals/has-own-property');
var InternalStateModule = require('../internals/internal-state');
var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;
var find = ArrayIterationModule.find;
var findIndex = ArrayIterationModule.findIndex;
var splice = uncurryThis([].splice);
var id = 0;
// fallback for uncaught frozen keys
var uncaughtFrozenStore = function(store) {
    return store.frozen || (store.frozen = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function() {
    this.entries = [];
};
var findUncaughtFrozen = function(store, key) {
    return find(store.entries, function(it) {
        return it[0] === key;
    });
};
UncaughtFrozenStore.prototype = {
    get: function(key) {
        var entry = findUncaughtFrozen(this, key);
        if (entry) return entry[1];
    },
    has: function(key) {
        return !!findUncaughtFrozen(this, key);
    },
    set: function(key, value) {
        var entry = findUncaughtFrozen(this, key);
        if (entry) entry[1] = value;
        else this.entries.push([
            key,
            value
        ]);
    },
    'delete': function(key) {
        var index = findIndex(this.entries, function(it) {
            return it[0] === key;
        });
        if (~index) splice(this.entries, index, 1);
        return !!~index;
    }
};
module.exports = {
    getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
        var Constructor = wrapper(function(that, iterable) {
            anInstance(that, Prototype);
            setInternalState(that, {
                type: CONSTRUCTOR_NAME,
                id: id++,
                frozen: undefined
            });
            if (iterable != undefined) iterate(iterable, that[ADDER], {
                that: that,
                AS_ENTRIES: IS_MAP
            });
        });
        var Prototype = Constructor.prototype;
        var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
        var define = function(that, key, value) {
            var state = getInternalState(that);
            var data = getWeakData(anObject(key), true);
            if (data === true) uncaughtFrozenStore(state).set(key, value);
            else data[state.id] = value;
            return that;
        };
        redefineAll(Prototype, {
            // `{ WeakMap, WeakSet }.prototype.delete(key)` methods
            // https://tc39.es/ecma262/#sec-weakmap.prototype.delete
            // https://tc39.es/ecma262/#sec-weakset.prototype.delete
            'delete': function(key) {
                var state = getInternalState(this);
                if (!isObject(key)) return false;
                var data = getWeakData(key);
                if (data === true) return uncaughtFrozenStore(state)['delete'](key);
                return data && hasOwn(data, state.id) && delete data[state.id];
            },
            // `{ WeakMap, WeakSet }.prototype.has(key)` methods
            // https://tc39.es/ecma262/#sec-weakmap.prototype.has
            // https://tc39.es/ecma262/#sec-weakset.prototype.has
            has: function has(key) {
                var state = getInternalState(this);
                if (!isObject(key)) return false;
                var data = getWeakData(key);
                if (data === true) return uncaughtFrozenStore(state).has(key);
                return data && hasOwn(data, state.id);
            }
        });
        redefineAll(Prototype, IS_MAP ? {
            // `WeakMap.prototype.get(key)` method
            // https://tc39.es/ecma262/#sec-weakmap.prototype.get
            get: function get(key) {
                var state = getInternalState(this);
                if (isObject(key)) {
                    var data = getWeakData(key);
                    if (data === true) return uncaughtFrozenStore(state).get(key);
                    return data ? data[state.id] : undefined;
                }
            },
            // `WeakMap.prototype.set(key, value)` method
            // https://tc39.es/ecma262/#sec-weakmap.prototype.set
            set: function set(key, value) {
                return define(this, key, value);
            }
        } : {
            // `WeakSet.prototype.add(value)` method
            // https://tc39.es/ecma262/#sec-weakset.prototype.add
            add: function add(value) {
                return define(this, value, true);
            }
        });
        return Constructor;
    }
};

},{"../internals/function-uncurry-this":"jJnXC","../internals/redefine-all":"ch5Rt","../internals/internal-metadata":"fD10R","../internals/an-object":"1LIz9","../internals/is-object":"dplrD","../internals/an-instance":"2zeQg","../internals/iterate":"fTyka","../internals/array-iteration":"8a6lB","../internals/has-own-property":"3ZdUC","../internals/internal-state":"i6AaM"}],"cSvCc":[function(require,module,exports) {
'use strict';
var collection = require('../internals/collection');
var collectionWeak = require('../internals/collection-weak');
// `WeakSet` constructor
// https://tc39.es/ecma262/#sec-weakset-constructor
collection('WeakSet', function(init) {
    return function WeakSet() {
        return init(this, arguments.length ? arguments[0] : undefined);
    };
}, collectionWeak);

},{"../internals/collection":"g8aLF","../internals/collection-weak":"jVw7W"}],"70EYB":[function(require,module,exports) {
// TODO: Remove from `core-js@4`
require('../modules/es.aggregate-error');

},{"../modules/es.aggregate-error":"j0Eys"}],"ktLIO":[function(require,module,exports) {
var $ = require('../internals/export');
var fromAsync = require('../internals/array-from-async');
// `Array.fromAsync` method
// https://github.com/tc39/proposal-array-from-async
$({
    target: 'Array',
    stat: true
}, {
    fromAsync: fromAsync
});

},{"../internals/export":"8yfGv","../internals/array-from-async":"bWWh7"}],"bWWh7":[function(require,module,exports) {
'use strict';
var bind = require('../internals/function-bind-context');
var toObject = require('../internals/to-object');
var isConstructor = require('../internals/is-constructor');
var getAsyncIterator = require('../internals/get-async-iterator');
var getIterator = require('../internals/get-iterator');
var getIteratorMethod = require('../internals/get-iterator-method');
var getMethod = require('../internals/get-method');
var getVirtual = require('../internals/entry-virtual');
var getBuiltIn = require('../internals/get-built-in');
var wellKnownSymbol = require('../internals/well-known-symbol');
var AsyncFromSyncIterator = require('../internals/async-from-sync-iterator');
var toArray = require('../internals/async-iterator-iteration').toArray;
var ASYNC_ITERATOR = wellKnownSymbol('asyncIterator');
var arrayIterator = getVirtual('Array').values;
// `Array.fromAsync` method implementation
// https://github.com/tc39/proposal-array-from-async
module.exports = function fromAsync(asyncItems /* , mapfn = undefined, thisArg = undefined */ ) {
    var C = this;
    var argumentsLength = arguments.length;
    var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
    var thisArg = argumentsLength > 2 ? arguments[2] : undefined;
    return new (getBuiltIn('Promise'))(function(resolve) {
        var O = toObject(asyncItems);
        if (mapfn !== undefined) mapfn = bind(mapfn, thisArg);
        var usingAsyncIterator = getMethod(O, ASYNC_ITERATOR);
        var usingSyncIterator = usingAsyncIterator ? undefined : getIteratorMethod(O) || arrayIterator;
        var A = isConstructor(C) ? new C() : [];
        var iterator = usingAsyncIterator ? getAsyncIterator(O, usingAsyncIterator) : new AsyncFromSyncIterator(getIterator(O, usingSyncIterator));
        resolve(toArray(iterator, mapfn, A));
    });
};

},{"../internals/function-bind-context":"kZubc","../internals/to-object":"eEdae","../internals/is-constructor":"iNoNi","../internals/get-async-iterator":"sRWY3","../internals/get-iterator":"dQrLE","../internals/get-iterator-method":"5CTSY","../internals/get-method":"hEJ6b","../internals/entry-virtual":"59ha4","../internals/get-built-in":"78arb","../internals/well-known-symbol":"5C8sm","../internals/async-from-sync-iterator":"51v3w","../internals/async-iterator-iteration":"7OKbn"}],"sRWY3":[function(require,module,exports) {
var call = require('../internals/function-call');
var AsyncFromSyncIterator = require('../internals/async-from-sync-iterator');
var anObject = require('../internals/an-object');
var getIterator = require('../internals/get-iterator');
var getMethod = require('../internals/get-method');
var wellKnownSymbol = require('../internals/well-known-symbol');
var ASYNC_ITERATOR = wellKnownSymbol('asyncIterator');
module.exports = function(it, usingIterator) {
    var method = arguments.length < 2 ? getMethod(it, ASYNC_ITERATOR) : usingIterator;
    return method ? anObject(call(method, it)) : new AsyncFromSyncIterator(getIterator(it));
};

},{"../internals/function-call":"jhLed","../internals/async-from-sync-iterator":"51v3w","../internals/an-object":"1LIz9","../internals/get-iterator":"dQrLE","../internals/get-method":"hEJ6b","../internals/well-known-symbol":"5C8sm"}],"51v3w":[function(require,module,exports) {
'use strict';
var apply = require('../internals/function-apply');
var anObject = require('../internals/an-object');
var create = require('../internals/object-create');
var getMethod = require('../internals/get-method');
var redefineAll = require('../internals/redefine-all');
var InternalStateModule = require('../internals/internal-state');
var getBuiltIn = require('../internals/get-built-in');
var AsyncIteratorPrototype = require('../internals/async-iterator-prototype');
var Promise = getBuiltIn('Promise');
var ASYNC_FROM_SYNC_ITERATOR = 'AsyncFromSyncIterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ASYNC_FROM_SYNC_ITERATOR);
var asyncFromSyncIteratorContinuation = function(result, resolve, reject) {
    var done = result.done;
    Promise.resolve(result.value).then(function(value) {
        resolve({
            done: done,
            value: value
        });
    }, reject);
};
var AsyncFromSyncIterator = function AsyncIterator(iterator) {
    setInternalState(this, {
        type: ASYNC_FROM_SYNC_ITERATOR,
        iterator: anObject(iterator),
        next: iterator.next
    });
};
AsyncFromSyncIterator.prototype = redefineAll(create(AsyncIteratorPrototype), {
    next: function next(arg) {
        var state = getInternalState(this);
        var hasArg = !!arguments.length;
        return new Promise(function(resolve, reject) {
            var result = anObject(apply(state.next, state.iterator, hasArg ? [
                arg
            ] : []));
            asyncFromSyncIteratorContinuation(result, resolve, reject);
        });
    },
    'return': function(arg) {
        var iterator = getInternalState(this).iterator;
        var hasArg = !!arguments.length;
        return new Promise(function(resolve, reject) {
            var $return = getMethod(iterator, 'return');
            if ($return === undefined) return resolve({
                done: true,
                value: arg
            });
            var result = anObject(apply($return, iterator, hasArg ? [
                arg
            ] : []));
            asyncFromSyncIteratorContinuation(result, resolve, reject);
        });
    },
    'throw': function(arg) {
        var iterator = getInternalState(this).iterator;
        var hasArg = !!arguments.length;
        return new Promise(function(resolve, reject) {
            var $throw = getMethod(iterator, 'throw');
            if ($throw === undefined) return reject(arg);
            var result = anObject(apply($throw, iterator, hasArg ? [
                arg
            ] : []));
            asyncFromSyncIteratorContinuation(result, resolve, reject);
        });
    }
});
module.exports = AsyncFromSyncIterator;

},{"../internals/function-apply":"206oi","../internals/an-object":"1LIz9","../internals/object-create":"1As5O","../internals/get-method":"hEJ6b","../internals/redefine-all":"ch5Rt","../internals/internal-state":"i6AaM","../internals/get-built-in":"78arb","../internals/async-iterator-prototype":"3NvMm"}],"3NvMm":[function(require,module,exports) {
var global = require('../internals/global');
var shared = require('../internals/shared-store');
var isCallable = require('../internals/is-callable');
var create = require('../internals/object-create');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var redefine = require('../internals/redefine');
var wellKnownSymbol = require('../internals/well-known-symbol');
var IS_PURE = require('../internals/is-pure');
var USE_FUNCTION_CONSTRUCTOR = 'USE_FUNCTION_CONSTRUCTOR';
var ASYNC_ITERATOR = wellKnownSymbol('asyncIterator');
var AsyncIterator = global.AsyncIterator;
var PassedAsyncIteratorPrototype = shared.AsyncIteratorPrototype;
var AsyncIteratorPrototype, prototype;
if (PassedAsyncIteratorPrototype) AsyncIteratorPrototype = PassedAsyncIteratorPrototype;
else if (isCallable(AsyncIterator)) AsyncIteratorPrototype = AsyncIterator.prototype;
else if (shared[USE_FUNCTION_CONSTRUCTOR] || global[USE_FUNCTION_CONSTRUCTOR]) try {
    // eslint-disable-next-line no-new-func -- we have no alternatives without usage of modern syntax
    prototype = getPrototypeOf(getPrototypeOf(getPrototypeOf(Function('return async function*(){}()')())));
    if (getPrototypeOf(prototype) === Object.prototype) AsyncIteratorPrototype = prototype;
} catch (error) {
}
if (!AsyncIteratorPrototype) AsyncIteratorPrototype = {
};
else if (IS_PURE) AsyncIteratorPrototype = create(AsyncIteratorPrototype);
if (!isCallable(AsyncIteratorPrototype[ASYNC_ITERATOR])) redefine(AsyncIteratorPrototype, ASYNC_ITERATOR, function() {
    return this;
});
module.exports = AsyncIteratorPrototype;

},{"../internals/global":"jxPDA","../internals/shared-store":"3QdEO","../internals/is-callable":"kPhuP","../internals/object-create":"1As5O","../internals/object-get-prototype-of":"lBy7h","../internals/redefine":"kxbj8","../internals/well-known-symbol":"5C8sm","../internals/is-pure":"6Bbq0"}],"59ha4":[function(require,module,exports) {
var global = require('../internals/global');
module.exports = function(CONSTRUCTOR) {
    return global[CONSTRUCTOR].prototype;
};

},{"../internals/global":"jxPDA"}],"7OKbn":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
// https://github.com/tc39/proposal-array-from-async
var global = require('../internals/global');
var call = require('../internals/function-call');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
var getBuiltIn = require('../internals/get-built-in');
var getMethod = require('../internals/get-method');
var MAX_SAFE_INTEGER = 9007199254740991;
var TypeError = global.TypeError;
var createMethod = function(TYPE) {
    var IS_TO_ARRAY = TYPE == 0;
    var IS_FOR_EACH = TYPE == 1;
    var IS_EVERY = TYPE == 2;
    var IS_SOME = TYPE == 3;
    return function(iterator, fn, target) {
        anObject(iterator);
        var Promise = getBuiltIn('Promise');
        var next = aCallable(iterator.next);
        var index = 0;
        var MAPPING = fn !== undefined;
        if (MAPPING || !IS_TO_ARRAY) aCallable(fn);
        return new Promise(function(resolve, reject) {
            var closeIteration = function(method, argument) {
                try {
                    var returnMethod = getMethod(iterator, 'return');
                    if (returnMethod) return Promise.resolve(call(returnMethod, iterator)).then(function() {
                        method(argument);
                    }, function(error) {
                        reject(error);
                    });
                } catch (error2) {
                    return reject(error2);
                }
                method(argument);
            };
            var onError = function(error) {
                closeIteration(reject, error);
            };
            var loop = function() {
                try {
                    if (IS_TO_ARRAY && index > MAX_SAFE_INTEGER && MAPPING) throw TypeError('The allowed number of iterations has been exceeded');
                    Promise.resolve(anObject(call(next, iterator))).then(function(step) {
                        try {
                            if (anObject(step).done) {
                                if (IS_TO_ARRAY) {
                                    target.length = index;
                                    resolve(target);
                                } else resolve(IS_SOME ? false : IS_EVERY || undefined);
                            } else {
                                var value = step.value;
                                if (MAPPING) Promise.resolve(IS_TO_ARRAY ? fn(value, index) : fn(value)).then(function(result) {
                                    if (IS_FOR_EACH) loop();
                                    else if (IS_EVERY) result ? loop() : closeIteration(resolve, false);
                                    else if (IS_TO_ARRAY) {
                                        target[index++] = result;
                                        loop();
                                    } else result ? closeIteration(resolve, IS_SOME || value) : loop();
                                }, onError);
                                else {
                                    target[index++] = value;
                                    loop();
                                }
                            }
                        } catch (error) {
                            onError(error);
                        }
                    }, onError);
                } catch (error2) {
                    onError(error2);
                }
            };
            loop();
        });
    };
};
module.exports = {
    toArray: createMethod(0),
    forEach: createMethod(1),
    every: createMethod(2),
    some: createMethod(3),
    find: createMethod(4)
};

},{"../internals/global":"jxPDA","../internals/function-call":"jhLed","../internals/a-callable":"83opn","../internals/an-object":"1LIz9","../internals/get-built-in":"78arb","../internals/get-method":"hEJ6b"}],"di5CS":[function(require,module,exports) {
// TODO: Remove from `core-js@4`
require('../modules/es.array.at');

},{"../modules/es.array.at":"jo7av"}],"ccrhr":[function(require,module,exports) {
'use strict';
// TODO: remove from `core-js@4`
var $ = require('../internals/export');
var $filterReject = require('../internals/array-iteration').filterReject;
var addToUnscopables = require('../internals/add-to-unscopables');
// `Array.prototype.filterOut` method
// https://github.com/tc39/proposal-array-filtering
$({
    target: 'Array',
    proto: true
}, {
    filterOut: function filterOut(callbackfn /* , thisArg */ ) {
        return $filterReject(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
});
addToUnscopables('filterOut');

},{"../internals/export":"8yfGv","../internals/array-iteration":"8a6lB","../internals/add-to-unscopables":"icGQt"}],"4e7QK":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $filterReject = require('../internals/array-iteration').filterReject;
var addToUnscopables = require('../internals/add-to-unscopables');
// `Array.prototype.filterReject` method
// https://github.com/tc39/proposal-array-filtering
$({
    target: 'Array',
    proto: true
}, {
    filterReject: function filterReject(callbackfn /* , thisArg */ ) {
        return $filterReject(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
});
addToUnscopables('filterReject');

},{"../internals/export":"8yfGv","../internals/array-iteration":"8a6lB","../internals/add-to-unscopables":"icGQt"}],"62TqK":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $findLast = require('../internals/array-iteration-from-last').findLast;
var addToUnscopables = require('../internals/add-to-unscopables');
// `Array.prototype.findLast` method
// https://github.com/tc39/proposal-array-find-from-last
$({
    target: 'Array',
    proto: true
}, {
    findLast: function findLast(callbackfn /* , that = undefined */ ) {
        return $findLast(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
});
addToUnscopables('findLast');

},{"../internals/export":"8yfGv","../internals/array-iteration-from-last":"l7T6K","../internals/add-to-unscopables":"icGQt"}],"l7T6K":[function(require,module,exports) {
var bind = require('../internals/function-bind-context');
var IndexedObject = require('../internals/indexed-object');
var toObject = require('../internals/to-object');
var lengthOfArrayLike = require('../internals/length-of-array-like');
// `Array.prototype.{ findLast, findLastIndex }` methods implementation
var createMethod = function(TYPE) {
    var IS_FIND_LAST_INDEX = TYPE == 1;
    return function($this, callbackfn, that) {
        var O = toObject($this);
        var self = IndexedObject(O);
        var boundFunction = bind(callbackfn, that);
        var index = lengthOfArrayLike(self);
        var value, result;
        while(index-- > 0){
            value = self[index];
            result = boundFunction(value, index, O);
            if (result) switch(TYPE){
                case 0:
                    return value; // findLast
                case 1:
                    return index; // findLastIndex
            }
        }
        return IS_FIND_LAST_INDEX ? -1 : undefined;
    };
};
module.exports = {
    // `Array.prototype.findLast` method
    // https://github.com/tc39/proposal-array-find-from-last
    findLast: createMethod(0),
    // `Array.prototype.findLastIndex` method
    // https://github.com/tc39/proposal-array-find-from-last
    findLastIndex: createMethod(1)
};

},{"../internals/function-bind-context":"kZubc","../internals/indexed-object":"e5ccT","../internals/to-object":"eEdae","../internals/length-of-array-like":"afDy6"}],"cpUL5":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $findLastIndex = require('../internals/array-iteration-from-last').findLastIndex;
var addToUnscopables = require('../internals/add-to-unscopables');
// `Array.prototype.findLastIndex` method
// https://github.com/tc39/proposal-array-find-from-last
$({
    target: 'Array',
    proto: true
}, {
    findLastIndex: function findLastIndex(callbackfn /* , that = undefined */ ) {
        return $findLastIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
});
addToUnscopables('findLastIndex');

},{"../internals/export":"8yfGv","../internals/array-iteration-from-last":"l7T6K","../internals/add-to-unscopables":"icGQt"}],"9Ud4n":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var $groupBy = require('../internals/array-group-by');
var addToUnscopables = require('../internals/add-to-unscopables');
// `Array.prototype.groupBy` method
// https://github.com/tc39/proposal-array-grouping
$({
    target: 'Array',
    proto: true
}, {
    groupBy: function groupBy(callbackfn /* , thisArg */ ) {
        var thisArg = arguments.length > 1 ? arguments[1] : undefined;
        return $groupBy(this, callbackfn, thisArg);
    }
});
addToUnscopables('groupBy');

},{"../internals/export":"8yfGv","../internals/array-group-by":"5d7IU","../internals/add-to-unscopables":"icGQt"}],"5d7IU":[function(require,module,exports) {
var global = require('../internals/global');
var bind = require('../internals/function-bind-context');
var uncurryThis = require('../internals/function-uncurry-this');
var IndexedObject = require('../internals/indexed-object');
var toObject = require('../internals/to-object');
var toPropertyKey = require('../internals/to-property-key');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var objectCreate = require('../internals/object-create');
var arrayFromConstructorAndList = require('../internals/array-from-constructor-and-list');
var Array = global.Array;
var push = uncurryThis([].push);
module.exports = function($this, callbackfn, that, specificConstructor) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that);
    var target = objectCreate(null);
    var length = lengthOfArrayLike(self);
    var index = 0;
    var Constructor, key, value;
    for(; length > index; index++){
        value = self[index];
        key = toPropertyKey(boundFunction(value, index, O));
        // in some IE10 builds, `hasOwnProperty` returns incorrect result on integer keys
        // but since it's a `null` prototype object, we can safely use `in`
        if (key in target) push(target[key], value);
        else target[key] = [
            value
        ];
    }
    // TODO: Remove this block from `core-js@4`
    if (specificConstructor) {
        Constructor = specificConstructor(O);
        if (Constructor !== Array) for(key in target)target[key] = arrayFromConstructorAndList(Constructor, target[key]);
    }
    return target;
};

},{"../internals/global":"jxPDA","../internals/function-bind-context":"kZubc","../internals/function-uncurry-this":"jJnXC","../internals/indexed-object":"e5ccT","../internals/to-object":"eEdae","../internals/to-property-key":"bMDpS","../internals/length-of-array-like":"afDy6","../internals/object-create":"1As5O","../internals/array-from-constructor-and-list":"5X1AQ"}],"gyeat":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var getBuiltIn = require('../internals/get-built-in');
var bind = require('../internals/function-bind-context');
var uncurryThis = require('../internals/function-uncurry-this');
var IndexedObject = require('../internals/indexed-object');
var toObject = require('../internals/to-object');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var addToUnscopables = require('../internals/add-to-unscopables');
var Map = getBuiltIn('Map');
var MapPrototype = Map.prototype;
var mapGet = uncurryThis(MapPrototype.get);
var mapHas = uncurryThis(MapPrototype.has);
var mapSet = uncurryThis(MapPrototype.set);
var push = uncurryThis([].push);
// `Array.prototype.groupByToMap` method
// https://github.com/tc39/proposal-array-grouping
$({
    target: 'Array',
    proto: true
}, {
    groupByToMap: function groupByToMap(callbackfn /* , thisArg */ ) {
        var O = toObject(this);
        var self = IndexedObject(O);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        var map = new Map();
        var length = lengthOfArrayLike(self);
        var index = 0;
        var key, value;
        for(; length > index; index++){
            value = self[index];
            key = boundFunction(value, index, O);
            if (mapHas(map, key)) push(mapGet(map, key), value);
            else mapSet(map, key, [
                value
            ]);
        }
        return map;
    }
});
addToUnscopables('groupByToMap');

},{"../internals/export":"8yfGv","../internals/get-built-in":"78arb","../internals/function-bind-context":"kZubc","../internals/function-uncurry-this":"jJnXC","../internals/indexed-object":"e5ccT","../internals/to-object":"eEdae","../internals/length-of-array-like":"afDy6","../internals/add-to-unscopables":"icGQt"}],"g7cAj":[function(require,module,exports) {
var $ = require('../internals/export');
var isArray = require('../internals/is-array');
// eslint-disable-next-line es/no-object-isfrozen -- safe
var isFrozen = Object.isFrozen;
var isFrozenStringArray = function(array, allowUndefined) {
    if (!isFrozen || !isArray(array) || !isFrozen(array)) return false;
    var index = 0;
    var length = array.length;
    var element;
    while(index < length){
        element = array[index++];
        if (!(typeof element == 'string' || allowUndefined && typeof element == 'undefined')) return false;
    }
    return length !== 0;
};
// `Array.isTemplateObject` method
// https://github.com/tc39/proposal-array-is-template-object
$({
    target: 'Array',
    stat: true
}, {
    isTemplateObject: function isTemplateObject(value) {
        if (!isFrozenStringArray(value, true)) return false;
        var raw = value.raw;
        if (raw.length !== value.length || !isFrozenStringArray(raw, false)) return false;
        return true;
    }
});

},{"../internals/export":"8yfGv","../internals/is-array":"gN5mt"}],"6p2xc":[function(require,module,exports) {
'use strict';
var DESCRIPTORS = require('../internals/descriptors');
var addToUnscopables = require('../internals/add-to-unscopables');
var toObject = require('../internals/to-object');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var defineProperty = require('../internals/object-define-property').f;
// `Array.prototype.lastIndex` getter
// https://github.com/keithamus/proposal-array-last
if (DESCRIPTORS && !('lastIndex' in [])) {
    defineProperty(Array.prototype, 'lastIndex', {
        configurable: true,
        get: function lastIndex() {
            var O = toObject(this);
            var len = lengthOfArrayLike(O);
            return len == 0 ? 0 : len - 1;
        }
    });
    addToUnscopables('lastIndex');
}

},{"../internals/descriptors":"6ZLib","../internals/add-to-unscopables":"icGQt","../internals/to-object":"eEdae","../internals/length-of-array-like":"afDy6","../internals/object-define-property":"bauTd"}],"4kVea":[function(require,module,exports) {
'use strict';
var DESCRIPTORS = require('../internals/descriptors');
var addToUnscopables = require('../internals/add-to-unscopables');
var toObject = require('../internals/to-object');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var defineProperty = require('../internals/object-define-property').f;
// `Array.prototype.lastIndex` accessor
// https://github.com/keithamus/proposal-array-last
if (DESCRIPTORS && !('lastItem' in [])) {
    defineProperty(Array.prototype, 'lastItem', {
        configurable: true,
        get: function lastItem() {
            var O = toObject(this);
            var len = lengthOfArrayLike(O);
            return len == 0 ? undefined : O[len - 1];
        },
        set: function lastItem(value) {
            var O = toObject(this);
            var len = lengthOfArrayLike(O);
            return O[len == 0 ? 0 : len - 1] = value;
        }
    });
    addToUnscopables('lastItem');
}

},{"../internals/descriptors":"6ZLib","../internals/add-to-unscopables":"icGQt","../internals/to-object":"eEdae","../internals/length-of-array-like":"afDy6","../internals/object-define-property":"bauTd"}],"gV8bc":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var global = require('../internals/global');
var arrayToReversed = require('../internals/array-to-reversed');
var toIndexedObject = require('../internals/to-indexed-object');
var addToUnscopables = require('../internals/add-to-unscopables');
var Array = global.Array;
// `Array.prototype.toReversed` method
// https://tc39.es/proposal-change-array-by-copy/#sec-array.prototype.toReversed
$({
    target: 'Array',
    proto: true
}, {
    toReversed: function toReversed() {
        return arrayToReversed(toIndexedObject(this), Array);
    }
});
addToUnscopables('toReversed');

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/array-to-reversed":"4JI26","../internals/to-indexed-object":"8ueFu","../internals/add-to-unscopables":"icGQt"}],"4JI26":[function(require,module,exports) {
var lengthOfArrayLike = require('../internals/length-of-array-like');
// https://tc39.es/proposal-change-array-by-copy/#sec-array.prototype.toReversed
// https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.toReversed
module.exports = function(O, C) {
    var len = lengthOfArrayLike(O);
    var A = new C(len);
    var k = 0;
    for(; k < len; k++)A[k] = O[len - k - 1];
    return A;
};

},{"../internals/length-of-array-like":"afDy6"}],"3ivwY":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var global = require('../internals/global');
var uncurryThis = require('../internals/function-uncurry-this');
var aCallable = require('../internals/a-callable');
var toIndexedObject = require('../internals/to-indexed-object');
var arrayFromConstructorAndList = require('../internals/array-from-constructor-and-list');
var getVirtual = require('../internals/entry-virtual');
var addToUnscopables = require('../internals/add-to-unscopables');
var Array = global.Array;
var sort = uncurryThis(getVirtual('Array').sort);
// `Array.prototype.toSorted` method
// https://tc39.es/proposal-change-array-by-copy/#sec-array.prototype.toSorted
$({
    target: 'Array',
    proto: true
}, {
    toSorted: function toSorted(compareFn) {
        if (compareFn !== undefined) aCallable(compareFn);
        var O = toIndexedObject(this);
        var A = arrayFromConstructorAndList(Array, O);
        return sort(A, compareFn);
    }
});
addToUnscopables('toSorted');

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/function-uncurry-this":"jJnXC","../internals/a-callable":"83opn","../internals/to-indexed-object":"8ueFu","../internals/array-from-constructor-and-list":"5X1AQ","../internals/entry-virtual":"59ha4","../internals/add-to-unscopables":"icGQt"}],"g115k":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var global = require('../internals/global');
var toIndexedObject = require('../internals/to-indexed-object');
var arraySlice = require('../internals/array-slice');
var arrayToSpliced = require('../internals/array-to-spliced');
var addToUnscopables = require('../internals/add-to-unscopables');
var Array = global.Array;
// `Array.prototype.toSpliced` method
// https://tc39.es/proposal-change-array-by-copy/#sec-array.prototype.toSpliced
$({
    target: 'Array',
    proto: true
}, {
    // eslint-disable-next-line no-unused-vars -- required for .length
    toSpliced: function toSpliced(start, deleteCount /* , ...items */ ) {
        return arrayToSpliced(toIndexedObject(this), Array, arraySlice(arguments));
    }
});
addToUnscopables('toSpliced');

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/to-indexed-object":"8ueFu","../internals/array-slice":"bI1dk","../internals/array-to-spliced":"5dGtj","../internals/add-to-unscopables":"icGQt"}],"5dGtj":[function(require,module,exports) {
var lengthOfArrayLike = require('../internals/length-of-array-like');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
var max = Math.max;
var min = Math.min;
// https://tc39.es/proposal-change-array-by-copy/#sec-array.prototype.toSpliced
// https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.toSpliced
module.exports = function(O, C, args) {
    var start = args[0];
    var deleteCount = args[1];
    var len = lengthOfArrayLike(O);
    var actualStart = toAbsoluteIndex(start, len);
    var argumentsLength = args.length;
    var k = 0;
    var insertCount, actualDeleteCount, newLen, A;
    if (argumentsLength === 0) insertCount = actualDeleteCount = 0;
    else if (argumentsLength === 1) {
        insertCount = 0;
        actualDeleteCount = len - actualStart;
    } else {
        insertCount = argumentsLength - 2;
        actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
    }
    newLen = len + insertCount - actualDeleteCount;
    A = new C(newLen);
    for(; k < actualStart; k++)A[k] = O[k];
    for(; k < actualStart + insertCount; k++)A[k] = args[k - actualStart + 2];
    for(; k < newLen; k++)A[k] = O[k + actualDeleteCount - insertCount];
    return A;
};

},{"../internals/length-of-array-like":"afDy6","../internals/to-absolute-index":"dDgEq","../internals/to-integer-or-infinity":"aqyxv"}],"7d8QQ":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var addToUnscopables = require('../internals/add-to-unscopables');
var uniqueBy = require('../internals/array-unique-by');
// `Array.prototype.uniqueBy` method
// https://github.com/tc39/proposal-array-unique
$({
    target: 'Array',
    proto: true
}, {
    uniqueBy: uniqueBy
});
addToUnscopables('uniqueBy');

},{"../internals/export":"8yfGv","../internals/add-to-unscopables":"icGQt","../internals/array-unique-by":"43InR"}],"43InR":[function(require,module,exports) {
'use strict';
var getBuiltIn = require('../internals/get-built-in');
var uncurryThis = require('../internals/function-uncurry-this');
var aCallable = require('../internals/a-callable');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var toObject = require('../internals/to-object');
var arraySpeciesCreate = require('../internals/array-species-create');
var Map = getBuiltIn('Map');
var MapPrototype = Map.prototype;
var mapForEach = uncurryThis(MapPrototype.forEach);
var mapHas = uncurryThis(MapPrototype.has);
var mapSet = uncurryThis(MapPrototype.set);
var push = uncurryThis([].push);
// `Array.prototype.uniqueBy` method
// https://github.com/tc39/proposal-array-unique
module.exports = function uniqueBy(resolver) {
    var that = toObject(this);
    var length = lengthOfArrayLike(that);
    var result = arraySpeciesCreate(that, 0);
    var map = new Map();
    var resolverFunction = resolver != null ? aCallable(resolver) : function(value) {
        return value;
    };
    var index, item, key;
    for(index = 0; index < length; index++){
        item = that[index];
        key = resolverFunction(item);
        if (!mapHas(map, key)) mapSet(map, key, item);
    }
    mapForEach(map, function(value) {
        push(result, value);
    });
    return result;
};

},{"../internals/get-built-in":"78arb","../internals/function-uncurry-this":"jJnXC","../internals/a-callable":"83opn","../internals/length-of-array-like":"afDy6","../internals/to-object":"eEdae","../internals/array-species-create":"dEli4"}],"lsRPZ":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var global = require('../internals/global');
var arrayWith = require('../internals/array-with');
var toIndexedObject = require('../internals/to-indexed-object');
var Array = global.Array;
// `Array.prototype.with` method
// https://tc39.es/proposal-change-array-by-copy/#sec-array.prototype.with
$({
    target: 'Array',
    proto: true
}, {
    'with': function(index, value) {
        return arrayWith(toIndexedObject(this), Array, index, value);
    }
});

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/array-with":"5bUpU","../internals/to-indexed-object":"8ueFu"}],"5bUpU":[function(require,module,exports) {
var global = require('../internals/global');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
var RangeError = global.RangeError;
// https://tc39.es/proposal-change-array-by-copy/#sec-array.prototype.with
// https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.with
module.exports = function(O, C, index, value) {
    var len = lengthOfArrayLike(O);
    var relativeIndex = toIntegerOrInfinity(index);
    var actualIndex = relativeIndex < 0 ? len + relativeIndex : relativeIndex;
    if (actualIndex >= len || actualIndex < 0) throw RangeError('Incorrect index');
    var A = new C(len);
    var k = 0;
    for(; k < len; k++)A[k] = k === actualIndex ? value : O[k];
    return A;
};

},{"../internals/global":"jxPDA","../internals/length-of-array-like":"afDy6","../internals/to-integer-or-infinity":"aqyxv"}],"eMV4r":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var anInstance = require('../internals/an-instance');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var hasOwn = require('../internals/has-own-property');
var wellKnownSymbol = require('../internals/well-known-symbol');
var AsyncIteratorPrototype = require('../internals/async-iterator-prototype');
var IS_PURE = require('../internals/is-pure');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var AsyncIteratorConstructor = function AsyncIterator() {
    anInstance(this, AsyncIteratorPrototype);
};
AsyncIteratorConstructor.prototype = AsyncIteratorPrototype;
if (!hasOwn(AsyncIteratorPrototype, TO_STRING_TAG)) createNonEnumerableProperty(AsyncIteratorPrototype, TO_STRING_TAG, 'AsyncIterator');
if (IS_PURE || !hasOwn(AsyncIteratorPrototype, 'constructor') || AsyncIteratorPrototype.constructor === Object) createNonEnumerableProperty(AsyncIteratorPrototype, 'constructor', AsyncIteratorConstructor);
$({
    global: true,
    forced: IS_PURE
}, {
    AsyncIterator: AsyncIteratorConstructor
});

},{"../internals/export":"8yfGv","../internals/an-instance":"2zeQg","../internals/create-non-enumerable-property":"6Z1es","../internals/has-own-property":"3ZdUC","../internals/well-known-symbol":"5C8sm","../internals/async-iterator-prototype":"3NvMm","../internals/is-pure":"6Bbq0"}],"1TCwH":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var apply = require('../internals/function-apply');
var anObject = require('../internals/an-object');
var createAsyncIteratorProxy = require('../internals/async-iterator-create-proxy');
var AsyncIteratorProxy = createAsyncIteratorProxy(function(Promise, args) {
    var state = this;
    var iterator = state.iterator;
    return Promise.resolve(anObject(apply(state.next, iterator, args))).then(function(step) {
        if (anObject(step).done) {
            state.done = true;
            return {
                done: true,
                value: undefined
            };
        }
        return {
            done: false,
            value: [
                state.index++,
                step.value
            ]
        };
    });
});
$({
    target: 'AsyncIterator',
    proto: true,
    real: true
}, {
    asIndexedPairs: function asIndexedPairs() {
        return new AsyncIteratorProxy({
            iterator: anObject(this),
            index: 0
        });
    }
});

},{"../internals/export":"8yfGv","../internals/function-apply":"206oi","../internals/an-object":"1LIz9","../internals/async-iterator-create-proxy":"1bDzF"}],"1bDzF":[function(require,module,exports) {
'use strict';
var call = require('../internals/function-call');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
var create = require('../internals/object-create');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var redefineAll = require('../internals/redefine-all');
var wellKnownSymbol = require('../internals/well-known-symbol');
var InternalStateModule = require('../internals/internal-state');
var getBuiltIn = require('../internals/get-built-in');
var getMethod = require('../internals/get-method');
var AsyncIteratorPrototype = require('../internals/async-iterator-prototype');
var Promise = getBuiltIn('Promise');
var ASYNC_ITERATOR_PROXY = 'AsyncIteratorProxy';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ASYNC_ITERATOR_PROXY);
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
module.exports = function(nextHandler, IS_ITERATOR) {
    var AsyncIteratorProxy = function AsyncIterator(state) {
        state.type = ASYNC_ITERATOR_PROXY;
        state.next = aCallable(state.iterator.next);
        state.done = false;
        state.ignoreArgument = !IS_ITERATOR;
        setInternalState(this, state);
    };
    AsyncIteratorProxy.prototype = redefineAll(create(AsyncIteratorPrototype), {
        next: function next(arg) {
            var that = this;
            var hasArgument = !!arguments.length;
            return new Promise(function(resolve) {
                var state = getInternalState(that);
                var args = hasArgument ? [
                    state.ignoreArgument ? undefined : arg
                ] : IS_ITERATOR ? [] : [
                    undefined
                ];
                state.ignoreArgument = false;
                resolve(state.done ? {
                    done: true,
                    value: undefined
                } : anObject(call(nextHandler, state, Promise, args)));
            });
        },
        'return': function(value) {
            var that = this;
            return new Promise(function(resolve, reject) {
                var state = getInternalState(that);
                var iterator = state.iterator;
                state.done = true;
                var $$return = getMethod(iterator, 'return');
                if ($$return === undefined) return resolve({
                    done: true,
                    value: value
                });
                Promise.resolve(call($$return, iterator, value)).then(function(result) {
                    anObject(result);
                    resolve({
                        done: true,
                        value: value
                    });
                }, reject);
            });
        },
        'throw': function(value) {
            var that = this;
            return new Promise(function(resolve, reject) {
                var state = getInternalState(that);
                var iterator = state.iterator;
                state.done = true;
                var $$throw = getMethod(iterator, 'throw');
                if ($$throw === undefined) return reject(value);
                resolve(call($$throw, iterator, value));
            });
        }
    });
    if (!IS_ITERATOR) createNonEnumerableProperty(AsyncIteratorProxy.prototype, TO_STRING_TAG, 'Generator');
    return AsyncIteratorProxy;
};

},{"../internals/function-call":"jhLed","../internals/a-callable":"83opn","../internals/an-object":"1LIz9","../internals/object-create":"1As5O","../internals/create-non-enumerable-property":"6Z1es","../internals/redefine-all":"ch5Rt","../internals/well-known-symbol":"5C8sm","../internals/internal-state":"i6AaM","../internals/get-built-in":"78arb","../internals/get-method":"hEJ6b","../internals/async-iterator-prototype":"3NvMm"}],"cYNpf":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var apply = require('../internals/function-apply');
var anObject = require('../internals/an-object');
var toPositiveInteger = require('../internals/to-positive-integer');
var createAsyncIteratorProxy = require('../internals/async-iterator-create-proxy');
var AsyncIteratorProxy = createAsyncIteratorProxy(function(Promise, args) {
    var state = this;
    return new Promise(function(resolve, reject) {
        var loop = function() {
            try {
                Promise.resolve(anObject(apply(state.next, state.iterator, state.remaining ? [] : args))).then(function(step) {
                    try {
                        if (anObject(step).done) {
                            state.done = true;
                            resolve({
                                done: true,
                                value: undefined
                            });
                        } else if (state.remaining) {
                            state.remaining--;
                            loop();
                        } else resolve({
                            done: false,
                            value: step.value
                        });
                    } catch (err) {
                        reject(err);
                    }
                }, reject);
            } catch (error) {
                reject(error);
            }
        };
        loop();
    });
});
$({
    target: 'AsyncIterator',
    proto: true,
    real: true
}, {
    drop: function drop(limit) {
        return new AsyncIteratorProxy({
            iterator: anObject(this),
            remaining: toPositiveInteger(limit)
        });
    }
});

},{"../internals/export":"8yfGv","../internals/function-apply":"206oi","../internals/an-object":"1LIz9","../internals/to-positive-integer":"ezIBe","../internals/async-iterator-create-proxy":"1bDzF"}],"dnh5V":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var $every = require('../internals/async-iterator-iteration').every;
$({
    target: 'AsyncIterator',
    proto: true,
    real: true
}, {
    every: function every(fn) {
        return $every(this, fn);
    }
});

},{"../internals/export":"8yfGv","../internals/async-iterator-iteration":"7OKbn"}],"hssZz":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var apply = require('../internals/function-apply');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
var createAsyncIteratorProxy = require('../internals/async-iterator-create-proxy');
var AsyncIteratorProxy = createAsyncIteratorProxy(function(Promise, args) {
    var state = this;
    var filterer = state.filterer;
    return new Promise(function(resolve, reject) {
        var loop = function() {
            try {
                Promise.resolve(anObject(apply(state.next, state.iterator, args))).then(function(step) {
                    try {
                        if (anObject(step).done) {
                            state.done = true;
                            resolve({
                                done: true,
                                value: undefined
                            });
                        } else {
                            var value = step.value;
                            Promise.resolve(filterer(value)).then(function(selected) {
                                selected ? resolve({
                                    done: false,
                                    value: value
                                }) : loop();
                            }, reject);
                        }
                    } catch (err) {
                        reject(err);
                    }
                }, reject);
            } catch (error) {
                reject(error);
            }
        };
        loop();
    });
});
$({
    target: 'AsyncIterator',
    proto: true,
    real: true
}, {
    filter: function filter(filterer) {
        return new AsyncIteratorProxy({
            iterator: anObject(this),
            filterer: aCallable(filterer)
        });
    }
});

},{"../internals/export":"8yfGv","../internals/function-apply":"206oi","../internals/a-callable":"83opn","../internals/an-object":"1LIz9","../internals/async-iterator-create-proxy":"1bDzF"}],"iFZL2":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var $find = require('../internals/async-iterator-iteration').find;
$({
    target: 'AsyncIterator',
    proto: true,
    real: true
}, {
    find: function find(fn) {
        return $find(this, fn);
    }
});

},{"../internals/export":"8yfGv","../internals/async-iterator-iteration":"7OKbn"}],"4L5wI":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var call = require('../internals/function-call');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
var createAsyncIteratorProxy = require('../internals/async-iterator-create-proxy');
var getAsyncIterator = require('../internals/get-async-iterator');
var AsyncIteratorProxy = createAsyncIteratorProxy(function(Promise) {
    var state = this;
    var mapper = state.mapper;
    var innerIterator;
    return new Promise(function(resolve, reject) {
        var outerLoop = function() {
            try {
                Promise.resolve(anObject(call(state.next, state.iterator))).then(function(step) {
                    try {
                        if (anObject(step).done) {
                            state.done = true;
                            resolve({
                                done: true,
                                value: undefined
                            });
                        } else Promise.resolve(mapper(step.value)).then(function(mapped) {
                            try {
                                state.innerIterator = innerIterator = getAsyncIterator(mapped);
                                state.innerNext = aCallable(innerIterator.next);
                                return innerLoop();
                            } catch (error2) {
                                reject(error2);
                            }
                        }, reject);
                    } catch (error1) {
                        reject(error1);
                    }
                }, reject);
            } catch (error) {
                reject(error);
            }
        };
        var innerLoop = function() {
            if (innerIterator = state.innerIterator) try {
                Promise.resolve(anObject(call(state.innerNext, innerIterator))).then(function(result) {
                    try {
                        if (anObject(result).done) {
                            state.innerIterator = state.innerNext = null;
                            outerLoop();
                        } else resolve({
                            done: false,
                            value: result.value
                        });
                    } catch (error1) {
                        reject(error1);
                    }
                }, reject);
            } catch (error) {
                reject(error);
            }
            else outerLoop();
        };
        innerLoop();
    });
});
$({
    target: 'AsyncIterator',
    proto: true,
    real: true
}, {
    flatMap: function flatMap(mapper) {
        return new AsyncIteratorProxy({
            iterator: anObject(this),
            mapper: aCallable(mapper),
            innerIterator: null,
            innerNext: null
        });
    }
});

},{"../internals/export":"8yfGv","../internals/function-call":"jhLed","../internals/a-callable":"83opn","../internals/an-object":"1LIz9","../internals/async-iterator-create-proxy":"1bDzF","../internals/get-async-iterator":"sRWY3"}],"2NZEj":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var $forEach = require('../internals/async-iterator-iteration').forEach;
$({
    target: 'AsyncIterator',
    proto: true,
    real: true
}, {
    forEach: function forEach(fn) {
        return $forEach(this, fn);
    }
});

},{"../internals/export":"8yfGv","../internals/async-iterator-iteration":"7OKbn"}],"4I85Q":[function(require,module,exports) {
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var apply = require('../internals/function-apply');
var anObject = require('../internals/an-object');
var toObject = require('../internals/to-object');
var isPrototypeOf = require('../internals/object-is-prototype-of');
var AsyncIteratorPrototype = require('../internals/async-iterator-prototype');
var createAsyncIteratorProxy = require('../internals/async-iterator-create-proxy');
var getAsyncIterator = require('../internals/get-async-iterator');
var getIterator = require('../internals/get-iterator');
var getIteratorMethod = require('../internals/get-iterator-method');
var getMethod = require('../internals/get-method');
var wellKnownSymbol = require('../internals/well-known-symbol');
var AsyncFromSyncIterator = require('../internals/async-from-sync-iterator');
var ASYNC_ITERATOR = wellKnownSymbol('asyncIterator');
var AsyncIteratorProxy = createAsyncIteratorProxy(function(Promise, args) {
    return anObject(apply(this.next, this.iterator, args));
}, true);
$({
    target: 'AsyncIterator',
    stat: true
}, {
    from: function from(O) {
        var object = toObject(O);
        var usingIterator = getMethod(object, ASYNC_ITERATOR);
        var iterator;
        if (usingIterator) {
            iterator = getAsyncIterator(object, usingIterator);
            if (isPrototypeOf(AsyncIteratorPrototype, iterator)) return iterator;
        }
        if (iterator === undefined) {
            usingIterator = getIteratorMethod(object);
            if (usingIterator) return new AsyncFromSyncIterator(getIterator(object, usingIterator));
        }
        return new AsyncIteratorProxy({
            iterator: iterator !== undefined ? iterator : object
        });
    }
});

},{"../internals/export":"8yfGv","../internals/function-apply":"206oi","../internals/an-object":"1LIz9","../internals/to-object":"eEdae","../internals/object-is-prototype-of":"fyf1A","../internals/async-iterator-prototype":"3NvMm","../internals/async-iterator-create-proxy":"1bDzF","../internals/get-async-iterator":"sRWY3","../internals/get-iterator":"dQrLE","../internals/get-iterator-method":"5CTSY","../internals/get-method":"hEJ6b","../internals/well-known-symbol":"5C8sm","../internals/async-from-sync-iterator":"51v3w"}],"26Mtn":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var apply = require('../internals/function-apply');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
var createAsyncIteratorProxy = require('../internals/async-iterator-create-proxy');
var AsyncIteratorProxy = createAsyncIteratorProxy(function(Promise, args) {
    var state = this;
    var mapper = state.mapper;
    return Promise.resolve(anObject(apply(state.next, state.iterator, args))).then(function(step) {
        if (anObject(step).done) {
            state.done = true;
            return {
                done: true,
                value: undefined
            };
        }
        return Promise.resolve(mapper(step.value)).then(function(value) {
            return {
                done: false,
                value: value
            };
        });
    });
});
$({
    target: 'AsyncIterator',
    proto: true,
    real: true
}, {
    map: function map(mapper) {
        return new AsyncIteratorProxy({
            iterator: anObject(this),
            mapper: aCallable(mapper)
        });
    }
});

},{"../internals/export":"8yfGv","../internals/function-apply":"206oi","../internals/a-callable":"83opn","../internals/an-object":"1LIz9","../internals/async-iterator-create-proxy":"1bDzF"}],"Y3GEp":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var global = require('../internals/global');
var call = require('../internals/function-call');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
var getBuiltIn = require('../internals/get-built-in');
var Promise = getBuiltIn('Promise');
var TypeError = global.TypeError;
$({
    target: 'AsyncIterator',
    proto: true,
    real: true
}, {
    reduce: function reduce(reducer /* , initialValue */ ) {
        var iterator = anObject(this);
        var next = aCallable(iterator.next);
        var noInitial = arguments.length < 2;
        var accumulator = noInitial ? undefined : arguments[1];
        aCallable(reducer);
        return new Promise(function(resolve, reject) {
            var loop = function() {
                try {
                    Promise.resolve(anObject(call(next, iterator))).then(function(step) {
                        try {
                            if (anObject(step).done) noInitial ? reject(TypeError('Reduce of empty iterator with no initial value')) : resolve(accumulator);
                            else {
                                var value = step.value;
                                if (noInitial) {
                                    noInitial = false;
                                    accumulator = value;
                                    loop();
                                } else Promise.resolve(reducer(accumulator, value)).then(function(result) {
                                    accumulator = result;
                                    loop();
                                }, reject);
                            }
                        } catch (err) {
                            reject(err);
                        }
                    }, reject);
                } catch (error) {
                    reject(error);
                }
            };
            loop();
        });
    }
});

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/function-call":"jhLed","../internals/a-callable":"83opn","../internals/an-object":"1LIz9","../internals/get-built-in":"78arb"}],"gWclC":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var $some = require('../internals/async-iterator-iteration').some;
$({
    target: 'AsyncIterator',
    proto: true,
    real: true
}, {
    some: function some(fn) {
        return $some(this, fn);
    }
});

},{"../internals/export":"8yfGv","../internals/async-iterator-iteration":"7OKbn"}],"bt9Td":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var apply = require('../internals/function-apply');
var call = require('../internals/function-call');
var anObject = require('../internals/an-object');
var toPositiveInteger = require('../internals/to-positive-integer');
var createAsyncIteratorProxy = require('../internals/async-iterator-create-proxy');
var AsyncIteratorProxy = createAsyncIteratorProxy(function(Promise, args) {
    var iterator = this.iterator;
    var returnMethod, result;
    if (!this.remaining--) {
        result = {
            done: true,
            value: undefined
        };
        this.done = true;
        returnMethod = iterator['return'];
        if (returnMethod !== undefined) return Promise.resolve(call(returnMethod, iterator)).then(function() {
            return result;
        });
        return result;
    }
    return apply(this.next, iterator, args);
});
$({
    target: 'AsyncIterator',
    proto: true,
    real: true
}, {
    take: function take(limit) {
        return new AsyncIteratorProxy({
            iterator: anObject(this),
            remaining: toPositiveInteger(limit)
        });
    }
});

},{"../internals/export":"8yfGv","../internals/function-apply":"206oi","../internals/function-call":"jhLed","../internals/an-object":"1LIz9","../internals/to-positive-integer":"ezIBe","../internals/async-iterator-create-proxy":"1bDzF"}],"iTt4i":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var $toArray = require('../internals/async-iterator-iteration').toArray;
$({
    target: 'AsyncIterator',
    proto: true,
    real: true
}, {
    toArray: function toArray() {
        return $toArray(this, undefined, []);
    }
});

},{"../internals/export":"8yfGv","../internals/async-iterator-iteration":"7OKbn"}],"7Yfjk":[function(require,module,exports) {
'use strict';
/* eslint-disable es/no-bigint -- safe */ var $ = require('../internals/export');
var NumericRangeIterator = require('../internals/numeric-range-iterator');
// `BigInt.range` method
// https://github.com/tc39/proposal-Number.range
if (typeof BigInt == 'function') $({
    target: 'BigInt',
    stat: true
}, {
    range: function range(start, end, option) {
        return new NumericRangeIterator(start, end, option, 'bigint', BigInt(0), BigInt(1));
    }
});

},{"../internals/export":"8yfGv","../internals/numeric-range-iterator":"kHyPF"}],"kHyPF":[function(require,module,exports) {
'use strict';
var global = require('../internals/global');
var InternalStateModule = require('../internals/internal-state');
var createIteratorConstructor = require('../internals/create-iterator-constructor');
var isObject = require('../internals/is-object');
var defineProperties = require('../internals/object-define-properties').f;
var DESCRIPTORS = require('../internals/descriptors');
var INCORRECT_RANGE = 'Incorrect Number.range arguments';
var NUMERIC_RANGE_ITERATOR = 'NumericRangeIterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(NUMERIC_RANGE_ITERATOR);
var RangeError = global.RangeError;
var TypeError = global.TypeError;
var $RangeIterator = createIteratorConstructor(function NumericRangeIterator(start, end, option, type, zero, one) {
    if (typeof start != type || end !== Infinity && end !== -Infinity && typeof end != type) throw new TypeError(INCORRECT_RANGE);
    if (start === Infinity || start === -Infinity) throw new RangeError(INCORRECT_RANGE);
    var ifIncrease = end > start;
    var inclusiveEnd = false;
    var step;
    if (option === undefined) step = undefined;
    else if (isObject(option)) {
        step = option.step;
        inclusiveEnd = !!option.inclusive;
    } else if (typeof option == type) step = option;
    else throw new TypeError(INCORRECT_RANGE);
    if (step == null) step = ifIncrease ? one : -one;
    if (typeof step != type) throw new TypeError(INCORRECT_RANGE);
    if (step === Infinity || step === -Infinity || step === zero && start !== end) throw new RangeError(INCORRECT_RANGE);
    // eslint-disable-next-line no-self-compare -- NaN check
    var hitsEnd = start != start || end != end || step != step || end > start !== step > zero;
    setInternalState(this, {
        type: NUMERIC_RANGE_ITERATOR,
        start: start,
        end: end,
        step: step,
        inclusiveEnd: inclusiveEnd,
        hitsEnd: hitsEnd,
        currentCount: zero,
        zero: zero
    });
    if (!DESCRIPTORS) {
        this.start = start;
        this.end = end;
        this.step = step;
        this.inclusive = inclusiveEnd;
    }
}, NUMERIC_RANGE_ITERATOR, function next() {
    var state = getInternalState(this);
    if (state.hitsEnd) return {
        value: undefined,
        done: true
    };
    var start = state.start;
    var end = state.end;
    var step = state.step;
    var currentYieldingValue = start + step * state.currentCount++;
    if (currentYieldingValue === end) state.hitsEnd = true;
    var inclusiveEnd = state.inclusiveEnd;
    var endCondition;
    if (end > start) endCondition = inclusiveEnd ? currentYieldingValue > end : currentYieldingValue >= end;
    else endCondition = inclusiveEnd ? end > currentYieldingValue : end >= currentYieldingValue;
    if (endCondition) return {
        value: undefined,
        done: state.hitsEnd = true
    };
    return {
        value: currentYieldingValue,
        done: false
    };
});
var getter = function(fn) {
    return {
        get: fn,
        set: function() {
        },
        configurable: true,
        enumerable: false
    };
};
if (DESCRIPTORS) defineProperties($RangeIterator.prototype, {
    start: getter(function() {
        return getInternalState(this).start;
    }),
    end: getter(function() {
        return getInternalState(this).end;
    }),
    inclusive: getter(function() {
        return getInternalState(this).inclusiveEnd;
    }),
    step: getter(function() {
        return getInternalState(this).step;
    })
});
module.exports = $RangeIterator;

},{"../internals/global":"jxPDA","../internals/internal-state":"i6AaM","../internals/create-iterator-constructor":"1fB00","../internals/is-object":"dplrD","../internals/object-define-properties":"8PPlc","../internals/descriptors":"6ZLib"}],"9oI2D":[function(require,module,exports) {
var $ = require('../internals/export');
var global = require('../internals/global');
var apply = require('../internals/function-apply');
var getCompositeKeyNode = require('../internals/composite-key');
var getBuiltIn = require('../internals/get-built-in');
var create = require('../internals/object-create');
var Object = global.Object;
var initializer = function() {
    var freeze = getBuiltIn('Object', 'freeze');
    return freeze ? freeze(create(null)) : create(null);
};
// https://github.com/tc39/proposal-richer-keys/tree/master/compositeKey
$({
    global: true
}, {
    compositeKey: function compositeKey() {
        return apply(getCompositeKeyNode, Object, arguments).get('object', initializer);
    }
});

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/function-apply":"206oi","../internals/composite-key":"3b5Fg","../internals/get-built-in":"78arb","../internals/object-create":"1As5O"}],"3b5Fg":[function(require,module,exports) {
// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
require('../modules/es.map');
require('../modules/es.weak-map');
var global = require('../internals/global');
var getBuiltIn = require('../internals/get-built-in');
var create = require('../internals/object-create');
var isObject = require('../internals/is-object');
var Object = global.Object;
var TypeError = global.TypeError;
var Map = getBuiltIn('Map');
var WeakMap = getBuiltIn('WeakMap');
var Node = function() {
    // keys
    this.object = null;
    this.symbol = null;
    // child nodes
    this.primitives = null;
    this.objectsByIndex = create(null);
};
Node.prototype.get = function(key, initializer) {
    return this[key] || (this[key] = initializer());
};
Node.prototype.next = function(i, it, IS_OBJECT) {
    var store = IS_OBJECT ? this.objectsByIndex[i] || (this.objectsByIndex[i] = new WeakMap()) : this.primitives || (this.primitives = new Map());
    var entry = store.get(it);
    if (!entry) store.set(it, entry = new Node());
    return entry;
};
var root = new Node();
module.exports = function() {
    var active = root;
    var length = arguments.length;
    var i, it;
    // for prevent leaking, start from objects
    for(i = 0; i < length; i++)if (isObject(it = arguments[i])) active = active.next(i, it, true);
    if (this === Object && active === root) throw TypeError('Composite keys must contain a non-primitive component');
    for(i = 0; i < length; i++)if (!isObject(it = arguments[i])) active = active.next(i, it, false);
    return active;
};

},{"../modules/es.map":"ayxWX","../modules/es.weak-map":"lEfis","../internals/global":"jxPDA","../internals/get-built-in":"78arb","../internals/object-create":"1As5O","../internals/is-object":"dplrD"}],"4cZHd":[function(require,module,exports) {
var $ = require('../internals/export');
var getCompositeKeyNode = require('../internals/composite-key');
var getBuiltIn = require('../internals/get-built-in');
var apply = require('../internals/function-apply');
// https://github.com/tc39/proposal-richer-keys/tree/master/compositeKey
$({
    global: true
}, {
    compositeSymbol: function compositeSymbol() {
        if (arguments.length == 1 && typeof arguments[0] == 'string') return getBuiltIn('Symbol')['for'](arguments[0]);
        return apply(getCompositeKeyNode, null, arguments).get('symbol', getBuiltIn('Symbol'));
    }
});

},{"../internals/export":"8yfGv","../internals/composite-key":"3b5Fg","../internals/get-built-in":"78arb","../internals/function-apply":"206oi"}],"1qlYY":[function(require,module,exports) {
var $ = require('../internals/export');
var uncurryThis = require('../internals/function-uncurry-this');
var $isCallable = require('../internals/is-callable');
var inspectSource = require('../internals/inspect-source');
var hasOwn = require('../internals/has-own-property');
var DESCRIPTORS = require('../internals/descriptors');
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var classRegExp = /^\s*class\b/;
var exec = uncurryThis(classRegExp.exec);
var isClassConstructor = function(argument) {
    try {
        // `Function#toString` throws on some built-it function in some legacy engines
        // (for example, `DOMQuad` and similar in FF41-)
        if (!DESCRIPTORS || !exec(classRegExp, inspectSource(argument))) return false;
    } catch (error) {
    }
    var prototype = getOwnPropertyDescriptor(argument, 'prototype');
    return !!prototype && hasOwn(prototype, 'writable') && !prototype.writable;
};
// `Function.isCallable` method
// https://github.com/caitp/TC39-Proposals/blob/trunk/tc39-reflect-isconstructor-iscallable.md
$({
    target: 'Function',
    stat: true,
    sham: true
}, {
    isCallable: function isCallable(argument) {
        return $isCallable(argument) && !isClassConstructor(argument);
    }
});

},{"../internals/export":"8yfGv","../internals/function-uncurry-this":"jJnXC","../internals/is-callable":"kPhuP","../internals/inspect-source":"7DOzX","../internals/has-own-property":"3ZdUC","../internals/descriptors":"6ZLib"}],"h2oIG":[function(require,module,exports) {
var $ = require('../internals/export');
var isConstructor = require('../internals/is-constructor');
// `Function.isConstructor` method
// https://github.com/caitp/TC39-Proposals/blob/trunk/tc39-reflect-isconstructor-iscallable.md
$({
    target: 'Function',
    stat: true
}, {
    isConstructor: isConstructor
});

},{"../internals/export":"8yfGv","../internals/is-constructor":"iNoNi"}],"htuAE":[function(require,module,exports) {
var $ = require('../internals/export');
var uncurryThis = require('../internals/function-uncurry-this');
var aCallable = require('../internals/a-callable');
// `Function.prototype.unThis` method
// https://github.com/js-choi/proposal-function-un-this
$({
    target: 'Function',
    proto: true
}, {
    unThis: function unThis() {
        return uncurryThis(aCallable(this));
    }
});

},{"../internals/export":"8yfGv","../internals/function-uncurry-this":"jJnXC","../internals/a-callable":"83opn"}],"euics":[function(require,module,exports) {
// TODO: Remove from `core-js@4`
require('../modules/es.global-this');

},{"../modules/es.global-this":"3I5ZQ"}],"hhAVF":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var global = require('../internals/global');
var anInstance = require('../internals/an-instance');
var isCallable = require('../internals/is-callable');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var fails = require('../internals/fails');
var hasOwn = require('../internals/has-own-property');
var wellKnownSymbol = require('../internals/well-known-symbol');
var IteratorPrototype = require('../internals/iterators-core').IteratorPrototype;
var IS_PURE = require('../internals/is-pure');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var NativeIterator = global.Iterator;
// FF56- have non-standard global helper `Iterator`
var FORCED = IS_PURE || !isCallable(NativeIterator) || NativeIterator.prototype !== IteratorPrototype || !fails(function() {
    NativeIterator({
    });
});
var IteratorConstructor = function Iterator() {
    anInstance(this, IteratorPrototype);
};
if (!hasOwn(IteratorPrototype, TO_STRING_TAG)) createNonEnumerableProperty(IteratorPrototype, TO_STRING_TAG, 'Iterator');
if (FORCED || !hasOwn(IteratorPrototype, 'constructor') || IteratorPrototype.constructor === Object) createNonEnumerableProperty(IteratorPrototype, 'constructor', IteratorConstructor);
IteratorConstructor.prototype = IteratorPrototype;
$({
    global: true,
    forced: FORCED
}, {
    Iterator: IteratorConstructor
});

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/an-instance":"2zeQg","../internals/is-callable":"kPhuP","../internals/create-non-enumerable-property":"6Z1es","../internals/fails":"8IfZQ","../internals/has-own-property":"3ZdUC","../internals/well-known-symbol":"5C8sm","../internals/iterators-core":"gL68y","../internals/is-pure":"6Bbq0"}],"6B0J9":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var apply = require('../internals/function-apply');
var anObject = require('../internals/an-object');
var createIteratorProxy = require('../internals/iterator-create-proxy');
var IteratorProxy = createIteratorProxy(function(args) {
    var result = anObject(apply(this.next, this.iterator, args));
    var done = this.done = !!result.done;
    if (!done) return [
        this.index++,
        result.value
    ];
});
$({
    target: 'Iterator',
    proto: true,
    real: true
}, {
    asIndexedPairs: function asIndexedPairs() {
        return new IteratorProxy({
            iterator: anObject(this),
            index: 0
        });
    }
});

},{"../internals/export":"8yfGv","../internals/function-apply":"206oi","../internals/an-object":"1LIz9","../internals/iterator-create-proxy":"R2cz8"}],"R2cz8":[function(require,module,exports) {
'use strict';
var call = require('../internals/function-call');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
var create = require('../internals/object-create');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var redefineAll = require('../internals/redefine-all');
var wellKnownSymbol = require('../internals/well-known-symbol');
var InternalStateModule = require('../internals/internal-state');
var getMethod = require('../internals/get-method');
var IteratorPrototype = require('../internals/iterators-core').IteratorPrototype;
var ITERATOR_PROXY = 'IteratorProxy';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ITERATOR_PROXY);
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
module.exports = function(nextHandler, IS_ITERATOR) {
    var IteratorProxy = function Iterator(state) {
        state.type = ITERATOR_PROXY;
        state.next = aCallable(state.iterator.next);
        state.done = false;
        state.ignoreArg = !IS_ITERATOR;
        setInternalState(this, state);
    };
    IteratorProxy.prototype = redefineAll(create(IteratorPrototype), {
        next: function next(arg) {
            var state = getInternalState(this);
            var args = arguments.length ? [
                state.ignoreArg ? undefined : arg
            ] : IS_ITERATOR ? [] : [
                undefined
            ];
            state.ignoreArg = false;
            var result = state.done ? undefined : call(nextHandler, state, args);
            return {
                done: state.done,
                value: result
            };
        },
        'return': function(value) {
            var state = getInternalState(this);
            var iterator = state.iterator;
            state.done = true;
            var $$return = getMethod(iterator, 'return');
            return {
                done: true,
                value: $$return ? anObject(call($$return, iterator, value)).value : value
            };
        },
        'throw': function(value) {
            var state = getInternalState(this);
            var iterator = state.iterator;
            state.done = true;
            var $$throw = getMethod(iterator, 'throw');
            if ($$throw) return call($$throw, iterator, value);
            throw value;
        }
    });
    if (!IS_ITERATOR) createNonEnumerableProperty(IteratorProxy.prototype, TO_STRING_TAG, 'Generator');
    return IteratorProxy;
};

},{"../internals/function-call":"jhLed","../internals/a-callable":"83opn","../internals/an-object":"1LIz9","../internals/object-create":"1As5O","../internals/create-non-enumerable-property":"6Z1es","../internals/redefine-all":"ch5Rt","../internals/well-known-symbol":"5C8sm","../internals/internal-state":"i6AaM","../internals/get-method":"hEJ6b","../internals/iterators-core":"gL68y"}],"k1ek5":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var apply = require('../internals/function-apply');
var call = require('../internals/function-call');
var anObject = require('../internals/an-object');
var toPositiveInteger = require('../internals/to-positive-integer');
var createIteratorProxy = require('../internals/iterator-create-proxy');
var IteratorProxy = createIteratorProxy(function(args) {
    var iterator = this.iterator;
    var next = this.next;
    var result, done;
    while(this.remaining){
        this.remaining--;
        result = anObject(call(next, iterator));
        done = this.done = !!result.done;
        if (done) return;
    }
    result = anObject(apply(next, iterator, args));
    done = this.done = !!result.done;
    if (!done) return result.value;
});
$({
    target: 'Iterator',
    proto: true,
    real: true
}, {
    drop: function drop(limit) {
        return new IteratorProxy({
            iterator: anObject(this),
            remaining: toPositiveInteger(limit)
        });
    }
});

},{"../internals/export":"8yfGv","../internals/function-apply":"206oi","../internals/function-call":"jhLed","../internals/an-object":"1LIz9","../internals/to-positive-integer":"ezIBe","../internals/iterator-create-proxy":"R2cz8"}],"6rXrL":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var iterate = require('../internals/iterate');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
$({
    target: 'Iterator',
    proto: true,
    real: true
}, {
    every: function every(fn) {
        anObject(this);
        aCallable(fn);
        return !iterate(this, function(value, stop) {
            if (!fn(value)) return stop();
        }, {
            IS_ITERATOR: true,
            INTERRUPTED: true
        }).stopped;
    }
});

},{"../internals/export":"8yfGv","../internals/iterate":"fTyka","../internals/a-callable":"83opn","../internals/an-object":"1LIz9"}],"iVsDp":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var apply = require('../internals/function-apply');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
var createIteratorProxy = require('../internals/iterator-create-proxy');
var callWithSafeIterationClosing = require('../internals/call-with-safe-iteration-closing');
var IteratorProxy = createIteratorProxy(function(args) {
    var iterator = this.iterator;
    var filterer = this.filterer;
    var next = this.next;
    var result, done, value;
    while(true){
        result = anObject(apply(next, iterator, args));
        done = this.done = !!result.done;
        if (done) return;
        value = result.value;
        if (callWithSafeIterationClosing(iterator, filterer, value)) return value;
    }
});
$({
    target: 'Iterator',
    proto: true,
    real: true
}, {
    filter: function filter(filterer) {
        return new IteratorProxy({
            iterator: anObject(this),
            filterer: aCallable(filterer)
        });
    }
});

},{"../internals/export":"8yfGv","../internals/function-apply":"206oi","../internals/a-callable":"83opn","../internals/an-object":"1LIz9","../internals/iterator-create-proxy":"R2cz8","../internals/call-with-safe-iteration-closing":"b1Dt0"}],"9BC4R":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var iterate = require('../internals/iterate');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
$({
    target: 'Iterator',
    proto: true,
    real: true
}, {
    find: function find(fn) {
        anObject(this);
        aCallable(fn);
        return iterate(this, function(value, stop) {
            if (fn(value)) return stop(value);
        }, {
            IS_ITERATOR: true,
            INTERRUPTED: true
        }).result;
    }
});

},{"../internals/export":"8yfGv","../internals/iterate":"fTyka","../internals/a-callable":"83opn","../internals/an-object":"1LIz9"}],"6neKF":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var global = require('../internals/global');
var call = require('../internals/function-call');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
var getIteratorMethod = require('../internals/get-iterator-method');
var createIteratorProxy = require('../internals/iterator-create-proxy');
var iteratorClose = require('../internals/iterator-close');
var TypeError = global.TypeError;
var IteratorProxy = createIteratorProxy(function() {
    var iterator = this.iterator;
    var mapper = this.mapper;
    var result, mapped, iteratorMethod, innerIterator;
    while(true)try {
        if (innerIterator = this.innerIterator) {
            result = anObject(call(this.innerNext, innerIterator));
            if (!result.done) return result.value;
            this.innerIterator = this.innerNext = null;
        }
        result = anObject(call(this.next, iterator));
        if (this.done = !!result.done) return;
        mapped = mapper(result.value);
        iteratorMethod = getIteratorMethod(mapped);
        if (!iteratorMethod) throw TypeError('.flatMap callback should return an iterable object');
        this.innerIterator = innerIterator = anObject(call(iteratorMethod, mapped));
        this.innerNext = aCallable(innerIterator.next);
    } catch (error) {
        iteratorClose(iterator, 'throw', error);
    }
});
$({
    target: 'Iterator',
    proto: true,
    real: true
}, {
    flatMap: function flatMap(mapper) {
        return new IteratorProxy({
            iterator: anObject(this),
            mapper: aCallable(mapper),
            innerIterator: null,
            innerNext: null
        });
    }
});

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/function-call":"jhLed","../internals/a-callable":"83opn","../internals/an-object":"1LIz9","../internals/get-iterator-method":"5CTSY","../internals/iterator-create-proxy":"R2cz8","../internals/iterator-close":"cwu4L"}],"7S92S":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var iterate = require('../internals/iterate');
var anObject = require('../internals/an-object');
$({
    target: 'Iterator',
    proto: true,
    real: true
}, {
    forEach: function forEach(fn) {
        iterate(anObject(this), fn, {
            IS_ITERATOR: true
        });
    }
});

},{"../internals/export":"8yfGv","../internals/iterate":"fTyka","../internals/an-object":"1LIz9"}],"hpOTI":[function(require,module,exports) {
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var apply = require('../internals/function-apply');
var anObject = require('../internals/an-object');
var toObject = require('../internals/to-object');
var isPrototypeOf = require('../internals/object-is-prototype-of');
var IteratorPrototype = require('../internals/iterators-core').IteratorPrototype;
var createIteratorProxy = require('../internals/iterator-create-proxy');
var getIterator = require('../internals/get-iterator');
var getIteratorMethod = require('../internals/get-iterator-method');
var IteratorProxy = createIteratorProxy(function(args) {
    var result = anObject(apply(this.next, this.iterator, args));
    var done = this.done = !!result.done;
    if (!done) return result.value;
}, true);
$({
    target: 'Iterator',
    stat: true
}, {
    from: function from(O) {
        var object = toObject(O);
        var usingIterator = getIteratorMethod(object);
        var iterator;
        if (usingIterator) {
            iterator = getIterator(object, usingIterator);
            if (isPrototypeOf(IteratorPrototype, iterator)) return iterator;
        } else iterator = object;
        return new IteratorProxy({
            iterator: iterator
        });
    }
});

},{"../internals/export":"8yfGv","../internals/function-apply":"206oi","../internals/an-object":"1LIz9","../internals/to-object":"eEdae","../internals/object-is-prototype-of":"fyf1A","../internals/iterators-core":"gL68y","../internals/iterator-create-proxy":"R2cz8","../internals/get-iterator":"dQrLE","../internals/get-iterator-method":"5CTSY"}],"a6W9Q":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var apply = require('../internals/function-apply');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
var createIteratorProxy = require('../internals/iterator-create-proxy');
var callWithSafeIterationClosing = require('../internals/call-with-safe-iteration-closing');
var IteratorProxy = createIteratorProxy(function(args) {
    var iterator = this.iterator;
    var result = anObject(apply(this.next, iterator, args));
    var done = this.done = !!result.done;
    if (!done) return callWithSafeIterationClosing(iterator, this.mapper, result.value);
});
$({
    target: 'Iterator',
    proto: true,
    real: true
}, {
    map: function map(mapper) {
        return new IteratorProxy({
            iterator: anObject(this),
            mapper: aCallable(mapper)
        });
    }
});

},{"../internals/export":"8yfGv","../internals/function-apply":"206oi","../internals/a-callable":"83opn","../internals/an-object":"1LIz9","../internals/iterator-create-proxy":"R2cz8","../internals/call-with-safe-iteration-closing":"b1Dt0"}],"YIpsq":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var global = require('../internals/global');
var iterate = require('../internals/iterate');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
var TypeError = global.TypeError;
$({
    target: 'Iterator',
    proto: true,
    real: true
}, {
    reduce: function reduce(reducer /* , initialValue */ ) {
        anObject(this);
        aCallable(reducer);
        var noInitial = arguments.length < 2;
        var accumulator = noInitial ? undefined : arguments[1];
        iterate(this, function(value) {
            if (noInitial) {
                noInitial = false;
                accumulator = value;
            } else accumulator = reducer(accumulator, value);
        }, {
            IS_ITERATOR: true
        });
        if (noInitial) throw TypeError('Reduce of empty iterator with no initial value');
        return accumulator;
    }
});

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/iterate":"fTyka","../internals/a-callable":"83opn","../internals/an-object":"1LIz9"}],"7DnaM":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var iterate = require('../internals/iterate');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
$({
    target: 'Iterator',
    proto: true,
    real: true
}, {
    some: function some(fn) {
        anObject(this);
        aCallable(fn);
        return iterate(this, function(value, stop) {
            if (fn(value)) return stop();
        }, {
            IS_ITERATOR: true,
            INTERRUPTED: true
        }).stopped;
    }
});

},{"../internals/export":"8yfGv","../internals/iterate":"fTyka","../internals/a-callable":"83opn","../internals/an-object":"1LIz9"}],"7ID7Q":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var apply = require('../internals/function-apply');
var anObject = require('../internals/an-object');
var toPositiveInteger = require('../internals/to-positive-integer');
var createIteratorProxy = require('../internals/iterator-create-proxy');
var iteratorClose = require('../internals/iterator-close');
var IteratorProxy = createIteratorProxy(function(args) {
    var iterator = this.iterator;
    if (!this.remaining--) {
        this.done = true;
        return iteratorClose(iterator, 'normal', undefined);
    }
    var result = anObject(apply(this.next, iterator, args));
    var done = this.done = !!result.done;
    if (!done) return result.value;
});
$({
    target: 'Iterator',
    proto: true,
    real: true
}, {
    take: function take(limit) {
        return new IteratorProxy({
            iterator: anObject(this),
            remaining: toPositiveInteger(limit)
        });
    }
});

},{"../internals/export":"8yfGv","../internals/function-apply":"206oi","../internals/an-object":"1LIz9","../internals/to-positive-integer":"ezIBe","../internals/iterator-create-proxy":"R2cz8","../internals/iterator-close":"cwu4L"}],"7TI8P":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var iterate = require('../internals/iterate');
var anObject = require('../internals/an-object');
var push = [].push;
$({
    target: 'Iterator',
    proto: true,
    real: true
}, {
    toArray: function toArray() {
        var result = [];
        iterate(anObject(this), push, {
            that: result,
            IS_ITERATOR: true
        });
        return result;
    }
});

},{"../internals/export":"8yfGv","../internals/iterate":"fTyka","../internals/an-object":"1LIz9"}],"8jp9R":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-iterator-helpers
var $ = require('../internals/export');
var AsyncFromSyncIterator = require('../internals/async-from-sync-iterator');
$({
    target: 'Iterator',
    proto: true,
    real: true
}, {
    toAsync: function toAsync() {
        return new AsyncFromSyncIterator(this);
    }
});

},{"../internals/export":"8yfGv","../internals/async-from-sync-iterator":"51v3w"}],"2YiIi":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var deleteAll = require('../internals/collection-delete-all');
// `Map.prototype.deleteAll` method
// https://github.com/tc39/proposal-collection-methods
$({
    target: 'Map',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    deleteAll: deleteAll
});

},{"../internals/export":"8yfGv","../internals/is-pure":"6Bbq0","../internals/collection-delete-all":"7mZy7"}],"7mZy7":[function(require,module,exports) {
'use strict';
var call = require('../internals/function-call');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
// https://github.com/tc39/collection-methods
module.exports = function deleteAll() {
    var collection = anObject(this);
    var remover = aCallable(collection['delete']);
    var allDeleted = true;
    var wasDeleted;
    for(var k = 0, len = arguments.length; k < len; k++){
        wasDeleted = call(remover, collection, arguments[k]);
        allDeleted = allDeleted && wasDeleted;
    }
    return !!allDeleted;
};

},{"../internals/function-call":"jhLed","../internals/a-callable":"83opn","../internals/an-object":"1LIz9"}],"bOO2p":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var emplace = require('../internals/map-emplace');
// `Map.prototype.emplace` method
// https://github.com/thumbsupep/proposal-upsert
$({
    target: 'Map',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    emplace: emplace
});

},{"../internals/export":"8yfGv","../internals/is-pure":"6Bbq0","../internals/map-emplace":"6ZCu9"}],"6ZCu9":[function(require,module,exports) {
'use strict';
var call = require('../internals/function-call');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
// `Map.prototype.emplace` method
// https://github.com/thumbsupep/proposal-upsert
module.exports = function emplace(key, handler) {
    var map = anObject(this);
    var get = aCallable(map.get);
    var has = aCallable(map.has);
    var set = aCallable(map.set);
    var value = call(has, map, key) && 'update' in handler ? handler.update(call(get, map, key), key, map) : handler.insert(key, map);
    call(set, map, key, value);
    return value;
};

},{"../internals/function-call":"jhLed","../internals/a-callable":"83opn","../internals/an-object":"1LIz9"}],"gyAAN":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var anObject = require('../internals/an-object');
var bind = require('../internals/function-bind-context');
var getMapIterator = require('../internals/get-map-iterator');
var iterate = require('../internals/iterate');
// `Map.prototype.every` method
// https://github.com/tc39/proposal-collection-methods
$({
    target: 'Map',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    every: function every(callbackfn /* , thisArg */ ) {
        var map = anObject(this);
        var iterator = getMapIterator(map);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        return !iterate(iterator, function(key, value, stop) {
            if (!boundFunction(value, key, map)) return stop();
        }, {
            AS_ENTRIES: true,
            IS_ITERATOR: true,
            INTERRUPTED: true
        }).stopped;
    }
});

},{"../internals/export":"8yfGv","../internals/is-pure":"6Bbq0","../internals/an-object":"1LIz9","../internals/function-bind-context":"kZubc","../internals/get-map-iterator":"eIAYy","../internals/iterate":"fTyka"}],"eIAYy":[function(require,module,exports) {
var call = require('../internals/function-call');
module.exports = function(it) {
    // eslint-disable-next-line es/no-map -- safe
    return call(Map.prototype.entries, it);
};

},{"../internals/function-call":"jhLed"}],"aej1a":[function(require,module,exports) {
'use strict';
var IS_PURE = require('../internals/is-pure');
var $ = require('../internals/export');
var getBuiltIn = require('../internals/get-built-in');
var bind = require('../internals/function-bind-context');
var call = require('../internals/function-call');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
var speciesConstructor = require('../internals/species-constructor');
var getMapIterator = require('../internals/get-map-iterator');
var iterate = require('../internals/iterate');
// `Map.prototype.filter` method
// https://github.com/tc39/proposal-collection-methods
$({
    target: 'Map',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    filter: function filter(callbackfn /* , thisArg */ ) {
        var map = anObject(this);
        var iterator = getMapIterator(map);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        var newMap = new (speciesConstructor(map, getBuiltIn('Map')))();
        var setter = aCallable(newMap.set);
        iterate(iterator, function(key, value) {
            if (boundFunction(value, key, map)) call(setter, newMap, key, value);
        }, {
            AS_ENTRIES: true,
            IS_ITERATOR: true
        });
        return newMap;
    }
});

},{"../internals/is-pure":"6Bbq0","../internals/export":"8yfGv","../internals/get-built-in":"78arb","../internals/function-bind-context":"kZubc","../internals/function-call":"jhLed","../internals/a-callable":"83opn","../internals/an-object":"1LIz9","../internals/species-constructor":"hqPl9","../internals/get-map-iterator":"eIAYy","../internals/iterate":"fTyka"}],"gdx3a":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var anObject = require('../internals/an-object');
var bind = require('../internals/function-bind-context');
var getMapIterator = require('../internals/get-map-iterator');
var iterate = require('../internals/iterate');
// `Map.prototype.find` method
// https://github.com/tc39/proposal-collection-methods
$({
    target: 'Map',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    find: function find(callbackfn /* , thisArg */ ) {
        var map = anObject(this);
        var iterator = getMapIterator(map);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        return iterate(iterator, function(key, value, stop) {
            if (boundFunction(value, key, map)) return stop(value);
        }, {
            AS_ENTRIES: true,
            IS_ITERATOR: true,
            INTERRUPTED: true
        }).result;
    }
});

},{"../internals/export":"8yfGv","../internals/is-pure":"6Bbq0","../internals/an-object":"1LIz9","../internals/function-bind-context":"kZubc","../internals/get-map-iterator":"eIAYy","../internals/iterate":"fTyka"}],"4oJli":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var anObject = require('../internals/an-object');
var bind = require('../internals/function-bind-context');
var getMapIterator = require('../internals/get-map-iterator');
var iterate = require('../internals/iterate');
// `Map.prototype.findKey` method
// https://github.com/tc39/proposal-collection-methods
$({
    target: 'Map',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    findKey: function findKey(callbackfn /* , thisArg */ ) {
        var map = anObject(this);
        var iterator = getMapIterator(map);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        return iterate(iterator, function(key, value, stop) {
            if (boundFunction(value, key, map)) return stop(key);
        }, {
            AS_ENTRIES: true,
            IS_ITERATOR: true,
            INTERRUPTED: true
        }).result;
    }
});

},{"../internals/export":"8yfGv","../internals/is-pure":"6Bbq0","../internals/an-object":"1LIz9","../internals/function-bind-context":"kZubc","../internals/get-map-iterator":"eIAYy","../internals/iterate":"fTyka"}],"ebR4F":[function(require,module,exports) {
var $ = require('../internals/export');
var from = require('../internals/collection-from');
// `Map.from` method
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
$({
    target: 'Map',
    stat: true
}, {
    from: from
});

},{"../internals/export":"8yfGv","../internals/collection-from":"2eDYq"}],"2eDYq":[function(require,module,exports) {
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var bind = require('../internals/function-bind-context');
var call = require('../internals/function-call');
var aCallable = require('../internals/a-callable');
var aConstructor = require('../internals/a-constructor');
var iterate = require('../internals/iterate');
var push = [].push;
module.exports = function from(source /* , mapFn, thisArg */ ) {
    var length = arguments.length;
    var mapFn = length > 1 ? arguments[1] : undefined;
    var mapping, array, n, boundFunction;
    aConstructor(this);
    mapping = mapFn !== undefined;
    if (mapping) aCallable(mapFn);
    if (source == undefined) return new this();
    array = [];
    if (mapping) {
        n = 0;
        boundFunction = bind(mapFn, length > 2 ? arguments[2] : undefined);
        iterate(source, function(nextItem) {
            call(push, array, boundFunction(nextItem, n++));
        });
    } else iterate(source, push, {
        that: array
    });
    return new this(array);
};

},{"../internals/function-bind-context":"kZubc","../internals/function-call":"jhLed","../internals/a-callable":"83opn","../internals/a-constructor":"1DOBp","../internals/iterate":"fTyka"}],"adTFE":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var call = require('../internals/function-call');
var uncurryThis = require('../internals/function-uncurry-this');
var aCallable = require('../internals/a-callable');
var getIterator = require('../internals/get-iterator');
var iterate = require('../internals/iterate');
var push = uncurryThis([].push);
// `Map.groupBy` method
// https://github.com/tc39/proposal-collection-methods
$({
    target: 'Map',
    stat: true
}, {
    groupBy: function groupBy(iterable, keyDerivative) {
        aCallable(keyDerivative);
        var iterator = getIterator(iterable);
        var newMap = new this();
        var has = aCallable(newMap.has);
        var get = aCallable(newMap.get);
        var set = aCallable(newMap.set);
        iterate(iterator, function(element) {
            var derivedKey = keyDerivative(element);
            if (!call(has, newMap, derivedKey)) call(set, newMap, derivedKey, [
                element
            ]);
            else push(call(get, newMap, derivedKey), element);
        }, {
            IS_ITERATOR: true
        });
        return newMap;
    }
});

},{"../internals/export":"8yfGv","../internals/function-call":"jhLed","../internals/function-uncurry-this":"jJnXC","../internals/a-callable":"83opn","../internals/get-iterator":"dQrLE","../internals/iterate":"fTyka"}],"02KWf":[function(require,module,exports) {
'use strict';
var IS_PURE = require('../internals/is-pure');
var $ = require('../internals/export');
var anObject = require('../internals/an-object');
var getMapIterator = require('../internals/get-map-iterator');
var sameValueZero = require('../internals/same-value-zero');
var iterate = require('../internals/iterate');
// `Map.prototype.includes` method
// https://github.com/tc39/proposal-collection-methods
$({
    target: 'Map',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    includes: function includes(searchElement) {
        return iterate(getMapIterator(anObject(this)), function(key, value, stop) {
            if (sameValueZero(value, searchElement)) return stop();
        }, {
            AS_ENTRIES: true,
            IS_ITERATOR: true,
            INTERRUPTED: true
        }).stopped;
    }
});

},{"../internals/is-pure":"6Bbq0","../internals/export":"8yfGv","../internals/an-object":"1LIz9","../internals/get-map-iterator":"eIAYy","../internals/same-value-zero":"iKjp2","../internals/iterate":"fTyka"}],"iKjp2":[function(require,module,exports) {
// `SameValueZero` abstract operation
// https://tc39.es/ecma262/#sec-samevaluezero
module.exports = function(x, y) {
    // eslint-disable-next-line no-self-compare -- NaN check
    return x === y || x != x && y != y;
};

},{}],"hG3nB":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var call = require('../internals/function-call');
var iterate = require('../internals/iterate');
var aCallable = require('../internals/a-callable');
// `Map.keyBy` method
// https://github.com/tc39/proposal-collection-methods
$({
    target: 'Map',
    stat: true
}, {
    keyBy: function keyBy(iterable, keyDerivative) {
        var newMap = new this();
        aCallable(keyDerivative);
        var setter = aCallable(newMap.set);
        iterate(iterable, function(element) {
            call(setter, newMap, keyDerivative(element), element);
        });
        return newMap;
    }
});

},{"../internals/export":"8yfGv","../internals/function-call":"jhLed","../internals/iterate":"fTyka","../internals/a-callable":"83opn"}],"bVfpe":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var anObject = require('../internals/an-object');
var getMapIterator = require('../internals/get-map-iterator');
var iterate = require('../internals/iterate');
// `Map.prototype.keyOf` method
// https://github.com/tc39/proposal-collection-methods
$({
    target: 'Map',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    keyOf: function keyOf(searchElement) {
        return iterate(getMapIterator(anObject(this)), function(key, value, stop) {
            if (value === searchElement) return stop(key);
        }, {
            AS_ENTRIES: true,
            IS_ITERATOR: true,
            INTERRUPTED: true
        }).result;
    }
});

},{"../internals/export":"8yfGv","../internals/is-pure":"6Bbq0","../internals/an-object":"1LIz9","../internals/get-map-iterator":"eIAYy","../internals/iterate":"fTyka"}],"dNgs8":[function(require,module,exports) {
'use strict';
var IS_PURE = require('../internals/is-pure');
var $ = require('../internals/export');
var getBuiltIn = require('../internals/get-built-in');
var bind = require('../internals/function-bind-context');
var call = require('../internals/function-call');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
var speciesConstructor = require('../internals/species-constructor');
var getMapIterator = require('../internals/get-map-iterator');
var iterate = require('../internals/iterate');
// `Map.prototype.mapKeys` method
// https://github.com/tc39/proposal-collection-methods
$({
    target: 'Map',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    mapKeys: function mapKeys(callbackfn /* , thisArg */ ) {
        var map = anObject(this);
        var iterator = getMapIterator(map);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        var newMap = new (speciesConstructor(map, getBuiltIn('Map')))();
        var setter = aCallable(newMap.set);
        iterate(iterator, function(key, value) {
            call(setter, newMap, boundFunction(value, key, map), value);
        }, {
            AS_ENTRIES: true,
            IS_ITERATOR: true
        });
        return newMap;
    }
});

},{"../internals/is-pure":"6Bbq0","../internals/export":"8yfGv","../internals/get-built-in":"78arb","../internals/function-bind-context":"kZubc","../internals/function-call":"jhLed","../internals/a-callable":"83opn","../internals/an-object":"1LIz9","../internals/species-constructor":"hqPl9","../internals/get-map-iterator":"eIAYy","../internals/iterate":"fTyka"}],"1ynz9":[function(require,module,exports) {
'use strict';
var IS_PURE = require('../internals/is-pure');
var $ = require('../internals/export');
var getBuiltIn = require('../internals/get-built-in');
var bind = require('../internals/function-bind-context');
var call = require('../internals/function-call');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
var speciesConstructor = require('../internals/species-constructor');
var getMapIterator = require('../internals/get-map-iterator');
var iterate = require('../internals/iterate');
// `Map.prototype.mapValues` method
// https://github.com/tc39/proposal-collection-methods
$({
    target: 'Map',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    mapValues: function mapValues(callbackfn /* , thisArg */ ) {
        var map = anObject(this);
        var iterator = getMapIterator(map);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        var newMap = new (speciesConstructor(map, getBuiltIn('Map')))();
        var setter = aCallable(newMap.set);
        iterate(iterator, function(key, value) {
            call(setter, newMap, key, boundFunction(value, key, map));
        }, {
            AS_ENTRIES: true,
            IS_ITERATOR: true
        });
        return newMap;
    }
});

},{"../internals/is-pure":"6Bbq0","../internals/export":"8yfGv","../internals/get-built-in":"78arb","../internals/function-bind-context":"kZubc","../internals/function-call":"jhLed","../internals/a-callable":"83opn","../internals/an-object":"1LIz9","../internals/species-constructor":"hqPl9","../internals/get-map-iterator":"eIAYy","../internals/iterate":"fTyka"}],"1BNOD":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
var iterate = require('../internals/iterate');
// `Map.prototype.merge` method
// https://github.com/tc39/proposal-collection-methods
$({
    target: 'Map',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    merge: function merge(iterable /* ...iterables */ ) {
        var map = anObject(this);
        var setter = aCallable(map.set);
        var argumentsLength = arguments.length;
        var i = 0;
        while(i < argumentsLength)iterate(arguments[i++], setter, {
            that: map,
            AS_ENTRIES: true
        });
        return map;
    }
});

},{"../internals/export":"8yfGv","../internals/is-pure":"6Bbq0","../internals/a-callable":"83opn","../internals/an-object":"1LIz9","../internals/iterate":"fTyka"}],"hGshw":[function(require,module,exports) {
var $ = require('../internals/export');
var of = require('../internals/collection-of');
// `Map.of` method
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
$({
    target: 'Map',
    stat: true
}, {
    of: of
});

},{"../internals/export":"8yfGv","../internals/collection-of":"7mrXK"}],"7mrXK":[function(require,module,exports) {
'use strict';
var arraySlice = require('../internals/array-slice');
// https://tc39.github.io/proposal-setmap-offrom/
module.exports = function of() {
    return new this(arraySlice(arguments));
};

},{"../internals/array-slice":"bI1dk"}],"92SIE":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var global = require('../internals/global');
var IS_PURE = require('../internals/is-pure');
var anObject = require('../internals/an-object');
var aCallable = require('../internals/a-callable');
var getMapIterator = require('../internals/get-map-iterator');
var iterate = require('../internals/iterate');
var TypeError = global.TypeError;
// `Map.prototype.reduce` method
// https://github.com/tc39/proposal-collection-methods
$({
    target: 'Map',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    reduce: function reduce(callbackfn /* , initialValue */ ) {
        var map = anObject(this);
        var iterator = getMapIterator(map);
        var noInitial = arguments.length < 2;
        var accumulator = noInitial ? undefined : arguments[1];
        aCallable(callbackfn);
        iterate(iterator, function(key, value) {
            if (noInitial) {
                noInitial = false;
                accumulator = value;
            } else accumulator = callbackfn(accumulator, value, key, map);
        }, {
            AS_ENTRIES: true,
            IS_ITERATOR: true
        });
        if (noInitial) throw TypeError('Reduce of empty map with no initial value');
        return accumulator;
    }
});

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/is-pure":"6Bbq0","../internals/an-object":"1LIz9","../internals/a-callable":"83opn","../internals/get-map-iterator":"eIAYy","../internals/iterate":"fTyka"}],"eXnP7":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var anObject = require('../internals/an-object');
var bind = require('../internals/function-bind-context');
var getMapIterator = require('../internals/get-map-iterator');
var iterate = require('../internals/iterate');
// `Set.prototype.some` method
// https://github.com/tc39/proposal-collection-methods
$({
    target: 'Map',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    some: function some(callbackfn /* , thisArg */ ) {
        var map = anObject(this);
        var iterator = getMapIterator(map);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        return iterate(iterator, function(key, value, stop) {
            if (boundFunction(value, key, map)) return stop();
        }, {
            AS_ENTRIES: true,
            IS_ITERATOR: true,
            INTERRUPTED: true
        }).stopped;
    }
});

},{"../internals/export":"8yfGv","../internals/is-pure":"6Bbq0","../internals/an-object":"1LIz9","../internals/function-bind-context":"kZubc","../internals/get-map-iterator":"eIAYy","../internals/iterate":"fTyka"}],"2dDW5":[function(require,module,exports) {
'use strict';
var IS_PURE = require('../internals/is-pure');
var $ = require('../internals/export');
var global = require('../internals/global');
var call = require('../internals/function-call');
var anObject = require('../internals/an-object');
var aCallable = require('../internals/a-callable');
var TypeError = global.TypeError;
// `Set.prototype.update` method
// https://github.com/tc39/proposal-collection-methods
$({
    target: 'Map',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    update: function update(key, callback /* , thunk */ ) {
        var map = anObject(this);
        var get = aCallable(map.get);
        var has = aCallable(map.has);
        var set = aCallable(map.set);
        var length = arguments.length;
        aCallable(callback);
        var isPresentInMap = call(has, map, key);
        if (!isPresentInMap && length < 3) throw TypeError('Updating absent value');
        var value = isPresentInMap ? call(get, map, key) : aCallable(length > 2 ? arguments[2] : undefined)(key, map);
        call(set, map, key, callback(value, key, map));
        return map;
    }
});

},{"../internals/is-pure":"6Bbq0","../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/function-call":"jhLed","../internals/an-object":"1LIz9","../internals/a-callable":"83opn"}],"gnbfb":[function(require,module,exports) {
'use strict';
// TODO: remove from `core-js@4`
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var upsert = require('../internals/map-upsert');
// `Map.prototype.updateOrInsert` method (replaced by `Map.prototype.emplace`)
// https://github.com/thumbsupep/proposal-upsert
$({
    target: 'Map',
    proto: true,
    real: true,
    name: 'upsert',
    forced: IS_PURE
}, {
    updateOrInsert: upsert
});

},{"../internals/export":"8yfGv","../internals/is-pure":"6Bbq0","../internals/map-upsert":"aZc2E"}],"aZc2E":[function(require,module,exports) {
'use strict';
var global = require('../internals/global');
var call = require('../internals/function-call');
var aCallable = require('../internals/a-callable');
var isCallable = require('../internals/is-callable');
var anObject = require('../internals/an-object');
var TypeError = global.TypeError;
// `Map.prototype.upsert` method
// https://github.com/thumbsupep/proposal-upsert
module.exports = function upsert(key, updateFn /* , insertFn */ ) {
    var map = anObject(this);
    var get = aCallable(map.get);
    var has = aCallable(map.has);
    var set = aCallable(map.set);
    var insertFn = arguments.length > 2 ? arguments[2] : undefined;
    var value;
    if (!isCallable(updateFn) && !isCallable(insertFn)) throw TypeError('At least one callback required');
    if (call(has, map, key)) {
        value = call(get, map, key);
        if (isCallable(updateFn)) {
            value = updateFn(value);
            call(set, map, key, value);
        }
    } else if (isCallable(insertFn)) {
        value = insertFn();
        call(set, map, key, value);
    }
    return value;
};

},{"../internals/global":"jxPDA","../internals/function-call":"jhLed","../internals/a-callable":"83opn","../internals/is-callable":"kPhuP","../internals/an-object":"1LIz9"}],"bEOE2":[function(require,module,exports) {
'use strict';
// TODO: remove from `core-js@4`
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var upsert = require('../internals/map-upsert');
// `Map.prototype.upsert` method (replaced by `Map.prototype.emplace`)
// https://github.com/thumbsupep/proposal-upsert
$({
    target: 'Map',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    upsert: upsert
});

},{"../internals/export":"8yfGv","../internals/is-pure":"6Bbq0","../internals/map-upsert":"aZc2E"}],"kH4QW":[function(require,module,exports) {
var $ = require('../internals/export');
var min = Math.min;
var max = Math.max;
// `Math.clamp` method
// https://rwaldron.github.io/proposal-math-extensions/
$({
    target: 'Math',
    stat: true
}, {
    clamp: function clamp(x, lower, upper) {
        return min(upper, max(lower, x));
    }
});

},{"../internals/export":"8yfGv"}],"jJkpH":[function(require,module,exports) {
var $ = require('../internals/export');
// `Math.DEG_PER_RAD` constant
// https://rwaldron.github.io/proposal-math-extensions/
$({
    target: 'Math',
    stat: true
}, {
    DEG_PER_RAD: Math.PI / 180
});

},{"../internals/export":"8yfGv"}],"lMntd":[function(require,module,exports) {
var $ = require('../internals/export');
var RAD_PER_DEG = 180 / Math.PI;
// `Math.degrees` method
// https://rwaldron.github.io/proposal-math-extensions/
$({
    target: 'Math',
    stat: true
}, {
    degrees: function degrees(radians) {
        return radians * RAD_PER_DEG;
    }
});

},{"../internals/export":"8yfGv"}],"f4pY4":[function(require,module,exports) {
var $ = require('../internals/export');
var scale = require('../internals/math-scale');
var fround = require('../internals/math-fround');
// `Math.fscale` method
// https://rwaldron.github.io/proposal-math-extensions/
$({
    target: 'Math',
    stat: true
}, {
    fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
        return fround(scale(x, inLow, inHigh, outLow, outHigh));
    }
});

},{"../internals/export":"8yfGv","../internals/math-scale":"jYo3z","../internals/math-fround":"4x3OH"}],"jYo3z":[function(require,module,exports) {
// `Math.scale` method implementation
// https://rwaldron.github.io/proposal-math-extensions/
module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
    var nx = +x;
    var nInLow = +inLow;
    var nInHigh = +inHigh;
    var nOutLow = +outLow;
    var nOutHigh = +outHigh;
    // eslint-disable-next-line no-self-compare -- NaN check
    if (nx != nx || nInLow != nInLow || nInHigh != nInHigh || nOutLow != nOutLow || nOutHigh != nOutHigh) return NaN;
    if (nx === Infinity || nx === -Infinity) return nx;
    return (nx - nInLow) * (nOutHigh - nOutLow) / (nInHigh - nInLow) + nOutLow;
};

},{}],"gU7xA":[function(require,module,exports) {
var $ = require('../internals/export');
// `Math.iaddh` method
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
// TODO: Remove from `core-js@4`
$({
    target: 'Math',
    stat: true
}, {
    iaddh: function iaddh(x0, x1, y0, y1) {
        var $x0 = x0 >>> 0;
        var $x1 = x1 >>> 0;
        var $y0 = y0 >>> 0;
        return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
    }
});

},{"../internals/export":"8yfGv"}],"gSmGL":[function(require,module,exports) {
var $ = require('../internals/export');
// `Math.imulh` method
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
// TODO: Remove from `core-js@4`
$({
    target: 'Math',
    stat: true
}, {
    imulh: function imulh(u, v) {
        var UINT16 = 65535;
        var $u = +u;
        var $v = +v;
        var u0 = $u & UINT16;
        var v0 = $v & UINT16;
        var u1 = $u >> 16;
        var v1 = $v >> 16;
        var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
        return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
    }
});

},{"../internals/export":"8yfGv"}],"ai2ZI":[function(require,module,exports) {
var $ = require('../internals/export');
// `Math.isubh` method
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
// TODO: Remove from `core-js@4`
$({
    target: 'Math',
    stat: true
}, {
    isubh: function isubh(x0, x1, y0, y1) {
        var $x0 = x0 >>> 0;
        var $x1 = x1 >>> 0;
        var $y0 = y0 >>> 0;
        return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
    }
});

},{"../internals/export":"8yfGv"}],"5Xw5Q":[function(require,module,exports) {
var $ = require('../internals/export');
// `Math.RAD_PER_DEG` constant
// https://rwaldron.github.io/proposal-math-extensions/
$({
    target: 'Math',
    stat: true
}, {
    RAD_PER_DEG: 180 / Math.PI
});

},{"../internals/export":"8yfGv"}],"3pizV":[function(require,module,exports) {
var $ = require('../internals/export');
var DEG_PER_RAD = Math.PI / 180;
// `Math.radians` method
// https://rwaldron.github.io/proposal-math-extensions/
$({
    target: 'Math',
    stat: true
}, {
    radians: function radians(degrees) {
        return degrees * DEG_PER_RAD;
    }
});

},{"../internals/export":"8yfGv"}],"1Hici":[function(require,module,exports) {
var $ = require('../internals/export');
var scale = require('../internals/math-scale');
// `Math.scale` method
// https://rwaldron.github.io/proposal-math-extensions/
$({
    target: 'Math',
    stat: true
}, {
    scale: scale
});

},{"../internals/export":"8yfGv","../internals/math-scale":"jYo3z"}],"ltxqc":[function(require,module,exports) {
var $ = require('../internals/export');
var global = require('../internals/global');
var anObject = require('../internals/an-object');
var numberIsFinite = require('../internals/number-is-finite');
var createIteratorConstructor = require('../internals/create-iterator-constructor');
var InternalStateModule = require('../internals/internal-state');
var SEEDED_RANDOM = 'Seeded Random';
var SEEDED_RANDOM_GENERATOR = SEEDED_RANDOM + ' Generator';
var SEED_TYPE_ERROR = 'Math.seededPRNG() argument should have a "seed" field with a finite value.';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SEEDED_RANDOM_GENERATOR);
var TypeError = global.TypeError;
var $SeededRandomGenerator = createIteratorConstructor(function SeededRandomGenerator(seed) {
    setInternalState(this, {
        type: SEEDED_RANDOM_GENERATOR,
        seed: seed % 2147483647
    });
}, SEEDED_RANDOM, function next() {
    var state = getInternalState(this);
    var seed = state.seed = (state.seed * 1103515245 + 12345) % 2147483647;
    return {
        value: (seed & 1073741823) / 1073741823,
        done: false
    };
});
// `Math.seededPRNG` method
// https://github.com/tc39/proposal-seeded-random
// based on https://github.com/tc39/proposal-seeded-random/blob/78b8258835b57fc2100d076151ab506bc3202ae6/demo.html
$({
    target: 'Math',
    stat: true,
    forced: true
}, {
    seededPRNG: function seededPRNG(it) {
        var seed = anObject(it).seed;
        if (!numberIsFinite(seed)) throw TypeError(SEED_TYPE_ERROR);
        return new $SeededRandomGenerator(seed);
    }
});

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/an-object":"1LIz9","../internals/number-is-finite":"d2LZ1","../internals/create-iterator-constructor":"1fB00","../internals/internal-state":"i6AaM"}],"93Af1":[function(require,module,exports) {
var $ = require('../internals/export');
// `Math.signbit` method
// https://github.com/tc39/proposal-Math.signbit
$({
    target: 'Math',
    stat: true
}, {
    signbit: function signbit(x) {
        return (x = +x) == x && x == 0 ? 1 / x == -Infinity : x < 0;
    }
});

},{"../internals/export":"8yfGv"}],"8FapI":[function(require,module,exports) {
var $ = require('../internals/export');
// `Math.umulh` method
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
// TODO: Remove from `core-js@4`
$({
    target: 'Math',
    stat: true
}, {
    umulh: function umulh(u, v) {
        var UINT16 = 65535;
        var $u = +u;
        var $v = +v;
        var u0 = $u & UINT16;
        var v0 = $v & UINT16;
        var u1 = $u >>> 16;
        var v1 = $v >>> 16;
        var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
        return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
    }
});

},{"../internals/export":"8yfGv"}],"dcrra":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var global = require('../internals/global');
var uncurryThis = require('../internals/function-uncurry-this');
var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
var parseInt = require('../internals/number-parse-int');
var INVALID_NUMBER_REPRESENTATION = 'Invalid number representation';
var INVALID_RADIX = 'Invalid radix';
var RangeError = global.RangeError;
var SyntaxError = global.SyntaxError;
var TypeError = global.TypeError;
var valid = /^[\da-z]+$/;
var charAt = uncurryThis(''.charAt);
var exec = uncurryThis(valid.exec);
var numberToString = uncurryThis(1..toString);
var stringSlice = uncurryThis(''.slice);
// `Number.fromString` method
// https://github.com/tc39/proposal-number-fromstring
$({
    target: 'Number',
    stat: true
}, {
    fromString: function fromString(string, radix) {
        var sign = 1;
        var R, mathNum;
        if (typeof string != 'string') throw TypeError(INVALID_NUMBER_REPRESENTATION);
        if (!string.length) throw SyntaxError(INVALID_NUMBER_REPRESENTATION);
        if (charAt(string, 0) == '-') {
            sign = -1;
            string = stringSlice(string, 1);
            if (!string.length) throw SyntaxError(INVALID_NUMBER_REPRESENTATION);
        }
        R = radix === undefined ? 10 : toIntegerOrInfinity(radix);
        if (R < 2 || R > 36) throw RangeError(INVALID_RADIX);
        if (!exec(valid, string) || numberToString(mathNum = parseInt(string, R), R) !== string) throw SyntaxError(INVALID_NUMBER_REPRESENTATION);
        return sign * mathNum;
    }
});

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/function-uncurry-this":"jJnXC","../internals/to-integer-or-infinity":"aqyxv","../internals/number-parse-int":"6rlJ1"}],"bwLIP":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var NumericRangeIterator = require('../internals/numeric-range-iterator');
// `Number.range` method
// https://github.com/tc39/proposal-Number.range
$({
    target: 'Number',
    stat: true
}, {
    range: function range(start, end, option) {
        return new NumericRangeIterator(start, end, option, 'number', 0, 1);
    }
});

},{"../internals/export":"8yfGv","../internals/numeric-range-iterator":"kHyPF"}],"cv3dG":[function(require,module,exports) {
// TODO: Remove from `core-js@4`
require('../modules/es.object.has-own');

},{"../modules/es.object.has-own":"fwKd5"}],"eav8f":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var ObjectIterator = require('../internals/object-iterator');
// `Object.iterateEntries` method
// https://github.com/tc39/proposal-object-iteration
$({
    target: 'Object',
    stat: true
}, {
    iterateEntries: function iterateEntries(object) {
        return new ObjectIterator(object, 'entries');
    }
});

},{"../internals/export":"8yfGv","../internals/object-iterator":"4B85F"}],"4B85F":[function(require,module,exports) {
'use strict';
var InternalStateModule = require('../internals/internal-state');
var createIteratorConstructor = require('../internals/create-iterator-constructor');
var hasOwn = require('../internals/has-own-property');
var objectKeys = require('../internals/object-keys');
var toObject = require('../internals/to-object');
var OBJECT_ITERATOR = 'Object Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(OBJECT_ITERATOR);
module.exports = createIteratorConstructor(function ObjectIterator(source, mode) {
    var object = toObject(source);
    setInternalState(this, {
        type: OBJECT_ITERATOR,
        mode: mode,
        object: object,
        keys: objectKeys(object),
        index: 0
    });
}, 'Object', function next() {
    var state = getInternalState(this);
    var keys = state.keys;
    while(true){
        if (keys === null || state.index >= keys.length) {
            state.object = state.keys = null;
            return {
                value: undefined,
                done: true
            };
        }
        var key = keys[state.index++];
        var object = state.object;
        if (!hasOwn(object, key)) continue;
        switch(state.mode){
            case 'keys':
                return {
                    value: key,
                    done: false
                };
            case 'values':
                return {
                    value: object[key],
                    done: false
                };
        } /* entries */ 
        return {
            value: [
                key,
                object[key]
            ],
            done: false
        };
    }
});

},{"../internals/internal-state":"i6AaM","../internals/create-iterator-constructor":"1fB00","../internals/has-own-property":"3ZdUC","../internals/object-keys":"9bK4Y","../internals/to-object":"eEdae"}],"Tv2RH":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var ObjectIterator = require('../internals/object-iterator');
// `Object.iterateKeys` method
// https://github.com/tc39/proposal-object-iteration
$({
    target: 'Object',
    stat: true
}, {
    iterateKeys: function iterateKeys(object) {
        return new ObjectIterator(object, 'keys');
    }
});

},{"../internals/export":"8yfGv","../internals/object-iterator":"4B85F"}],"gw6b3":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var ObjectIterator = require('../internals/object-iterator');
// `Object.iterateValues` method
// https://github.com/tc39/proposal-object-iteration
$({
    target: 'Object',
    stat: true
}, {
    iterateValues: function iterateValues(object) {
        return new ObjectIterator(object, 'values');
    }
});

},{"../internals/export":"8yfGv","../internals/object-iterator":"4B85F"}],"aFQ7a":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-observable
var $ = require('../internals/export');
var global = require('../internals/global');
var call = require('../internals/function-call');
var DESCRIPTORS = require('../internals/descriptors');
var setSpecies = require('../internals/set-species');
var aCallable = require('../internals/a-callable');
var isCallable = require('../internals/is-callable');
var isConstructor = require('../internals/is-constructor');
var anObject = require('../internals/an-object');
var isObject = require('../internals/is-object');
var anInstance = require('../internals/an-instance');
var defineProperty = require('../internals/object-define-property').f;
var redefine = require('../internals/redefine');
var redefineAll = require('../internals/redefine-all');
var getIterator = require('../internals/get-iterator');
var getMethod = require('../internals/get-method');
var iterate = require('../internals/iterate');
var hostReportErrors = require('../internals/host-report-errors');
var wellKnownSymbol = require('../internals/well-known-symbol');
var InternalStateModule = require('../internals/internal-state');
var $$OBSERVABLE = wellKnownSymbol('observable');
var OBSERVABLE = 'Observable';
var SUBSCRIPTION = 'Subscription';
var SUBSCRIPTION_OBSERVER = 'SubscriptionObserver';
var getterFor = InternalStateModule.getterFor;
var setInternalState = InternalStateModule.set;
var getObservableInternalState = getterFor(OBSERVABLE);
var getSubscriptionInternalState = getterFor(SUBSCRIPTION);
var getSubscriptionObserverInternalState = getterFor(SUBSCRIPTION_OBSERVER);
var Array = global.Array;
var SubscriptionState = function(observer) {
    this.observer = anObject(observer);
    this.cleanup = undefined;
    this.subscriptionObserver = undefined;
};
SubscriptionState.prototype = {
    type: SUBSCRIPTION,
    clean: function() {
        var cleanup = this.cleanup;
        if (cleanup) {
            this.cleanup = undefined;
            try {
                cleanup();
            } catch (error) {
                hostReportErrors(error);
            }
        }
    },
    close: function() {
        if (!DESCRIPTORS) {
            var subscription = this.facade;
            var subscriptionObserver = this.subscriptionObserver;
            subscription.closed = true;
            if (subscriptionObserver) subscriptionObserver.closed = true;
        }
        this.observer = undefined;
    },
    isClosed: function() {
        return this.observer === undefined;
    }
};
var Subscription = function(observer, subscriber) {
    var subscriptionState = setInternalState(this, new SubscriptionState(observer));
    var start;
    if (!DESCRIPTORS) this.closed = false;
    try {
        if (start = getMethod(observer, 'start')) call(start, observer, this);
    } catch (error) {
        hostReportErrors(error);
    }
    if (subscriptionState.isClosed()) return;
    var subscriptionObserver = subscriptionState.subscriptionObserver = new SubscriptionObserver(subscriptionState);
    try {
        var cleanup = subscriber(subscriptionObserver);
        var subscription = cleanup;
        if (cleanup != null) subscriptionState.cleanup = isCallable(cleanup.unsubscribe) ? function() {
            subscription.unsubscribe();
        } : aCallable(cleanup);
    } catch (error1) {
        subscriptionObserver.error(error1);
        return;
    }
    if (subscriptionState.isClosed()) subscriptionState.clean();
};
Subscription.prototype = redefineAll({
}, {
    unsubscribe: function unsubscribe() {
        var subscriptionState = getSubscriptionInternalState(this);
        if (!subscriptionState.isClosed()) {
            subscriptionState.close();
            subscriptionState.clean();
        }
    }
});
if (DESCRIPTORS) defineProperty(Subscription.prototype, 'closed', {
    configurable: true,
    get: function() {
        return getSubscriptionInternalState(this).isClosed();
    }
});
var SubscriptionObserver = function(subscriptionState) {
    setInternalState(this, {
        type: SUBSCRIPTION_OBSERVER,
        subscriptionState: subscriptionState
    });
    if (!DESCRIPTORS) this.closed = false;
};
SubscriptionObserver.prototype = redefineAll({
}, {
    next: function next(value) {
        var subscriptionState = getSubscriptionObserverInternalState(this).subscriptionState;
        if (!subscriptionState.isClosed()) {
            var observer = subscriptionState.observer;
            try {
                var nextMethod = getMethod(observer, 'next');
                if (nextMethod) call(nextMethod, observer, value);
            } catch (error) {
                hostReportErrors(error);
            }
        }
    },
    error: function error(value) {
        var subscriptionState = getSubscriptionObserverInternalState(this).subscriptionState;
        if (!subscriptionState.isClosed()) {
            var observer = subscriptionState.observer;
            subscriptionState.close();
            try {
                var errorMethod = getMethod(observer, 'error');
                if (errorMethod) call(errorMethod, observer, value);
                else hostReportErrors(value);
            } catch (err) {
                hostReportErrors(err);
            }
            subscriptionState.clean();
        }
    },
    complete: function complete() {
        var subscriptionState = getSubscriptionObserverInternalState(this).subscriptionState;
        if (!subscriptionState.isClosed()) {
            var observer = subscriptionState.observer;
            subscriptionState.close();
            try {
                var completeMethod = getMethod(observer, 'complete');
                if (completeMethod) call(completeMethod, observer);
            } catch (error) {
                hostReportErrors(error);
            }
            subscriptionState.clean();
        }
    }
});
if (DESCRIPTORS) defineProperty(SubscriptionObserver.prototype, 'closed', {
    configurable: true,
    get: function() {
        return getSubscriptionObserverInternalState(this).subscriptionState.isClosed();
    }
});
var $Observable = function Observable(subscriber) {
    anInstance(this, ObservablePrototype);
    setInternalState(this, {
        type: OBSERVABLE,
        subscriber: aCallable(subscriber)
    });
};
var ObservablePrototype = $Observable.prototype;
redefineAll(ObservablePrototype, {
    subscribe: function subscribe(observer) {
        var length = arguments.length;
        return new Subscription(isCallable(observer) ? {
            next: observer,
            error: length > 1 ? arguments[1] : undefined,
            complete: length > 2 ? arguments[2] : undefined
        } : isObject(observer) ? observer : {
        }, getObservableInternalState(this).subscriber);
    }
});
redefineAll($Observable, {
    from: function from(x) {
        var C = isConstructor(this) ? this : $Observable;
        var observableMethod = getMethod(anObject(x), $$OBSERVABLE);
        if (observableMethod) {
            var observable = anObject(call(observableMethod, x));
            return observable.constructor === C ? observable : new C(function(observer) {
                return observable.subscribe(observer);
            });
        }
        var iterator = getIterator(x);
        return new C(function(observer) {
            iterate(iterator, function(it, stop) {
                observer.next(it);
                if (observer.closed) return stop();
            }, {
                IS_ITERATOR: true,
                INTERRUPTED: true
            });
            observer.complete();
        });
    },
    of: function of() {
        var C = isConstructor(this) ? this : $Observable;
        var length = arguments.length;
        var items = Array(length);
        var index = 0;
        while(index < length)items[index] = arguments[index++];
        return new C(function(observer) {
            for(var i = 0; i < length; i++){
                observer.next(items[i]);
                if (observer.closed) return;
            }
            observer.complete();
        });
    }
});
redefine(ObservablePrototype, $$OBSERVABLE, function() {
    return this;
});
$({
    global: true
}, {
    Observable: $Observable
});
setSpecies(OBSERVABLE);

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/function-call":"jhLed","../internals/descriptors":"6ZLib","../internals/set-species":"hBKMQ","../internals/a-callable":"83opn","../internals/is-callable":"kPhuP","../internals/is-constructor":"iNoNi","../internals/an-object":"1LIz9","../internals/is-object":"dplrD","../internals/an-instance":"2zeQg","../internals/object-define-property":"bauTd","../internals/redefine":"kxbj8","../internals/redefine-all":"ch5Rt","../internals/get-iterator":"dQrLE","../internals/get-method":"hEJ6b","../internals/iterate":"fTyka","../internals/host-report-errors":"99n7W","../internals/well-known-symbol":"5C8sm","../internals/internal-state":"i6AaM"}],"1EjGT":[function(require,module,exports) {
// TODO: Remove from `core-js@4`
require('../modules/es.promise.all-settled.js');

},{"../modules/es.promise.all-settled.js":"drqVJ"}],"kCS9D":[function(require,module,exports) {
// TODO: Remove from `core-js@4`
require('../modules/es.promise.any');

},{"../modules/es.promise.any":"6J3yz"}],"eJs6O":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var newPromiseCapabilityModule = require('../internals/new-promise-capability');
var perform = require('../internals/perform');
// `Promise.try` method
// https://github.com/tc39/proposal-promise-try
$({
    target: 'Promise',
    stat: true
}, {
    'try': function(callbackfn) {
        var promiseCapability = newPromiseCapabilityModule.f(this);
        var result = perform(callbackfn);
        (result.error ? promiseCapability.reject : promiseCapability.resolve)(result.value);
        return promiseCapability.promise;
    }
});

},{"../internals/export":"8yfGv","../internals/new-promise-capability":"1jyVt","../internals/perform":"1r4qC"}],"kBQIa":[function(require,module,exports) {
var $ = require('../internals/export');
var ReflectMetadataModule = require('../internals/reflect-metadata');
var anObject = require('../internals/an-object');
var toMetadataKey = ReflectMetadataModule.toKey;
var ordinaryDefineOwnMetadata = ReflectMetadataModule.set;
// `Reflect.defineMetadata` method
// https://github.com/rbuckton/reflect-metadata
$({
    target: 'Reflect',
    stat: true
}, {
    defineMetadata: function defineMetadata(metadataKey, metadataValue, target /* , targetKey */ ) {
        var targetKey = arguments.length < 4 ? undefined : toMetadataKey(arguments[3]);
        ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), targetKey);
    }
});

},{"../internals/export":"8yfGv","../internals/reflect-metadata":"9j1OR","../internals/an-object":"1LIz9"}],"9j1OR":[function(require,module,exports) {
// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
require('../modules/es.map');
require('../modules/es.weak-map');
var getBuiltIn = require('../internals/get-built-in');
var uncurryThis = require('../internals/function-uncurry-this');
var shared = require('../internals/shared');
var Map = getBuiltIn('Map');
var WeakMap = getBuiltIn('WeakMap');
var push = uncurryThis([].push);
var metadata = shared('metadata');
var store = metadata.store || (metadata.store = new WeakMap());
var getOrCreateMetadataMap = function(target, targetKey, create) {
    var targetMetadata = store.get(target);
    if (!targetMetadata) {
        if (!create) return;
        store.set(target, targetMetadata = new Map());
    }
    var keyMetadata = targetMetadata.get(targetKey);
    if (!keyMetadata) {
        if (!create) return;
        targetMetadata.set(targetKey, keyMetadata = new Map());
    }
    return keyMetadata;
};
var ordinaryHasOwnMetadata = function(MetadataKey, O, P) {
    var metadataMap = getOrCreateMetadataMap(O, P, false);
    return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function(MetadataKey, O, P) {
    var metadataMap = getOrCreateMetadataMap(O, P, false);
    return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function(MetadataKey, MetadataValue, O, P) {
    getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function(target, targetKey) {
    var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
    var keys = [];
    if (metadataMap) metadataMap.forEach(function(_, key) {
        push(keys, key);
    });
    return keys;
};
var toMetadataKey = function(it) {
    return it === undefined || typeof it == 'symbol' ? it : String(it);
};
module.exports = {
    store: store,
    getMap: getOrCreateMetadataMap,
    has: ordinaryHasOwnMetadata,
    get: ordinaryGetOwnMetadata,
    set: ordinaryDefineOwnMetadata,
    keys: ordinaryOwnMetadataKeys,
    toKey: toMetadataKey
};

},{"../modules/es.map":"ayxWX","../modules/es.weak-map":"lEfis","../internals/get-built-in":"78arb","../internals/function-uncurry-this":"jJnXC","../internals/shared":"7VLeP"}],"4gsYN":[function(require,module,exports) {
var $ = require('../internals/export');
var ReflectMetadataModule = require('../internals/reflect-metadata');
var anObject = require('../internals/an-object');
var toMetadataKey = ReflectMetadataModule.toKey;
var getOrCreateMetadataMap = ReflectMetadataModule.getMap;
var store = ReflectMetadataModule.store;
// `Reflect.deleteMetadata` method
// https://github.com/rbuckton/reflect-metadata
$({
    target: 'Reflect',
    stat: true
}, {
    deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */ ) {
        var targetKey = arguments.length < 3 ? undefined : toMetadataKey(arguments[2]);
        var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
        if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
        if (metadataMap.size) return true;
        var targetMetadata = store.get(target);
        targetMetadata['delete'](targetKey);
        return !!targetMetadata.size || store['delete'](target);
    }
});

},{"../internals/export":"8yfGv","../internals/reflect-metadata":"9j1OR","../internals/an-object":"1LIz9"}],"7sMI1":[function(require,module,exports) {
var $ = require('../internals/export');
var ReflectMetadataModule = require('../internals/reflect-metadata');
var anObject = require('../internals/an-object');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var ordinaryHasOwnMetadata = ReflectMetadataModule.has;
var ordinaryGetOwnMetadata = ReflectMetadataModule.get;
var toMetadataKey = ReflectMetadataModule.toKey;
var ordinaryGetMetadata = function(MetadataKey, O, P) {
    var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
    if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
    var parent = getPrototypeOf(O);
    return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};
// `Reflect.getMetadata` method
// https://github.com/rbuckton/reflect-metadata
$({
    target: 'Reflect',
    stat: true
}, {
    getMetadata: function getMetadata(metadataKey, target /* , targetKey */ ) {
        var targetKey = arguments.length < 3 ? undefined : toMetadataKey(arguments[2]);
        return ordinaryGetMetadata(metadataKey, anObject(target), targetKey);
    }
});

},{"../internals/export":"8yfGv","../internals/reflect-metadata":"9j1OR","../internals/an-object":"1LIz9","../internals/object-get-prototype-of":"lBy7h"}],"4wehQ":[function(require,module,exports) {
var $ = require('../internals/export');
var uncurryThis = require('../internals/function-uncurry-this');
var ReflectMetadataModule = require('../internals/reflect-metadata');
var anObject = require('../internals/an-object');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var $arrayUniqueBy = require('../internals/array-unique-by');
var arrayUniqueBy = uncurryThis($arrayUniqueBy);
var concat = uncurryThis([].concat);
var ordinaryOwnMetadataKeys = ReflectMetadataModule.keys;
var toMetadataKey = ReflectMetadataModule.toKey;
var ordinaryMetadataKeys = function(O, P) {
    var oKeys = ordinaryOwnMetadataKeys(O, P);
    var parent = getPrototypeOf(O);
    if (parent === null) return oKeys;
    var pKeys = ordinaryMetadataKeys(parent, P);
    return pKeys.length ? oKeys.length ? arrayUniqueBy(concat(oKeys, pKeys)) : pKeys : oKeys;
};
// `Reflect.getMetadataKeys` method
// https://github.com/rbuckton/reflect-metadata
$({
    target: 'Reflect',
    stat: true
}, {
    getMetadataKeys: function getMetadataKeys(target /* , targetKey */ ) {
        var targetKey = arguments.length < 2 ? undefined : toMetadataKey(arguments[1]);
        return ordinaryMetadataKeys(anObject(target), targetKey);
    }
});

},{"../internals/export":"8yfGv","../internals/function-uncurry-this":"jJnXC","../internals/reflect-metadata":"9j1OR","../internals/an-object":"1LIz9","../internals/object-get-prototype-of":"lBy7h","../internals/array-unique-by":"43InR"}],"lyeG8":[function(require,module,exports) {
var $ = require('../internals/export');
var ReflectMetadataModule = require('../internals/reflect-metadata');
var anObject = require('../internals/an-object');
var ordinaryGetOwnMetadata = ReflectMetadataModule.get;
var toMetadataKey = ReflectMetadataModule.toKey;
// `Reflect.getOwnMetadata` method
// https://github.com/rbuckton/reflect-metadata
$({
    target: 'Reflect',
    stat: true
}, {
    getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */ ) {
        var targetKey = arguments.length < 3 ? undefined : toMetadataKey(arguments[2]);
        return ordinaryGetOwnMetadata(metadataKey, anObject(target), targetKey);
    }
});

},{"../internals/export":"8yfGv","../internals/reflect-metadata":"9j1OR","../internals/an-object":"1LIz9"}],"67yRm":[function(require,module,exports) {
var $ = require('../internals/export');
var ReflectMetadataModule = require('../internals/reflect-metadata');
var anObject = require('../internals/an-object');
var ordinaryOwnMetadataKeys = ReflectMetadataModule.keys;
var toMetadataKey = ReflectMetadataModule.toKey;
// `Reflect.getOwnMetadataKeys` method
// https://github.com/rbuckton/reflect-metadata
$({
    target: 'Reflect',
    stat: true
}, {
    getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */ ) {
        var targetKey = arguments.length < 2 ? undefined : toMetadataKey(arguments[1]);
        return ordinaryOwnMetadataKeys(anObject(target), targetKey);
    }
});

},{"../internals/export":"8yfGv","../internals/reflect-metadata":"9j1OR","../internals/an-object":"1LIz9"}],"4RJ2Z":[function(require,module,exports) {
var $ = require('../internals/export');
var ReflectMetadataModule = require('../internals/reflect-metadata');
var anObject = require('../internals/an-object');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var ordinaryHasOwnMetadata = ReflectMetadataModule.has;
var toMetadataKey = ReflectMetadataModule.toKey;
var ordinaryHasMetadata = function(MetadataKey, O, P) {
    var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
    if (hasOwn) return true;
    var parent = getPrototypeOf(O);
    return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};
// `Reflect.hasMetadata` method
// https://github.com/rbuckton/reflect-metadata
$({
    target: 'Reflect',
    stat: true
}, {
    hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */ ) {
        var targetKey = arguments.length < 3 ? undefined : toMetadataKey(arguments[2]);
        return ordinaryHasMetadata(metadataKey, anObject(target), targetKey);
    }
});

},{"../internals/export":"8yfGv","../internals/reflect-metadata":"9j1OR","../internals/an-object":"1LIz9","../internals/object-get-prototype-of":"lBy7h"}],"fgTte":[function(require,module,exports) {
var $ = require('../internals/export');
var ReflectMetadataModule = require('../internals/reflect-metadata');
var anObject = require('../internals/an-object');
var ordinaryHasOwnMetadata = ReflectMetadataModule.has;
var toMetadataKey = ReflectMetadataModule.toKey;
// `Reflect.hasOwnMetadata` method
// https://github.com/rbuckton/reflect-metadata
$({
    target: 'Reflect',
    stat: true
}, {
    hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */ ) {
        var targetKey = arguments.length < 3 ? undefined : toMetadataKey(arguments[2]);
        return ordinaryHasOwnMetadata(metadataKey, anObject(target), targetKey);
    }
});

},{"../internals/export":"8yfGv","../internals/reflect-metadata":"9j1OR","../internals/an-object":"1LIz9"}],"iolfU":[function(require,module,exports) {
var $ = require('../internals/export');
var ReflectMetadataModule = require('../internals/reflect-metadata');
var anObject = require('../internals/an-object');
var toMetadataKey = ReflectMetadataModule.toKey;
var ordinaryDefineOwnMetadata = ReflectMetadataModule.set;
// `Reflect.metadata` method
// https://github.com/rbuckton/reflect-metadata
$({
    target: 'Reflect',
    stat: true
}, {
    metadata: function metadata(metadataKey, metadataValue) {
        return function decorator(target, key) {
            ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetadataKey(key));
        };
    }
});

},{"../internals/export":"8yfGv","../internals/reflect-metadata":"9j1OR","../internals/an-object":"1LIz9"}],"jv0cJ":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var addAll = require('../internals/collection-add-all');
// `Set.prototype.addAll` method
// https://github.com/tc39/proposal-collection-methods
$({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    addAll: addAll
});

},{"../internals/export":"8yfGv","../internals/is-pure":"6Bbq0","../internals/collection-add-all":"1I877"}],"1I877":[function(require,module,exports) {
'use strict';
var call = require('../internals/function-call');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
// https://github.com/tc39/collection-methods
module.exports = function addAll() {
    var set = anObject(this);
    var adder = aCallable(set.add);
    for(var k = 0, len = arguments.length; k < len; k++)call(adder, set, arguments[k]);
    return set;
};

},{"../internals/function-call":"jhLed","../internals/a-callable":"83opn","../internals/an-object":"1LIz9"}],"3Wgu2":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var deleteAll = require('../internals/collection-delete-all');
// `Set.prototype.deleteAll` method
// https://github.com/tc39/proposal-collection-methods
$({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    deleteAll: deleteAll
});

},{"../internals/export":"8yfGv","../internals/is-pure":"6Bbq0","../internals/collection-delete-all":"7mZy7"}],"hFHYU":[function(require,module,exports) {
'use strict';
var IS_PURE = require('../internals/is-pure');
var $ = require('../internals/export');
var getBuiltIn = require('../internals/get-built-in');
var call = require('../internals/function-call');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
var speciesConstructor = require('../internals/species-constructor');
var iterate = require('../internals/iterate');
// `Set.prototype.difference` method
// https://github.com/tc39/proposal-set-methods
$({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    difference: function difference(iterable) {
        var set = anObject(this);
        var newSet = new (speciesConstructor(set, getBuiltIn('Set')))(set);
        var remover = aCallable(newSet['delete']);
        iterate(iterable, function(value) {
            call(remover, newSet, value);
        });
        return newSet;
    }
});

},{"../internals/is-pure":"6Bbq0","../internals/export":"8yfGv","../internals/get-built-in":"78arb","../internals/function-call":"jhLed","../internals/a-callable":"83opn","../internals/an-object":"1LIz9","../internals/species-constructor":"hqPl9","../internals/iterate":"fTyka"}],"7zC6t":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var anObject = require('../internals/an-object');
var bind = require('../internals/function-bind-context');
var getSetIterator = require('../internals/get-set-iterator');
var iterate = require('../internals/iterate');
// `Set.prototype.every` method
// https://github.com/tc39/proposal-collection-methods
$({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    every: function every(callbackfn /* , thisArg */ ) {
        var set = anObject(this);
        var iterator = getSetIterator(set);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        return !iterate(iterator, function(value, stop) {
            if (!boundFunction(value, value, set)) return stop();
        }, {
            IS_ITERATOR: true,
            INTERRUPTED: true
        }).stopped;
    }
});

},{"../internals/export":"8yfGv","../internals/is-pure":"6Bbq0","../internals/an-object":"1LIz9","../internals/function-bind-context":"kZubc","../internals/get-set-iterator":"iN6xq","../internals/iterate":"fTyka"}],"iN6xq":[function(require,module,exports) {
var call = require('../internals/function-call');
module.exports = function(it) {
    // eslint-disable-next-line es/no-set -- safe
    return call(Set.prototype.values, it);
};

},{"../internals/function-call":"jhLed"}],"gSQqX":[function(require,module,exports) {
'use strict';
var IS_PURE = require('../internals/is-pure');
var $ = require('../internals/export');
var getBuiltIn = require('../internals/get-built-in');
var call = require('../internals/function-call');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
var bind = require('../internals/function-bind-context');
var speciesConstructor = require('../internals/species-constructor');
var getSetIterator = require('../internals/get-set-iterator');
var iterate = require('../internals/iterate');
// `Set.prototype.filter` method
// https://github.com/tc39/proposal-collection-methods
$({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    filter: function filter(callbackfn /* , thisArg */ ) {
        var set = anObject(this);
        var iterator = getSetIterator(set);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        var newSet = new (speciesConstructor(set, getBuiltIn('Set')))();
        var adder = aCallable(newSet.add);
        iterate(iterator, function(value) {
            if (boundFunction(value, value, set)) call(adder, newSet, value);
        }, {
            IS_ITERATOR: true
        });
        return newSet;
    }
});

},{"../internals/is-pure":"6Bbq0","../internals/export":"8yfGv","../internals/get-built-in":"78arb","../internals/function-call":"jhLed","../internals/a-callable":"83opn","../internals/an-object":"1LIz9","../internals/function-bind-context":"kZubc","../internals/species-constructor":"hqPl9","../internals/get-set-iterator":"iN6xq","../internals/iterate":"fTyka"}],"hhbAH":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var anObject = require('../internals/an-object');
var bind = require('../internals/function-bind-context');
var getSetIterator = require('../internals/get-set-iterator');
var iterate = require('../internals/iterate');
// `Set.prototype.find` method
// https://github.com/tc39/proposal-collection-methods
$({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    find: function find(callbackfn /* , thisArg */ ) {
        var set = anObject(this);
        var iterator = getSetIterator(set);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        return iterate(iterator, function(value, stop) {
            if (boundFunction(value, value, set)) return stop(value);
        }, {
            IS_ITERATOR: true,
            INTERRUPTED: true
        }).result;
    }
});

},{"../internals/export":"8yfGv","../internals/is-pure":"6Bbq0","../internals/an-object":"1LIz9","../internals/function-bind-context":"kZubc","../internals/get-set-iterator":"iN6xq","../internals/iterate":"fTyka"}],"aGi3H":[function(require,module,exports) {
var $ = require('../internals/export');
var from = require('../internals/collection-from');
// `Set.from` method
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
$({
    target: 'Set',
    stat: true
}, {
    from: from
});

},{"../internals/export":"8yfGv","../internals/collection-from":"2eDYq"}],"gpRel":[function(require,module,exports) {
'use strict';
var IS_PURE = require('../internals/is-pure');
var $ = require('../internals/export');
var getBuiltIn = require('../internals/get-built-in');
var call = require('../internals/function-call');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
var speciesConstructor = require('../internals/species-constructor');
var iterate = require('../internals/iterate');
// `Set.prototype.intersection` method
// https://github.com/tc39/proposal-set-methods
$({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    intersection: function intersection(iterable) {
        var set = anObject(this);
        var newSet = new (speciesConstructor(set, getBuiltIn('Set')))();
        var hasCheck = aCallable(set.has);
        var adder = aCallable(newSet.add);
        iterate(iterable, function(value) {
            if (call(hasCheck, set, value)) call(adder, newSet, value);
        });
        return newSet;
    }
});

},{"../internals/is-pure":"6Bbq0","../internals/export":"8yfGv","../internals/get-built-in":"78arb","../internals/function-call":"jhLed","../internals/a-callable":"83opn","../internals/an-object":"1LIz9","../internals/species-constructor":"hqPl9","../internals/iterate":"fTyka"}],"BQOKB":[function(require,module,exports) {
'use strict';
var IS_PURE = require('../internals/is-pure');
var $ = require('../internals/export');
var call = require('../internals/function-call');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
var iterate = require('../internals/iterate');
// `Set.prototype.isDisjointFrom` method
// https://tc39.github.io/proposal-set-methods/#Set.prototype.isDisjointFrom
$({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    isDisjointFrom: function isDisjointFrom(iterable) {
        var set = anObject(this);
        var hasCheck = aCallable(set.has);
        return !iterate(iterable, function(value, stop) {
            if (call(hasCheck, set, value) === true) return stop();
        }, {
            INTERRUPTED: true
        }).stopped;
    }
});

},{"../internals/is-pure":"6Bbq0","../internals/export":"8yfGv","../internals/function-call":"jhLed","../internals/a-callable":"83opn","../internals/an-object":"1LIz9","../internals/iterate":"fTyka"}],"94dBs":[function(require,module,exports) {
'use strict';
var IS_PURE = require('../internals/is-pure');
var $ = require('../internals/export');
var getBuiltIn = require('../internals/get-built-in');
var call = require('../internals/function-call');
var aCallable = require('../internals/a-callable');
var isCallable = require('../internals/is-callable');
var anObject = require('../internals/an-object');
var getIterator = require('../internals/get-iterator');
var iterate = require('../internals/iterate');
// `Set.prototype.isSubsetOf` method
// https://tc39.github.io/proposal-set-methods/#Set.prototype.isSubsetOf
$({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    isSubsetOf: function isSubsetOf(iterable) {
        var iterator = getIterator(this);
        var otherSet = anObject(iterable);
        var hasCheck = otherSet.has;
        if (!isCallable(hasCheck)) {
            otherSet = new (getBuiltIn('Set'))(iterable);
            hasCheck = aCallable(otherSet.has);
        }
        return !iterate(iterator, function(value, stop) {
            if (call(hasCheck, otherSet, value) === false) return stop();
        }, {
            IS_ITERATOR: true,
            INTERRUPTED: true
        }).stopped;
    }
});

},{"../internals/is-pure":"6Bbq0","../internals/export":"8yfGv","../internals/get-built-in":"78arb","../internals/function-call":"jhLed","../internals/a-callable":"83opn","../internals/is-callable":"kPhuP","../internals/an-object":"1LIz9","../internals/get-iterator":"dQrLE","../internals/iterate":"fTyka"}],"lfTb9":[function(require,module,exports) {
'use strict';
var IS_PURE = require('../internals/is-pure');
var $ = require('../internals/export');
var call = require('../internals/function-call');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
var iterate = require('../internals/iterate');
// `Set.prototype.isSupersetOf` method
// https://tc39.github.io/proposal-set-methods/#Set.prototype.isSupersetOf
$({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    isSupersetOf: function isSupersetOf(iterable) {
        var set = anObject(this);
        var hasCheck = aCallable(set.has);
        return !iterate(iterable, function(value, stop) {
            if (call(hasCheck, set, value) === false) return stop();
        }, {
            INTERRUPTED: true
        }).stopped;
    }
});

},{"../internals/is-pure":"6Bbq0","../internals/export":"8yfGv","../internals/function-call":"jhLed","../internals/a-callable":"83opn","../internals/an-object":"1LIz9","../internals/iterate":"fTyka"}],"byvs7":[function(require,module,exports) {
'use strict';
var IS_PURE = require('../internals/is-pure');
var $ = require('../internals/export');
var uncurryThis = require('../internals/function-uncurry-this');
var anObject = require('../internals/an-object');
var toString = require('../internals/to-string');
var getSetIterator = require('../internals/get-set-iterator');
var iterate = require('../internals/iterate');
var arrayJoin = uncurryThis([].join);
var push = [].push;
// `Set.prototype.join` method
// https://github.com/tc39/proposal-collection-methods
$({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    join: function join(separator) {
        var set = anObject(this);
        var iterator = getSetIterator(set);
        var sep = separator === undefined ? ',' : toString(separator);
        var result = [];
        iterate(iterator, push, {
            that: result,
            IS_ITERATOR: true
        });
        return arrayJoin(result, sep);
    }
});

},{"../internals/is-pure":"6Bbq0","../internals/export":"8yfGv","../internals/function-uncurry-this":"jJnXC","../internals/an-object":"1LIz9","../internals/to-string":"4cTlm","../internals/get-set-iterator":"iN6xq","../internals/iterate":"fTyka"}],"iwGoP":[function(require,module,exports) {
'use strict';
var IS_PURE = require('../internals/is-pure');
var $ = require('../internals/export');
var getBuiltIn = require('../internals/get-built-in');
var bind = require('../internals/function-bind-context');
var call = require('../internals/function-call');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
var speciesConstructor = require('../internals/species-constructor');
var getSetIterator = require('../internals/get-set-iterator');
var iterate = require('../internals/iterate');
// `Set.prototype.map` method
// https://github.com/tc39/proposal-collection-methods
$({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    map: function map(callbackfn /* , thisArg */ ) {
        var set = anObject(this);
        var iterator = getSetIterator(set);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        var newSet = new (speciesConstructor(set, getBuiltIn('Set')))();
        var adder = aCallable(newSet.add);
        iterate(iterator, function(value) {
            call(adder, newSet, boundFunction(value, value, set));
        }, {
            IS_ITERATOR: true
        });
        return newSet;
    }
});

},{"../internals/is-pure":"6Bbq0","../internals/export":"8yfGv","../internals/get-built-in":"78arb","../internals/function-bind-context":"kZubc","../internals/function-call":"jhLed","../internals/a-callable":"83opn","../internals/an-object":"1LIz9","../internals/species-constructor":"hqPl9","../internals/get-set-iterator":"iN6xq","../internals/iterate":"fTyka"}],"bJUYk":[function(require,module,exports) {
var $ = require('../internals/export');
var of = require('../internals/collection-of');
// `Set.of` method
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
$({
    target: 'Set',
    stat: true
}, {
    of: of
});

},{"../internals/export":"8yfGv","../internals/collection-of":"7mrXK"}],"7UiJD":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var global = require('../internals/global');
var IS_PURE = require('../internals/is-pure');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
var getSetIterator = require('../internals/get-set-iterator');
var iterate = require('../internals/iterate');
var TypeError = global.TypeError;
// `Set.prototype.reduce` method
// https://github.com/tc39/proposal-collection-methods
$({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    reduce: function reduce(callbackfn /* , initialValue */ ) {
        var set = anObject(this);
        var iterator = getSetIterator(set);
        var noInitial = arguments.length < 2;
        var accumulator = noInitial ? undefined : arguments[1];
        aCallable(callbackfn);
        iterate(iterator, function(value) {
            if (noInitial) {
                noInitial = false;
                accumulator = value;
            } else accumulator = callbackfn(accumulator, value, value, set);
        }, {
            IS_ITERATOR: true
        });
        if (noInitial) throw TypeError('Reduce of empty set with no initial value');
        return accumulator;
    }
});

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/is-pure":"6Bbq0","../internals/a-callable":"83opn","../internals/an-object":"1LIz9","../internals/get-set-iterator":"iN6xq","../internals/iterate":"fTyka"}],"gJ8rp":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var anObject = require('../internals/an-object');
var bind = require('../internals/function-bind-context');
var getSetIterator = require('../internals/get-set-iterator');
var iterate = require('../internals/iterate');
// `Set.prototype.some` method
// https://github.com/tc39/proposal-collection-methods
$({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    some: function some(callbackfn /* , thisArg */ ) {
        var set = anObject(this);
        var iterator = getSetIterator(set);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        return iterate(iterator, function(value, stop) {
            if (boundFunction(value, value, set)) return stop();
        }, {
            IS_ITERATOR: true,
            INTERRUPTED: true
        }).stopped;
    }
});

},{"../internals/export":"8yfGv","../internals/is-pure":"6Bbq0","../internals/an-object":"1LIz9","../internals/function-bind-context":"kZubc","../internals/get-set-iterator":"iN6xq","../internals/iterate":"fTyka"}],"kG944":[function(require,module,exports) {
'use strict';
var IS_PURE = require('../internals/is-pure');
var $ = require('../internals/export');
var getBuiltIn = require('../internals/get-built-in');
var call = require('../internals/function-call');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
var speciesConstructor = require('../internals/species-constructor');
var iterate = require('../internals/iterate');
// `Set.prototype.symmetricDifference` method
// https://github.com/tc39/proposal-set-methods
$({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    symmetricDifference: function symmetricDifference(iterable) {
        var set = anObject(this);
        var newSet = new (speciesConstructor(set, getBuiltIn('Set')))(set);
        var remover = aCallable(newSet['delete']);
        var adder = aCallable(newSet.add);
        iterate(iterable, function(value) {
            call(remover, newSet, value) || call(adder, newSet, value);
        });
        return newSet;
    }
});

},{"../internals/is-pure":"6Bbq0","../internals/export":"8yfGv","../internals/get-built-in":"78arb","../internals/function-call":"jhLed","../internals/a-callable":"83opn","../internals/an-object":"1LIz9","../internals/species-constructor":"hqPl9","../internals/iterate":"fTyka"}],"6zkeN":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var getBuiltIn = require('../internals/get-built-in');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
var speciesConstructor = require('../internals/species-constructor');
var iterate = require('../internals/iterate');
// `Set.prototype.union` method
// https://github.com/tc39/proposal-set-methods
$({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    union: function union(iterable) {
        var set = anObject(this);
        var newSet = new (speciesConstructor(set, getBuiltIn('Set')))(set);
        iterate(iterable, aCallable(newSet.add), {
            that: newSet
        });
        return newSet;
    }
});

},{"../internals/export":"8yfGv","../internals/is-pure":"6Bbq0","../internals/get-built-in":"78arb","../internals/a-callable":"83opn","../internals/an-object":"1LIz9","../internals/species-constructor":"hqPl9","../internals/iterate":"fTyka"}],"2dQvW":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var charAt = require('../internals/string-multibyte').charAt;
var fails = require('../internals/fails');
var requireObjectCoercible = require('../internals/require-object-coercible');
var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
var toString = require('../internals/to-string');
var FORCED = fails(function() {
    return '𠮷'.at(-2) !== '𠮷';
});
// `String.prototype.at` method
// https://github.com/mathiasbynens/String.prototype.at
$({
    target: 'String',
    proto: true,
    forced: FORCED
}, {
    at: function at(index) {
        var S = toString(requireObjectCoercible(this));
        var len = S.length;
        var relativeIndex = toIntegerOrInfinity(index);
        var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
        return k < 0 || k >= len ? undefined : charAt(S, k);
    }
});

},{"../internals/export":"8yfGv","../internals/string-multibyte":"a9S4J","../internals/fails":"8IfZQ","../internals/require-object-coercible":"3Qlyo","../internals/to-integer-or-infinity":"aqyxv","../internals/to-string":"4cTlm"}],"ijNn8":[function(require,module,exports) {
var $ = require('../internals/export');
var global = require('../internals/global');
var uncurryThis = require('../internals/function-uncurry-this');
var toIndexedObject = require('../internals/to-indexed-object');
var toString = require('../internals/to-string');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var TypeError = global.TypeError;
var ArrayPrototype = Array.prototype;
var push = uncurryThis(ArrayPrototype.push);
var join = uncurryThis(ArrayPrototype.join);
// `String.cooked` method
// https://github.com/tc39/proposal-string-cooked
$({
    target: 'String',
    stat: true
}, {
    cooked: function cooked(template /* , ...substitutions */ ) {
        var cookedTemplate = toIndexedObject(template);
        var literalSegments = lengthOfArrayLike(cookedTemplate);
        var argumentsLength = arguments.length;
        var elements = [];
        var i = 0;
        while(literalSegments > i){
            var nextVal = cookedTemplate[i++];
            if (nextVal === undefined) throw TypeError('Incorrect template');
            push(elements, toString(nextVal));
            if (i === literalSegments) return join(elements, '');
            if (i < argumentsLength) push(elements, toString(arguments[i]));
        }
    }
});

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/function-uncurry-this":"jJnXC","../internals/to-indexed-object":"8ueFu","../internals/to-string":"4cTlm","../internals/length-of-array-like":"afDy6"}],"1GQw4":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var createIteratorConstructor = require('../internals/create-iterator-constructor');
var requireObjectCoercible = require('../internals/require-object-coercible');
var toString = require('../internals/to-string');
var InternalStateModule = require('../internals/internal-state');
var StringMultibyteModule = require('../internals/string-multibyte');
var codeAt = StringMultibyteModule.codeAt;
var charAt = StringMultibyteModule.charAt;
var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
// TODO: unify with String#@@iterator
var $StringIterator = createIteratorConstructor(function StringIterator(string) {
    setInternalState(this, {
        type: STRING_ITERATOR,
        string: string,
        index: 0
    });
}, 'String', function next() {
    var state = getInternalState(this);
    var string = state.string;
    var index = state.index;
    var point;
    if (index >= string.length) return {
        value: undefined,
        done: true
    };
    point = charAt(string, index);
    state.index += point.length;
    return {
        value: {
            codePoint: codeAt(point, 0),
            position: index
        },
        done: false
    };
});
// `String.prototype.codePoints` method
// https://github.com/tc39/proposal-string-prototype-codepoints
$({
    target: 'String',
    proto: true
}, {
    codePoints: function codePoints() {
        return new $StringIterator(toString(requireObjectCoercible(this)));
    }
});

},{"../internals/export":"8yfGv","../internals/create-iterator-constructor":"1fB00","../internals/require-object-coercible":"3Qlyo","../internals/to-string":"4cTlm","../internals/internal-state":"i6AaM","../internals/string-multibyte":"a9S4J"}],"c3ZN3":[function(require,module,exports) {
// TODO: Remove from `core-js@4`
require('../modules/es.string.match-all');

},{"../modules/es.string.match-all":"hNQS5"}],"elCVp":[function(require,module,exports) {
// TODO: Remove from `core-js@4`
require('../modules/es.string.replace-all');

},{"../modules/es.string.replace-all":"3DDbg"}],"d5Hvw":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.asyncDispose` well-known symbol
// https://github.com/tc39/proposal-using-statement
defineWellKnownSymbol('asyncDispose');

},{"../internals/define-well-known-symbol":"iX7WZ"}],"91OZ3":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.dispose` well-known symbol
// https://github.com/tc39/proposal-using-statement
defineWellKnownSymbol('dispose');

},{"../internals/define-well-known-symbol":"iX7WZ"}],"7e0KR":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.matcher` well-known symbol
// https://github.com/tc39/proposal-pattern-matching
defineWellKnownSymbol('matcher');

},{"../internals/define-well-known-symbol":"iX7WZ"}],"1rAX6":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.metadata` well-known symbol
// https://github.com/tc39/proposal-decorators
defineWellKnownSymbol('metadata');

},{"../internals/define-well-known-symbol":"iX7WZ"}],"lUJcr":[function(require,module,exports) {
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.observable` well-known symbol
// https://github.com/tc39/proposal-observable
defineWellKnownSymbol('observable');

},{"../internals/define-well-known-symbol":"iX7WZ"}],"20Egz":[function(require,module,exports) {
// TODO: remove from `core-js@4`
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
// `Symbol.patternMatch` well-known symbol
// https://github.com/tc39/proposal-pattern-matching
defineWellKnownSymbol('patternMatch');

},{"../internals/define-well-known-symbol":"iX7WZ"}],"6Oysi":[function(require,module,exports) {
// TODO: remove from `core-js@4`
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
defineWellKnownSymbol('replaceAll');

},{"../internals/define-well-known-symbol":"iX7WZ"}],"3lGbr":[function(require,module,exports) {
'use strict';
// TODO: Remove from `core-js@4`
var getBuiltIn = require('../internals/get-built-in');
var aConstructor = require('../internals/a-constructor');
var arrayFromAsync = require('../internals/array-from-async');
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require('../internals/typed-array-constructors-require-wrappers');
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var arrayFromConstructorAndList = require('../internals/array-from-constructor-and-list');
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayStaticMethod = ArrayBufferViewCore.exportTypedArrayStaticMethod;
// `%TypedArray%.fromAsync` method
// https://github.com/tc39/proposal-array-from-async
exportTypedArrayStaticMethod('fromAsync', function fromAsync(asyncItems /* , mapfn = undefined, thisArg = undefined */ ) {
    var C = this;
    var argumentsLength = arguments.length;
    var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
    var thisArg = argumentsLength > 2 ? arguments[2] : undefined;
    return new (getBuiltIn('Promise'))(function(resolve) {
        aConstructor(C);
        resolve(arrayFromAsync(asyncItems, mapfn, thisArg));
    }).then(function(list) {
        return arrayFromConstructorAndList(aTypedArrayConstructor(C), list);
    });
}, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);

},{"../internals/get-built-in":"78arb","../internals/a-constructor":"1DOBp","../internals/array-from-async":"bWWh7","../internals/typed-array-constructors-require-wrappers":"gMlLy","../internals/array-buffer-view-core":"7PXuA","../internals/array-from-constructor-and-list":"5X1AQ"}],"ezffH":[function(require,module,exports) {
// TODO: Remove from `core-js@4`
require('../modules/es.typed-array.at');

},{"../modules/es.typed-array.at":"eSUgO"}],"aC7FP":[function(require,module,exports) {
'use strict';
// TODO: Remove from `core-js@4`
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $filterReject = require('../internals/array-iteration').filterReject;
var fromSpeciesAndList = require('../internals/typed-array-from-species-and-list');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.filterOut` method
// https://github.com/tc39/proposal-array-filtering
exportTypedArrayMethod('filterOut', function filterOut(callbackfn /* , thisArg */ ) {
    var list = $filterReject(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return fromSpeciesAndList(this, list);
});

},{"../internals/array-buffer-view-core":"7PXuA","../internals/array-iteration":"8a6lB","../internals/typed-array-from-species-and-list":"eF9eX"}],"3nhN5":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $filterReject = require('../internals/array-iteration').filterReject;
var fromSpeciesAndList = require('../internals/typed-array-from-species-and-list');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.filterReject` method
// https://github.com/tc39/proposal-array-filtering
exportTypedArrayMethod('filterReject', function filterReject(callbackfn /* , thisArg */ ) {
    var list = $filterReject(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return fromSpeciesAndList(this, list);
});

},{"../internals/array-buffer-view-core":"7PXuA","../internals/array-iteration":"8a6lB","../internals/typed-array-from-species-and-list":"eF9eX"}],"epong":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $findLast = require('../internals/array-iteration-from-last').findLast;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.findLast` method
// https://github.com/tc39/proposal-array-find-from-last
exportTypedArrayMethod('findLast', function findLast(predicate /* , thisArg */ ) {
    return $findLast(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":"7PXuA","../internals/array-iteration-from-last":"l7T6K"}],"ex7Ja":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $findLastIndex = require('../internals/array-iteration-from-last').findLastIndex;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.findLastIndex` method
// https://github.com/tc39/proposal-array-find-from-last
exportTypedArrayMethod('findLastIndex', function findLastIndex(predicate /* , thisArg */ ) {
    return $findLastIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});

},{"../internals/array-buffer-view-core":"7PXuA","../internals/array-iteration-from-last":"l7T6K"}],"awKab":[function(require,module,exports) {
'use strict';
// TODO: Remove from `core-js@4`
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $groupBy = require('../internals/array-group-by');
var typedArraySpeciesConstructor = require('../internals/typed-array-species-constructor');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
// `%TypedArray%.prototype.groupBy` method
// https://github.com/tc39/proposal-array-grouping
exportTypedArrayMethod('groupBy', function groupBy(callbackfn /* , thisArg */ ) {
    var thisArg = arguments.length > 1 ? arguments[1] : undefined;
    return $groupBy(aTypedArray(this), callbackfn, thisArg, typedArraySpeciesConstructor);
});

},{"../internals/array-buffer-view-core":"7PXuA","../internals/array-group-by":"5d7IU","../internals/typed-array-species-constructor":"b4oOp"}],"b9379":[function(require,module,exports) {
'use strict';
var arrayToReversed = require('../internals/array-to-reversed');
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var TYPED_ARRAY_CONSTRUCTOR = ArrayBufferViewCore.TYPED_ARRAY_CONSTRUCTOR;
// `%TypedArray%.prototype.toReversed` method
// https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.toReversed
exportTypedArrayMethod('toReversed', function toReversed() {
    return arrayToReversed(aTypedArray(this), this[TYPED_ARRAY_CONSTRUCTOR]);
});

},{"../internals/array-to-reversed":"4JI26","../internals/array-buffer-view-core":"7PXuA"}],"jhhlF":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var uncurryThis = require('../internals/function-uncurry-this');
var aCallable = require('../internals/a-callable');
var arrayFromConstructorAndList = require('../internals/array-from-constructor-and-list');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var TYPED_ARRAY_CONSTRUCTOR = ArrayBufferViewCore.TYPED_ARRAY_CONSTRUCTOR;
var sort = uncurryThis(ArrayBufferViewCore.TypedArrayPrototype.sort);
// `%TypedArray%.prototype.toSorted` method
// https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.toSorted
exportTypedArrayMethod('toSorted', function toSorted(compareFn) {
    if (compareFn !== undefined) aCallable(compareFn);
    var O = aTypedArray(this);
    var A = arrayFromConstructorAndList(O[TYPED_ARRAY_CONSTRUCTOR], O);
    return sort(A, compareFn);
});

},{"../internals/array-buffer-view-core":"7PXuA","../internals/function-uncurry-this":"jJnXC","../internals/a-callable":"83opn","../internals/array-from-constructor-and-list":"5X1AQ"}],"bwpqF":[function(require,module,exports) {
'use strict';
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var arraySlice = require('../internals/array-slice');
var arrayToSpliced = require('../internals/array-to-spliced');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var TYPED_ARRAY_CONSTRUCTOR = ArrayBufferViewCore.TYPED_ARRAY_CONSTRUCTOR;
// `%TypedArray%.prototype.toSpliced` method
// https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.toSpliced
// eslint-disable-next-line no-unused-vars -- required for .length
exportTypedArrayMethod('toSpliced', function toSpliced(start, deleteCount /* , ...items */ ) {
    return arrayToSpliced(aTypedArray(this), this[TYPED_ARRAY_CONSTRUCTOR], arraySlice(arguments));
});

},{"../internals/array-buffer-view-core":"7PXuA","../internals/array-slice":"bI1dk","../internals/array-to-spliced":"5dGtj"}],"gGjlC":[function(require,module,exports) {
'use strict';
var uncurryThis = require('../internals/function-uncurry-this');
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var $arrayUniqueBy = require('../internals/array-unique-by');
var fromSpeciesAndList = require('../internals/typed-array-from-species-and-list');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var arrayUniqueBy = uncurryThis($arrayUniqueBy);
// `%TypedArray%.prototype.uniqueBy` method
// https://github.com/tc39/proposal-array-unique
exportTypedArrayMethod('uniqueBy', function uniqueBy(resolver) {
    return fromSpeciesAndList(this, arrayUniqueBy(aTypedArray(this), resolver));
});

},{"../internals/function-uncurry-this":"jJnXC","../internals/array-buffer-view-core":"7PXuA","../internals/array-unique-by":"43InR","../internals/typed-array-from-species-and-list":"eF9eX"}],"bEgOQ":[function(require,module,exports) {
'use strict';
var arrayWith = require('../internals/array-with');
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var TYPED_ARRAY_CONSTRUCTOR = ArrayBufferViewCore.TYPED_ARRAY_CONSTRUCTOR;
// `%TypedArray%.prototype.with` method
// https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.with
exportTypedArrayMethod('with', {
    'with': function(index, value) {
        return arrayWith(aTypedArray(this), this[TYPED_ARRAY_CONSTRUCTOR], index, value);
    }
}['with']);

},{"../internals/array-with":"5bUpU","../internals/array-buffer-view-core":"7PXuA"}],"jJPKp":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var deleteAll = require('../internals/collection-delete-all');
// `WeakMap.prototype.deleteAll` method
// https://github.com/tc39/proposal-collection-methods
$({
    target: 'WeakMap',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    deleteAll: deleteAll
});

},{"../internals/export":"8yfGv","../internals/is-pure":"6Bbq0","../internals/collection-delete-all":"7mZy7"}],"28OCP":[function(require,module,exports) {
var $ = require('../internals/export');
var from = require('../internals/collection-from');
// `WeakMap.from` method
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
$({
    target: 'WeakMap',
    stat: true
}, {
    from: from
});

},{"../internals/export":"8yfGv","../internals/collection-from":"2eDYq"}],"48CKd":[function(require,module,exports) {
var $ = require('../internals/export');
var of = require('../internals/collection-of');
// `WeakMap.of` method
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
$({
    target: 'WeakMap',
    stat: true
}, {
    of: of
});

},{"../internals/export":"8yfGv","../internals/collection-of":"7mrXK"}],"9mTD5":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var emplace = require('../internals/map-emplace');
// `WeakMap.prototype.emplace` method
// https://github.com/tc39/proposal-upsert
$({
    target: 'WeakMap',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    emplace: emplace
});

},{"../internals/export":"8yfGv","../internals/is-pure":"6Bbq0","../internals/map-emplace":"6ZCu9"}],"juSVe":[function(require,module,exports) {
'use strict';
// TODO: remove from `core-js@4`
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var upsert = require('../internals/map-upsert');
// `WeakMap.prototype.upsert` method (replaced by `WeakMap.prototype.emplace`)
// https://github.com/tc39/proposal-upsert
$({
    target: 'WeakMap',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    upsert: upsert
});

},{"../internals/export":"8yfGv","../internals/is-pure":"6Bbq0","../internals/map-upsert":"aZc2E"}],"dSVOD":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var addAll = require('../internals/collection-add-all');
// `WeakSet.prototype.addAll` method
// https://github.com/tc39/proposal-collection-methods
$({
    target: 'WeakSet',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    addAll: addAll
});

},{"../internals/export":"8yfGv","../internals/is-pure":"6Bbq0","../internals/collection-add-all":"1I877"}],"beZeG":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var deleteAll = require('../internals/collection-delete-all');
// `WeakSet.prototype.deleteAll` method
// https://github.com/tc39/proposal-collection-methods
$({
    target: 'WeakSet',
    proto: true,
    real: true,
    forced: IS_PURE
}, {
    deleteAll: deleteAll
});

},{"../internals/export":"8yfGv","../internals/is-pure":"6Bbq0","../internals/collection-delete-all":"7mZy7"}],"aAw8l":[function(require,module,exports) {
var $ = require('../internals/export');
var from = require('../internals/collection-from');
// `WeakSet.from` method
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
$({
    target: 'WeakSet',
    stat: true
}, {
    from: from
});

},{"../internals/export":"8yfGv","../internals/collection-from":"2eDYq"}],"3wee4":[function(require,module,exports) {
var $ = require('../internals/export');
var of = require('../internals/collection-of');
// `WeakSet.of` method
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
$({
    target: 'WeakSet',
    stat: true
}, {
    of: of
});

},{"../internals/export":"8yfGv","../internals/collection-of":"7mrXK"}],"d06QC":[function(require,module,exports) {
var global = require('../internals/global');
var DOMIterables = require('../internals/dom-iterables');
var DOMTokenListPrototype = require('../internals/dom-token-list-prototype');
var forEach = require('../internals/array-for-each');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var handlePrototype = function(CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
        createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);
    } catch (error) {
        CollectionPrototype.forEach = forEach;
    }
};
for(var COLLECTION_NAME in DOMIterables)if (DOMIterables[COLLECTION_NAME]) handlePrototype(global[COLLECTION_NAME] && global[COLLECTION_NAME].prototype);
handlePrototype(DOMTokenListPrototype);

},{"../internals/global":"jxPDA","../internals/dom-iterables":"7H0N4","../internals/dom-token-list-prototype":"eWdLK","../internals/array-for-each":"aAPs6","../internals/create-non-enumerable-property":"6Z1es"}],"7H0N4":[function(require,module,exports) {
// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
    CSSRuleList: 0,
    CSSStyleDeclaration: 0,
    CSSValueList: 0,
    ClientRectList: 0,
    DOMRectList: 0,
    DOMStringList: 0,
    DOMTokenList: 1,
    DataTransferItemList: 0,
    FileList: 0,
    HTMLAllCollection: 0,
    HTMLCollection: 0,
    HTMLFormElement: 0,
    HTMLSelectElement: 0,
    MediaList: 0,
    MimeTypeArray: 0,
    NamedNodeMap: 0,
    NodeList: 1,
    PaintRequestList: 0,
    Plugin: 0,
    PluginArray: 0,
    SVGLengthList: 0,
    SVGNumberList: 0,
    SVGPathSegList: 0,
    SVGPointList: 0,
    SVGStringList: 0,
    SVGTransformList: 0,
    SourceBufferList: 0,
    StyleSheetList: 0,
    TextTrackCueList: 0,
    TextTrackList: 0,
    TouchList: 0
};

},{}],"eWdLK":[function(require,module,exports) {
// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`
var documentCreateElement = require('../internals/document-create-element');
var classList = documentCreateElement('span').classList;
var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;
module.exports = DOMTokenListPrototype === Object.prototype ? undefined : DOMTokenListPrototype;

},{"../internals/document-create-element":"jKd7d"}],"cNl8W":[function(require,module,exports) {
var global = require('../internals/global');
var DOMIterables = require('../internals/dom-iterables');
var DOMTokenListPrototype = require('../internals/dom-token-list-prototype');
var ArrayIteratorMethods = require('../modules/es.array.iterator');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var wellKnownSymbol = require('../internals/well-known-symbol');
var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ArrayValues = ArrayIteratorMethods.values;
var handlePrototype = function(CollectionPrototype, COLLECTION_NAME1) {
    if (CollectionPrototype) {
        // some Chrome versions have non-configurable methods on DOMTokenList
        if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
            createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
        } catch (error) {
            CollectionPrototype[ITERATOR] = ArrayValues;
        }
        if (!CollectionPrototype[TO_STRING_TAG]) createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME1);
        if (DOMIterables[COLLECTION_NAME1]) for(var METHOD_NAME in ArrayIteratorMethods){
            // some Chrome versions have non-configurable methods on DOMTokenList
            if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
                createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
            } catch (error) {
                CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
            }
        }
    }
};
for(var COLLECTION_NAME in DOMIterables)handlePrototype(global[COLLECTION_NAME] && global[COLLECTION_NAME].prototype, COLLECTION_NAME);
handlePrototype(DOMTokenListPrototype, 'DOMTokenList');

},{"../internals/global":"jxPDA","../internals/dom-iterables":"7H0N4","../internals/dom-token-list-prototype":"eWdLK","../modules/es.array.iterator":"bLuDU","../internals/create-non-enumerable-property":"6Z1es","../internals/well-known-symbol":"5C8sm"}],"jKOFN":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var tryNodeRequire = require('../internals/try-node-require');
var getBuiltIn = require('../internals/get-built-in');
var fails = require('../internals/fails');
var create = require('../internals/object-create');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var defineProperty = require('../internals/object-define-property').f;
var defineProperties = require('../internals/object-define-properties').f;
var redefine = require('../internals/redefine');
var hasOwn = require('../internals/has-own-property');
var anInstance = require('../internals/an-instance');
var anObject = require('../internals/an-object');
var errorToString = require('../internals/error-to-string');
var normalizeStringArgument = require('../internals/normalize-string-argument');
var DOMExceptionConstants = require('../internals/dom-exception-constants');
var clearErrorStack = require('../internals/clear-error-stack');
var InternalStateModule = require('../internals/internal-state');
var DESCRIPTORS = require('../internals/descriptors');
var IS_PURE = require('../internals/is-pure');
var DOM_EXCEPTION = 'DOMException';
var DATA_CLONE_ERR = 'DATA_CLONE_ERR';
var Error = getBuiltIn('Error');
// NodeJS < 17.0 does not expose `DOMException` to global
var NativeDOMException = getBuiltIn(DOM_EXCEPTION) || function() {
    try {
        // NodeJS < 15.0 does not expose `MessageChannel` to global
        var MessageChannel = getBuiltIn('MessageChannel') || tryNodeRequire('worker_threads').MessageChannel;
        // eslint-disable-next-line es/no-weak-map, unicorn/require-post-message-target-origin -- safe
        new MessageChannel().port1.postMessage(new WeakMap());
    } catch (error) {
        if (error.name == DATA_CLONE_ERR && error.code == 25) return error.constructor;
    }
}();
var NativeDOMExceptionPrototype = NativeDOMException && NativeDOMException.prototype;
var ErrorPrototype = Error.prototype;
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(DOM_EXCEPTION);
var HAS_STACK = 'stack' in Error(DOM_EXCEPTION);
var codeFor = function(name) {
    return hasOwn(DOMExceptionConstants, name) && DOMExceptionConstants[name].m ? DOMExceptionConstants[name].c : 0;
};
var $DOMException = function DOMException() {
    anInstance(this, DOMExceptionPrototype);
    var argumentsLength = arguments.length;
    var message = normalizeStringArgument(argumentsLength < 1 ? undefined : arguments[0]);
    var name = normalizeStringArgument(argumentsLength < 2 ? undefined : arguments[1], 'Error');
    var code = codeFor(name);
    setInternalState(this, {
        type: DOM_EXCEPTION,
        name: name,
        message: message,
        code: code
    });
    if (!DESCRIPTORS) {
        this.name = name;
        this.message = message;
        this.code = code;
    }
    if (HAS_STACK) {
        var error = Error(message);
        error.name = DOM_EXCEPTION;
        defineProperty(this, 'stack', createPropertyDescriptor(1, clearErrorStack(error.stack, 1)));
    }
};
var DOMExceptionPrototype = $DOMException.prototype = create(ErrorPrototype);
var createGetterDescriptor = function(get) {
    return {
        enumerable: true,
        configurable: true,
        get: get
    };
};
var getterFor = function(key) {
    return createGetterDescriptor(function() {
        return getInternalState(this)[key];
    });
};
if (DESCRIPTORS) defineProperties(DOMExceptionPrototype, {
    name: getterFor('name'),
    message: getterFor('message'),
    code: getterFor('code')
});
defineProperty(DOMExceptionPrototype, 'constructor', createPropertyDescriptor(1, $DOMException));
// FF36- DOMException is a function, but can't be constructed
var INCORRECT_CONSTRUCTOR = fails(function() {
    return !(new NativeDOMException() instanceof Error);
});
// Safari 10.1 / Chrome 32- / IE8- DOMException.prototype.toString bugs
var INCORRECT_TO_STRING = INCORRECT_CONSTRUCTOR || fails(function() {
    return ErrorPrototype.toString !== errorToString || String(new NativeDOMException(1, 2)) !== '2: 1';
});
// Deno 1.6.3- DOMException.prototype.code just missed
var INCORRECT_CODE = INCORRECT_CONSTRUCTOR || fails(function() {
    return new NativeDOMException(1, 'DataCloneError').code !== 25;
});
// Deno 1.6.3- DOMException constants just missed
var MISSED_CONSTANTS = INCORRECT_CONSTRUCTOR || NativeDOMException[DATA_CLONE_ERR] !== 25 || NativeDOMExceptionPrototype[DATA_CLONE_ERR] !== 25;
var FORCED_CONSTRUCTOR = IS_PURE ? INCORRECT_TO_STRING || INCORRECT_CODE || MISSED_CONSTANTS : INCORRECT_CONSTRUCTOR;
// `DOMException` constructor
// https://webidl.spec.whatwg.org/#idl-DOMException
$({
    global: true,
    forced: FORCED_CONSTRUCTOR
}, {
    DOMException: FORCED_CONSTRUCTOR ? $DOMException : NativeDOMException
});
var PolyfilledDOMException = getBuiltIn(DOM_EXCEPTION);
var PolyfilledDOMExceptionPrototype = PolyfilledDOMException.prototype;
if (INCORRECT_TO_STRING && (IS_PURE || NativeDOMException === PolyfilledDOMException)) redefine(PolyfilledDOMExceptionPrototype, 'toString', errorToString);
if (INCORRECT_CODE && DESCRIPTORS && NativeDOMException === PolyfilledDOMException) defineProperty(PolyfilledDOMExceptionPrototype, 'code', createGetterDescriptor(function() {
    return codeFor(anObject(this).name);
}));
for(var key in DOMExceptionConstants)if (hasOwn(DOMExceptionConstants, key)) {
    var constant = DOMExceptionConstants[key];
    var constantName = constant.s;
    var descriptor = createPropertyDescriptor(6, constant.c);
    if (!hasOwn(PolyfilledDOMException, constantName)) defineProperty(PolyfilledDOMException, constantName, descriptor);
    if (!hasOwn(PolyfilledDOMExceptionPrototype, constantName)) defineProperty(PolyfilledDOMExceptionPrototype, constantName, descriptor);
}

},{"../internals/export":"8yfGv","../internals/try-node-require":"iak8l","../internals/get-built-in":"78arb","../internals/fails":"8IfZQ","../internals/object-create":"1As5O","../internals/create-property-descriptor":"ermgb","../internals/object-define-property":"bauTd","../internals/object-define-properties":"8PPlc","../internals/redefine":"kxbj8","../internals/has-own-property":"3ZdUC","../internals/an-instance":"2zeQg","../internals/an-object":"1LIz9","../internals/error-to-string":"eMkvz","../internals/normalize-string-argument":"1P71G","../internals/dom-exception-constants":"f6xro","../internals/clear-error-stack":"etw2G","../internals/internal-state":"i6AaM","../internals/descriptors":"6ZLib","../internals/is-pure":"6Bbq0"}],"iak8l":[function(require,module,exports) {
var IS_NODE = require('../internals/engine-is-node');
module.exports = function(name) {
    try {
        // eslint-disable-next-line no-new-func -- safe
        if (IS_NODE) return Function('return require("' + name + '")')();
    } catch (error) {
    }
};

},{"../internals/engine-is-node":"jwobg"}],"f6xro":[function(require,module,exports) {
module.exports = {
    IndexSizeError: {
        s: 'INDEX_SIZE_ERR',
        c: 1,
        m: 1
    },
    DOMStringSizeError: {
        s: 'DOMSTRING_SIZE_ERR',
        c: 2,
        m: 0
    },
    HierarchyRequestError: {
        s: 'HIERARCHY_REQUEST_ERR',
        c: 3,
        m: 1
    },
    WrongDocumentError: {
        s: 'WRONG_DOCUMENT_ERR',
        c: 4,
        m: 1
    },
    InvalidCharacterError: {
        s: 'INVALID_CHARACTER_ERR',
        c: 5,
        m: 1
    },
    NoDataAllowedError: {
        s: 'NO_DATA_ALLOWED_ERR',
        c: 6,
        m: 0
    },
    NoModificationAllowedError: {
        s: 'NO_MODIFICATION_ALLOWED_ERR',
        c: 7,
        m: 1
    },
    NotFoundError: {
        s: 'NOT_FOUND_ERR',
        c: 8,
        m: 1
    },
    NotSupportedError: {
        s: 'NOT_SUPPORTED_ERR',
        c: 9,
        m: 1
    },
    InUseAttributeError: {
        s: 'INUSE_ATTRIBUTE_ERR',
        c: 10,
        m: 1
    },
    InvalidStateError: {
        s: 'INVALID_STATE_ERR',
        c: 11,
        m: 1
    },
    SyntaxError: {
        s: 'SYNTAX_ERR',
        c: 12,
        m: 1
    },
    InvalidModificationError: {
        s: 'INVALID_MODIFICATION_ERR',
        c: 13,
        m: 1
    },
    NamespaceError: {
        s: 'NAMESPACE_ERR',
        c: 14,
        m: 1
    },
    InvalidAccessError: {
        s: 'INVALID_ACCESS_ERR',
        c: 15,
        m: 1
    },
    ValidationError: {
        s: 'VALIDATION_ERR',
        c: 16,
        m: 0
    },
    TypeMismatchError: {
        s: 'TYPE_MISMATCH_ERR',
        c: 17,
        m: 1
    },
    SecurityError: {
        s: 'SECURITY_ERR',
        c: 18,
        m: 1
    },
    NetworkError: {
        s: 'NETWORK_ERR',
        c: 19,
        m: 1
    },
    AbortError: {
        s: 'ABORT_ERR',
        c: 20,
        m: 1
    },
    URLMismatchError: {
        s: 'URL_MISMATCH_ERR',
        c: 21,
        m: 1
    },
    QuotaExceededError: {
        s: 'QUOTA_EXCEEDED_ERR',
        c: 22,
        m: 1
    },
    TimeoutError: {
        s: 'TIMEOUT_ERR',
        c: 23,
        m: 1
    },
    InvalidNodeTypeError: {
        s: 'INVALID_NODE_TYPE_ERR',
        c: 24,
        m: 1
    },
    DataCloneError: {
        s: 'DATA_CLONE_ERR',
        c: 25,
        m: 1
    }
};

},{}],"b7W4C":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var getBuiltIn = require('../internals/get-built-in');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var defineProperty = require('../internals/object-define-property').f;
var hasOwn = require('../internals/has-own-property');
var anInstance = require('../internals/an-instance');
var inheritIfRequired = require('../internals/inherit-if-required');
var normalizeStringArgument = require('../internals/normalize-string-argument');
var DOMExceptionConstants = require('../internals/dom-exception-constants');
var clearErrorStack = require('../internals/clear-error-stack');
var IS_PURE = require('../internals/is-pure');
var DOM_EXCEPTION = 'DOMException';
var Error = getBuiltIn('Error');
var NativeDOMException = getBuiltIn(DOM_EXCEPTION);
var $DOMException = function DOMException() {
    anInstance(this, DOMExceptionPrototype);
    var argumentsLength = arguments.length;
    var message = normalizeStringArgument(argumentsLength < 1 ? undefined : arguments[0]);
    var name = normalizeStringArgument(argumentsLength < 2 ? undefined : arguments[1], 'Error');
    var that = new NativeDOMException(message, name);
    var error = Error(message);
    error.name = DOM_EXCEPTION;
    defineProperty(that, 'stack', createPropertyDescriptor(1, clearErrorStack(error.stack, 1)));
    inheritIfRequired(that, this, $DOMException);
    return that;
};
var DOMExceptionPrototype = $DOMException.prototype = NativeDOMException.prototype;
var ERROR_HAS_STACK = 'stack' in Error(DOM_EXCEPTION);
var DOM_EXCEPTION_HAS_STACK = 'stack' in new NativeDOMException(1, 2);
var FORCED_CONSTRUCTOR = ERROR_HAS_STACK && !DOM_EXCEPTION_HAS_STACK;
// `DOMException` constructor patch for `.stack` where it's required
// https://webidl.spec.whatwg.org/#es-DOMException-specialness
$({
    global: true,
    forced: IS_PURE || FORCED_CONSTRUCTOR
}, {
    DOMException: FORCED_CONSTRUCTOR ? $DOMException : NativeDOMException
});
var PolyfilledDOMException = getBuiltIn(DOM_EXCEPTION);
var PolyfilledDOMExceptionPrototype = PolyfilledDOMException.prototype;
if (PolyfilledDOMExceptionPrototype.constructor !== PolyfilledDOMException) {
    if (!IS_PURE) defineProperty(PolyfilledDOMExceptionPrototype, 'constructor', createPropertyDescriptor(1, PolyfilledDOMException));
    for(var key in DOMExceptionConstants)if (hasOwn(DOMExceptionConstants, key)) {
        var constant = DOMExceptionConstants[key];
        var constantName = constant.s;
        if (!hasOwn(PolyfilledDOMException, constantName)) defineProperty(PolyfilledDOMException, constantName, createPropertyDescriptor(6, constant.c));
    }
}

},{"../internals/export":"8yfGv","../internals/get-built-in":"78arb","../internals/create-property-descriptor":"ermgb","../internals/object-define-property":"bauTd","../internals/has-own-property":"3ZdUC","../internals/an-instance":"2zeQg","../internals/inherit-if-required":"kXY2O","../internals/normalize-string-argument":"1P71G","../internals/dom-exception-constants":"f6xro","../internals/clear-error-stack":"etw2G","../internals/is-pure":"6Bbq0"}],"ewDGe":[function(require,module,exports) {
var getBuiltIn = require('../internals/get-built-in');
var setToStringTag = require('../internals/set-to-string-tag');
var DOM_EXCEPTION = 'DOMException';
setToStringTag(getBuiltIn(DOM_EXCEPTION), DOM_EXCEPTION);

},{"../internals/get-built-in":"78arb","../internals/set-to-string-tag":"9arwS"}],"bzVdw":[function(require,module,exports) {
var $ = require('../internals/export');
var global = require('../internals/global');
var task = require('../internals/task');
var FORCED = !global.setImmediate || !global.clearImmediate;
// http://w3c.github.io/setImmediate/
$({
    global: true,
    bind: true,
    enumerable: true,
    forced: FORCED
}, {
    // `setImmediate` method
    // http://w3c.github.io/setImmediate/#si-setImmediate
    setImmediate: task.set,
    // `clearImmediate` method
    // http://w3c.github.io/setImmediate/#si-clearImmediate
    clearImmediate: task.clear
});

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/task":"5TiiK"}],"jDEHx":[function(require,module,exports) {
var $ = require('../internals/export');
var global = require('../internals/global');
var microtask = require('../internals/microtask');
var IS_NODE = require('../internals/engine-is-node');
var process = global.process;
// `queueMicrotask` method
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-queuemicrotask
$({
    global: true,
    enumerable: true,
    noTargetGet: true
}, {
    queueMicrotask: function queueMicrotask(fn) {
        var domain = IS_NODE && process.domain;
        microtask(domain ? domain.bind(fn) : fn);
    }
});

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/microtask":"hWCOJ","../internals/engine-is-node":"jwobg"}],"21ror":[function(require,module,exports) {
var IS_PURE = require('../internals/is-pure');
var $ = require('../internals/export');
var global = require('../internals/global');
var getBuiltin = require('../internals/get-built-in');
var uncurryThis = require('../internals/function-uncurry-this');
var fails = require('../internals/fails');
var uid = require('../internals/uid');
var isCallable = require('../internals/is-callable');
var isConstructor = require('../internals/is-constructor');
var isObject = require('../internals/is-object');
var isSymbol = require('../internals/is-symbol');
var iterate = require('../internals/iterate');
var anObject = require('../internals/an-object');
var classof = require('../internals/classof');
var hasOwn = require('../internals/has-own-property');
var createProperty = require('../internals/create-property');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var validateArgumentsLength = require('../internals/validate-arguments-length');
var regExpFlags = require('../internals/regexp-flags');
var ERROR_STACK_INSTALLABLE = require('../internals/error-stack-installable');
var Object = global.Object;
var Date = global.Date;
var Error = global.Error;
var EvalError = global.EvalError;
var RangeError = global.RangeError;
var ReferenceError = global.ReferenceError;
var SyntaxError = global.SyntaxError;
var TypeError = global.TypeError;
var URIError = global.URIError;
var PerformanceMark = global.PerformanceMark;
var WebAssembly = global.WebAssembly;
var CompileError = WebAssembly && WebAssembly.CompileError || Error;
var LinkError = WebAssembly && WebAssembly.LinkError || Error;
var RuntimeError = WebAssembly && WebAssembly.RuntimeError || Error;
var DOMException = getBuiltin('DOMException');
var Set = getBuiltin('Set');
var Map = getBuiltin('Map');
var MapPrototype = Map.prototype;
var mapHas = uncurryThis(MapPrototype.has);
var mapGet = uncurryThis(MapPrototype.get);
var mapSet = uncurryThis(MapPrototype.set);
var setAdd = uncurryThis(Set.prototype.add);
var objectKeys = getBuiltin('Object', 'keys');
var push = uncurryThis([].push);
var booleanValueOf = uncurryThis(true.valueOf);
var numberValueOf = uncurryThis(1..valueOf);
var stringValueOf = uncurryThis(''.valueOf);
var getFlags = uncurryThis(regExpFlags);
var getTime = uncurryThis(Date.prototype.getTime);
var PERFORMANCE_MARK = uid('structuredClone');
var DATA_CLONE_ERROR = 'DataCloneError';
var TRANSFERRING = 'Transferring';
var checkBasicSemantic = function(structuredCloneImplementation) {
    return !fails(function() {
        var set1 = new global.Set([
            7
        ]);
        var set2 = structuredCloneImplementation(set1);
        var number = structuredCloneImplementation(Object(7));
        return set2 == set1 || !set2.has(7) || typeof number != 'object' || number != 7;
    }) && structuredCloneImplementation;
};
// https://github.com/whatwg/html/pull/5749
var checkNewErrorsSemantic = function(structuredCloneImplementation) {
    return !fails(function() {
        var test = structuredCloneImplementation(new global.AggregateError([
            1
        ], PERFORMANCE_MARK, {
            cause: 3
        }));
        return test.name != 'AggregateError' || test.errors[0] != 1 || test.message != PERFORMANCE_MARK || test.cause != 3;
    }) && structuredCloneImplementation;
};
// FF94+, Safari TP134+, Chrome Canary 98+, NodeJS 17.0+, Deno 1.13+
// current FF and Safari implementations can't clone errors
// https://bugzilla.mozilla.org/show_bug.cgi?id=1556604
// no one of current implementations supports new (html/5749) error cloning semantic
var nativeStructuredClone = global.structuredClone;
var FORCED_REPLACEMENT = IS_PURE || !checkNewErrorsSemantic(nativeStructuredClone);
// Chrome 82+, Safari 14.1+, Deno 1.11+
// Chrome 78-81 implementation swaps `.name` and `.message` of cloned `DOMException`
// Safari 14.1 implementation doesn't clone some `RegExp` flags, so requires a workaround
// current Safari implementation can't clone errors
// Deno 1.2-1.10 implementations too naive
// NodeJS 16.0+ does not have `PerformanceMark` constructor, structured cloning implementation
//   from `performance.mark` is too naive and can't clone, for example, `RegExp` or some boxed primitives
//   https://github.com/nodejs/node/issues/40840
// no one of current implementations supports new (html/5749) error cloning semantic
var structuredCloneFromMark = !nativeStructuredClone && checkBasicSemantic(function(value) {
    return new PerformanceMark(PERFORMANCE_MARK, {
        detail: value
    }).detail;
});
var nativeRestrictedStructuredClone = checkBasicSemantic(nativeStructuredClone) || structuredCloneFromMark;
var throwUncloneable = function(type) {
    throw new DOMException('Uncloneable type: ' + type, DATA_CLONE_ERROR);
};
var throwUnpolyfillable = function(type, kind) {
    throw new DOMException((kind || 'Cloning') + ' of ' + type + ' cannot be properly polyfilled in this engine', DATA_CLONE_ERROR);
};
var structuredCloneInternal = function(value, map) {
    if (isSymbol(value)) throwUncloneable('Symbol');
    if (!isObject(value)) return value;
    // effectively preserves circular references
    if (map) {
        if (mapHas(map, value)) return mapGet(map, value);
    } else map = new Map();
    var type = classof(value);
    var deep = false;
    var C, name, cloned, dataTransfer, i, length, keys, key, source, target;
    switch(type){
        case 'Array':
            cloned = [];
            deep = true;
            break;
        case 'Object':
            cloned = {
            };
            deep = true;
            break;
        case 'Map':
            cloned = new Map();
            deep = true;
            break;
        case 'Set':
            cloned = new Set();
            deep = true;
            break;
        case 'RegExp':
            // in this block because of a Safari 14.1 bug
            // old FF does not clone regexes passed to the constructor, so get the source and flags directly
            cloned = new RegExp(value.source, 'flags' in value ? value.flags : getFlags(value));
            break;
        case 'Error':
            name = value.name;
            switch(name){
                case 'AggregateError':
                    cloned = getBuiltin('AggregateError')([]);
                    break;
                case 'EvalError':
                    cloned = EvalError();
                    break;
                case 'RangeError':
                    cloned = RangeError();
                    break;
                case 'ReferenceError':
                    cloned = ReferenceError();
                    break;
                case 'SyntaxError':
                    cloned = SyntaxError();
                    break;
                case 'TypeError':
                    cloned = TypeError();
                    break;
                case 'URIError':
                    cloned = URIError();
                    break;
                case 'CompileError':
                    cloned = CompileError();
                    break;
                case 'LinkError':
                    cloned = LinkError();
                    break;
                case 'RuntimeError':
                    cloned = RuntimeError();
                    break;
                default:
                    cloned = Error();
            }
            deep = true;
            break;
        case 'DOMException':
            cloned = new DOMException(value.message, value.name);
            deep = true;
            break;
        case 'DataView':
        case 'Int8Array':
        case 'Uint8Array':
        case 'Uint8ClampedArray':
        case 'Int16Array':
        case 'Uint16Array':
        case 'Int32Array':
        case 'Uint32Array':
        case 'Float32Array':
        case 'Float64Array':
        case 'BigInt64Array':
        case 'BigUint64Array':
            C = global[type];
            // in some old engines like Safari 9, typeof C is 'object'
            // on Uint8ClampedArray or some other constructors
            if (!isObject(C)) throwUnpolyfillable(type);
            cloned = new C(// this is safe, since arraybuffer cannot have circular references
            structuredCloneInternal(value.buffer, map), value.byteOffset, type === 'DataView' ? value.byteLength : value.length);
            break;
        case 'DOMQuad':
            try {
                cloned = new DOMQuad(structuredCloneInternal(value.p1, map), structuredCloneInternal(value.p2, map), structuredCloneInternal(value.p3, map), structuredCloneInternal(value.p4, map));
            } catch (error) {
                if (nativeRestrictedStructuredClone) cloned = nativeRestrictedStructuredClone(value);
                else throwUnpolyfillable(type);
            }
            break;
        case 'FileList':
            C = global.DataTransfer;
            if (isConstructor(C)) {
                dataTransfer = new C();
                for(i = 0, length = lengthOfArrayLike(value); i < length; i++)dataTransfer.items.add(structuredCloneInternal(value[i], map));
                cloned = dataTransfer.files;
            } else if (nativeRestrictedStructuredClone) cloned = nativeRestrictedStructuredClone(value);
            else throwUnpolyfillable(type);
            break;
        case 'ImageData':
            // Safari 9 ImageData is a constructor, but typeof ImageData is 'object'
            try {
                cloned = new ImageData(structuredCloneInternal(value.data, map), value.width, value.height, {
                    colorSpace: value.colorSpace
                });
            } catch (error1) {
                if (nativeRestrictedStructuredClone) cloned = nativeRestrictedStructuredClone(value);
                else throwUnpolyfillable(type);
            }
            break;
        default:
            if (nativeRestrictedStructuredClone) cloned = nativeRestrictedStructuredClone(value);
            else switch(type){
                case 'BigInt':
                    // can be a 3rd party polyfill
                    cloned = Object(value.valueOf());
                    break;
                case 'Boolean':
                    cloned = Object(booleanValueOf(value));
                    break;
                case 'Number':
                    cloned = Object(numberValueOf(value));
                    break;
                case 'String':
                    cloned = Object(stringValueOf(value));
                    break;
                case 'Date':
                    cloned = new Date(getTime(value));
                    break;
                case 'ArrayBuffer':
                    C = global.DataView;
                    // `ArrayBuffer#slice` is not available in IE10
                    // `ArrayBuffer#slice` and `DataView` are not available in old FF
                    if (!C && typeof value.slice != 'function') throwUnpolyfillable(type);
                    // detached buffers throws in `DataView` and `.slice`
                    try {
                        if (typeof value.slice == 'function') cloned = value.slice(0);
                        else {
                            length = value.byteLength;
                            cloned = new ArrayBuffer(length);
                            source = new C(value);
                            target = new C(cloned);
                            for(i = 0; i < length; i++)target.setUint8(i, source.getUint8(i));
                        }
                    } catch (error2) {
                        throw new DOMException('ArrayBuffer is detached', DATA_CLONE_ERROR);
                    }
                    break;
                case 'SharedArrayBuffer':
                    // SharedArrayBuffer should use shared memory, we can't polyfill it, so return the original
                    cloned = value;
                    break;
                case 'Blob':
                    try {
                        cloned = value.slice(0, value.size, value.type);
                    } catch (error3) {
                        throwUnpolyfillable(type);
                    }
                    break;
                case 'DOMPoint':
                case 'DOMPointReadOnly':
                    C = global[type];
                    try {
                        cloned = C.fromPoint ? C.fromPoint(value) : new C(value.x, value.y, value.z, value.w);
                    } catch (error4) {
                        throwUnpolyfillable(type);
                    }
                    break;
                case 'DOMRect':
                case 'DOMRectReadOnly':
                    C = global[type];
                    try {
                        cloned = C.fromRect ? C.fromRect(value) : new C(value.x, value.y, value.width, value.height);
                    } catch (error5) {
                        throwUnpolyfillable(type);
                    }
                    break;
                case 'DOMMatrix':
                case 'DOMMatrixReadOnly':
                    C = global[type];
                    try {
                        cloned = C.fromMatrix ? C.fromMatrix(value) : new C(value);
                    } catch (error6) {
                        throwUnpolyfillable(type);
                    }
                    break;
                case 'AudioData':
                case 'VideoFrame':
                    if (!isCallable(value.clone)) throwUnpolyfillable(type);
                    try {
                        cloned = value.clone();
                    } catch (error7) {
                        throwUncloneable(type);
                    }
                    break;
                case 'File':
                    try {
                        cloned = new File([
                            value
                        ], value.name, value);
                    } catch (error8) {
                        throwUnpolyfillable(type);
                    }
                    break;
                case 'CryptoKey':
                case 'GPUCompilationMessage':
                case 'GPUCompilationInfo':
                case 'ImageBitmap':
                case 'RTCCertificate':
                case 'WebAssembly.Module':
                    throwUnpolyfillable(type);
                // break omitted
                default:
                    throwUncloneable(type);
            }
    }
    mapSet(map, value, cloned);
    if (deep) switch(type){
        case 'Array':
        case 'Object':
            keys = objectKeys(value);
            for(i = 0, length = lengthOfArrayLike(keys); i < length; i++){
                key = keys[i];
                createProperty(cloned, key, structuredCloneInternal(value[key], map));
            }
            break;
        case 'Map':
            value.forEach(function(v, k) {
                mapSet(cloned, structuredCloneInternal(k, map), structuredCloneInternal(v, map));
            });
            break;
        case 'Set':
            value.forEach(function(v) {
                setAdd(cloned, structuredCloneInternal(v, map));
            });
            break;
        case 'Error':
            createNonEnumerableProperty(cloned, 'message', structuredCloneInternal(value.message, map));
            if (hasOwn(value, 'cause')) createNonEnumerableProperty(cloned, 'cause', structuredCloneInternal(value.cause, map));
            if (name == 'AggregateError') cloned.errors = structuredCloneInternal(value.errors, map);
             // break omitted
        case 'DOMException':
            if (ERROR_STACK_INSTALLABLE) createNonEnumerableProperty(cloned, 'stack', structuredCloneInternal(value.stack, map));
    }
    return cloned;
};
var PROPER_TRANSFER = nativeStructuredClone && !fails(function() {
    var buffer = new ArrayBuffer(8);
    var clone = nativeStructuredClone(buffer, {
        transfer: [
            buffer
        ]
    });
    return buffer.byteLength != 0 || clone.byteLength != 8;
});
var tryToTransfer = function(rawTransfer, map) {
    if (!isObject(rawTransfer)) throw TypeError('Transfer option cannot be converted to a sequence');
    var transfer = [];
    iterate(rawTransfer, function(value) {
        push(transfer, anObject(value));
    });
    var i = 0;
    var length = lengthOfArrayLike(transfer);
    var value1, type, C, transferredArray, transferred, canvas, context;
    if (PROPER_TRANSFER) {
        transferredArray = nativeStructuredClone(transfer, {
            transfer: transfer
        });
        while(i < length)mapSet(map, transfer[i], transferredArray[i++]);
    } else while(i < length){
        value1 = transfer[i++];
        if (mapHas(map, value1)) throw new DOMException('Duplicate transferable', DATA_CLONE_ERROR);
        type = classof(value1);
        switch(type){
            case 'ImageBitmap':
                C = global.OffscreenCanvas;
                if (!isConstructor(C)) throwUnpolyfillable(type, TRANSFERRING);
                try {
                    canvas = new C(value1.width, value1.height);
                    context = canvas.getContext('bitmaprenderer');
                    context.transferFromImageBitmap(value1);
                    transferred = canvas.transferToImageBitmap();
                } catch (error) {
                }
                break;
            case 'AudioData':
            case 'VideoFrame':
                if (!isCallable(value1.clone) || !isCallable(value1.close)) throwUnpolyfillable(type, TRANSFERRING);
                try {
                    transferred = value1.clone();
                    value1.close();
                } catch (error9) {
                }
                break;
            case 'ArrayBuffer':
            case 'MessagePort':
            case 'OffscreenCanvas':
            case 'ReadableStream':
            case 'TransformStream':
            case 'WritableStream':
                throwUnpolyfillable(type, TRANSFERRING);
        }
        if (transferred === undefined) throw new DOMException('This object cannot be transferred: ' + type, DATA_CLONE_ERROR);
        mapSet(map, value1, transferred);
    }
};
$({
    global: true,
    enumerable: true,
    sham: !PROPER_TRANSFER,
    forced: FORCED_REPLACEMENT
}, {
    structuredClone: function structuredClone(value /* , { transfer } */ ) {
        var options = validateArgumentsLength(arguments.length, 1) > 1 ? anObject(arguments[1]) : undefined;
        var transfer = options ? options.transfer : undefined;
        var map;
        if (transfer !== undefined) {
            map = new Map();
            tryToTransfer(transfer, map);
        }
        return structuredCloneInternal(value, map);
    }
});

},{"../internals/is-pure":"6Bbq0","../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/get-built-in":"78arb","../internals/function-uncurry-this":"jJnXC","../internals/fails":"8IfZQ","../internals/uid":"eMBx9","../internals/is-callable":"kPhuP","../internals/is-constructor":"iNoNi","../internals/is-object":"dplrD","../internals/is-symbol":"imyt8","../internals/iterate":"fTyka","../internals/an-object":"1LIz9","../internals/classof":"kJ8JQ","../internals/has-own-property":"3ZdUC","../internals/create-property":"a2n8E","../internals/create-non-enumerable-property":"6Z1es","../internals/length-of-array-like":"afDy6","../internals/validate-arguments-length":"gKrE5","../internals/regexp-flags":"4QDzk","../internals/error-stack-installable":"81LgE"}],"gKrE5":[function(require,module,exports) {
var global = require('../internals/global');
var TypeError = global.TypeError;
module.exports = function(passed, required) {
    if (passed < required) throw TypeError('Not enough arguments');
    return passed;
};

},{"../internals/global":"jxPDA"}],"7iQ00":[function(require,module,exports) {
var $ = require('../internals/export');
var global = require('../internals/global');
var apply = require('../internals/function-apply');
var isCallable = require('../internals/is-callable');
var userAgent = require('../internals/engine-user-agent');
var arraySlice = require('../internals/array-slice');
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
var Function = global.Function;
var wrap = function(scheduler) {
    return function(handler, timeout /* , ...arguments */ ) {
        var boundArgs = arguments.length > 2;
        var args = boundArgs ? arraySlice(arguments, 2) : undefined;
        return scheduler(boundArgs ? function() {
            apply(isCallable(handler) ? handler : Function(handler), this, args);
        } : handler, timeout);
    };
};
// ie9- setTimeout & setInterval additional parameters fix
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers
$({
    global: true,
    bind: true,
    forced: MSIE
}, {
    // `setTimeout` method
    // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
    setTimeout: wrap(global.setTimeout),
    // `setInterval` method
    // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
    setInterval: wrap(global.setInterval)
});

},{"../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/function-apply":"206oi","../internals/is-callable":"kPhuP","../internals/engine-user-agent":"boFeV","../internals/array-slice":"bI1dk"}],"fQSbp":[function(require,module,exports) {
'use strict';
// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
require('../modules/es.string.iterator');
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var USE_NATIVE_URL = require('../internals/native-url');
var global = require('../internals/global');
var bind = require('../internals/function-bind-context');
var uncurryThis = require('../internals/function-uncurry-this');
var defineProperties = require('../internals/object-define-properties').f;
var redefine = require('../internals/redefine');
var anInstance = require('../internals/an-instance');
var hasOwn = require('../internals/has-own-property');
var assign = require('../internals/object-assign');
var arrayFrom = require('../internals/array-from');
var arraySlice = require('../internals/array-slice-simple');
var codeAt = require('../internals/string-multibyte').codeAt;
var toASCII = require('../internals/string-punycode-to-ascii');
var $toString = require('../internals/to-string');
var setToStringTag = require('../internals/set-to-string-tag');
var URLSearchParamsModule = require('../modules/web.url-search-params');
var InternalStateModule = require('../internals/internal-state');
var setInternalState = InternalStateModule.set;
var getInternalURLState = InternalStateModule.getterFor('URL');
var URLSearchParams = URLSearchParamsModule.URLSearchParams;
var getInternalSearchParamsState = URLSearchParamsModule.getState;
var NativeURL = global.URL;
var TypeError = global.TypeError;
var parseInt = global.parseInt;
var floor = Math.floor;
var pow = Math.pow;
var charAt = uncurryThis(''.charAt);
var exec = uncurryThis(/./.exec);
var join = uncurryThis([].join);
var numberToString = uncurryThis(1..toString);
var pop = uncurryThis([].pop);
var push = uncurryThis([].push);
var replace = uncurryThis(''.replace);
var shift = uncurryThis([].shift);
var split = uncurryThis(''.split);
var stringSlice = uncurryThis(''.slice);
var toLowerCase = uncurryThis(''.toLowerCase);
var unshift = uncurryThis([].unshift);
var INVALID_AUTHORITY = 'Invalid authority';
var INVALID_SCHEME = 'Invalid scheme';
var INVALID_HOST = 'Invalid host';
var INVALID_PORT = 'Invalid port';
var ALPHA = /[a-z]/i;
// eslint-disable-next-line regexp/no-obscure-range -- safe
var ALPHANUMERIC = /[\d+-.a-z]/i;
var DIGIT = /\d/;
var HEX_START = /^0x/i;
var OCT = /^[0-7]+$/;
var DEC = /^\d+$/;
var HEX = /^[\da-f]+$/i;
/* eslint-disable regexp/no-control-character -- safe */ var FORBIDDEN_HOST_CODE_POINT = /[\0\t\n\r #%/:<>?@[\\\]^|]/;
var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\0\t\n\r #/:<>?@[\\\]^|]/;
var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u0020]+|[\u0000-\u0020]+$/g;
var TAB_AND_NEW_LINE = /[\t\n\r]/g;
/* eslint-enable regexp/no-control-character -- safe */ var EOF;
// https://url.spec.whatwg.org/#ipv4-number-parser
var parseIPv4 = function(input) {
    var parts = split(input, '.');
    var partsLength, numbers, index, part, radix, number, ipv4;
    if (parts.length && parts[parts.length - 1] == '') parts.length--;
    partsLength = parts.length;
    if (partsLength > 4) return input;
    numbers = [];
    for(index = 0; index < partsLength; index++){
        part = parts[index];
        if (part == '') return input;
        radix = 10;
        if (part.length > 1 && charAt(part, 0) == '0') {
            radix = exec(HEX_START, part) ? 16 : 8;
            part = stringSlice(part, radix == 8 ? 1 : 2);
        }
        if (part === '') number = 0;
        else {
            if (!exec(radix == 10 ? DEC : radix == 8 ? OCT : HEX, part)) return input;
            number = parseInt(part, radix);
        }
        push(numbers, number);
    }
    for(index = 0; index < partsLength; index++){
        number = numbers[index];
        if (index == partsLength - 1) {
            if (number >= pow(256, 5 - partsLength)) return null;
        } else if (number > 255) return null;
    }
    ipv4 = pop(numbers);
    for(index = 0; index < numbers.length; index++)ipv4 += numbers[index] * pow(256, 3 - index);
    return ipv4;
};
// https://url.spec.whatwg.org/#concept-ipv6-parser
// eslint-disable-next-line max-statements -- TODO
var parseIPv6 = function(input) {
    var address = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
    ];
    var pieceIndex = 0;
    var compress = null;
    var pointer = 0;
    var value, length, numbersSeen, ipv4Piece, number, swaps, swap;
    var chr = function() {
        return charAt(input, pointer);
    };
    if (chr() == ':') {
        if (charAt(input, 1) != ':') return;
        pointer += 2;
        pieceIndex++;
        compress = pieceIndex;
    }
    while(chr()){
        if (pieceIndex == 8) return;
        if (chr() == ':') {
            if (compress !== null) return;
            pointer++;
            pieceIndex++;
            compress = pieceIndex;
            continue;
        }
        value = length = 0;
        while(length < 4 && exec(HEX, chr())){
            value = value * 16 + parseInt(chr(), 16);
            pointer++;
            length++;
        }
        if (chr() == '.') {
            if (length == 0) return;
            pointer -= length;
            if (pieceIndex > 6) return;
            numbersSeen = 0;
            while(chr()){
                ipv4Piece = null;
                if (numbersSeen > 0) {
                    if (chr() == '.' && numbersSeen < 4) pointer++;
                    else return;
                }
                if (!exec(DIGIT, chr())) return;
                while(exec(DIGIT, chr())){
                    number = parseInt(chr(), 10);
                    if (ipv4Piece === null) ipv4Piece = number;
                    else if (ipv4Piece == 0) return;
                    else ipv4Piece = ipv4Piece * 10 + number;
                    if (ipv4Piece > 255) return;
                    pointer++;
                }
                address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
                numbersSeen++;
                if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++;
            }
            if (numbersSeen != 4) return;
            break;
        } else if (chr() == ':') {
            pointer++;
            if (!chr()) return;
        } else if (chr()) return;
        address[pieceIndex++] = value;
    }
    if (compress !== null) {
        swaps = pieceIndex - compress;
        pieceIndex = 7;
        while(pieceIndex != 0 && swaps > 0){
            swap = address[pieceIndex];
            address[pieceIndex--] = address[compress + swaps - 1];
            address[compress + --swaps] = swap;
        }
    } else if (pieceIndex != 8) return;
    return address;
};
var findLongestZeroSequence = function(ipv6) {
    var maxIndex = null;
    var maxLength = 1;
    var currStart = null;
    var currLength = 0;
    var index = 0;
    for(; index < 8; index++)if (ipv6[index] !== 0) {
        if (currLength > maxLength) {
            maxIndex = currStart;
            maxLength = currLength;
        }
        currStart = null;
        currLength = 0;
    } else {
        if (currStart === null) currStart = index;
        ++currLength;
    }
    if (currLength > maxLength) {
        maxIndex = currStart;
        maxLength = currLength;
    }
    return maxIndex;
};
// https://url.spec.whatwg.org/#host-serializing
var serializeHost = function(host) {
    var result, index, compress, ignore0;
    // ipv4
    if (typeof host == 'number') {
        result = [];
        for(index = 0; index < 4; index++){
            unshift(result, host % 256);
            host = floor(host / 256);
        }
        return join(result, '.');
    // ipv6
    } else if (typeof host == 'object') {
        result = '';
        compress = findLongestZeroSequence(host);
        for(index = 0; index < 8; index++){
            if (ignore0 && host[index] === 0) continue;
            if (ignore0) ignore0 = false;
            if (compress === index) {
                result += index ? ':' : '::';
                ignore0 = true;
            } else {
                result += numberToString(host[index], 16);
                if (index < 7) result += ':';
            }
        }
        return '[' + result + ']';
    }
    return host;
};
var C0ControlPercentEncodeSet = {
};
var fragmentPercentEncodeSet = assign({
}, C0ControlPercentEncodeSet, {
    ' ': 1,
    '"': 1,
    '<': 1,
    '>': 1,
    '`': 1
});
var pathPercentEncodeSet = assign({
}, fragmentPercentEncodeSet, {
    '#': 1,
    '?': 1,
    '{': 1,
    '}': 1
});
var userinfoPercentEncodeSet = assign({
}, pathPercentEncodeSet, {
    '/': 1,
    ':': 1,
    ';': 1,
    '=': 1,
    '@': 1,
    '[': 1,
    '\\': 1,
    ']': 1,
    '^': 1,
    '|': 1
});
var percentEncode = function(chr, set) {
    var code = codeAt(chr, 0);
    return code > 32 && code < 127 && !hasOwn(set, chr) ? chr : encodeURIComponent(chr);
};
// https://url.spec.whatwg.org/#special-scheme
var specialSchemes = {
    ftp: 21,
    file: null,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
};
// https://url.spec.whatwg.org/#windows-drive-letter
var isWindowsDriveLetter = function(string, normalized) {
    var second;
    return string.length == 2 && exec(ALPHA, charAt(string, 0)) && ((second = charAt(string, 1)) == ':' || !normalized && second == '|');
};
// https://url.spec.whatwg.org/#start-with-a-windows-drive-letter
var startsWithWindowsDriveLetter = function(string) {
    var third;
    return string.length > 1 && isWindowsDriveLetter(stringSlice(string, 0, 2)) && (string.length == 2 || (third = charAt(string, 2)) === '/' || third === '\\' || third === '?' || third === '#');
};
// https://url.spec.whatwg.org/#single-dot-path-segment
var isSingleDot = function(segment) {
    return segment === '.' || toLowerCase(segment) === '%2e';
};
// https://url.spec.whatwg.org/#double-dot-path-segment
var isDoubleDot = function(segment) {
    segment = toLowerCase(segment);
    return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';
};
// States:
var SCHEME_START = {
};
var SCHEME = {
};
var NO_SCHEME = {
};
var SPECIAL_RELATIVE_OR_AUTHORITY = {
};
var PATH_OR_AUTHORITY = {
};
var RELATIVE = {
};
var RELATIVE_SLASH = {
};
var SPECIAL_AUTHORITY_SLASHES = {
};
var SPECIAL_AUTHORITY_IGNORE_SLASHES = {
};
var AUTHORITY = {
};
var HOST = {
};
var HOSTNAME = {
};
var PORT = {
};
var FILE = {
};
var FILE_SLASH = {
};
var FILE_HOST = {
};
var PATH_START = {
};
var PATH = {
};
var CANNOT_BE_A_BASE_URL_PATH = {
};
var QUERY = {
};
var FRAGMENT = {
};
var URLState = function(url, isBase, base) {
    var urlString = $toString(url);
    var baseState, failure, searchParams;
    if (isBase) {
        failure = this.parse(urlString);
        if (failure) throw TypeError(failure);
        this.searchParams = null;
    } else {
        if (base !== undefined) baseState = new URLState(base, true);
        failure = this.parse(urlString, null, baseState);
        if (failure) throw TypeError(failure);
        searchParams = getInternalSearchParamsState(new URLSearchParams());
        searchParams.bindURL(this);
        this.searchParams = searchParams;
    }
};
URLState.prototype = {
    type: 'URL',
    // https://url.spec.whatwg.org/#url-parsing
    // eslint-disable-next-line max-statements -- TODO
    parse: function(input, stateOverride, base) {
        var url = this;
        var state = stateOverride || SCHEME_START;
        var pointer = 0;
        var buffer = '';
        var seenAt = false;
        var seenBracket = false;
        var seenPasswordToken = false;
        var codePoints, chr, bufferCodePoints, failure;
        input = $toString(input);
        if (!stateOverride) {
            url.scheme = '';
            url.username = '';
            url.password = '';
            url.host = null;
            url.port = null;
            url.path = [];
            url.query = null;
            url.fragment = null;
            url.cannotBeABaseURL = false;
            input = replace(input, LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');
        }
        input = replace(input, TAB_AND_NEW_LINE, '');
        codePoints = arrayFrom(input);
        while(pointer <= codePoints.length){
            chr = codePoints[pointer];
            switch(state){
                case SCHEME_START:
                    if (chr && exec(ALPHA, chr)) {
                        buffer += toLowerCase(chr);
                        state = SCHEME;
                    } else if (!stateOverride) {
                        state = NO_SCHEME;
                        continue;
                    } else return INVALID_SCHEME;
                    break;
                case SCHEME:
                    if (chr && (exec(ALPHANUMERIC, chr) || chr == '+' || chr == '-' || chr == '.')) buffer += toLowerCase(chr);
                    else if (chr == ':') {
                        if (stateOverride && (url.isSpecial() != hasOwn(specialSchemes, buffer) || buffer == 'file' && (url.includesCredentials() || url.port !== null) || url.scheme == 'file' && !url.host)) return;
                        url.scheme = buffer;
                        if (stateOverride) {
                            if (url.isSpecial() && specialSchemes[url.scheme] == url.port) url.port = null;
                            return;
                        }
                        buffer = '';
                        if (url.scheme == 'file') state = FILE;
                        else if (url.isSpecial() && base && base.scheme == url.scheme) state = SPECIAL_RELATIVE_OR_AUTHORITY;
                        else if (url.isSpecial()) state = SPECIAL_AUTHORITY_SLASHES;
                        else if (codePoints[pointer + 1] == '/') {
                            state = PATH_OR_AUTHORITY;
                            pointer++;
                        } else {
                            url.cannotBeABaseURL = true;
                            push(url.path, '');
                            state = CANNOT_BE_A_BASE_URL_PATH;
                        }
                    } else if (!stateOverride) {
                        buffer = '';
                        state = NO_SCHEME;
                        pointer = 0;
                        continue;
                    } else return INVALID_SCHEME;
                    break;
                case NO_SCHEME:
                    if (!base || base.cannotBeABaseURL && chr != '#') return INVALID_SCHEME;
                    if (base.cannotBeABaseURL && chr == '#') {
                        url.scheme = base.scheme;
                        url.path = arraySlice(base.path);
                        url.query = base.query;
                        url.fragment = '';
                        url.cannotBeABaseURL = true;
                        state = FRAGMENT;
                        break;
                    }
                    state = base.scheme == 'file' ? FILE : RELATIVE;
                    continue;
                case SPECIAL_RELATIVE_OR_AUTHORITY:
                    if (chr == '/' && codePoints[pointer + 1] == '/') {
                        state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                        pointer++;
                    } else {
                        state = RELATIVE;
                        continue;
                    }
                    break;
                case PATH_OR_AUTHORITY:
                    if (chr == '/') {
                        state = AUTHORITY;
                        break;
                    } else {
                        state = PATH;
                        continue;
                    }
                case RELATIVE:
                    url.scheme = base.scheme;
                    if (chr == EOF) {
                        url.username = base.username;
                        url.password = base.password;
                        url.host = base.host;
                        url.port = base.port;
                        url.path = arraySlice(base.path);
                        url.query = base.query;
                    } else if (chr == '/' || chr == '\\' && url.isSpecial()) state = RELATIVE_SLASH;
                    else if (chr == '?') {
                        url.username = base.username;
                        url.password = base.password;
                        url.host = base.host;
                        url.port = base.port;
                        url.path = arraySlice(base.path);
                        url.query = '';
                        state = QUERY;
                    } else if (chr == '#') {
                        url.username = base.username;
                        url.password = base.password;
                        url.host = base.host;
                        url.port = base.port;
                        url.path = arraySlice(base.path);
                        url.query = base.query;
                        url.fragment = '';
                        state = FRAGMENT;
                    } else {
                        url.username = base.username;
                        url.password = base.password;
                        url.host = base.host;
                        url.port = base.port;
                        url.path = arraySlice(base.path);
                        url.path.length--;
                        state = PATH;
                        continue;
                    }
                    break;
                case RELATIVE_SLASH:
                    if (url.isSpecial() && (chr == '/' || chr == '\\')) state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                    else if (chr == '/') state = AUTHORITY;
                    else {
                        url.username = base.username;
                        url.password = base.password;
                        url.host = base.host;
                        url.port = base.port;
                        state = PATH;
                        continue;
                    }
                    break;
                case SPECIAL_AUTHORITY_SLASHES:
                    state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                    if (chr != '/' || charAt(buffer, pointer + 1) != '/') continue;
                    pointer++;
                    break;
                case SPECIAL_AUTHORITY_IGNORE_SLASHES:
                    if (chr != '/' && chr != '\\') {
                        state = AUTHORITY;
                        continue;
                    }
                    break;
                case AUTHORITY:
                    if (chr == '@') {
                        if (seenAt) buffer = '%40' + buffer;
                        seenAt = true;
                        bufferCodePoints = arrayFrom(buffer);
                        for(var i = 0; i < bufferCodePoints.length; i++){
                            var codePoint = bufferCodePoints[i];
                            if (codePoint == ':' && !seenPasswordToken) {
                                seenPasswordToken = true;
                                continue;
                            }
                            var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
                            if (seenPasswordToken) url.password += encodedCodePoints;
                            else url.username += encodedCodePoints;
                        }
                        buffer = '';
                    } else if (chr == EOF || chr == '/' || chr == '?' || chr == '#' || chr == '\\' && url.isSpecial()) {
                        if (seenAt && buffer == '') return INVALID_AUTHORITY;
                        pointer -= arrayFrom(buffer).length + 1;
                        buffer = '';
                        state = HOST;
                    } else buffer += chr;
                    break;
                case HOST:
                case HOSTNAME:
                    if (stateOverride && url.scheme == 'file') {
                        state = FILE_HOST;
                        continue;
                    } else if (chr == ':' && !seenBracket) {
                        if (buffer == '') return INVALID_HOST;
                        failure = url.parseHost(buffer);
                        if (failure) return failure;
                        buffer = '';
                        state = PORT;
                        if (stateOverride == HOSTNAME) return;
                    } else if (chr == EOF || chr == '/' || chr == '?' || chr == '#' || chr == '\\' && url.isSpecial()) {
                        if (url.isSpecial() && buffer == '') return INVALID_HOST;
                        if (stateOverride && buffer == '' && (url.includesCredentials() || url.port !== null)) return;
                        failure = url.parseHost(buffer);
                        if (failure) return failure;
                        buffer = '';
                        state = PATH_START;
                        if (stateOverride) return;
                        continue;
                    } else {
                        if (chr == '[') seenBracket = true;
                        else if (chr == ']') seenBracket = false;
                        buffer += chr;
                    }
                    break;
                case PORT:
                    if (exec(DIGIT, chr)) buffer += chr;
                    else if (chr == EOF || chr == '/' || chr == '?' || chr == '#' || chr == '\\' && url.isSpecial() || stateOverride) {
                        if (buffer != '') {
                            var port = parseInt(buffer, 10);
                            if (port > 65535) return INVALID_PORT;
                            url.port = url.isSpecial() && port === specialSchemes[url.scheme] ? null : port;
                            buffer = '';
                        }
                        if (stateOverride) return;
                        state = PATH_START;
                        continue;
                    } else return INVALID_PORT;
                    break;
                case FILE:
                    url.scheme = 'file';
                    if (chr == '/' || chr == '\\') state = FILE_SLASH;
                    else if (base && base.scheme == 'file') {
                        if (chr == EOF) {
                            url.host = base.host;
                            url.path = arraySlice(base.path);
                            url.query = base.query;
                        } else if (chr == '?') {
                            url.host = base.host;
                            url.path = arraySlice(base.path);
                            url.query = '';
                            state = QUERY;
                        } else if (chr == '#') {
                            url.host = base.host;
                            url.path = arraySlice(base.path);
                            url.query = base.query;
                            url.fragment = '';
                            state = FRAGMENT;
                        } else {
                            if (!startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), ''))) {
                                url.host = base.host;
                                url.path = arraySlice(base.path);
                                url.shortenPath();
                            }
                            state = PATH;
                            continue;
                        }
                    } else {
                        state = PATH;
                        continue;
                    }
                    break;
                case FILE_SLASH:
                    if (chr == '/' || chr == '\\') {
                        state = FILE_HOST;
                        break;
                    }
                    if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), ''))) {
                        if (isWindowsDriveLetter(base.path[0], true)) push(url.path, base.path[0]);
                        else url.host = base.host;
                    }
                    state = PATH;
                    continue;
                case FILE_HOST:
                    if (chr == EOF || chr == '/' || chr == '\\' || chr == '?' || chr == '#') {
                        if (!stateOverride && isWindowsDriveLetter(buffer)) state = PATH;
                        else if (buffer == '') {
                            url.host = '';
                            if (stateOverride) return;
                            state = PATH_START;
                        } else {
                            failure = url.parseHost(buffer);
                            if (failure) return failure;
                            if (url.host == 'localhost') url.host = '';
                            if (stateOverride) return;
                            buffer = '';
                            state = PATH_START;
                        }
                        continue;
                    } else buffer += chr;
                    break;
                case PATH_START:
                    if (url.isSpecial()) {
                        state = PATH;
                        if (chr != '/' && chr != '\\') continue;
                    } else if (!stateOverride && chr == '?') {
                        url.query = '';
                        state = QUERY;
                    } else if (!stateOverride && chr == '#') {
                        url.fragment = '';
                        state = FRAGMENT;
                    } else if (chr != EOF) {
                        state = PATH;
                        if (chr != '/') continue;
                    }
                    break;
                case PATH:
                    if (chr == EOF || chr == '/' || chr == '\\' && url.isSpecial() || !stateOverride && (chr == '?' || chr == '#')) {
                        if (isDoubleDot(buffer)) {
                            url.shortenPath();
                            if (chr != '/' && !(chr == '\\' && url.isSpecial())) push(url.path, '');
                        } else if (isSingleDot(buffer)) {
                            if (chr != '/' && !(chr == '\\' && url.isSpecial())) push(url.path, '');
                        } else {
                            if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {
                                if (url.host) url.host = '';
                                buffer = charAt(buffer, 0) + ':'; // normalize windows drive letter
                            }
                            push(url.path, buffer);
                        }
                        buffer = '';
                        if (url.scheme == 'file' && (chr == EOF || chr == '?' || chr == '#')) while(url.path.length > 1 && url.path[0] === '')shift(url.path);
                        if (chr == '?') {
                            url.query = '';
                            state = QUERY;
                        } else if (chr == '#') {
                            url.fragment = '';
                            state = FRAGMENT;
                        }
                    } else buffer += percentEncode(chr, pathPercentEncodeSet);
                    break;
                case CANNOT_BE_A_BASE_URL_PATH:
                    if (chr == '?') {
                        url.query = '';
                        state = QUERY;
                    } else if (chr == '#') {
                        url.fragment = '';
                        state = FRAGMENT;
                    } else if (chr != EOF) url.path[0] += percentEncode(chr, C0ControlPercentEncodeSet);
                    break;
                case QUERY:
                    if (!stateOverride && chr == '#') {
                        url.fragment = '';
                        state = FRAGMENT;
                    } else if (chr != EOF) {
                        if (chr == "'" && url.isSpecial()) url.query += '%27';
                        else if (chr == '#') url.query += '%23';
                        else url.query += percentEncode(chr, C0ControlPercentEncodeSet);
                    }
                    break;
                case FRAGMENT:
                    if (chr != EOF) url.fragment += percentEncode(chr, fragmentPercentEncodeSet);
                    break;
            }
            pointer++;
        }
    },
    // https://url.spec.whatwg.org/#host-parsing
    parseHost: function(input) {
        var result, codePoints, index;
        if (charAt(input, 0) == '[') {
            if (charAt(input, input.length - 1) != ']') return INVALID_HOST;
            result = parseIPv6(stringSlice(input, 1, -1));
            if (!result) return INVALID_HOST;
            this.host = result;
        // opaque host
        } else if (!this.isSpecial()) {
            if (exec(FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT, input)) return INVALID_HOST;
            result = '';
            codePoints = arrayFrom(input);
            for(index = 0; index < codePoints.length; index++)result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
            this.host = result;
        } else {
            input = toASCII(input);
            if (exec(FORBIDDEN_HOST_CODE_POINT, input)) return INVALID_HOST;
            result = parseIPv4(input);
            if (result === null) return INVALID_HOST;
            this.host = result;
        }
    },
    // https://url.spec.whatwg.org/#cannot-have-a-username-password-port
    cannotHaveUsernamePasswordPort: function() {
        return !this.host || this.cannotBeABaseURL || this.scheme == 'file';
    },
    // https://url.spec.whatwg.org/#include-credentials
    includesCredentials: function() {
        return this.username != '' || this.password != '';
    },
    // https://url.spec.whatwg.org/#is-special
    isSpecial: function() {
        return hasOwn(specialSchemes, this.scheme);
    },
    // https://url.spec.whatwg.org/#shorten-a-urls-path
    shortenPath: function() {
        var path = this.path;
        var pathSize = path.length;
        if (pathSize && (this.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) path.length--;
    },
    // https://url.spec.whatwg.org/#concept-url-serializer
    serialize: function() {
        var url = this;
        var scheme = url.scheme;
        var username = url.username;
        var password = url.password;
        var host = url.host;
        var port = url.port;
        var path = url.path;
        var query = url.query;
        var fragment = url.fragment;
        var output = scheme + ':';
        if (host !== null) {
            output += '//';
            if (url.includesCredentials()) output += username + (password ? ':' + password : '') + '@';
            output += serializeHost(host);
            if (port !== null) output += ':' + port;
        } else if (scheme == 'file') output += '//';
        output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + join(path, '/') : '';
        if (query !== null) output += '?' + query;
        if (fragment !== null) output += '#' + fragment;
        return output;
    },
    // https://url.spec.whatwg.org/#dom-url-href
    setHref: function(href) {
        var failure = this.parse(href);
        if (failure) throw TypeError(failure);
        this.searchParams.update();
    },
    // https://url.spec.whatwg.org/#dom-url-origin
    getOrigin: function() {
        var scheme = this.scheme;
        var port = this.port;
        if (scheme == 'blob') try {
            return new URLConstructor(scheme.path[0]).origin;
        } catch (error) {
            return 'null';
        }
        if (scheme == 'file' || !this.isSpecial()) return 'null';
        return scheme + '://' + serializeHost(this.host) + (port !== null ? ':' + port : '');
    },
    // https://url.spec.whatwg.org/#dom-url-protocol
    getProtocol: function() {
        return this.scheme + ':';
    },
    setProtocol: function(protocol) {
        this.parse($toString(protocol) + ':', SCHEME_START);
    },
    // https://url.spec.whatwg.org/#dom-url-username
    getUsername: function() {
        return this.username;
    },
    setUsername: function(username) {
        var codePoints = arrayFrom($toString(username));
        if (this.cannotHaveUsernamePasswordPort()) return;
        this.username = '';
        for(var i = 0; i < codePoints.length; i++)this.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
    },
    // https://url.spec.whatwg.org/#dom-url-password
    getPassword: function() {
        return this.password;
    },
    setPassword: function(password) {
        var codePoints = arrayFrom($toString(password));
        if (this.cannotHaveUsernamePasswordPort()) return;
        this.password = '';
        for(var i = 0; i < codePoints.length; i++)this.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
    },
    // https://url.spec.whatwg.org/#dom-url-host
    getHost: function() {
        var host = this.host;
        var port = this.port;
        return host === null ? '' : port === null ? serializeHost(host) : serializeHost(host) + ':' + port;
    },
    setHost: function(host) {
        if (this.cannotBeABaseURL) return;
        this.parse(host, HOST);
    },
    // https://url.spec.whatwg.org/#dom-url-hostname
    getHostname: function() {
        var host = this.host;
        return host === null ? '' : serializeHost(host);
    },
    setHostname: function(hostname) {
        if (this.cannotBeABaseURL) return;
        this.parse(hostname, HOSTNAME);
    },
    // https://url.spec.whatwg.org/#dom-url-port
    getPort: function() {
        var port = this.port;
        return port === null ? '' : $toString(port);
    },
    setPort: function(port) {
        if (this.cannotHaveUsernamePasswordPort()) return;
        port = $toString(port);
        if (port == '') this.port = null;
        else this.parse(port, PORT);
    },
    // https://url.spec.whatwg.org/#dom-url-pathname
    getPathname: function() {
        var path = this.path;
        return this.cannotBeABaseURL ? path[0] : path.length ? '/' + join(path, '/') : '';
    },
    setPathname: function(pathname) {
        if (this.cannotBeABaseURL) return;
        this.path = [];
        this.parse(pathname, PATH_START);
    },
    // https://url.spec.whatwg.org/#dom-url-search
    getSearch: function() {
        var query = this.query;
        return query ? '?' + query : '';
    },
    setSearch: function(search) {
        search = $toString(search);
        if (search == '') this.query = null;
        else {
            if ('?' == charAt(search, 0)) search = stringSlice(search, 1);
            this.query = '';
            this.parse(search, QUERY);
        }
        this.searchParams.update();
    },
    // https://url.spec.whatwg.org/#dom-url-searchparams
    getSearchParams: function() {
        return this.searchParams.facade;
    },
    // https://url.spec.whatwg.org/#dom-url-hash
    getHash: function() {
        var fragment = this.fragment;
        return fragment ? '#' + fragment : '';
    },
    setHash: function(hash) {
        hash = $toString(hash);
        if (hash == '') {
            this.fragment = null;
            return;
        }
        if ('#' == charAt(hash, 0)) hash = stringSlice(hash, 1);
        this.fragment = '';
        this.parse(hash, FRAGMENT);
    },
    update: function() {
        this.query = this.searchParams.serialize() || null;
    }
};
// `URL` constructor
// https://url.spec.whatwg.org/#url-class
var URLConstructor = function URL(url /* , base */ ) {
    var that = anInstance(this, URLPrototype);
    var base = arguments.length > 1 ? arguments[1] : undefined;
    var state = setInternalState(that, new URLState(url, false, base));
    if (!DESCRIPTORS) {
        that.href = state.serialize();
        that.origin = state.getOrigin();
        that.protocol = state.getProtocol();
        that.username = state.getUsername();
        that.password = state.getPassword();
        that.host = state.getHost();
        that.hostname = state.getHostname();
        that.port = state.getPort();
        that.pathname = state.getPathname();
        that.search = state.getSearch();
        that.searchParams = state.getSearchParams();
        that.hash = state.getHash();
    }
};
var URLPrototype = URLConstructor.prototype;
var accessorDescriptor = function(getter, setter) {
    return {
        get: function() {
            return getInternalURLState(this)[getter]();
        },
        set: setter && function(value) {
            return getInternalURLState(this)[setter](value);
        },
        configurable: true,
        enumerable: true
    };
};
if (DESCRIPTORS) defineProperties(URLPrototype, {
    // `URL.prototype.href` accessors pair
    // https://url.spec.whatwg.org/#dom-url-href
    href: accessorDescriptor('serialize', 'setHref'),
    // `URL.prototype.origin` getter
    // https://url.spec.whatwg.org/#dom-url-origin
    origin: accessorDescriptor('getOrigin'),
    // `URL.prototype.protocol` accessors pair
    // https://url.spec.whatwg.org/#dom-url-protocol
    protocol: accessorDescriptor('getProtocol', 'setProtocol'),
    // `URL.prototype.username` accessors pair
    // https://url.spec.whatwg.org/#dom-url-username
    username: accessorDescriptor('getUsername', 'setUsername'),
    // `URL.prototype.password` accessors pair
    // https://url.spec.whatwg.org/#dom-url-password
    password: accessorDescriptor('getPassword', 'setPassword'),
    // `URL.prototype.host` accessors pair
    // https://url.spec.whatwg.org/#dom-url-host
    host: accessorDescriptor('getHost', 'setHost'),
    // `URL.prototype.hostname` accessors pair
    // https://url.spec.whatwg.org/#dom-url-hostname
    hostname: accessorDescriptor('getHostname', 'setHostname'),
    // `URL.prototype.port` accessors pair
    // https://url.spec.whatwg.org/#dom-url-port
    port: accessorDescriptor('getPort', 'setPort'),
    // `URL.prototype.pathname` accessors pair
    // https://url.spec.whatwg.org/#dom-url-pathname
    pathname: accessorDescriptor('getPathname', 'setPathname'),
    // `URL.prototype.search` accessors pair
    // https://url.spec.whatwg.org/#dom-url-search
    search: accessorDescriptor('getSearch', 'setSearch'),
    // `URL.prototype.searchParams` getter
    // https://url.spec.whatwg.org/#dom-url-searchparams
    searchParams: accessorDescriptor('getSearchParams'),
    // `URL.prototype.hash` accessors pair
    // https://url.spec.whatwg.org/#dom-url-hash
    hash: accessorDescriptor('getHash', 'setHash')
});
// `URL.prototype.toJSON` method
// https://url.spec.whatwg.org/#dom-url-tojson
redefine(URLPrototype, 'toJSON', function toJSON() {
    return getInternalURLState(this).serialize();
}, {
    enumerable: true
});
// `URL.prototype.toString` method
// https://url.spec.whatwg.org/#URL-stringification-behavior
redefine(URLPrototype, 'toString', function toString() {
    return getInternalURLState(this).serialize();
}, {
    enumerable: true
});
if (NativeURL) {
    var nativeCreateObjectURL = NativeURL.createObjectURL;
    var nativeRevokeObjectURL = NativeURL.revokeObjectURL;
    // `URL.createObjectURL` method
    // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
    if (nativeCreateObjectURL) redefine(URLConstructor, 'createObjectURL', bind(nativeCreateObjectURL, NativeURL));
    // `URL.revokeObjectURL` method
    // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL
    if (nativeRevokeObjectURL) redefine(URLConstructor, 'revokeObjectURL', bind(nativeRevokeObjectURL, NativeURL));
}
setToStringTag(URLConstructor, 'URL');
$({
    global: true,
    forced: !USE_NATIVE_URL,
    sham: !DESCRIPTORS
}, {
    URL: URLConstructor
});

},{"../modules/es.string.iterator":"b0sE2","../internals/export":"8yfGv","../internals/descriptors":"6ZLib","../internals/native-url":"amPCD","../internals/global":"jxPDA","../internals/function-bind-context":"kZubc","../internals/function-uncurry-this":"jJnXC","../internals/object-define-properties":"8PPlc","../internals/redefine":"kxbj8","../internals/an-instance":"2zeQg","../internals/has-own-property":"3ZdUC","../internals/object-assign":"aXKvb","../internals/array-from":"feEcT","../internals/array-slice-simple":"bYLId","../internals/string-multibyte":"a9S4J","../internals/string-punycode-to-ascii":"2PCiG","../internals/to-string":"4cTlm","../internals/set-to-string-tag":"9arwS","../modules/web.url-search-params":"gLlKq","../internals/internal-state":"i6AaM"}],"amPCD":[function(require,module,exports) {
var fails = require('../internals/fails');
var wellKnownSymbol = require('../internals/well-known-symbol');
var IS_PURE = require('../internals/is-pure');
var ITERATOR = wellKnownSymbol('iterator');
module.exports = !fails(function() {
    // eslint-disable-next-line unicorn/relative-url-style -- required for testing
    var url = new URL('b?a=1&b=2&c=3', 'http://a');
    var searchParams = url.searchParams;
    var result = '';
    url.pathname = 'c%20d';
    searchParams.forEach(function(value, key) {
        searchParams['delete']('b');
        result += key + value;
    });
    return IS_PURE && !url.toJSON || !searchParams.sort || url.href !== 'http://a/c%20d?a=1&c=3' || searchParams.get('c') !== '3' || String(new URLSearchParams('?a=1')) !== 'a=1' || !searchParams[ITERATOR] || new URL('https://a@b').username !== 'a' || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b' || new URL('http://тест').host !== 'xn--e1aybc' || new URL('http://a#б').hash !== '#%D0%B1' || result !== 'a1c3' || new URL('http://x', undefined).host !== 'x';
});

},{"../internals/fails":"8IfZQ","../internals/well-known-symbol":"5C8sm","../internals/is-pure":"6Bbq0"}],"2PCiG":[function(require,module,exports) {
'use strict';
// based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js
var global = require('../internals/global');
var uncurryThis = require('../internals/function-uncurry-this');
var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = '-'; // '\x2D'
var regexNonASCII = /[^\0-\u007E]/; // non-ASCII chars
var regexSeparators = /[.\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
var OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';
var baseMinusTMin = base - tMin;
var RangeError = global.RangeError;
var exec = uncurryThis(regexSeparators.exec);
var floor = Math.floor;
var fromCharCode = String.fromCharCode;
var charCodeAt = uncurryThis(''.charCodeAt);
var join = uncurryThis([].join);
var push = uncurryThis([].push);
var replace = uncurryThis(''.replace);
var split = uncurryThis(''.split);
var toLowerCase = uncurryThis(''.toLowerCase);
/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 */ var ucs2decode = function(string) {
    var output = [];
    var counter = 0;
    var length = string.length;
    while(counter < length){
        var value = charCodeAt(string, counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
            // It's a high surrogate, and there is a next character.
            var extra = charCodeAt(string, counter++);
            if ((extra & 64512) == 56320) push(output, ((value & 1023) << 10) + (extra & 1023) + 65536);
            else {
                // It's an unmatched surrogate; only append this code unit, in case the
                // next code unit is the high surrogate of a surrogate pair.
                push(output, value);
                counter--;
            }
        } else push(output, value);
    }
    return output;
};
/**
 * Converts a digit/integer into a basic code point.
 */ var digitToBasic = function(digit) {
    //  0..25 map to ASCII a..z or A..Z
    // 26..35 map to ASCII 0..9
    return digit + 22 + 75 * (digit < 26);
};
/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 */ var adapt = function(delta, numPoints, firstTime) {
    var k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);
    while(delta > baseMinusTMin * tMax >> 1){
        delta = floor(delta / baseMinusTMin);
        k += base;
    }
    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};
/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 */ var encode = function(input) {
    var output = [];
    // Convert the input in UCS-2 to an array of Unicode code points.
    input = ucs2decode(input);
    // Cache the length.
    var inputLength = input.length;
    // Initialize the state.
    var n = initialN;
    var delta = 0;
    var bias = initialBias;
    var i, currentValue;
    // Handle the basic code points.
    for(i = 0; i < input.length; i++){
        currentValue = input[i];
        if (currentValue < 128) push(output, fromCharCode(currentValue));
    }
    var basicLength = output.length; // number of basic code points.
    var handledCPCount = basicLength; // number of code points that have been handled;
    // Finish the basic string with a delimiter unless it's empty.
    if (basicLength) push(output, delimiter);
    // Main encoding loop:
    while(handledCPCount < inputLength){
        // All non-basic code points < n have been handled already. Find the next larger one:
        var m = maxInt;
        for(i = 0; i < input.length; i++){
            currentValue = input[i];
            if (currentValue >= n && currentValue < m) m = currentValue;
        }
        // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.
        var handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) throw RangeError(OVERFLOW_ERROR);
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        for(i = 0; i < input.length; i++){
            currentValue = input[i];
            if (currentValue < n && ++delta > maxInt) throw RangeError(OVERFLOW_ERROR);
            if (currentValue == n) {
                // Represent delta as a generalized variable-length integer.
                var q = delta;
                var k = base;
                while(true){
                    var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                    if (q < t) break;
                    var qMinusT = q - t;
                    var baseMinusT = base - t;
                    push(output, fromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
                    q = floor(qMinusT / baseMinusT);
                    k += base;
                }
                push(output, fromCharCode(digitToBasic(q)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                handledCPCount++;
            }
        }
        delta++;
        n++;
    }
    return join(output, '');
};
module.exports = function(input) {
    var encoded = [];
    var labels = split(replace(toLowerCase(input), regexSeparators, '\u002E'), '.');
    var i, label;
    for(i = 0; i < labels.length; i++){
        label = labels[i];
        push(encoded, exec(regexNonASCII, label) ? 'xn--' + encode(label) : label);
    }
    return join(encoded, '.');
};

},{"../internals/global":"jxPDA","../internals/function-uncurry-this":"jJnXC"}],"gLlKq":[function(require,module,exports) {
'use strict';
// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
require('../modules/es.array.iterator');
var $ = require('../internals/export');
var global = require('../internals/global');
var getBuiltIn = require('../internals/get-built-in');
var call = require('../internals/function-call');
var uncurryThis = require('../internals/function-uncurry-this');
var USE_NATIVE_URL = require('../internals/native-url');
var redefine = require('../internals/redefine');
var redefineAll = require('../internals/redefine-all');
var setToStringTag = require('../internals/set-to-string-tag');
var createIteratorConstructor = require('../internals/create-iterator-constructor');
var InternalStateModule = require('../internals/internal-state');
var anInstance = require('../internals/an-instance');
var isCallable = require('../internals/is-callable');
var hasOwn = require('../internals/has-own-property');
var bind = require('../internals/function-bind-context');
var classof = require('../internals/classof');
var anObject = require('../internals/an-object');
var isObject = require('../internals/is-object');
var $toString = require('../internals/to-string');
var create = require('../internals/object-create');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var getIterator = require('../internals/get-iterator');
var getIteratorMethod = require('../internals/get-iterator-method');
var validateArgumentsLength = require('../internals/validate-arguments-length');
var wellKnownSymbol = require('../internals/well-known-symbol');
var arraySort = require('../internals/array-sort');
var ITERATOR = wellKnownSymbol('iterator');
var URL_SEARCH_PARAMS = 'URLSearchParams';
var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
var setInternalState = InternalStateModule.set;
var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);
var n$Fetch = getBuiltIn('fetch');
var N$Request = getBuiltIn('Request');
var Headers = getBuiltIn('Headers');
var RequestPrototype = N$Request && N$Request.prototype;
var HeadersPrototype = Headers && Headers.prototype;
var RegExp = global.RegExp;
var TypeError = global.TypeError;
var decodeURIComponent = global.decodeURIComponent;
var encodeURIComponent = global.encodeURIComponent;
var charAt = uncurryThis(''.charAt);
var join = uncurryThis([].join);
var push = uncurryThis([].push);
var replace = uncurryThis(''.replace);
var shift = uncurryThis([].shift);
var splice = uncurryThis([].splice);
var split = uncurryThis(''.split);
var stringSlice = uncurryThis(''.slice);
var plus = /\+/g;
var sequences = Array(4);
var percentSequence = function(bytes) {
    return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp('((?:%[\\da-f]{2}){' + bytes + '})', 'gi'));
};
var percentDecode = function(sequence) {
    try {
        return decodeURIComponent(sequence);
    } catch (error) {
        return sequence;
    }
};
var deserialize = function(it) {
    var result = replace(it, plus, ' ');
    var bytes = 4;
    try {
        return decodeURIComponent(result);
    } catch (error) {
        while(bytes)result = replace(result, percentSequence(bytes--), percentDecode);
        return result;
    }
};
var find = /[!'()~]|%20/g;
var replacements = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+'
};
var replacer = function(match) {
    return replacements[match];
};
var serialize = function(it) {
    return replace(encodeURIComponent(it), find, replacer);
};
var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
    setInternalState(this, {
        type: URL_SEARCH_PARAMS_ITERATOR,
        iterator: getIterator(getInternalParamsState(params).entries),
        kind: kind
    });
}, 'Iterator', function next() {
    var state = getInternalIteratorState(this);
    var kind = state.kind;
    var step = state.iterator.next();
    var entry = step.value;
    if (!step.done) step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [
        entry.key,
        entry.value
    ];
    return step;
}, true);
var URLSearchParamsState = function(init) {
    this.entries = [];
    this.url = null;
    if (init !== undefined) {
        if (isObject(init)) this.parseObject(init);
        else this.parseQuery(typeof init == 'string' ? charAt(init, 0) === '?' ? stringSlice(init, 1) : init : $toString(init));
    }
};
URLSearchParamsState.prototype = {
    type: URL_SEARCH_PARAMS,
    bindURL: function(url) {
        this.url = url;
        this.update();
    },
    parseObject: function(object) {
        var iteratorMethod = getIteratorMethod(object);
        var iterator, next, step, entryIterator, entryNext, first, second;
        if (iteratorMethod) {
            iterator = getIterator(object, iteratorMethod);
            next = iterator.next;
            while(!(step = call(next, iterator)).done){
                entryIterator = getIterator(anObject(step.value));
                entryNext = entryIterator.next;
                if ((first = call(entryNext, entryIterator)).done || (second = call(entryNext, entryIterator)).done || !call(entryNext, entryIterator).done) throw TypeError('Expected sequence with length 2');
                push(this.entries, {
                    key: $toString(first.value),
                    value: $toString(second.value)
                });
            }
        } else for(var key in object)if (hasOwn(object, key)) push(this.entries, {
            key: key,
            value: $toString(object[key])
        });
    },
    parseQuery: function(query) {
        if (query) {
            var attributes = split(query, '&');
            var index = 0;
            var attribute, entry;
            while(index < attributes.length){
                attribute = attributes[index++];
                if (attribute.length) {
                    entry = split(attribute, '=');
                    push(this.entries, {
                        key: deserialize(shift(entry)),
                        value: deserialize(join(entry, '='))
                    });
                }
            }
        }
    },
    serialize: function() {
        var entries = this.entries;
        var result = [];
        var index = 0;
        var entry;
        while(index < entries.length){
            entry = entries[index++];
            push(result, serialize(entry.key) + '=' + serialize(entry.value));
        }
        return join(result, '&');
    },
    update: function() {
        this.entries.length = 0;
        this.parseQuery(this.url.query);
    },
    updateURL: function() {
        if (this.url) this.url.update();
    }
};
// `URLSearchParams` constructor
// https://url.spec.whatwg.org/#interface-urlsearchparams
var URLSearchParamsConstructor = function URLSearchParams() {
    anInstance(this, URLSearchParamsPrototype);
    var init = arguments.length > 0 ? arguments[0] : undefined;
    setInternalState(this, new URLSearchParamsState(init));
};
var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;
redefineAll(URLSearchParamsPrototype, {
    // `URLSearchParams.prototype.append` method
    // https://url.spec.whatwg.org/#dom-urlsearchparams-append
    append: function append(name, value) {
        validateArgumentsLength(arguments.length, 2);
        var state = getInternalParamsState(this);
        push(state.entries, {
            key: $toString(name),
            value: $toString(value)
        });
        state.updateURL();
    },
    // `URLSearchParams.prototype.delete` method
    // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
    'delete': function(name) {
        validateArgumentsLength(arguments.length, 1);
        var state = getInternalParamsState(this);
        var entries = state.entries;
        var key = $toString(name);
        var index = 0;
        while(index < entries.length)if (entries[index].key === key) splice(entries, index, 1);
        else index++;
        state.updateURL();
    },
    // `URLSearchParams.prototype.get` method
    // https://url.spec.whatwg.org/#dom-urlsearchparams-get
    get: function get(name) {
        validateArgumentsLength(arguments.length, 1);
        var entries = getInternalParamsState(this).entries;
        var key = $toString(name);
        var index = 0;
        for(; index < entries.length; index++){
            if (entries[index].key === key) return entries[index].value;
        }
        return null;
    },
    // `URLSearchParams.prototype.getAll` method
    // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
    getAll: function getAll(name) {
        validateArgumentsLength(arguments.length, 1);
        var entries = getInternalParamsState(this).entries;
        var key = $toString(name);
        var result = [];
        var index = 0;
        for(; index < entries.length; index++)if (entries[index].key === key) push(result, entries[index].value);
        return result;
    },
    // `URLSearchParams.prototype.has` method
    // https://url.spec.whatwg.org/#dom-urlsearchparams-has
    has: function has(name) {
        validateArgumentsLength(arguments.length, 1);
        var entries = getInternalParamsState(this).entries;
        var key = $toString(name);
        var index = 0;
        while(index < entries.length){
            if (entries[index++].key === key) return true;
        }
        return false;
    },
    // `URLSearchParams.prototype.set` method
    // https://url.spec.whatwg.org/#dom-urlsearchparams-set
    set: function set(name, value) {
        validateArgumentsLength(arguments.length, 1);
        var state = getInternalParamsState(this);
        var entries = state.entries;
        var found = false;
        var key = $toString(name);
        var val = $toString(value);
        var index = 0;
        var entry;
        for(; index < entries.length; index++){
            entry = entries[index];
            if (entry.key === key) {
                if (found) splice(entries, index--, 1);
                else {
                    found = true;
                    entry.value = val;
                }
            }
        }
        if (!found) push(entries, {
            key: key,
            value: val
        });
        state.updateURL();
    },
    // `URLSearchParams.prototype.sort` method
    // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
    sort: function sort() {
        var state = getInternalParamsState(this);
        arraySort(state.entries, function(a, b) {
            return a.key > b.key ? 1 : -1;
        });
        state.updateURL();
    },
    // `URLSearchParams.prototype.forEach` method
    forEach: function forEach(callback /* , thisArg */ ) {
        var entries = getInternalParamsState(this).entries;
        var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : undefined);
        var index = 0;
        var entry;
        while(index < entries.length){
            entry = entries[index++];
            boundFunction(entry.value, entry.key, this);
        }
    },
    // `URLSearchParams.prototype.keys` method
    keys: function keys() {
        return new URLSearchParamsIterator(this, 'keys');
    },
    // `URLSearchParams.prototype.values` method
    values: function values() {
        return new URLSearchParamsIterator(this, 'values');
    },
    // `URLSearchParams.prototype.entries` method
    entries: function entries() {
        return new URLSearchParamsIterator(this, 'entries');
    }
}, {
    enumerable: true
});
// `URLSearchParams.prototype[@@iterator]` method
redefine(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries, {
    name: 'entries'
});
// `URLSearchParams.prototype.toString` method
// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior
redefine(URLSearchParamsPrototype, 'toString', function toString() {
    return getInternalParamsState(this).serialize();
}, {
    enumerable: true
});
setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);
$({
    global: true,
    forced: !USE_NATIVE_URL
}, {
    URLSearchParams: URLSearchParamsConstructor
});
// Wrap `fetch` and `Request` for correct work with polyfilled `URLSearchParams`
if (!USE_NATIVE_URL && isCallable(Headers)) {
    var headersHas = uncurryThis(HeadersPrototype.has);
    var headersSet = uncurryThis(HeadersPrototype.set);
    var wrapRequestOptions = function(init) {
        if (isObject(init)) {
            var body = init.body;
            var headers;
            if (classof(body) === URL_SEARCH_PARAMS) {
                headers = init.headers ? new Headers(init.headers) : new Headers();
                if (!headersHas(headers, 'content-type')) headersSet(headers, 'content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
                return create(init, {
                    body: createPropertyDescriptor(0, $toString(body)),
                    headers: createPropertyDescriptor(0, headers)
                });
            }
        }
        return init;
    };
    if (isCallable(n$Fetch)) $({
        global: true,
        enumerable: true,
        forced: true
    }, {
        fetch: function fetch(input /* , init */ ) {
            return n$Fetch(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {
            });
        }
    });
    if (isCallable(N$Request)) {
        var RequestConstructor = function Request(input /* , init */ ) {
            anInstance(this, RequestPrototype);
            return new N$Request(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {
            });
        };
        RequestPrototype.constructor = RequestConstructor;
        RequestConstructor.prototype = RequestPrototype;
        $({
            global: true,
            forced: true
        }, {
            Request: RequestConstructor
        });
    }
}
module.exports = {
    URLSearchParams: URLSearchParamsConstructor,
    getState: getInternalParamsState
};

},{"../modules/es.array.iterator":"bLuDU","../internals/export":"8yfGv","../internals/global":"jxPDA","../internals/get-built-in":"78arb","../internals/function-call":"jhLed","../internals/function-uncurry-this":"jJnXC","../internals/native-url":"amPCD","../internals/redefine":"kxbj8","../internals/redefine-all":"ch5Rt","../internals/set-to-string-tag":"9arwS","../internals/create-iterator-constructor":"1fB00","../internals/internal-state":"i6AaM","../internals/an-instance":"2zeQg","../internals/is-callable":"kPhuP","../internals/has-own-property":"3ZdUC","../internals/function-bind-context":"kZubc","../internals/classof":"kJ8JQ","../internals/an-object":"1LIz9","../internals/is-object":"dplrD","../internals/to-string":"4cTlm","../internals/object-create":"1As5O","../internals/create-property-descriptor":"ermgb","../internals/get-iterator":"dQrLE","../internals/get-iterator-method":"5CTSY","../internals/validate-arguments-length":"gKrE5","../internals/well-known-symbol":"5C8sm","../internals/array-sort":"ik2R5"}],"gk5Ay":[function(require,module,exports) {
'use strict';
var $ = require('../internals/export');
var call = require('../internals/function-call');
// `URL.prototype.toJSON` method
// https://url.spec.whatwg.org/#dom-url-tojson
$({
    target: 'URL',
    proto: true,
    enumerable: true
}, {
    toJSON: function toJSON() {
        return call(URL.prototype.toString, this);
    }
});

},{"../internals/export":"8yfGv","../internals/function-call":"jhLed"}],"bpUQH":[function(require,module,exports) {
!function() {
    function t1() {
        var e1 = Array.prototype.slice.call(arguments), n = document.createDocumentFragment();
        e1.forEach(function(e) {
            var t = e instanceof Node;
            n.appendChild(t ? e : document.createTextNode(String(e)));
        }), this.appendChild(n);
    }
    [
        Element.prototype,
        Document.prototype,
        DocumentFragment.prototype
    ].forEach(function(e) {
        e.hasOwnProperty("append") || Object.defineProperty(e, "append", {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            value: t1
        });
    });
}();

},{}],"e3nbn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BB", ()=>BB
);
var _eventListener = require("./input/event-listener");
var _base = require("./base/base");
var _browser = require("./base/browser");
var _keyListener = require("./input/key-listener");
var _pointerListener = require("./input/pointer-listener");
var _eventChain = require("./input/event-chain");
var _canvas = require("./base/canvas");
var _matrix = require("./math/matrix");
var _vec2 = require("./math/vec2");
var _line = require("./math/line");
var _color = require("./color/color");
var _ui = require("./base/ui");
var _math = require("./math/math");
var _createCanvas = require("./base/create-canvas");
var _bbLog = require("./base/bb-log");
var _localStorage = require("./base/local-storage");
const BB = {
    eventUsesHighResTimeStamp: // ---- browser ----
    _browser.eventUsesHighResTimeStamp,
    mouseEventHasMovement: _browser.mouseEventHasMovement,
    hasPointerEvents: _browser.hasPointerEvents,
    hasWebGl: _browser.hasWebGl,
    getVisitor: _browser.getVisitor,
    isCssMinMaxSupported: _browser.isCssMinMaxSupported,
    canShareFiles: _browser.canShareFiles,
    insertAfter: // ---- base ----
    _base.insertAfter,
    loadImage: _base.loadImage,
    css: _base.css,
    setAttributes: _base.setAttributes,
    addClassName: _base.addClassName,
    removeClassName: _base.removeClassName,
    append: _base.append,
    fitInto: _base.fitInto,
    centerWithin: _base.centerWithin,
    getDate: _base.getDate,
    gcd: _base.gcd,
    reduce: _base.reduce,
    decToFraction: _base.decToFraction,
    imageBlobToUrl: _base.imageBlobToUrl,
    dateDayDifference: _base.dateDayDifference,
    copyObj: _base.copyObj,
    shareCanvas: _base.shareCanvas,
    handleClick: _base.handleClick,
    createSvg: _base.createSvg,
    BbLog: _bbLog.BbLog,
    LocalStorage: _localStorage.LocalStorage,
    mix: // ---- math ----
    _math.mix,
    dist: _math.dist,
    distSquared: _math.distSquared,
    lenSquared: _math.lenSquared,
    pointsToAngleRad: _math.pointsToAngleRad,
    pointsToAngleDeg: _math.pointsToAngleDeg,
    clamp: _math.clamp,
    rotate: _math.rotate,
    rotateAround: _math.rotateAround,
    Matrix: _matrix.Matrix,
    Vec2: _vec2.Vec2,
    intDxy: _math.intDxy,
    roundEven: _math.roundEven,
    roundUneven: _math.roundUneven,
    updateBounds: _math.updateBounds,
    boundsInArea: _math.boundsInArea,
    projectPointOnLine: // ---- line ----
    _line.projectPointOnLine,
    PointLine: _line.PointLine,
    BezierLine: _line.BezierLine,
    SplineInterpolator: _line.SplineInterpolator,
    quadraticSplineInput: _line.quadraticSplineInput,
    // ---- canvas ----
    canvas: _createCanvas.createCanvas,
    copyCanvas: _canvas.copyCanvas,
    testShouldPixelate: _canvas.testShouldPixelate,
    drawTransformedImageWithBounds: _canvas.drawTransformedImageWithBounds,
    drawTransformedImageOnCanvas: _canvas.drawTransformedImageOnCanvas,
    createCheckerCanvas: _canvas.createCheckerCanvas,
    createCheckerDataUrl: _canvas.createCheckerDataUrl,
    resizeCanvas: _canvas.resizeCanvas,
    convertToAlphaChannelCanvas: _canvas.convertToAlphaChannelCanvas,
    HSV: // ---- color ----
    _color.HSV,
    RGB: _color.RGB,
    CMYK: _color.CMYK,
    ColorConverter: _color.ColorConverter,
    testIsWhiteBestContrast: _color.testIsWhiteBestContrast,
    appendTextDiv: // ---- UI ----
    _ui.appendTextDiv,
    clearSelection: _ui.clearSelection,
    makeUnfocusable: _ui.makeUnfocusable,
    el: _ui.el,
    destroyEl: _ui.destroyEl,
    isInputFocused: _ui.isInputFocused,
    // ---- events / input ----
    addEventListener: _eventListener.addEventListener,
    removeEventListener: _eventListener.removeEventListener,
    setEventListener: _eventListener.setEventListener,
    KeyListener: _keyListener.KeyListener,
    PointerListener: _pointerListener.PointerListener,
    sameKeys: _keyListener.sameKeys,
    EventChain: _eventChain
};

},{"./input/event-listener":"9MYB6","./base/base":"5EeOC","./base/browser":"gLGO4","./input/key-listener":"iyGjq","./input/pointer-listener":"04b7Q","./input/event-chain":"eAbTm","./base/canvas":"10kvU","./math/matrix":"ikOLk","./math/vec2":"8AWT9","./math/line":"azjNA","./color/color":"8BDeD","./base/ui":"RH5Pp","./math/math":"bwQIx","./base/create-canvas":"lUl5x","./base/bb-log":"5OFfM","./base/local-storage":"iOEIY","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9MYB6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setEventListener", ()=>setEventListener
);
parcelHelpers.export(exports, "addEventListener", ()=>addEventListener
);
parcelHelpers.export(exports, "removeEventListener", ()=>removeEventListener
);
var _browser = require("../base/browser");
const listenerFuncObj = {
};
const setEventListener = function(DomEl, type, listener) {
    if (!_browser.hasPointerEvents) type = type.replace('pointer', 'mouse');
    DomEl[type] = listener;
};
const addEventListener = function(DomEl, type, listener, options) {
    if (!_browser.hasPointerEvents) type = type.replace('pointer', 'mouse');
    if (!(type in listenerFuncObj)) listenerFuncObj[type] = [];
    listenerFuncObj[type].push(listener);
    DomEl.addEventListener(type, listener, options);
};
const removeEventListener = function(DomEl, type, listener, options) {
    if (!_browser.hasPointerEvents) type = type.replace('pointer', 'mouse');
    if (type in listenerFuncObj) {
        for(let i = 0; i < listenerFuncObj[type].length; i++)if (listenerFuncObj[type][i] === listener) {
            listenerFuncObj[type].splice(i, 1);
            i--;
        }
    }
    DomEl.removeEventListener(type, listener, options);
};

},{"../base/browser":"gLGO4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gLGO4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isFirefox", ()=>isFirefox
);
parcelHelpers.export(exports, "eventUsesHighResTimeStamp", ()=>eventUsesHighResTimeStamp
);
parcelHelpers.export(exports, "mouseEventHasMovement", ()=>mouseEventHasMovement
);
parcelHelpers.export(exports, "hasPointerEvents", ()=>hasPointerEvents
);
parcelHelpers.export(exports, "hasWebGl", ()=>hasWebGl
);
parcelHelpers.export(exports, "getVisitor", ()=>getVisitor
);
parcelHelpers.export(exports, "isCssMinMaxSupported", ()=>isCssMinMaxSupported
);
parcelHelpers.export(exports, "canShareFiles", ()=>canShareFiles
);
var _createCanvas = require("./create-canvas");
const isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
const eventUsesHighResTimeStamp = function() {
    let eventUsesHighResTimeStamp1 = null;
    if (document.body) (function() {
        const event = new Event('');
        eventUsesHighResTimeStamp1 = event.timeStamp < 3600000;
    })();
    else window.addEventListener('DOMContentLoaded', function(event) {
        eventUsesHighResTimeStamp1 = event.timeStamp < 3600000;
    });
    return function() {
        if (eventUsesHighResTimeStamp1 === null) throw 'eventUsesHighResTimeStamp not initialized';
        return eventUsesHighResTimeStamp1;
    };
}();
const mouseEventHasMovement = (()=>{
    // no support: IE, Safari, Safari iOS
    // supported but broken: Firefox
    if (!('MouseEvent' in window)) return false;
    let mouseEvent;
    try {
        mouseEvent = new MouseEvent('mousemove'); // browsers not supporting the constructor don't have it
    } catch (e) {
        return false;
    }
    if (!('movementX' in mouseEvent)) return false; // likely safari
    return !isFirefox;
})();
const hasPointerEvents = !!window.PointerEvent;
const hasWebGl = function() {
    const hasWebgl = function() {
        const canvas = _createCanvas.createCanvas();
        try {
            canvas.getContext('experimental-webgl', {
                premultipliedAlpha: false
            });
            return true;
        } catch (e) {
            return false;
        }
    }();
    return function() {
        return hasWebgl;
    };
}();
const getVisitor = function() {
    const visitor = {
        chrome: false,
        gl: false
    };
    //Chrome
    if (window.chrome && window.chrome.app) visitor.chrome = true;
    //WebGL
    visitor.gl = hasWebGl();
    return function() {
        return JSON.parse(JSON.stringify(visitor));
    };
}();
const isCssMinMaxSupported = function() {
    let result = null;
    function test() {
        const div = document.createElement('div');
        div.style.position = 'absolute';
        div.style.top = '0';
        div.style.left = 'max(0px, 25px)';
        document.body.appendChild(div);
        setTimeout(function() {
            result = div.offsetLeft === 25;
            document.body.removeChild(div);
        }, 25);
    }
    if (document.body) test();
    else window.addEventListener('DOMContentLoaded', function() {
        test();
    });
    return function() {
        if (result === null) throw new Error('isCssMinMaxSupported not initialized');
        return result;
    };
}();
const canShareFiles = function() {
    return 'share' in navigator && 'canShare' in navigator;
};

},{"./create-canvas":"lUl5x","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"lUl5x":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createCanvas", ()=>createCanvas
);
function createCanvas(w, h) {
    const result = document.createElement('canvas');
    if (w && h) {
        result.width = w;
        result.height = h;
    }
    return result;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ciiiV":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"5EeOC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "insertAfter", ()=>insertAfter
);
parcelHelpers.export(exports, "loadImage", ()=>loadImage
);
parcelHelpers.export(exports, "css", ()=>css
);
parcelHelpers.export(exports, "setAttributes", ()=>setAttributes
);
parcelHelpers.export(exports, "addClassName", ()=>addClassName
);
parcelHelpers.export(exports, "removeClassName", ()=>removeClassName
);
/**
 * appendChild with an array
 * @param target
 * @param els
 */ parcelHelpers.export(exports, "append", ()=>append
);
/**
 * a needs to fit into b
 * @param aw
 * @param ah
 * @param bw
 * @param bh
 * @param min
 */ parcelHelpers.export(exports, "fitInto", ()=>fitInto
);
/**
 * center b in a
 * @param aw
 * @param ah
 * @param bw
 * @param bh
 */ parcelHelpers.export(exports, "centerWithin", ()=>centerWithin
);
parcelHelpers.export(exports, "getDate", ()=>getDate
);
parcelHelpers.export(exports, "gcd", ()=>gcd
);
parcelHelpers.export(exports, "reduce", ()=>reduce
);
parcelHelpers.export(exports, "decToFraction", ()=>decToFraction
);
/**
 * blobObj isn't always a Blob, but rather an object, because Blob doesn't exist.
 * @param blobObj
 * @returns {string}
 */ parcelHelpers.export(exports, "imageBlobToUrl", ()=>imageBlobToUrl
);
parcelHelpers.export(exports, "dateDayDifference", ()=>dateDayDifference
);
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
parcelHelpers.export(exports, "copyObj", ()=>copyObj
);
/**
 * triggers Web Share API - share feature on mobile devices
 * Only works if they support file sharing - e.g. Safari can't do this yet
 * only call if BB.canShareFiles() -> true
 *
 * p = {
 *     canvas: Canvas,
 *     fileName: string,
 *     title: string
 * }
 *
 * @param p
 */ parcelHelpers.export(exports, "shareCanvas", ()=>shareCanvas
);
/**
 * Prevent ipad from zooming in when double tapping. iPadOS 13 bug.
 * Give it your click event
 *
 * @param clickEvent
 * @returns {boolean}
 */ parcelHelpers.export(exports, "handleClick", ()=>handleClick
);
/**
 * @param el {elementType: string, childrenArr: []el, ...svg attributes...}
 * @returns svg element tree
 */ parcelHelpers.export(exports, "createSvg", ()=>createSvg
);
function insertAfter(referenceNode, newNode) {
    if (referenceNode.parentNode) referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
}
function loadImage(im, callback) {
    let counter = 0;
    function check() {
        if (counter === 1000) {
            alert("couldn't load");
            return;
        }
        if (im.complete) {
            counter++;
            callback();
        } else setTimeout(check, 1);
    }
    check();
}
function css(el, styleObj) {
    const keyArr = Object.keys(styleObj);
    let keyStr;
    const style = el.style;
    for(let i = 0; i < keyArr.length; i++){
        keyStr = keyArr[i];
        style[keyStr] = styleObj[keyStr];
        style.alignContent = 'true';
        if (keyStr === 'userSelect') style.webkitUserSelect = styleObj[keyStr]; // safari
    }
}
function setAttributes(el, attrObj) {
    const keyArr = Object.keys(attrObj);
    let keyStr;
    for(let i = 0; i < keyArr.length; i++){
        keyStr = keyArr[i];
        el.setAttribute(keyStr, attrObj[keyStr]);
    }
}
function addClassName(el, classStr) {
    const classAttr = el.getAttribute('class');
    const splitArr = classAttr === null ? [] : classAttr.split(' ');
    if (splitArr.includes(classStr)) return;
    splitArr.push(classStr);
    el.setAttribute('class', splitArr.join(' '));
}
function removeClassName(el, classStr) {
    const classAttr = el.getAttribute('class');
    const splitArr = classAttr === null ? [] : classAttr.split(' ');
    if (!splitArr.includes(classStr)) return;
    for(let i = 0; i < splitArr.length; i++)if (splitArr[i] === classStr) {
        splitArr.splice(i, 1);
        i--;
    }
    el.setAttribute('class', splitArr.join(' '));
}
function append(target, els) {
    const fragment = document.createDocumentFragment();
    els.forEach((item)=>item ? fragment.append(item) : null
    );
    target.append(fragment);
}
function fitInto(aw, ah, bw, bh, min) {
    let width = aw * bw, height = ah * bw;
    if (width > bw) {
        height = bw / width * height;
        width = bw;
    }
    if (height > bh) {
        width = bh / height * width;
        height = bh;
    }
    if (min) {
        width = Math.max(min, width);
        height = Math.max(min, height);
    }
    return {
        width,
        height
    };
}
function centerWithin(aw, ah, bw, bh) {
    return {
        x: aw / 2 - bw / 2,
        y: ah / 2 - bh / 2
    };
}
function getDate() {
    const date = new Date();
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const day = date.getDate().toString().padStart(2, '0');
    const minutes = (date.getHours() * 60 + date.getMinutes()).toString(36).padStart(3, '0');
    return year + '_' + month + '_' + day + '_' + minutes + '_';
}
function gcd(a, b) {
    return b ? gcd(b, a % b) : a;
}
function reduce(numerator, denominator) {
    const g = gcd(numerator, denominator);
    return [
        numerator / g,
        denominator / g
    ];
}
function decToFraction(decimalNumber) {
    const len = decimalNumber.toString().length - 2;
    const denominator = Math.pow(10, len);
    const numerator = decimalNumber * denominator;
    return reduce(numerator, denominator);
}
function imageBlobToUrl(blobObj) {
    if (!blobObj) throw new Error('blobObj is undefined or null');
    if (window.Blob && blobObj instanceof Blob) return URL.createObjectURL(blobObj); // object url
    else if (blobObj.constructor.name === 'Object') {
        const fauxBlob = blobObj;
        return 'data:' + fauxBlob.type + ';' + fauxBlob.encoding + ',' + fauxBlob.data; // data url
    } else throw new Error('unknown blob format');
}
function dateDayDifference(dateA, dateB) {
    dateA = new Date(dateA);
    dateB = new Date(dateB);
    dateA.setHours(0, 0, 0, 0);
    dateB.setHours(0, 0, 0, 0);
    return (dateB.getTime() - dateA.getTime()) / 86400000;
}
function copyObj(obj) {
    return JSON.parse(JSON.stringify(obj));
}
function shareCanvas(p) {
    const mimetype = 'image/png';
    const err = ()=>alert('sharing not supported')
    ;
    p.canvas.toBlob(function(blob) {
        if (blob === null) {
            err();
            p.callback();
            return;
        }
        try {
            const filesArray = [
                new File([
                    blob
                ], p.fileName, {
                    type: mimetype
                })
            ];
            navigator.share({
                title: p.title,
                files: filesArray
            }).then((r)=>{
            }).catch((e)=>{
                err();
            });
        } catch (e) {
            err();
        }
        p.callback();
    }, mimetype);
}
function handleClick(clickEvent) {
    const target = clickEvent.target;
    if (!target) return false;
    if ([
        'A',
        'LABEL',
        'INPUT'
    ].includes(target.tagName) || target.allowClick) return true;
    clickEvent.preventDefault();
    return false;
}
function createSvg(el) {
    const result = document.createElementNS('http://www.w3.org/2000/svg', el.elementType);
    const keyArr = Object.keys(el);
    let keyStr;
    for(let i = 0; i < keyArr.length; i++){
        keyStr = keyArr[i];
        if (keyStr === 'childrenArr') for(let e = 0; e < el.childrenArr.length; e++)result.appendChild(createSvg(el.childrenArr[e]));
        else if (keyStr !== 'elementType') result.setAttribute(keyStr, el[keyStr]);
    }
    return result;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"iyGjq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Listens to key events in window. Makes combos easier - e.g. ctrl + z
 *
 * keyStr - see in implementation - my representation of a key. e.g. 'r' can be 'r' and 'R'
 * comboStr - string joins currently pressed keyStr with a +
 *              e.g. 'ctrl+z'
 *
 */ parcelHelpers.export(exports, "KeyListener", ()=>KeyListener
);
parcelHelpers.export(exports, "sameKeys", ()=>sameKeys
);
var _eventListener = require("./event-listener");
const globalKey = (()=>{
    const keyStrToKeyObj = {
        'space': [
            ' ',
            'Spacebar'
        ],
        'alt': [
            'Alt',
            'AltGraph'
        ],
        'shift': 'Shift',
        'ctrl': 'Control',
        'cmd': [
            'Meta',
            'MetaLeft',
            'MetaRight'
        ],
        'enter': 'Enter',
        'esc': 'Escape',
        'backspace': 'Backspace',
        'delete': 'Delete',
        'sqbr_open': '[',
        'sqbr_close': ']',
        'a': [
            'a',
            'A'
        ],
        'b': [
            'b',
            'B'
        ],
        'c': [
            'c',
            'C'
        ],
        'e': [
            'e',
            'E'
        ],
        'f': [
            'f',
            'F'
        ],
        'g': [
            'g',
            'G'
        ],
        'r': [
            'r',
            'R'
        ],
        's': [
            's',
            'S'
        ],
        't': [
            't',
            'T'
        ],
        'u': [
            'u',
            'U'
        ],
        'x': [
            'x',
            'X'
        ],
        'y': [
            'y',
            'Y'
        ],
        'z': [
            'z',
            'Z'
        ],
        'plus': '+',
        'minus': '-',
        'left': 'ArrowLeft',
        'right': 'ArrowRight',
        'up': 'ArrowUp',
        'down': 'ArrowDown',
        'home': 'Home',
        'end': 'End'
    };
    const keyToKeyStrArr = Object.keys(keyStrToKeyObj);
    const isDownObj = {
    };
    const keyToKeyStrObj = {
    }; // event.key to keyStr { ArrowLeft: 'left', ... }
    let comboArr = [];
    //a physical key's "key" can change as other keys get pressed. to keep track, need to also track the code
    let codeIsDownObj = {
    }; // { KeyE: 'e', KeyF: null } - null not down, string, the associated keyStr
    const listenerArr = [];
    for(let i1 = 0; i1 < keyToKeyStrArr.length; i1++){
        isDownObj[keyToKeyStrArr[i1]] = false;
        const code = keyStrToKeyObj[keyToKeyStrArr[i1]];
        if (typeof code === 'string') keyToKeyStrObj[keyStrToKeyObj[keyToKeyStrArr[i1]]] = keyToKeyStrArr[i1];
        else for(let e = 0; e < code.length; e++)keyToKeyStrObj[code[e]] = keyToKeyStrArr[i1];
    }
    function emitDown(a, b, c, d) {
        listenerArr.forEach((item)=>{
            if (!item[0]) return;
            item[0](a, b, c, d);
        });
    }
    function emitUp(a, b, c) {
        listenerArr.forEach((item)=>{
            if (!item[1]) return;
            item[1](a, b, c);
        });
    }
    function emitBlur() {
        listenerArr.forEach((item)=>{
            if (!item[2]) return;
            item[2]();
        });
    }
    function keyDown(e) {
        const key = e.key;
        const code = 'code' in e ? e.code : e.keyCode; // ie doesn't have code
        console.log(code);
        if (key in keyToKeyStrObj) {
            const keyStr = keyToKeyStrObj[key];
            if (isDownObj[keyStr]) {
                emitDown(keyStr, e, comboArr.join('+'), true);
                return;
            }
            isDownObj[keyStr] = true;
            codeIsDownObj[code] = keyStr;
            //add to combo
            comboArr.push(keyStr);
            emitDown(keyStr, e, comboArr.join('+'));
        }
    }
    function keyUp(e) {
        const key = e.key;
        const code = 'code' in e ? e.code : e.keyCode; // ie doesn't have code
        const oldComboStr = comboArr.join('+');
        // because of a macOS bug: when meta key is down, keyup of other keys does not fire.
        // https://stackoverflow.com/questions/25438608/javascript-keyup-isnt-called-when-command-and-another-is-pressed
        if ([
            'Meta',
            'MetaLeft',
            'MetaRight',
            'OSLeft',
            'OSRight'
        ].includes(code)) {
            blur(null);
            return;
        }
        if (code in codeIsDownObj && codeIsDownObj[code] !== null) {
            const keyStr = codeIsDownObj[code];
            isDownObj[keyStr] = false;
            codeIsDownObj[code] = null;
            //remove from combo
            for(let i = 0; i < comboArr.length; i++)if (comboArr[i] == keyStr) {
                comboArr.splice(i, 1);
                i--;
            }
            emitUp(keyStr, e, oldComboStr);
        }
    }
    function blur(event) {
        const oldComboStr = comboArr.join('+');
        comboArr = [];
        codeIsDownObj = {
        };
        const eventArr = [];
        for(let i = 0; i < keyToKeyStrArr.length; i++)if (isDownObj[keyToKeyStrArr[i]]) {
            isDownObj[keyToKeyStrArr[i]] = false;
            eventArr.push(keyToKeyStrArr[i]);
        }
        for(let i2 = 0; i2 < eventArr.length; i2++)emitUp(eventArr[i2], {
            preventDefault: function() {
            },
            stopPropagation: function() {
            }
        }, oldComboStr);
        emitBlur();
    }
    return {
        add: (keyListener)=>{
            if (listenerArr.includes(keyListener)) return;
            const first = listenerArr.length === 0;
            listenerArr.push(keyListener);
            if (first) {
                _eventListener.addEventListener(document, 'keydown', keyDown);
                _eventListener.addEventListener(document, 'keyup', keyUp);
                _eventListener.addEventListener(window, 'blur', blur);
            }
        },
        remove: (keyListener)=>{
            if (!listenerArr.includes(keyListener)) return;
            const last = listenerArr.length === 1;
            for(let i = 0; i < listenerArr.length; i++)if (listenerArr[i] === keyListener) {
                listenerArr.splice(i, 1);
                break;
            }
            if (last) {
                _eventListener.removeEventListener(document, 'keydown', keyDown);
                _eventListener.removeEventListener(document, 'keyup', keyUp);
                _eventListener.removeEventListener(window, 'blur', blur);
            }
        },
        getIsDown: ()=>{
            return isDownObj;
        },
        getCombo: ()=>{
            return comboArr;
        }
    };
})();
class KeyListener {
    constructor(p){
        this.onDown = p.onDown;
        this.onUp = p.onUp;
        this.onBlur = p.onBlur;
        this.ref = [
            this.onDown,
            this.onUp,
            this.onBlur
        ];
        globalKey.add(this.ref);
    }
    isPressed(keyStr) {
        if (!(keyStr in globalKey.getIsDown())) throw 'key "' + keyStr + '" not found';
        return globalKey.getIsDown()[keyStr];
    }
    getComboStr() {
        return globalKey.getCombo().join('+');
    }
    comboOnlyContains(keyStrArr) {
        for(let i = 0; i < globalKey.getCombo().length; i++){
            if (!keyStrArr.includes(globalKey.getCombo()[i])) return false;
        }
        return true;
    }
    destroy() {
        globalKey.remove(this.ref);
    }
}
function sameKeys(comboAStr, comboBStr) {
    return comboAStr.split('+').sort().join('+') === comboBStr.split('+').sort().join('+');
}

},{"./event-listener":"9MYB6","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"04b7Q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PointerListener", ()=>PointerListener
);
var _eventListener = require("./event-listener");
/**
 * Filters wheel events. removes swipe scrolling and pinch scrolling that trackpads do. (as best as it can)
 * Normalizes regular scrolls.
 *
 * Why:
 * - trackpad scrolling is different from old school mouse scrolling
 * - but there is not way to learn from the browser if it's trackpad scrolling
 * - browsers don't even give access to the raw swiping or pinching movement, but some abstraction on top, making the scrolling
 *      continue an arbitrary amount, at an arbitrary scale
 * - each browser does this differently. So you can't offer a coherent experience
 *
 * - also trackpads are painful to draw with. So supporting a trackpad-based workflow makes not much sense.
 *
 * @param callback - func({deltaY: number, pageX: number, pageY: number, clientX: number, clientY: number}
 * @constructor
 */ var _browser = require("../base/browser");
var _math = require("../math/math");
const WheelCleaner = function(callback) {
    const sequenceTimeoutMs = 200;
    const knownUnitArr = [
        100
    ];
    let sequenceLength = 0;
    let sequenceUnit = null;
    let endSequenceTimeout;
    let toEmitDelta = null;
    let position = null;
    function emit(delta) {
        callback({
            deltaY: Math.round(delta / sequenceUnit),
            pageX: position.pageX,
            pageY: position.pageY,
            clientX: position.clientX,
            clientY: position.clientY
        });
    }
    function endSequence() {
        if (toEmitDelta !== null) {
            emit(toEmitDelta);
            toEmitDelta = null;
        }
        if (sequenceUnit !== null && !knownUnitArr.includes(sequenceUnit)) knownUnitArr.push(sequenceUnit);
        sequenceLength = 0;
        sequenceUnit = null;
    }
    // --- interface ---
    this.process = function(event) {
        position = {
            pageX: event.pageX,
            pageY: event.pageY,
            clientX: event.clientX,
            clientY: event.clientY
        };
        clearTimeout(endSequenceTimeout);
        endSequenceTimeout = setTimeout(endSequence, sequenceTimeoutMs);
        //prep delta
        let delta = event.deltaY;
        if ('deltaMode' in event && event.deltaMode === 1) delta *= 100 / 3;
        const absDelta = Math.abs(delta);
        if (sequenceLength > 0 && sequenceUnit === null) {
            //previously determined dirty sequence
            toEmitDelta = null;
            return;
        }
        //sequence begins
        if (sequenceLength === 0) {
            sequenceLength++;
            if (absDelta < 50) //dirty - probably a swipe scroll or pinch scroll on trackpad
            return;
            sequenceUnit = absDelta;
            if (knownUnitArr.includes(sequenceUnit)) //we know this unit - emit right away
            emit(delta);
            else //unknown unit - wait until next event or sequence end, to have more certainty that it's clean
            toEmitDelta = delta;
            return;
        }
        //sequence continues
        if (absDelta === 0) //ignore zero scroll
        return;
        if (absDelta === sequenceUnit || absDelta / sequenceUnit % 1 < 0.0001 // a multiple
        ) ;
        else if (sequenceUnit / absDelta % 1 < 0.0001) //unit was actually a multiple - update it
        sequenceUnit = absDelta;
        else if (absDelta !== sequenceUnit) {
            //not clean - delta is varying - probably a swipe scroll or pinch scroll on trackpad
            sequenceUnit = null;
            toEmitDelta = null;
            return;
        }
        if (toEmitDelta !== null) {
            emit(toEmitDelta);
            toEmitDelta = null;
        }
        emit(delta);
    };
};
const PointerListener = function() {
    //keeping track of pointers for movement fallback
    const pointerArr = [];
    function addPointer(event) {
        const pointerObj = {
            pointerId: event.pointerId,
            lastPageX: null,
            lastPageY: null
        };
        pointerArr.push(pointerObj);
        if (pointerArr.length > 15) pointerArr.shift();
        return pointerObj;
    }
    function getPointer(event) {
        for(let i = pointerArr.length - 1; i >= 0; i--){
            if (event.pointerId === pointerArr[i].pointerId) return pointerArr[i];
        }
        return null;
    }
    let pressureNormalizeAvgCount = 0;
    let pressureNormalizeAvgPressure = null;
    let pressureNormalizeIsComplete = false;
    let pressureNormalizeFactor = 1;
    return function(p) {
        const targetElement = p.target;
        const onPointerCallback = p.onPointer;
        const onWheelCallback = p.onWheel;
        const onEnterLeaveCallback = p.onEnterLeave;
        const maxPointers = 'maxPointers' in p ? p.maxPointers : 1;
        const buttonsToStr = {
            '1': 'left',
            '2': 'right',
            '4': 'middle'
        };
        const wheelCleaner = new WheelCleaner(function(wheelEvent) {
            if (isDestroyed) return;
            if (onWheelCallback) {
                const bounds = targetElement.getBoundingClientRect();
                wheelEvent.relX = wheelEvent.clientX - bounds.left + targetElement.scrollLeft;
                wheelEvent.relY = wheelEvent.clientY - bounds.top + targetElement.scrollTop;
                onWheelCallback(wheelEvent);
            }
        });
        let isDestroyed = false;
        const timeStampOffset = _browser.eventUsesHighResTimeStamp() ? 0 : -performance.timing.navigationStart;
        //to circumvent a chrome input glitch
        let lastPointerType = '';
        let didSkip = false;
        /*
        pointers that are pressing a button
        dragObj = {
            pointerId: long,
            pointerType: 'mouse'|'pen'|'touch',
            downPageX: number, //where was pointer when down-event occurred
            downPageY: number,
            button: long,
            lastPageX: number, //pageX in previous event - only for touch events, because they don't have movementX/Y
            lastPageY: number,
            lastTimeStamp: number
        }
         */ const dragObjArr = [];
        const dragPointerIdArr = [];
        function getDragObj(pointerId) {
            for(let i = 0; i < dragObjArr.length; i++){
                if (pointerId === dragObjArr[i].pointerId) return dragObjArr[i];
            }
            return null;
        }
        function removeDragObj(pointerId) {
            let removedDragObj = null;
            for(let i = 0; i < dragPointerIdArr.length; i++)if (dragPointerIdArr[i] === pointerId) {
                removedDragObj = dragObjArr[i];
                dragObjArr.splice(i, 1);
                dragPointerIdArr.splice(i, 1);
                i--;
            }
            return removedDragObj;
        }
        function normalizePressure(pressure, type) {
            if (pressure === 0 || pressure === 1) return pressure;
            // was this there to prevent some glitch?
            /*if (pressureNormalizeIsComplete && type === 'pointerdown' && pressure !== 1) {
                pressure *= 0.004;
            }*/ if (pressureNormalizeAvgCount < 60) {
                if (pressureNormalizeAvgCount === 0) pressureNormalizeAvgPressure = pressure;
                else pressureNormalizeAvgPressure = _math.mix(pressure, pressureNormalizeAvgPressure, 0.95);
                pressureNormalizeAvgCount++;
            } else if (!pressureNormalizeIsComplete) {
                pressureNormalizeIsComplete = true;
                //BB.throwOut('avg pressure decision!' + pressureNormalizeAvgPressure);
                if (pressureNormalizeAvgPressure < 0.13) pressureNormalizeFactor = 2.3;
            }
            return Math.pow(pressure, 1 / pressureNormalizeFactor);
        }
        /**
         *
         * More trustworthy pointer attributes. that behave the same across browsers.
         * returns a new object. this object also gets attached to the orig event. -> event.corrected
         *
         * @param event
         * @returns {{pointerId: number, timeStamp: number, button, buttons, pointerType: (string|string|any), movementY: number, movementX: number, pressure, coalescedArr: [], pageY, pageX, clientX, clientY, eventPreventDefault: func, eventStopPropagation: func}
         */ function correctPointerEvent(event) {
            if (event.corrected) return event.corrected;
            /*if (event.type === 'pointermove' && !window.hidePressureOut) {
                if (event.type === 'pointermove') {
                    BB.throwOut(event.pressure + ' ' + event.pointerType);
                }
            }*/ const correctedObj = {
                pointerId: event.pointerId,
                pointerType: event.pointerType,
                pageX: event.pageX,
                pageY: event.pageY,
                clientX: event.clientX,
                clientY: event.clientY,
                movementX: event.movementX,
                movementY: event.movementY,
                timeStamp: event.timeStamp + timeStampOffset,
                pressure: normalizePressure(event.pressure, event.type),
                buttons: event.buttons,
                button: event.button,
                coalescedArr: [],
                eventPreventDefault: function() {
                    event.preventDefault();
                },
                eventStopPropagation: function() {
                    event.stopPropagation();
                }
            };
            event.corrected = correctedObj;
            let customPressure = null;
            if ('pointerId' in event) {
                if ('pressure' in event && event.buttons !== 0 && ([
                    'mouse'
                ].includes(event.pointerType) || event.pointerType === 'touch' && event.pressure === 0)) {
                    correctedObj.pressure = 1;
                    customPressure = 1;
                }
            } else {
                correctedObj.pointerId = 0;
                correctedObj.pointerType = 'mouse';
                correctedObj.pressure = event.buttons !== 0 ? 1 : 0;
                customPressure = correctedObj.pressure;
            }
            if (_browser.isFirefox && event.pointerType != 'mouse' && event.type === 'pointermove' && event.buttons === 0) correctedObj.buttons = 1; //todo wrong if no buttons actually pressed
            let coalescedEventArr = [];
            if ('getCoalescedEvents' in event) coalescedEventArr = event.getCoalescedEvents();
            // chrome somehow movementX not same scale as pageX. todo: only chrome?
            // so make my own
            let pointerObj = getPointer(correctedObj);
            if (pointerObj === null) pointerObj = addPointer(correctedObj);
            const totalLastX = pointerObj.lastPageX;
            const totalLastY = pointerObj.lastPageY;
            for(let i = 0; i < coalescedEventArr.length; i++){
                const eventItem = coalescedEventArr[i];
                correctedObj.coalescedArr.push({
                    pageX: eventItem.pageX,
                    pageY: eventItem.pageY,
                    clientX: eventItem.clientX,
                    clientY: eventItem.clientY,
                    movementX: pointerObj.lastPageX === null ? 0 : eventItem.pageX - pointerObj.lastPageX,
                    movementY: pointerObj.lastPageY === null ? 0 : eventItem.pageY - pointerObj.lastPageY,
                    timeStamp: eventItem.timeStamp === 0 ? correctedObj.timeStamp : eventItem.timeStamp + timeStampOffset,
                    pressure: customPressure === null ? normalizePressure(eventItem.pressure) : customPressure
                });
                pointerObj.lastPageX = eventItem.pageX;
                pointerObj.lastPageY = eventItem.pageY;
            }
            pointerObj.lastPageX = correctedObj.pageX;
            pointerObj.lastPageY = correctedObj.pageY;
            correctedObj.movementX = totalLastX === null ? 0 : pointerObj.lastPageX - totalLastX;
            correctedObj.movementY = totalLastY === null ? 0 : pointerObj.lastPageY - totalLastY;
            return correctedObj;
        }
        /**
         * creates a value for onPointer, from a pointer event handler
         *
         * @param typeStr string - 'pointerdown'|'pointermove'|'pointerup'
         * @param correctedEvent - corrected pointer event from correctPointerEvent()
         * @param custom - object for setting custom attributes
         * @returns {{pointerId: number, pointerType: *, dX: (*), relY: number, dY: (*), relX: number, type: *, event: *, pageY: *, pageX: *}}
         */ function createPointerOutEvent(typeStr, correctedEvent, custom) {
            const bounds = targetElement.getBoundingClientRect();
            const result = {
                type: typeStr,
                pointerId: correctedEvent.pointerId,
                pointerType: correctedEvent.pointerType,
                pageX: correctedEvent.pageX,
                pageY: correctedEvent.pageY,
                clientX: correctedEvent.clientX,
                clientY: correctedEvent.clientY,
                relX: correctedEvent.clientX - bounds.left + targetElement.scrollLeft,
                relY: correctedEvent.clientY - bounds.top + targetElement.scrollTop,
                dX: correctedEvent.movementX,
                dY: correctedEvent.movementY,
                time: correctedEvent.timeStamp,
                eventPreventDefault: correctedEvent.eventPreventDefault,
                eventStopPropagation: correctedEvent.eventStopPropagation
            };
            if (typeStr === 'pointermove') {
                result.coalescedArr = [];
                if (correctedEvent.coalescedArr.length > 1) {
                    let coalescedItem;
                    for(let i = 0; i < correctedEvent.coalescedArr.length; i++){
                        coalescedItem = correctedEvent.coalescedArr[i];
                        result.coalescedArr.push({
                            pageX: coalescedItem.pageX,
                            pageY: coalescedItem.pageY,
                            clientX: coalescedItem.clientX,
                            clientY: coalescedItem.clientY,
                            relX: coalescedItem.clientX - bounds.left + targetElement.scrollLeft,
                            relY: coalescedItem.clientY - bounds.top + targetElement.scrollTop,
                            dX: coalescedItem.movementX,
                            dY: coalescedItem.movementY,
                            time: coalescedItem.timeStamp
                        });
                    }
                }
            }
            if (custom) {
                const keyArr = Object.keys(custom);
                for(let i = 0; i < keyArr.length; i++)result[keyArr[i]] = custom[keyArr[i]];
            }
            return result;
        }
        /**
         * creates a value for onPointer, from a fallback touch event handler
         *
         * @param typeStr string - 'pointerdown'|'pointermove'|'pointerup'
         * @param touchListItem - element from changed touch list
         * @param touchEvent - touch event
         * @param custom - object for setting custom attributes
         * @returns {{pointerId: number, pointerType: string, relY: number, relX: number, type: *, event: *, pageY: *, pageX: *}}
         */ function createTouchOutEvent(typeStr, touchListItem, touchEvent, custom) {
            const bounds = targetElement.getBoundingClientRect();
            const result = {
                type: typeStr,
                pointerId: touchListItem.identifier,
                pointerType: 'touch',
                pageX: touchListItem.pageX,
                pageY: touchListItem.pageY,
                clientX: touchListItem.clientX,
                clientY: touchListItem.clientY,
                relX: touchListItem.pageX - bounds.left + targetElement.scrollLeft,
                relY: touchListItem.pageY - bounds.top + targetElement.scrollTop,
                time: touchEvent.timeStamp + timeStampOffset,
                eventPreventDefault: function() {
                    touchEvent.preventDefault();
                },
                eventStopPropagation: function() {
                    touchEvent.stopPropagation();
                }
            };
            if (typeStr === 'pointermove') result.coalescedArr = [];
            const keyArr = Object.keys(custom);
            for(let i = 0; i < keyArr.length; i++)result[keyArr[i]] = custom[keyArr[i]];
            return result;
        }
        function setupDocumentListeners() {
            _eventListener.addEventListener(document, 'pointermove', onGlobalPointerMove);
            _eventListener.addEventListener(document, 'pointerup', onGlobalPointerUp);
            _eventListener.addEventListener(document, 'pointerleave', onGlobalPointerLeave);
        }
        function destroyDocumentListeners() {
            _eventListener.removeEventListener(document, 'pointermove', onGlobalPointerMove);
            _eventListener.removeEventListener(document, 'pointerup', onGlobalPointerUp);
            _eventListener.removeEventListener(document, 'pointerleave', onGlobalPointerLeave);
        }
        let isOverCounter = 0; // might be multiple pointers
        function onPointerEnter() {
            isOverCounter++;
            if (onEnterLeaveCallback) onEnterLeaveCallback(true);
        }
        function onPointerLeave() {
            isOverCounter--;
            if (onEnterLeaveCallback) onEnterLeaveCallback(false);
        }
        function onPointermove(event) {
            event = correctPointerEvent(event);
            const tempLastPointerType = lastPointerType;
            lastPointerType = event.pointerType;
            if (dragPointerIdArr.includes(event.pointerId) || dragPointerIdArr.length === maxPointers || event.pointerType === 'touch') {
                didSkip = false;
                return;
            }
            // chrome input glitch workaround - throws in a random mouse event with the wrong position when using a stylus
            if (!didSkip && event.pointerType === 'mouse' && tempLastPointerType === 'pen') {
                didSkip = true;
                return;
            }
            didSkip = false;
            const outEvent = createPointerOutEvent('pointermove', event);
            onPointerCallback(outEvent);
        }
        function onPointerdown(event) {
            //BB.throwOut('pointerdown ' + event.pointerId + ' | ' + dragPointerIdArr.length);
            event = correctPointerEvent(event);
            ////console.log('debug: ' + event.pointerId + ' pointerdown');
            if (dragPointerIdArr.includes(event.pointerId) || dragPointerIdArr.length === maxPointers || ![
                1,
                2,
                4
            ].includes(event.buttons)) //BB.throwOut('pointerdown ignored');
            return;
            //set up global listeners
            if (dragObjArr.length === 0) setupDocumentListeners();
            const dragObj = {
                pointerId: event.pointerId,
                pointerType: event.pointerType,
                downPageX: event.pageX,
                downPageY: event.pageY,
                buttons: event.buttons,
                lastPageX: event.pageX,
                lastPageY: event.pageY,
                lastTimeStamp: event.timeStamp
            };
            dragObjArr.push(dragObj);
            setTouchTimeout(dragObj);
            dragPointerIdArr.push(event.pointerId);
            const outEvent = createPointerOutEvent('pointerdown', event, {
                downPageX: event.pageX,
                downPageY: event.pageY,
                button: buttonsToStr[event.buttons],
                pressure: event.pressure
            });
            onPointerCallback(outEvent);
        }
        function onGlobalPointerMove(event) {
            //BB.throwOut('pointermove ' + event.pointerId);
            event = correctPointerEvent(event);
            ////console.log('debug: ' + event.pointerId + ' GLOBALpointermove');
            if (!dragPointerIdArr.includes(event.pointerId)) return;
            const dragObj = getDragObj(event.pointerId);
            clearTouchTimeout(dragObj);
            //if pointer changes button its pressing -> turn into pointerup
            if (event.buttons !== dragObj.buttons) {
                //pointer up
                //remove listener
                if (dragObjArr.length === 1) destroyDocumentListeners();
                removeDragObj(event.pointerId);
                const outEvent = createPointerOutEvent('pointerup', event, {
                    downPageX: dragObj.downPageX,
                    downPageY: dragObj.downPageY
                });
                onPointerCallback(outEvent);
                return;
            }
            setTouchTimeout(dragObj);
            // ipad likes to do this
            if (event.pointerType === 'pen' && event.pageX === dragObj.lastPageX && event.pageY === dragObj.lastPageY && event.timeStamp === dragObj.lastTimeStamp) //ignore
            return;
            const outEvent = createPointerOutEvent('pointermove', event, {
                downPageX: dragObj.downPageX,
                downPageY: dragObj.downPageY,
                button: buttonsToStr[event.buttons],
                pressure: event.pressure
            });
            dragObj.lastPageX = event.pageX;
            dragObj.lastPageY = event.pageY;
            dragObj.lastTimeStamp = event.timeStamp;
            onPointerCallback(outEvent);
        }
        function onGlobalPointerUp(event) {
            //BB.throwOut('pointerup ' + event.pointerId);
            event = correctPointerEvent(event);
            ////console.log('debug: ' + event.pointerId + ' GLOBALpointerup');
            if (!dragPointerIdArr.includes(event.pointerId)) return;
            //remove listener
            if (dragObjArr.length === 1) destroyDocumentListeners();
            const dragObj = removeDragObj(event.pointerId);
            clearTouchTimeout(dragObj);
            const outEvent = createPointerOutEvent('pointerup', event, {
                downPageX: dragObj.downPageX,
                downPageY: dragObj.downPageY
            });
            onPointerCallback(outEvent);
        }
        function onGlobalPointerLeave(event) {
            //BB.throwOut('pointerleave ' + event.pointerId);
            event = correctPointerEvent(event);
            ////console.log('debug: ' + event.pointerId + ' onGlobalPointerLeave', event);
            if (!dragPointerIdArr.includes(event.pointerId)) return;
            //remove listener
            if (dragObjArr.length === 1) destroyDocumentListeners();
            const dragObj = removeDragObj(event.pointerId);
            clearTouchTimeout(dragObj);
            const outEvent = createPointerOutEvent('pointerup', event, {
                downPageX: dragObj.downPageX,
                downPageY: dragObj.downPageY
            });
            onPointerCallback(outEvent);
        }
        /*
        --- ipad pointer event glitch damage control ---

        ipad pointer events are glitchy. doesn't always fire pointerup.
        - when two fingers get really close to each other
        - when finger moves out and back in bottom

        This artificially fires a pointerup
        */ function onTouchTimeout(dragObj) {
            //create fake event
            const fakeEvent = {
                pointerId: dragObj.pointerId,
                pointerType: dragObj.pointerType,
                type: 'pointerup',
                timeStamp: performance.now(),
                pageX: 0,
                pageY: 0,
                clientX: 0,
                clientY: 0,
                preventDefault: function() {
                },
                stopPropagation: function() {
                }
            };
            //call onGlobalPointerUp with it
            onGlobalPointerUp(fakeEvent);
        }
        function setTouchTimeout(dragObj) {
            if (dragObj.pointerType !== 'touch') return;
            dragObj.touchTimeout = setTimeout(function() {
                onTouchTimeout(dragObj);
            }, 2500); // 2.5 seconds
        }
        function clearTouchTimeout(dragObj) {
            if (!dragObj.touchTimeout) return;
            clearTimeout(dragObj.touchTimeout);
            dragObj.touchTimeout = null;
        }
        if (onEnterLeaveCallback) {
            _eventListener.addEventListener(targetElement, 'pointerenter', onPointerEnter);
            _eventListener.addEventListener(targetElement, 'pointerleave', onPointerLeave);
        }
        if (onPointerCallback) {
            _eventListener.addEventListener(targetElement, 'pointermove', onPointermove);
            _eventListener.addEventListener(targetElement, 'pointerdown', onPointerdown);
        }
        if (onWheelCallback) _eventListener.addEventListener(targetElement, 'wheel', wheelCleaner.process);
        let onTouchstart;
        let onTouchmove;
        let onTouchend;
        // --- touch fallback ---
        if (!_browser.hasPointerEvents) {
            onTouchstart = function(event) {
                ////console.log('onTouchstart', event, event.changedTouches.length);
                event.preventDefault(); // needs to stay, otherwise page scrolls on iOS12
                const touchArr = event.changedTouches;
                for(let i = 0; i < touchArr.length && dragObjArr.length < maxPointers; i++){
                    const touchObj = touchArr[i];
                    //set up global listeners
                    if (dragObjArr.length === 0) {
                        _eventListener.addEventListener(document, 'touchmove', onTouchmove);
                        _eventListener.addEventListener(document, 'touchend', onTouchend);
                        _eventListener.addEventListener(document, 'touchcancel', onTouchend);
                    }
                    dragObjArr.push({
                        pointerId: touchObj.identifier,
                        downPageX: touchObj.pageX,
                        downPageY: touchObj.pageY,
                        buttons: 1,
                        lastPageX: touchObj.pageX,
                        lastPageY: touchObj.pageY
                    });
                    dragPointerIdArr.push(touchObj.identifier);
                    const outEvent = createTouchOutEvent('pointerdown', touchObj, event, {
                        dX: 0,
                        dY: 0,
                        downPageX: touchObj.downPageX,
                        downPageY: touchObj.downPageY,
                        button: 'left',
                        pressure: 1
                    });
                    onPointerCallback(outEvent);
                }
            };
            onTouchmove = function(event) {
                event.preventDefault(); // needs to stay, otherwise page scrolls on iOS12
                const touchArr = event.changedTouches;
                for(let i = 0; i < touchArr.length; i++){
                    const touchObj = touchArr[i];
                    if (!dragPointerIdArr.includes(touchObj.identifier)) continue;
                    const dragObj = getDragObj(touchObj.identifier);
                    const outEvent = createTouchOutEvent('pointermove', touchObj, event, {
                        dX: touchObj.pageX - dragObj.lastPageX,
                        dY: touchObj.pageY - dragObj.lastPageY,
                        downPageX: dragObj.downPageX,
                        downPageY: dragObj.downPageY,
                        button: 'left',
                        isCoalesced: false,
                        pressure: 1
                    });
                    dragObj.lastPageX = touchObj.pageX;
                    dragObj.lastPageY = touchObj.pageY;
                    onPointerCallback(outEvent);
                }
            };
            onTouchend = function(event) {
                if (event.type !== 'touchcancel') event.preventDefault(); // needs to stay, otherwise page scrolls on iOS12
                const touchArr = event.changedTouches;
                for(let i = 0; i < touchArr.length; i++){
                    const touchObj = touchArr[i];
                    if (!dragPointerIdArr.includes(touchObj.identifier)) continue;
                    //remove listener
                    if (dragObjArr.length === 1) {
                        _eventListener.removeEventListener(document, 'touchmove', onTouchmove);
                        _eventListener.removeEventListener(document, 'touchend', onTouchend);
                        _eventListener.removeEventListener(document, 'touchcancel', onTouchend);
                    }
                    const dragObj = removeDragObj(touchObj.identifier);
                    const outEvent = createTouchOutEvent('pointerup', touchObj, event, {
                        dX: touchObj.pageX - dragObj.lastPageX,
                        dY: touchObj.pageY - dragObj.lastPageY,
                        downPageX: dragObj.downPageX,
                        downPageY: dragObj.downPageY
                    });
                    onPointerCallback(outEvent);
                }
            };
            if (onPointerCallback) _eventListener.addEventListener(targetElement, 'touchstart', onTouchstart);
        } else if (p.fixScribble) {
            //ipad scribble workaround https://developer.apple.com/forums/thread/662874
            onTouchmove = function(e) {
                e.preventDefault();
            };
            _eventListener.addEventListener(targetElement, 'touchmove', onTouchmove);
        }
        // --- interface ---
        this.isOver = function() {
            return isOverCounter > 0;
        };
        this.destroy = function() {
            if (isDestroyed) return;
            isDestroyed = true;
            _eventListener.removeEventListener(targetElement, 'pointerenter', onPointerEnter);
            _eventListener.removeEventListener(targetElement, 'pointerleave', onPointerLeave);
            _eventListener.removeEventListener(targetElement, 'pointermove', onPointermove);
            _eventListener.removeEventListener(targetElement, 'pointerdown', onPointerdown);
            _eventListener.removeEventListener(targetElement, 'wheel', wheelCleaner.process);
            if (dragObjArr.length > 0) destroyDocumentListeners();
            if (!_browser.hasPointerEvents) {
                _eventListener.removeEventListener(targetElement, 'touchstart', onTouchstart);
                if (dragObjArr.length > 0) {
                    _eventListener.removeEventListener(document, 'touchmove', onTouchmove);
                    _eventListener.removeEventListener(document, 'touchend', onTouchend);
                    _eventListener.removeEventListener(document, 'touchcancel', onTouchend);
                }
            } else _eventListener.removeEventListener(targetElement, 'touchmove', onTouchmove);
        };
    };
}();

},{"./event-listener":"9MYB6","../base/browser":"gLGO4","../math/math":"bwQIx","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bwQIx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mix", ()=>mix
);
parcelHelpers.export(exports, "dist", ()=>dist
);
parcelHelpers.export(exports, "distSquared", ()=>distSquared
);
parcelHelpers.export(exports, "lenSquared", ()=>lenSquared
);
parcelHelpers.export(exports, "pointsToAngleRad", ()=>pointsToAngleRad
);
parcelHelpers.export(exports, "pointsToAngleDeg", ()=>pointsToAngleDeg
);
parcelHelpers.export(exports, "clamp", ()=>clamp
);
parcelHelpers.export(exports, "rotate", ()=>rotate
);
parcelHelpers.export(exports, "rotateAround", ()=>rotateAround
);
parcelHelpers.export(exports, "intDxy", ()=>intDxy
);
/**
 * return closest even number
 * @param f
 */ parcelHelpers.export(exports, "roundEven", ()=>roundEven
);
/**
 * return closest uneven number
 * @param f
 */ parcelHelpers.export(exports, "roundUneven", ()=>roundUneven
);
/**
 * update target so it includes bounds
 * @param target
 * @param bounds
 */ parcelHelpers.export(exports, "updateBounds", ()=>updateBounds
);
/**
 * determine overlap of bounds with width&height
 */ parcelHelpers.export(exports, "boundsInArea", ()=>boundsInArea
);
function mix(a, b, f) {
    return a * (1 - f) + b * f;
}
function dist(ax, ay, bx, by) {
    return Math.sqrt(Math.pow(ax - bx, 2) + Math.pow(ay - by, 2));
}
function distSquared(ax, ay, bx, by) {
    // faster because no square-root
    return Math.pow(ax - bx, 2) + Math.pow(ay - by, 2);
}
function lenSquared(x, y) {
    // faster because no square-root
    return x * x + y * y;
}
function pointsToAngleRad(p1, p2) {
    return Math.atan2(p2.y - p1.y, p2.x - p1.x);
}
function pointsToAngleDeg(p1, p2) {
    return pointsToAngleRad(p1, p2) * 180 / Math.PI;
}
function clamp(num, min, max) {
    return num <= min ? min : num >= max ? max : num;
}
function rotate(x, y, deg) {
    const theta = deg * (Math.PI / 180);
    const cs = Math.cos(theta);
    const sn = Math.sin(theta);
    return {
        x: x * cs - y * sn,
        y: x * sn + y * cs
    };
}
function rotateAround(center, point, deg) {
    const rot = rotate(point.x - center.x, point.y - center.y, deg);
    rot.x += center.x;
    rot.y += center.y;
    return rot;
}
function intDxy(remainder, fDx, fDy) {
    remainder.x += fDx;
    remainder.y += fDy;
    const dX = Math.round(remainder.x);
    const dY = Math.round(remainder.y);
    remainder.x -= dX;
    remainder.y -= dY;
    return {
        dX,
        dY
    };
}
function roundEven(f) {
    if (f % 1 === 0) {
        if (f % 2 === 0) return f;
        return f + 1;
    }
    const above = Math.ceil(f);
    const below = Math.floor(f);
    if (above % 2 === 0) return above;
    else return below;
}
function roundUneven(f) {
    if (f % 1 === 0) {
        if (f % 2 === 0) return f + 1;
        return f;
    }
    const above = Math.ceil(f);
    const below = Math.floor(f);
    if (above % 2 === 1) return above;
    else return below;
}
function updateBounds(target, bounds) {
    if (!bounds) return target;
    if (!target) target = {
        x1: bounds.x1,
        y1: bounds.y1,
        x2: bounds.x2,
        y2: bounds.y2
    };
    else {
        target.x1 = Math.min(target.x1, bounds.x1);
        target.y1 = Math.min(target.y1, bounds.y1);
        target.x2 = Math.max(target.x2, bounds.x2);
        target.y2 = Math.max(target.y2, bounds.y2);
    }
    return target;
}
function boundsInArea(bounds, width, height) {
    let x1 = Math.max(0, bounds.x1);
    let y1 = Math.max(0, bounds.y1);
    let x2 = Math.min(width - 1, bounds.x2);
    let y2 = Math.min(height - 1, bounds.y2);
    if (x1 > x2 || y1 > y2) return null;
    return {
        x1,
        y1,
        x2,
        y2
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"eAbTm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EventChain", ()=>EventChain
);
parcelHelpers.export(exports, "DoubleTapper", ()=>DoubleTapper
);
parcelHelpers.export(exports, "NFingerTapper", ()=>NFingerTapper
);
parcelHelpers.export(exports, "PinchZoomer", ()=>PinchZoomer
);
parcelHelpers.export(exports, "CoalescedExploder", ()=>CoalescedExploder
);
parcelHelpers.export(exports, "OnePointerLimiter", ()=>OnePointerLimiter
);
parcelHelpers.export(exports, "LinetoolProcessor", ()=>LinetoolProcessor
);
parcelHelpers.export(exports, "LineSanitizer", ()=>LineSanitizer
);
parcelHelpers.export(exports, "LineSmoothing", ()=>LineSmoothing
);
var _math = require("../math/math");
const EventChain = function(p) {
    const chainArr = p.chainArr;
    let chainOut = ()=>undefined
    ;
    function continueChain(i, event) {
        for(; i < chainArr.length; i++){
            event = chainArr[i].chainIn(event);
            if (event === null) return null;
        }
        chainOut(event);
        return null;
    }
    for(let i1 = 0; i1 < chainArr.length; i1++)(function(i) {
        chainArr[i].setChainOut(function(event) {
            continueChain(i + 1, event);
        });
    })(i1);
    // --- interface ---
    this.chainIn = function(event) {
        return continueChain(0, event);
    };
    this.setChainOut = function(func) {
        chainOut = func;
    };
};
const DoubleTapper = function(p) {
    let chainOut = function() {
    };
    const minSilenceBeforeDurationMs = 400;
    const maxPressedDurationMs = 300;
    const maxPressedDistancePx = 10;
    const maxInbetweenDistancePx = 19;
    const maxUpToUpDurationMs = 500;
    const maxUntilSecondDownDurationMs = 300;
    const minSilenceAfterMs = 250;
    let allowedPointerTypeArr = [
        'touch',
        'mouse',
        'pen'
    ];
    let allowedButtonArr = [
        'left'
    ];
    let sequenceArr = [];
    const pointersDownIdArr = [];
    let lastUpTime = 0;
    let nowTime = 0;
    let eventQueueArr = [];
    function fail() {
        if (sequenceArr.length === 0) return;
        clearTimeout(timeoutObj.fail);
        clearTimeout(timeoutObj.maxUntilSecondDown);
        clearTimeout(timeoutObj.success);
        timeoutObj.fail = null;
        timeoutObj.maxUntilSecondDown = null;
        timeoutObj.success = null;
        for(let i = 0; i < eventQueueArr.length; i++)chainOut(eventQueueArr[i]);
        eventQueueArr = [];
        sequenceArr = [];
    }
    // double tap achieved
    function success() {
        timeoutObj.fail = null;
        timeoutObj.success = null;
        eventQueueArr = []; // events get swallowed
        const lastSequenceItem = sequenceArr[sequenceArr.length - 1];
        sequenceArr = [];
        p.onDoubleTap({
            pageX: lastSequenceItem.pageX,
            pageY: lastSequenceItem.pageY
        });
    }
    const timeoutObj = {
        fail: null,
        maxUntilSecondDown: null,
        success: null
    };
    //returns false if time already up. otherwise sets up timeout
    function setupTimeout(timeoutStr, targetFunc, timeMS) {
        const diff = timeMS - nowTime;
        //console.log(fingers + ': ' + timeoutStr + ' diff', diff);
        if (diff <= 0) return false;
        timeoutObj[timeoutStr] = setTimeout(targetFunc, diff);
        return true;
    }
    /**
     * @param event object - a pointer event from BB.PointerListener
     */ function processEvent(event) {
        if (event.type === 'pointerdown') pointersDownIdArr.push(event.pointerId);
        else if (event.type === 'pointerup') {
            for(let i = 0; i < pointersDownIdArr.length; i++)if (pointersDownIdArr[i] === event.pointerId) {
                pointersDownIdArr.splice(i, 1);
                break;
            }
        }
        if (!allowedPointerTypeArr.includes(event.pointerType)) {
            //console.log('wrong input type -> fail');
            fail();
            return;
        }
        nowTime = performance.now();
        const lastSequenceItem = sequenceArr.length > 0 ? sequenceArr[sequenceArr.length - 1] : null;
        if (event.type === 'pointerup') lastUpTime = event.time;
        if (event.type === 'pointerdown') {
            if (pointersDownIdArr.length > 1) {
                //console.log('more than one pointer down -> fail');
                fail();
                return;
            }
            if (timeoutObj.success !== null) {
                //console.log('silence-after not achieved -> fail');
                fail();
                return;
            }
            if (sequenceArr.length === 0 && nowTime - lastUpTime < minSilenceBeforeDurationMs) {
                //console.log('silence before not achieved -> fail');
                fail();
                return;
            }
            if (!allowedButtonArr.includes(event.button)) {
                //console.log('wrong button -> fail', event.button, allowedButtonArr);
                fail();
                return;
            }
            if (lastSequenceItem && lastSequenceItem.isDown || sequenceArr.length > 2) {
                //console.log('jumbled -> fail');
                fail();
                return;
            }
            if (lastSequenceItem) {
                const distance = _math.dist(lastSequenceItem.position[0], lastSequenceItem.position[1], event.pageX, event.pageY);
                if (distance > maxInbetweenDistancePx) {
                    //console.log('maxInbetweenDistancePx -> reset');
                    fail();
                    if (nowTime - lastSequenceItem.time < minSilenceBeforeDurationMs) return;
                }
            }
            sequenceArr.push({
                isDown: true,
                time: nowTime,
                position: [
                    event.pageX,
                    event.pageY
                ],
                pointerId: event.pointerId
            });
            //maxUntilSecondDown
            if (sequenceArr.length > 1) clearTimeout(timeoutObj.maxUntilSecondDown);
            else if (!setupTimeout('maxUntilSecondDown', fail, event.time + maxUntilSecondDownDurationMs)) {
                //console.log('event.time + maxPressedDurationMs -> fail');
                fail();
                return;
            }
            clearTimeout(timeoutObj.fail);
            if (!setupTimeout('fail', fail, event.time + maxPressedDurationMs)) {
                //console.log('event.time + maxPressedDurationMs -> fail');
                fail();
                return;
            }
        }
        if (lastSequenceItem && event.type === 'pointermove' && lastSequenceItem.pointerId === event.pointerId) {
            /*if (lastSequenceItem.pointerId !== event.pointerId) { //another pointer mixing in -> fail
                console.log('another pointer mixing in -> fail');
                fail();
                return;
            }*/ const distance = _math.dist(lastSequenceItem.position[0], lastSequenceItem.position[1], event.pageX, event.pageY);
            if (distance > maxPressedDistancePx) {
                //console.log('maxPressedDistancePx -> fail');
                fail();
                return;
            }
        }
        if (lastSequenceItem && event.type === 'pointerup') {
            if (lastSequenceItem.pointerId !== event.pointerId) {
                fail();
                return;
            }
            if (nowTime >= lastSequenceItem.time + maxPressedDurationMs) {
                fail();
                return;
            }
            clearTimeout(timeoutObj.fail);
            if (sequenceArr.length < 3) {
                if (!setupTimeout('fail', fail, event.time + maxUpToUpDurationMs)) {
                    fail();
                    return;
                }
                sequenceArr = [
                    lastSequenceItem,
                    {
                        isUp: true,
                        time: nowTime,
                        position: [
                            event.pageX,
                            event.pageY
                        ]
                    }
                ];
                return;
            }
            if (nowTime < sequenceArr[1].time + maxUpToUpDurationMs) {
                // double tap almost success
                // only needs silence
                sequenceArr.push({
                    pageX: event.pageX,
                    pageY: event.pageY
                });
                if (!setupTimeout('success', success, event.time + minSilenceAfterMs)) fail();
            } else fail();
        }
    }
    // --- interface ---
    this.chainIn = function(event) {
        processEvent(event);
        if (sequenceArr.length === 0) {
            fail();
            return event;
        }
        // events might become a double tap -> queue
        eventQueueArr.push(event);
        return null;
    };
    this.setChainOut = function(func) {
        chainOut = func;
    };
    this.setAllowedPointerTypeArr = function(arr) {
        allowedPointerTypeArr = arr;
    };
    this.setAllowedButtonArr = function(arr) {
        allowedButtonArr = arr;
    };
};
const NFingerTapper = function(p) {
    const fingers = p.fingers;
    let chainOut = function() {
    };
    const minSilenceBeforeDurationMs = 50; //250;
    const maxTapMs = 500;
    const maxFirstLastFingerDownMs = 250;
    const maxPressedDistancePx = 12; //5 + fingers * 5;
    const silenceAfterDurationMs = 250;
    /*
        fingerObj = {
            pointerId: number,
            downTime: number,
            downPageX: number,
            downPageY: number,
            isUp: boolean
        }
     */ let fingerArr = [];
    let firstDownTime;
    let eventQueueArr = [];
    let lastEventTime = 0;
    const pointersDownIdArr = [];
    function fail() {
        if (eventQueueArr.length === 0) return;
        clearTimeout(timeoutObj.firstLastDownTimeout);
        clearTimeout(timeoutObj.tapTimeout);
        for(let i = 0; i < eventQueueArr.length; i++)chainOut(eventQueueArr[i]);
        eventQueueArr = [];
        fingerArr = [];
    }
    function success() {
        clearTimeout(timeoutObj.firstLastDownTimeout);
        clearTimeout(timeoutObj.tapTimeout);
        eventQueueArr = []; // events get swallowed
        fingerArr = [];
        p.onTap();
    }
    let nowTime;
    const timeoutObj = {
        firstLastDownTimeout: null,
        tapTimeout: null
    };
    function setupTimeout(timeoutStr, timeMS) {
        const diff = timeMS - nowTime;
        //console.log(fingers + ': ' + timeoutStr + ' diff', diff);
        if (diff <= 0) return false;
        timeoutObj[timeoutStr] = setTimeout(fail, diff);
        return true;
    }
    function processEvent(event) {
        const tempLastEventTime = lastEventTime;
        lastEventTime = event.time;
        if (event.type === 'pointerdown') pointersDownIdArr.push(event.pointerId);
        else if (event.type === 'pointerup') {
            for(let i = 0; i < pointersDownIdArr.length; i++)if (pointersDownIdArr[i] === event.pointerId) {
                pointersDownIdArr.splice(i, 1);
                break;
            }
        }
        if (event.pointerType !== 'touch') {
            if (fingerArr.length > 0) fail();
            return;
        }
        nowTime = performance.now();
        if (event.type === 'pointerdown') {
            //console.log('down');
            if (fingerArr.length + 1 !== pointersDownIdArr.length) {
                fail();
                return;
            }
            if (fingerArr.length === fingers) {
                //console.log(fingers + ': too many fingers down -> fail');
                fail();
                return;
            }
            if (fingerArr.length > 0 && event.time - maxFirstLastFingerDownMs > fingerArr[0].downTime) {
                //console.log(fingers + ': took too long to touch with all fingers -> fail');
                fail();
                return;
            }
            if (fingerArr.length === 0 && event.time - minSilenceBeforeDurationMs < tempLastEventTime) {
                //console.log(fingers + ': not enough silence before -> fail');
                fail();
                return;
            }
            if (fingerArr.length === 0) {
                firstDownTime = event.time;
                if (!setupTimeout('firstLastDownTimeout', event.time + maxFirstLastFingerDownMs) || !setupTimeout('tapTimeout', event.time + maxTapMs)) {
                    fail();
                    return;
                }
            }
            fingerArr.push({
                pointerId: event.pointerId,
                downTime: event.time,
                downPageX: event.pageX,
                downPageY: event.pageY
            });
            return;
        }
        if (event.type === 'pointermove') {
            if (fingerArr.length === 0) //not in a gesture -> ignore
            return;
            let fingerObj = null;
            for(let i = 0; i < fingerArr.length; i++)if (fingerArr[i].pointerId === event.pointerId) {
                fingerObj = fingerArr[i];
                break;
            }
            if (fingerObj === null) {
                fail();
                return;
            }
            if (event.time - maxTapMs > firstDownTime) {
                //console.log(fingers + ': tap took too long -> fail');
                fail();
                return;
            }
            const distance = _math.dist(event.pageX, event.pageY, fingerObj.downPageX, fingerObj.downPageY);
            if (distance > maxPressedDistancePx) {
                //console.log(fingers + ': a finger moved too much -> fail', distance);
                fail();
                return;
            }
        }
        if (event.type === 'pointerup') {
            if (fingerArr.length === 0) //not in a gesture -> ignore
            return;
            //console.log('up', event.pageX, event.pageY);
            if (fingerArr.length !== fingers) {
                //console.log(fingers + ': not enough fingers -> fail');
                fail();
                return;
            }
            let fingerObj = null;
            let i = 0;
            for(; i < fingerArr.length; i++)if (fingerArr[i].pointerId === event.pointerId) {
                fingerObj = fingerArr[i];
                break;
            }
            if (fingerObj === null) //do nothing
            return;
            if (event.time - maxTapMs > firstDownTime) {
                //console.log(fingers + ': tap took too long -> fail');
                fail();
                return;
            }
            const distance = _math.dist(event.pageX, event.pageY, fingerObj.downPageX, fingerObj.downPageY);
            if (distance > maxPressedDistancePx) {
                //console.log(fingers + ': b finger moved too much -> fail', distance, event.pageX, event.pageY);
                //console.log(fingerArr);
                fail();
                return;
            }
            fingerObj.isUp = true;
            let allAreUp = true;
            for(let i2 = 0; i2 < fingerArr.length; i2++)if (!fingerArr[i2].isUp) {
                allAreUp = false;
                break;
            }
            //console.log('fingerArr', fingerArr);
            if (allAreUp) {
                success();
                return true;
            }
        }
    }
    // --- interface ---
    this.chainIn = function(event) {
        const result = processEvent(event);
        //console.log(fingerArr.length);
        if (result === true) //tap success -> event gets swallowed
        return null;
        if (fingerArr.length === 0) return event;
        else eventQueueArr.push(event);
        return null;
    };
    this.setChainOut = function(func) {
        chainOut = func;
    };
};
const PinchZoomer = function(p) {
    const firstFingerMaxDistancePx = 10;
    const untilSecondFingerDurationMs = 250;
    let chainOut = function() {
    };
    const pointersDownIdArr = [];
    /*
    gestureObj = {
        touchPointerArr: Array of {
            pointerId: number,
            relX: number,
            relY: number,
            downRelX: number, // only for first
            downRelY: number
        },
        otherPointerIdArr: number[],
        isInProgress: boolean
    }
    */ let gestureObj1 = null;
    let eventQueueArr = [];
    function end() {
        gestureObj1 = null;
        eventQueueArr = [];
    }
    function fail(doSwallow) {
        if (!gestureObj1) return;
        clearTimeout(timeoutObj.secondFingerTimeout);
        if (!doSwallow) for(let i = 0; i < eventQueueArr.length; i++)chainOut(eventQueueArr[i]);
        end();
    }
    let nowTime;
    const timeoutObj = {
        secondFingerTimeout: null
    };
    function setupTimeout(timeoutStr, targetFunc, timeMS) {
        const diff = timeMS - nowTime;
        if (diff <= 0) return false;
        timeoutObj[timeoutStr] = setTimeout(targetFunc, diff);
        return true;
    }
    function processEvent(event) {
        if (event.type === 'pointerdown') pointersDownIdArr.push(event.pointerId);
        else if (event.type === 'pointerup') {
            for(let i = 0; i < pointersDownIdArr.length; i++)if (pointersDownIdArr[i] === event.pointerId) {
                pointersDownIdArr.splice(i, 1);
                break;
            }
        }
        //pass through scenarios
        if (!gestureObj1 && (event.pointerType !== 'touch' || event.type === 'pointermove' && pointersDownIdArr.length > 0 || pointersDownIdArr.length > 1 || event.type === 'pointerup' // failed before
        )) return;
        nowTime = performance.now();
        //pointer down
        if (event.type === 'pointerdown') {
            if (gestureObj1) {
                if (event.pointerType === 'touch') {
                    gestureObj1.touchPointerArr.push({
                        pointerId: event.pointerId,
                        relX: event.relX,
                        relY: event.relY
                    });
                    if (gestureObj1.isInProgress) continuePinch(gestureObj1, {
                        type: 'down',
                        index: gestureObj1.touchPointerArr.length - 1
                    });
                    else {
                        clearTimeout(timeoutObj.secondFingerTimeout);
                        gestureObj1.isInProgress = true;
                        beginPinch(gestureObj1);
                    }
                    return;
                } else {
                    if (gestureObj1.isInProgress) gestureObj1.otherPointerIdArr.push(event.pointerId);
                    else fail();
                    return;
                }
            } else {
                // first finger down - can only be touch if no gestureObj
                gestureObj1 = {
                    touchPointerArr: [
                        {
                            pointerId: event.pointerId,
                            relX: event.relX,
                            relY: event.relY,
                            downRelX: event.relX,
                            downRelY: event.relY
                        }
                    ],
                    otherPointerIdArr: [],
                    isInProgress: false
                };
                if (!setupTimeout('secondFingerTimeout', function() {
                    fail();
                }, event.time + untilSecondFingerDurationMs)) {
                    fail();
                    return;
                }
                return;
            }
        }
        //pointer move
        if (event.type === 'pointermove' && event.pointerType === 'touch') {
            //gesture object should always exist here
            let touchPointerObj = null;
            let i = 0;
            for(; i < gestureObj1.touchPointerArr.length; i++)if (event.pointerId === gestureObj1.touchPointerArr[i].pointerId) {
                touchPointerObj = gestureObj1.touchPointerArr[i];
                break;
            }
            //null should not be possible
            touchPointerObj.relX = event.relX;
            touchPointerObj.relY = event.relY;
            if (!gestureObj1.isInProgress) {
                const distance = _math.dist(touchPointerObj.downRelX, touchPointerObj.downRelY, touchPointerObj.relX, touchPointerObj.relY);
                if (distance > firstFingerMaxDistancePx) {
                    fail();
                    return;
                }
            } else if (i < 2) continuePinch(gestureObj1, {
                type: 'move',
                index: i
            });
            return;
        }
        //pointer up
        if (event.type === 'pointerup') {
            //gesture object should always exist here
            if (event.pointerType === 'touch') {
                let i = 0;
                for(; i < gestureObj1.touchPointerArr.length; i++)if (gestureObj1.touchPointerArr[i].pointerId === event.pointerId) {
                    gestureObj1.touchPointerArr.splice(i, 1);
                    break;
                }
                if (gestureObj1.touchPointerArr.length > 0) continuePinch(gestureObj1, {
                    type: 'up',
                    index: i
                });
            } else {
                for(let i = 0; i < gestureObj1.otherPointerIdArr.length; i++)if (gestureObj1.otherPointerIdArr[i] === event.pointerId) {
                    gestureObj1.otherPointerIdArr.splice(i, 1);
                    break;
                }
            }
            //all fingers lifted?
            if (gestureObj1.touchPointerArr.length === 0 && gestureObj1.otherPointerIdArr.length === 0) {
                if (gestureObj1.isInProgress) {
                    end();
                    endPinch();
                } else fail();
                return;
            }
        }
    }
    // --- actual pinch transform logic ---
    let pincherArr = [];
    function beginPinch(gestureObj) {
        for(let i = 0; i < gestureObj.touchPointerArr.length; i++){
            const pointerObj = gestureObj.touchPointerArr[i];
            pincherArr.push({
                pointerId: pointerObj.pointerId,
                relX: pointerObj.relX,
                relY: pointerObj.relY,
                downRelX: pointerObj.relX,
                downRelY: pointerObj.relY
            });
        }
        const event = {
            type: 'move',
            angleRad: 0,
            scale: 1
        };
        if (pincherArr.length === 1) {
            event.relX = pincherArr[0].downRelX;
            event.relY = pincherArr[0].downRelY;
        } else {
            event.relX = 0.5 * (pincherArr[0].downRelX + pincherArr[1].downRelX);
            event.relY = 0.5 * (pincherArr[0].downRelY + pincherArr[1].downRelY);
        }
        event.downRelX = event.relX;
        event.downRelY = event.relY;
        p.onPinch(event);
    }
    //actionObj = {type: 'down'|'move'|'up', index: number}
    function continuePinch(gestureObj, actionObj) {
        if (actionObj.index > 1) return;
        if (actionObj.type === 'move') {
            let event;
            pincherArr[actionObj.index].relX = gestureObj.touchPointerArr[actionObj.index].relX;
            pincherArr[actionObj.index].relY = gestureObj.touchPointerArr[actionObj.index].relY;
            if (pincherArr.length === 1) event = {
                type: 'move',
                downRelX: pincherArr[0].downRelX,
                downRelY: pincherArr[0].downRelY,
                relX: pincherArr[0].relX,
                relY: pincherArr[0].relY,
                angleRad: 0,
                scale: 1
            };
            else {
                const startDist = _math.dist(pincherArr[0].downRelX, pincherArr[0].downRelY, pincherArr[1].downRelX, pincherArr[1].downRelY);
                const distance = _math.dist(pincherArr[0].relX, pincherArr[0].relY, pincherArr[1].relX, pincherArr[1].relY);
                const startAngle = _math.pointsToAngleRad({
                    x: pincherArr[0].downRelX,
                    y: pincherArr[0].downRelY
                }, {
                    x: pincherArr[1].downRelX,
                    y: pincherArr[1].downRelY
                });
                const angle = _math.pointsToAngleRad({
                    x: pincherArr[0].relX,
                    y: pincherArr[0].relY
                }, {
                    x: pincherArr[1].relX,
                    y: pincherArr[1].relY
                });
                event = {
                    type: 'move',
                    downRelX: 0.5 * (pincherArr[0].downRelX + pincherArr[1].downRelX),
                    downRelY: 0.5 * (pincherArr[0].downRelY + pincherArr[1].downRelY),
                    relX: 0.5 * (pincherArr[0].relX + pincherArr[1].relX),
                    relY: 0.5 * (pincherArr[0].relY + pincherArr[1].relY),
                    angleRad: angle - startAngle,
                    scale: distance / startDist
                };
            }
            p.onPinch(event);
        } else if (actionObj.type === 'down' || actionObj.type === 'up') {
            endPinch();
            beginPinch(gestureObj);
        }
    }
    function endPinch() {
        pincherArr = [];
        p.onPinch({
            type: 'end'
        });
    }
    // --- interface ---
    this.chainIn = function(event) {
        processEvent(event);
        if (gestureObj1) {
            if (!gestureObj1.isInProgress) eventQueueArr.push(event);
        } else return event;
        return null;
    };
    this.setChainOut = function(func) {
        chainOut = func;
    };
};
const CoalescedExploder = function() {
    let chainOut = function() {
    };
    // --- interface ---
    this.chainIn = function(event) {
        if (event.type === 'pointermove') {
            if (event.coalescedArr.length > 0) {
                let eventCopy = JSON.parse(JSON.stringify(event));
                eventCopy.coalescedArr = [];
                let coalescedItem;
                for(let i = 0; i < event.coalescedArr.length; i++){
                    if (i > 0) eventCopy = JSON.parse(JSON.stringify(event));
                    coalescedItem = event.coalescedArr[i];
                    eventCopy.pageX = coalescedItem.pageX;
                    eventCopy.pageY = coalescedItem.pageY;
                    eventCopy.relX = coalescedItem.relX;
                    eventCopy.relY = coalescedItem.relY;
                    eventCopy.dX = coalescedItem.dX;
                    eventCopy.dY = coalescedItem.dY;
                    eventCopy.time = coalescedItem.time;
                    if (i < event.coalescedArr.length - 1) eventCopy.isCoalesced = true;
                    chainOut(eventCopy);
                }
            } else return event;
        } else return event;
        return null;
    };
    this.setChainOut = function(func) {
        chainOut = func;
    };
};
const OnePointerLimiter = function(pointers) {
    let chainOut = function() {
    };
    let downPointerId = null;
    const ignorePointerIdArr = [];
    // --- interface ---
    this.chainIn = function(event) {
        if (ignorePointerIdArr.includes(event.pointerId)) {
            if (event.type === 'pointerup') {
                for(let i = 0; i < ignorePointerIdArr.length; i++)if (ignorePointerIdArr[i] === event.pointerId) {
                    ignorePointerIdArr.splice(i, 1);
                    break;
                }
            }
            return null;
        }
        if (downPointerId === null) {
            if (event.type === 'pointerdown') downPointerId = event.pointerId;
            return event;
        } else {
            if (event.pointerId !== downPointerId) {
                if (event.type === 'pointerdown') ignorePointerIdArr.push(event.pointerId);
                return null;
            }
            if (event.type === 'pointerup') downPointerId = null;
            return event;
        }
        return null;
    };
    this.setChainOut = function(func) {
        chainOut = func;
    };
};
const LinetoolProcessor = function(p) {
    let downEvent = null;
    let eventQueue = [];
    let direction = null;
    const DIR_X = 0, DIR_Y = 1;
    this.process = function(event) {
        if (event.type === 'down') {
            downEvent = event;
            direction = null;
            if (event.shiftIsPressed) {
                p.onDraw({
                    type: 'line',
                    x0: null,
                    y0: null,
                    pressure0: null,
                    x1: event.x,
                    y1: event.y,
                    pressure1: event.pressure
                });
                eventQueue.push(event);
                return;
            }
        }
        if (event.type === 'move') {
            if (event.shiftIsPressed) {
                if (direction === null) {
                    const dX = Math.abs(event.x - downEvent.x);
                    const dY = Math.abs(event.y - downEvent.y);
                    if (dX > 5 || dY > 5) {
                        direction = dX > dY ? DIR_X : DIR_Y;
                        for(let i = 0; i < eventQueue.length; i++){
                            const e = eventQueue[i];
                            if (direction === DIR_X) e.y = downEvent.y;
                            else e.x = downEvent.x;
                            p.onDraw(JSON.parse(JSON.stringify(e)));
                        }
                        eventQueue = [];
                    }
                }
                if (direction === null) {
                    eventQueue.push(event);
                    return;
                }
                if (direction === DIR_X) event.y = downEvent.y;
                else event.x = downEvent.x;
            } else if (eventQueue.length > 0) {
                for(let i = 0; i < eventQueue.length; i++)p.onDraw(JSON.parse(JSON.stringify(eventQueue[i])));
                eventQueue = [];
            }
        }
        if (event.type === 'up') eventQueue = [];
        p.onDraw(JSON.parse(JSON.stringify(event)));
    };
};
const LineSanitizer = function() {
    let chainOut = function() {
    };
    let isDrawing = false;
    // --- interface ---
    this.chainIn = function(event) {
        if (event.type === 'down') {
            if (isDrawing) //console.log('line sanitizer - down, but already drawing');
            chainOut({
                type: 'up',
                scale: event.scale,
                shiftIsPressed: event.shiftIsPressed,
                isCoalesced: false
            });
            else isDrawing = true;
        }
        if (!isDrawing && (event.type === 'move' || event.type === 'up')) //console.log('line sanitizer - ' + event.type + ' but not drawing');
        return null;
        if (event.type === 'up' && isDrawing) isDrawing = false;
        return event;
    };
    this.setChainOut = function(func) {
        chainOut = func;
    };
    this.getIsDrawing = function() {
        return isDrawing;
    };
};
const LineSmoothing = function(p) {
    let chainOut = function() {
    };
    let smoothing = _math.clamp(p.smoothing, 0, 1);
    let lastMixedInput;
    let interval;
    let timeout;
    // --- interface ---
    this.chainIn = function(event) {
        event = JSON.parse(JSON.stringify(event));
        clearTimeout(timeout);
        clearInterval(interval);
        if (event.type === 'down') lastMixedInput = {
            x: event.x,
            y: event.y,
            pressure: event.pressure
        };
        if (event.type === 'move') {
            const inputX = event.x;
            const inputY = event.y;
            const inputPressure = event.pressure;
            event.x = _math.mix(event.x, lastMixedInput.x, smoothing);
            event.y = _math.mix(event.y, lastMixedInput.y, smoothing);
            event.pressure = _math.mix(event.pressure, lastMixedInput.pressure, smoothing);
            lastMixedInput = {
                x: event.x,
                y: event.y,
                pressure: event.pressure
            };
            if (smoothing > 0) timeout = setTimeout(function() {
                interval = setInterval(function() {
                    event = JSON.parse(JSON.stringify(event));
                    event.x = _math.mix(inputX, lastMixedInput.x, smoothing);
                    event.y = _math.mix(inputY, lastMixedInput.y, smoothing);
                    event.pressure = _math.mix(inputPressure, lastMixedInput.pressure, smoothing);
                    lastMixedInput = {
                        x: event.x,
                        y: event.y,
                        pressure: event.pressure
                    };
                    chainOut(event);
                }, 35);
            }, 80);
        }
        return event;
    };
    this.setChainOut = function(func) {
        chainOut = func;
    };
    this.setSmoothing = function(s) {
        smoothing = _math.clamp(s, 0, 1);
    };
};

},{"../math/math":"bwQIx","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"10kvU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "copyCanvas", ()=>copyCanvas
);
/**
 * Determine if should disable imageSmoothing for transformation.
 * ImageSmoothing can make images blurry even when they're in the original scale and aligned with the pixelgrid.
 */ parcelHelpers.export(exports, "testShouldPixelate", ()=>testShouldPixelate
);
/**
 * @param destCtx - the canvas that will be drawn on
 * @param transformImage - image that will be drawn on canvas
 * @param transform - {x, y, width, height, angle} - x and y are center of transformImage
 * @param bounds object - optional {x, y, width, height} - crop of transformImage in transformImage image space
 * @param pixelated
 */ parcelHelpers.export(exports, "drawTransformedImageWithBounds", ()=>drawTransformedImageWithBounds
);
/**
 * all transformations are optional
 * center is the point around which will be scaled and rotated
 *
 * @param baseCanvas canvas - the canvas that will be drawn on
 * @param transformImage image|canvas - image that will be drawn on canvas
 * @param transformObj {center: {x, y}, scale: {x, y}, translate: {x, y}, angleDegree}
 */ parcelHelpers.export(exports, "drawTransformedImageOnCanvas", ()=>drawTransformedImageOnCanvas
);
parcelHelpers.export(exports, "createCheckerCanvas", ()=>createCheckerCanvas
);
parcelHelpers.export(exports, "createCheckerDataUrl", ()=>createCheckerDataUrl
);
/**
 * smooth resize image
 * @param canvas canvas - will be resized (modified)
 * @param w
 * @param h
 * @param tmp1 canvas - optional, provide to save resources
 * @param tmp2 canvas - optional, provide to save resources
 */ parcelHelpers.export(exports, "resizeCanvas", ()=>resizeCanvas
);
/**
 * puts naive greyscale version of image into alpha channel.
 * only writes a, doesn't write rgb
 * @param canvas
 */ parcelHelpers.export(exports, "convertToAlphaChannelCanvas", ()=>convertToAlphaChannelCanvas
);
var _createCanvas = require("./create-canvas");
function copyCanvas(canvas) {
    const resultCanvas = _createCanvas.createCanvas(canvas.width, canvas.height);
    const ctx = resultCanvas.getContext('2d');
    if (!ctx) throw new Error('2d context not supported or canvas already initialized');
    ctx.drawImage(canvas, 0, 0);
    return resultCanvas;
}
function testShouldPixelate(transform, scaleX, scaleY) {
    if (![
        1,
        -1
    ].includes(scaleX) || ![
        1,
        -1
    ].includes(scaleY) || transform.width % 1 !== 0 || transform.height % 1 !== 0 || Math.abs(transform.angleDeg) % 90 !== 0) return false;
    const whSwapped = Math.abs(transform.angleDeg - 90) % 180 === 0;
    const width = whSwapped ? transform.height : transform.width;
    const height = whSwapped ? transform.width : transform.height;
    return (Math.abs(width) % 2 === 0 && transform.x % 1 === 0 || Math.abs(width) % 2 === 1 && transform.x % 1 === 0.5) && (Math.abs(height) % 2 === 0 && transform.y % 1 === 0 || Math.abs(height) % 2 === 1 && transform.y % 1 === 0.5);
}
function drawTransformedImageWithBounds(destCtx, transformImage, transform, bounds, pixelated) {
    if (!bounds) bounds = {
        x: 0,
        y: 0,
        width: transformImage.width,
        height: transformImage.height
    };
    destCtx.save();
    if (pixelated) destCtx.imageSmoothingEnabled = false;
    else {
        destCtx.imageSmoothingEnabled = true;
        destCtx.imageSmoothingQuality = 'high';
    }
    destCtx.translate(transform.x, transform.y);
    destCtx.rotate(transform.angleDeg / 180 * Math.PI);
    destCtx.scale(transform.width > 0 ? 1 : -1, transform.height > 0 ? 1 : -1);
    destCtx.drawImage(transformImage, bounds.x, bounds.y, bounds.width, bounds.height, -Math.abs(transform.width) / 2, -Math.abs(transform.height) / 2, Math.abs(transform.width), Math.abs(transform.height));
    destCtx.restore();
}
function drawTransformedImageOnCanvas(baseCanvas, transformImage, transformObj) {
    transformObj = JSON.parse(JSON.stringify(transformObj));
    if (!transformObj.center) transformObj.center = {
        x: transformImage.width / 2,
        y: transformImage.height / 2
    };
    if (!transformObj.scale) transformObj.scale = {
        x: 1,
        y: 1
    };
    if (!transformObj.angleDegree) transformObj.angleDegree = 0;
    if (!transformObj.translate) transformObj.translate = {
        x: 0,
        y: 0
    };
    const ctx = baseCanvas.getContext('2d');
    if (!ctx) throw new Error('2d context not supported or canvas already initialized');
    ctx.save();
    if (Math.abs(transformObj.scale.x - 1) > 0.000001 || Math.abs(transformObj.scale.y - 1) > 0.000001 || Math.abs(transformObj.angleDegree % 90) > 0.000001) {
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
    } else ctx.imageSmoothingEnabled = false;
    ctx.translate(transformObj.translate.x, transformObj.translate.y);
    ctx.translate(transformObj.center.x, transformObj.center.y);
    ctx.rotate(transformObj.angleDegree / 180 * Math.PI);
    ctx.scale(transformObj.scale.x, transformObj.scale.y);
    ctx.translate(-transformObj.center.x, -transformObj.center.y);
    ctx.drawImage(transformImage, 0, 0, transformImage.width, transformImage.height);
    ctx.restore();
}
const createCheckerCanvas = function(size) {
    const canvas = _createCanvas.createCanvas();
    let ctx;
    if (size < 1) {
        canvas.width = 1;
        canvas.height = 1;
        ctx = canvas.getContext('2d');
        if (!ctx) throw new Error('2d context not supported or canvas already initialized');
        ctx.fillStyle = 'rgb(128, 128, 128)';
        ctx.fillRect(0, 0, 1, 1);
    } else if (size > 200) {
        canvas.width = 401;
        canvas.height = 401;
    } else {
        canvas.width = size * 2;
        canvas.height = size * 2;
        ctx = canvas.getContext('2d');
        if (!ctx) throw new Error('2d context not supported or canvas already initialized');
        ctx.fillStyle = 'rgb(255, 255, 255)';
        ctx.fillRect(0, 0, size * 2, size * 2);
        ctx.fillStyle = 'rgb(200, 200, 200)';
        ctx.fillRect(0, 0, size, size);
        ctx.fillRect(size, size, size * 2, size * 2);
    }
    return canvas;
};
const createCheckerDataUrl = function() {
    const cache = {
        '8': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAMElEQVQ4T2M8ceLEfwY8wNzcHJ80A+OoAcMiDP7//483HZw8eRJ/Ohg1gIFx6IcBAIhJUqnarXQ1AAAAAElFTkSuQmCC',
        '4': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAJ0lEQVQoU2M8ceLEfwYkYG5ujsxlYKSDgv///6O44eTJk6huoL0CAGsOKVVu8UYvAAAAAElFTkSuQmCC'
    };
    return function(size1, callback) {
        function create(size) {
            size = parseInt('' + size);
            if (cache['' + size]) return cache['' + size];
            const canvas = createCheckerCanvas(size);
            const result = canvas.toDataURL('image/png');
            cache['' + size] = result;
            return result;
        }
        if (callback) setTimeout(function() {
            callback(create(size1));
        }, 1);
        else return create(size1);
    };
}();
function resizeCanvas(canvas, w, h, tmp1, tmp2) {
    //determine base 2 exponents of old and new size
    function getBase2Obj(oldW, oldH, newW, newH) {
        const result = {
            oldWidthEx: Math.round(Math.log2(oldW)),
            oldHeightEx: Math.round(Math.log2(oldH)),
            newWidthEx: Math.ceil(Math.log2(newW)),
            newHeightEx: Math.ceil(Math.log2(newH))
        };
        result.oldWidthEx = Math.max(result.oldWidthEx, result.newWidthEx);
        result.oldHeightEx = Math.max(result.oldHeightEx, result.newHeightEx);
        return result;
    }
    if (!w || !h || w === canvas.width && h === canvas.height) return;
    w = Math.max(w, 1);
    h = Math.max(h, 1);
    if (w <= canvas.width && h <= canvas.height) {
        tmp1 = !tmp1 ? _createCanvas.createCanvas() : tmp1;
        tmp2 = !tmp2 ? _createCanvas.createCanvas() : tmp2;
        const base2 = getBase2Obj(canvas.width, canvas.height, w, h);
        //initially scale to a base of 2. unless new size is too close to old. e.g. sizing from 900 to 600
        tmp2.width = base2.oldWidthEx > base2.newWidthEx ? Math.pow(2, base2.oldWidthEx) : w;
        tmp2.height = base2.oldHeightEx > base2.newHeightEx ? Math.pow(2, base2.oldHeightEx) : h;
        tmp1.getContext('2d').save();
        tmp2.getContext('2d').save();
        let ew, eh;
        let buffer1 = tmp1, buffer2 = tmp2;
        ew = base2.oldWidthEx;
        eh = base2.oldHeightEx;
        let bufferCtx = buffer2.getContext('2d');
        bufferCtx.imageSmoothingEnabled = true;
        bufferCtx.imageSmoothingQuality = 'high';
        bufferCtx.globalCompositeOperation = 'copy';
        bufferCtx.drawImage(canvas, 0, 0, buffer2.width, buffer2.height);
        let currentWidth = buffer2.width;
        let currentHeight = buffer2.height;
        //stepwise half the size
        for(; ew > base2.newWidthEx || eh > base2.newHeightEx; ew--, eh--){
            bufferCtx = buffer1.getContext('2d');
            bufferCtx.imageSmoothingEnabled = true;
            bufferCtx.imageSmoothingQuality = 'high';
            bufferCtx.globalCompositeOperation = 'copy';
            const newWidth = ew > base2.newWidthEx ? currentWidth / 2 : currentWidth;
            const newHeight = eh > base2.newHeightEx ? currentHeight / 2 : currentHeight;
            //buffer also needs to be properly sized, unfortunately
            buffer1.width = newWidth;
            buffer1.height = newHeight;
            bufferCtx.drawImage(buffer2, 0, 0, currentWidth, currentHeight, 0, 0, newWidth, newHeight);
            currentWidth = newWidth;
            currentHeight = newHeight;
            //swap
            const tmp = buffer1;
            buffer1 = buffer2;
            buffer2 = tmp;
        }
        //when no longer can be halved, bring to target size
        canvas.width = w;
        canvas.height = h;
        const canvasCtx = canvas.getContext('2d');
        canvasCtx.save();
        canvasCtx.imageSmoothingEnabled = true;
        canvasCtx.imageSmoothingQuality = 'high';
        canvasCtx.drawImage(buffer2, 0, 0, currentWidth, currentHeight, 0, 0, w, h);
        canvasCtx.restore();
        tmp1.getContext('2d').restore();
        tmp2.getContext('2d').restore();
    } else if (w >= canvas.width && h >= canvas.height) {
        tmp1 = !tmp1 ? _createCanvas.createCanvas() : tmp1;
        tmp1.width = w;
        tmp1.height = h;
        const tmp1Ctx = tmp1.getContext('2d');
        tmp1Ctx.save();
        tmp1Ctx.imageSmoothingEnabled = true;
        tmp1Ctx.imageSmoothingQuality = 'high';
        tmp1Ctx.drawImage(canvas, 0, 0, w, h);
        tmp1Ctx.restore();
        canvas.width = w;
        canvas.height = h;
        canvas.getContext('2d').drawImage(tmp1, 0, 0);
    } else {
        resizeCanvas(canvas, w, canvas.height, tmp1, tmp2);
        resizeCanvas(canvas, w, h, tmp1, tmp2);
    }
}
function convertToAlphaChannelCanvas(canvas) {
    const imdat = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
    for(let i = 0; i < imdat.data.length; i += 4){
        if (imdat.data[i + 3] === 0) continue;
        imdat.data[i + 3] = (imdat.data[i] + imdat.data[i + 1] + imdat.data[i + 2]) / 3 * (imdat.data[i + 3] / 255);
    }
    canvas.getContext('2d').putImageData(imdat, 0, 0);
}

},{"./create-canvas":"lUl5x","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ikOLk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Matrix", ()=>Matrix
);
const Matrix = function() {
    // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Matrix_math_for_the_web
    // yes not optimized - but it's not used for physics simulations.
    // const perfTotal = 0;
    // point • matrix
    function multiplyMatrixAndPoint(matrix, point) {
        const result = [
            point[0] * matrix[0] + point[1] * matrix[4] + point[2] * matrix[8] + point[3] * matrix[12],
            point[0] * matrix[1] + point[1] * matrix[5] + point[2] * matrix[9] + point[3] * matrix[13],
            point[0] * matrix[2] + point[1] * matrix[6] + point[2] * matrix[10] + point[3] * matrix[14],
            point[0] * matrix[3] + point[1] * matrix[7] + point[2] * matrix[11] + point[3] * matrix[15] // w
        ];
        return result;
    }
    //matrixB • matrixA
    function multiplyMatrices(matrixA, matrixB) {
        // Slice the second matrix up into rows
        const row0 = [
            matrixB[0],
            matrixB[1],
            matrixB[2],
            matrixB[3]
        ];
        const row1 = [
            matrixB[4],
            matrixB[5],
            matrixB[6],
            matrixB[7]
        ];
        const row2 = [
            matrixB[8],
            matrixB[9],
            matrixB[10],
            matrixB[11]
        ];
        const row3 = [
            matrixB[12],
            matrixB[13],
            matrixB[14],
            matrixB[15]
        ];
        // Multiply each row by matrixA
        const result0 = multiplyMatrixAndPoint(matrixA, row0);
        const result1 = multiplyMatrixAndPoint(matrixA, row1);
        const result2 = multiplyMatrixAndPoint(matrixA, row2);
        const result3 = multiplyMatrixAndPoint(matrixA, row3);
        // Turn the result rows back into a single matrix
        return [
            result0[0],
            result0[1],
            result0[2],
            result0[3],
            result1[0],
            result1[1],
            result1[2],
            result1[3],
            result2[0],
            result2[1],
            result2[2],
            result2[3],
            result3[0],
            result3[1],
            result3[2],
            result3[3]
        ];
    }
    function createTranslationMatrix(x, y) {
        return [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            x,
            y,
            0,
            1
        ];
    }
    function createRotationMatrix(angleRad) {
        //let angleRad = angleDeg / 360 * 2 * Math.PI;
        return [
            Math.cos(-angleRad),
            -Math.sin(-angleRad),
            0,
            0,
            Math.sin(-angleRad),
            Math.cos(-angleRad),
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ];
    }
    function createScaleMatrix(f) {
        return [
            f,
            0,
            0,
            0,
            0,
            f,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ];
    }
    return {
        getIdentity: function() {
            return [
                1,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                1
            ];
        },
        multiplyMatrixAndPoint: multiplyMatrixAndPoint,
        multiplyMatrices: multiplyMatrices,
        createTranslationMatrix: createTranslationMatrix,
        createRotationMatrix: createRotationMatrix,
        createScaleMatrix: createScaleMatrix
    };
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8AWT9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Vec2", ()=>Vec2
);
const Vec2 = {
    add: function(p1, p2) {
        return {
            x: p1.x + p2.x,
            y: p1.y + p2.y
        };
    },
    sub: function(p1, p2) {
        return {
            x: p1.x - p2.x,
            y: p1.y - p2.y
        };
    },
    nor: function(p) {
        const len = Math.sqrt(Math.pow(p.x, 2) + Math.pow(p.y, 2));
        return {
            x: p.x / len,
            y: p.y / len
        };
    },
    len: function(p) {
        return Math.sqrt(Math.pow(p.x, 2) + Math.pow(p.y, 2));
    },
    dist: function(p1, p2) {
        return Vec2.len(Vec2.sub(p1, p2));
    },
    mul: function(p, s) {
        return {
            x: p.x * s,
            y: p.y * s
        };
    },
    angle: function(p1, p2) {
        return Math.atan2(p2.y - p1.y, p2.x - p1.x);
    },
    dot: function(a, b) {
        const aArr = [
            a.x,
            a.y
        ];
        const bArr = [
            b.x,
            b.y
        ];
        return aArr.map((x, i)=>aArr[i] * bArr[i]
        ).reduce((m, n)=>m + n
        );
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"azjNA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "projectPointOnLine", ()=>projectPointOnLine
);
parcelHelpers.export(exports, "PointLine", ()=>PointLine
);
parcelHelpers.export(exports, "BezierLine", ()=>BezierLine
);
parcelHelpers.export(exports, "SplineInterpolator", ()=>SplineInterpolator
);
parcelHelpers.export(exports, "quadraticSplineInput", ()=>quadraticSplineInput
);
var _vec2 = require("./vec2");
var _math = require("./math");
const projectPointOnLine = function(lineStart, lineEnd, p) {
    let x, y;
    if (lineStart.x === lineEnd.x) {
        x = lineStart.x;
        y = p.y;
        return {
            x: x,
            y: y
        };
    }
    const m = (lineEnd.y - lineStart.y) / (lineEnd.x - lineStart.x);
    const b = lineStart.y - m * lineStart.x;
    x = (m * p.y + p.x - m * b) / (m * m + 1);
    y = (m * m * p.y + m * p.x + b) / (m * m + 1);
    return {
        x: x,
        y: y
    };
};
const PointLine = function(params) {
    const segmentArr = [];
    const _this = this;
    for(let i1 = 0; i1 < params.points.length; i1++)(function(i) {
        let length = undefined;
        if (i < params.points.length - 1) length = _math.dist(params.points[i].x, params.points[i].y, params.points[i + 1].x, params.points[i + 1].y);
        segmentArr[i] = {
            x: params.points[i].x,
            y: params.points[i].y,
            length: length
        };
    })(i1);
    /**
     * @param dist number - distance in pixels, > 0
     * @returns {{x: number, y: number}}
     */ this.getAtDist = function(dist) {
        let remainder = Math.min(_this.getLength(), dist);
        let i = 0;
        for(; remainder > segmentArr[i].length && i < segmentArr.length - 2; i++)remainder -= segmentArr[i].length;
        const fac = Math.min(1, Math.max(0, remainder / segmentArr[i].length));
        return {
            x: segmentArr[i].x * (1 - fac) + segmentArr[i + 1].x * fac,
            y: segmentArr[i].y * (1 - fac) + segmentArr[i + 1].y * fac
        };
    };
    this.getLength = function() {
        let result = 0;
        for(let i = 0; i < segmentArr.length - 1; i++)result += segmentArr[i].length;
        return result;
    };
};
const BezierLine = function() {
    const _this = this;
    const pointArr = [];
    let lastDot = 0;
    let lastPoint;
    let lastCallbackPoint;
    let lastAngle;
    let lastSpacing = null;
    /**
     * creates bezier curve from control points
     *
     * @param p1 - control point 1 {x: float, y: float}
     * @param p2 - control point 2 {x: float, y: float}
     * @param p3 - control point 3 {x: float, y: float}
     * @param p4 - control point 4 {x: float, y: float}
     * @param resolution - int
     * @returns {Array} - bezier curve made up of points {x: float, y: float}
     */ function getBezierPoints(p1, p2, p3, p4, resolution) {
        const curvePoints = [];
        let t, result;
        for(let i = 0; i <= resolution; i++){
            t = i / resolution;
            result = {
            };
            result.x = Math.pow(1 - t, 3) * p1.x + 3 * Math.pow(1 - t, 2) * t * p2.x + 3 * (1 - t) * Math.pow(t, 2) * p3.x + Math.pow(t, 3) * p4.x;
            result.y = Math.pow(1 - t, 3) * p1.y + 3 * Math.pow(1 - t, 2) * t * p2.y + 3 * (1 - t) * Math.pow(t, 2) * p3.y + Math.pow(t, 3) * p4.y;
            curvePoints[curvePoints.length] = result;
        }
        return curvePoints;
    }
    /**
     *
     * add now point to line
     * line will go until the previous point
     *
     * @param x - coord of new point
     * @param y - coord of new point
     * @param spacing - space between each step
     * @param callback - calls for each step - x, y, t - t is 0-1 how far along
     * @param controlsCallback - calls that callback with the bezier control points p1, p2, p3, p4 - each {x: float, y: float}
     */ this.add = function(x, y, spacing, callback, controlsCallback) {
        if (lastPoint && x === lastPoint.x && y === lastPoint.y) return;
        lastPoint = {
            x: x,
            y: y
        };
        pointArr[pointArr.length] = {
            x: x,
            y: y,
            spacing: spacing
        };
        //calculate directions
        if (pointArr.length === 1) {
            lastSpacing = spacing;
            return;
        } else if (pointArr.length === 2) {
            pointArr[0].dir = _vec2.Vec2.nor(_vec2.Vec2.sub(pointArr[1], pointArr[0]));
            lastDot = spacing;
            lastSpacing = spacing;
            return;
        } else {
            const pointM1 = pointArr[pointArr.length - 1];
            const pointM2 = pointArr[pointArr.length - 2];
            const pointM3 = pointArr[pointArr.length - 3];
            pointM2.dir = _vec2.Vec2.nor(_vec2.Vec2.sub(pointM1, pointM3));
            if (isNaN(pointM2.dir.x) || isNaN(pointM2.dir.y)) //when xy -3 == -1
            pointM2.dir = JSON.parse(JSON.stringify(pointM3.dir));
        }
        //get bezier curve
        const a = pointArr[pointArr.length - 3];
        const b = pointArr[pointArr.length - 2];
        const p1 = a;
        const p2 = _vec2.Vec2.add(a, _vec2.Vec2.mul(a.dir, _vec2.Vec2.dist(a, b) / 4));
        const p3 = _vec2.Vec2.sub(b, _vec2.Vec2.mul(b.dir, _vec2.Vec2.dist(a, b) / 4));
        const p4 = b;
        let pointLine;
        if (callback) {
            let curvePoints;
            curvePoints = getBezierPoints(p1, p2, p3, p4, 20);
            pointLine = new PointLine({
                points: curvePoints
            });
        } else pointLine = new PointLine({
            points: [
                p1,
                p4
            ]
        });
        //interate over curve with spacing and callback
        const len = pointLine.getLength();
        let tempSpacing = _math.mix(lastSpacing, spacing, _math.clamp(lastDot / len, 0, 1));
        let d = lastDot;
        for(; d <= len; d += tempSpacing){
            tempSpacing = _math.mix(lastSpacing, spacing, _math.clamp(d / len, 0, 1));
            const point = pointLine.getAtDist(d);
            const angle = lastCallbackPoint ? _math.pointsToAngleDeg(lastCallbackPoint, point) : undefined;
            if (callback) callback({
                x: point.x,
                y: point.y,
                t: d / len,
                angle: angle,
                dAngle: lastCallbackPoint ? angle - lastAngle : 0
            });
            lastCallbackPoint = point;
            lastAngle = angle;
        }
        if (callback) lastDot = d - len;
        else {
            lastDot = 0;
            controlsCallback({
                p1: p1,
                p2: p2,
                p3: p3,
                p4: p4
            });
        }
        lastSpacing = spacing;
    };
    this.addFinal = function(spacing, callback, controlsCallback) {
        if (pointArr.length < 2) return;
        const p1 = pointArr[pointArr.length - 2];
        const p2 = pointArr[pointArr.length - 1];
        const newP = _vec2.Vec2.add(p2, _vec2.Vec2.sub(p2, p1));
        _this.add(newP.x, newP.y, spacing, callback, controlsCallback);
    };
};
const SplineInterpolator = function(points) {
    const n = points.length;
    this.xa = [];
    this.ya = [];
    this.u = [];
    this.y2 = [];
    let i;
    const first = points[0][0];
    const last = points[points.length - 1][0];
    points.sort(function(a, b) {
        return a[0] - b[0];
    });
    for(i = 0; i < n; i++){
        this.xa.push(points[i][0]);
        this.ya.push(points[i][1]);
    }
    this.u[0] = 0;
    this.y2[0] = 0;
    for(i = 1; i < n - 1; ++i){
        // This is the decomposition loop of the tridiagonal algorithm.
        // y2 and u are used for temporary storage of the decomposed factors.
        const wx = this.xa[i + 1] - this.xa[i - 1];
        const sig = (this.xa[i] - this.xa[i - 1]) / wx;
        const p = sig * this.y2[i - 1] + 2;
        this.y2[i] = (sig - 1) / p;
        const ddydx = (this.ya[i + 1] - this.ya[i]) / (this.xa[i + 1] - this.xa[i]) - (this.ya[i] - this.ya[i - 1]) / (this.xa[i] - this.xa[i - 1]);
        this.u[i] = (6 * ddydx / wx - sig * this.u[i - 1]) / p;
    }
    this.y2[n - 1] = 0;
    // This is the backsubstitution loop of the tridiagonal algorithm
    for(i = n - 2; i >= 0; --i)this.y2[i] = this.y2[i] * this.y2[i + 1] + this.u[i];
    this.getFirstX = function() {
        return first;
    };
    this.getLastX = function() {
        return last;
    };
};
SplineInterpolator.prototype.interpolate = function(x) {
    const n = this.ya.length;
    let klo = 0;
    let khi = n - 1;
    // We will find the right place in the table by means of
    // bisection. This is optimal if sequential calls to this
    // routine are at random values of x. If sequential calls
    // are in order, and closely spaced, one would do better
    // to store previous values of klo and khi.
    while(khi - klo > 1){
        const k = khi + klo >> 1;
        if (this.xa[k] > x) khi = k;
        else klo = k;
    }
    const h = this.xa[khi] - this.xa[klo];
    const a = (this.xa[khi] - x) / h;
    const b = (x - this.xa[klo]) / h;
    // Cubic spline polynomial is now evaluated.
    return a * this.ya[klo] + b * this.ya[khi] + ((a * a * a - a) * this.y2[klo] + (b * b * b - b) * this.y2[khi]) * (h * h) / 6;
};
/**
 * find x to y. simply by stepping through. suboptimal, so don't call often.
 * searches in x 0-1 range
 *
 * @param y
 * @param resolution
 */ SplineInterpolator.prototype.findX = function(y, resolution) {
    let x = null;
    let dist = null;
    for(let i = 0; i <= resolution; i++){
        const tempX = i / resolution;
        const tempY = this.interpolate(tempX);
        if (x === null) {
            x = tempX;
            dist = Math.abs(tempY - y);
            continue;
        }
        const tempDist = Math.abs(tempY - y);
        if (tempDist < dist) {
            x = tempX;
            dist = tempDist;
        } else break;
    }
    return x;
};
const quadraticSplineInput = function(startVal, endVal, stepSize) {
    function round(v, dec) {
        return Math.round(v * Math.pow(10, dec)) / Math.pow(10, dec);
    }
    const resultArr = [];
    for(let i = 0; i <= 1; i += stepSize)resultArr.push([
        round(i, 4),
        round(startVal + Math.pow(i, 2) * (endVal - startVal), 4)
    ]);
    return resultArr;
};

},{"./vec2":"8AWT9","./math":"bwQIx","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8BDeD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// based on js color conversion http://www.webtoolkit.info/
parcelHelpers.export(exports, "HSV", ()=>HSV
);
parcelHelpers.export(exports, "RGB", ()=>RGB
);
parcelHelpers.export(exports, "CMYK", ()=>CMYK
);
parcelHelpers.export(exports, "ColorConverter", ()=>ColorConverter
);
parcelHelpers.export(exports, "testIsWhiteBestContrast", ()=>testIsWhiteBestContrast
);
class HSV {
    constructor(h, s, v){
        this.h = Math.max(0, Math.min(360, h));
        this.s = Math.max(0.001, Math.min(100, s)); //bug when 0
        this.v = Math.max(0, Math.min(100, v));
    }
}
class RGB {
    constructor(r, g, b){
        this.r = Math.max(0, Math.min(255, r));
        this.g = Math.max(0, Math.min(255, g));
        this.b = Math.max(0, Math.min(255, b));
    }
}
class CMYK {
    constructor(c, m, y, k){
        this.c = Math.max(0, Math.min(100, c));
        this.m = Math.max(0, Math.min(100, m));
        this.y = Math.max(0, Math.min(100, y));
        this.k = Math.max(0, Math.min(100, k));
    }
}
const ColorConverter = {
    _RGBtoHSV: function(RGB1) {
        const result = new HSV(0, 0, 0);
        const r = RGB1.r / 255;
        const g = RGB1.g / 255;
        const b = RGB1.b / 255;
        const minVal = Math.min(r, g, b);
        const maxVal = Math.max(r, g, b);
        const delta = maxVal - minVal;
        result.v = maxVal;
        if (delta == 0) {
            result.h = 0;
            result.s = 0;
        } else {
            result.s = delta / maxVal;
            const del_R = ((maxVal - r) / 6 + delta / 2) / delta;
            const del_G = ((maxVal - g) / 6 + delta / 2) / delta;
            const del_B = ((maxVal - b) / 6 + delta / 2) / delta;
            if (r == maxVal) result.h = del_B - del_G;
            else if (g == maxVal) result.h = 1 / 3 + del_R - del_B;
            else if (b == maxVal) result.h = 2 / 3 + del_G - del_R;
            if (result.h < 0) result.h += 1;
            if (result.h > 1) result.h -= 1;
        }
        result.h = Math.round(result.h * 360);
        result.s = Math.round(result.s * 100);
        result.v = Math.round(result.v * 100);
        return result;
    },
    _HSVtoRGB: function(HSV1) {
        const result = new RGB(0, 0, 0);
        let var_h, var_i, var_1, var_2, var_3, var_r, var_g, var_b;
        const h = HSV1.h / 360 % 1;
        const s = HSV1.s / 100;
        const v = HSV1.v / 100;
        if (s == 0) {
            result.r = v * 255;
            result.g = v * 255;
            result.b = v * 255;
        } else {
            var_h = h * 6;
            var_i = Math.floor(var_h);
            var_1 = v * (1 - s);
            var_2 = v * (1 - s * (var_h - var_i));
            var_3 = v * (1 - s * (1 - (var_h - var_i)));
            if (var_i == 0) {
                var_r = v;
                var_g = var_3;
                var_b = var_1;
            } else if (var_i == 1) {
                var_r = var_2;
                var_g = v;
                var_b = var_1;
            } else if (var_i == 2) {
                var_r = var_1;
                var_g = v;
                var_b = var_3;
            } else if (var_i == 3) {
                var_r = var_1;
                var_g = var_2;
                var_b = v;
            } else if (var_i == 4) {
                var_r = var_3;
                var_g = var_1;
                var_b = v;
            } else {
                var_r = v;
                var_g = var_1;
                var_b = var_2;
            }
            result.r = var_r * 255;
            result.g = var_g * 255;
            result.b = var_b * 255;
            result.r = Math.round(result.r);
            result.g = Math.round(result.g);
            result.b = Math.round(result.b);
        }
        return result;
    },
    _CMYKtoRGB: function(CMYK1) {
        const result = new RGB(0, 0, 0);
        const c = CMYK1.c / 100;
        const m = CMYK1.m / 100;
        const y = CMYK1.y / 100;
        const k = CMYK1.k / 100;
        result.r = 1 - Math.min(1, c * (1 - k) + k);
        result.g = 1 - Math.min(1, m * (1 - k) + k);
        result.b = 1 - Math.min(1, y * (1 - k) + k);
        result.r = Math.round(result.r * 255);
        result.g = Math.round(result.g * 255);
        result.b = Math.round(result.b * 255);
        return result;
    },
    _RGBtoCMYK: function(RGB2) {
        const result = new CMYK(0, 0, 0, 0);
        const r = RGB2.r / 255;
        const g = RGB2.g / 255;
        const b = RGB2.b / 255;
        result.k = Math.min(1 - r, 1 - g, 1 - b);
        result.c = (1 - r - result.k) / (1 - result.k);
        result.m = (1 - g - result.k) / (1 - result.k);
        result.y = (1 - b - result.k) / (1 - result.k);
        result.c = Math.round(result.c * 100);
        result.m = Math.round(result.m * 100);
        result.y = Math.round(result.y * 100);
        result.k = Math.round(result.k * 100);
        return result;
    },
    toRGB: function(o) {
        if (o instanceof RGB) return o;
        if (o instanceof HSV) return this._HSVtoRGB(o);
        if (o instanceof CMYK) return this._CMYKtoRGB(o);
    },
    toHSV: function(o) {
        if (o instanceof HSV) return o;
        if (o instanceof RGB) return this._RGBtoHSV(o);
        if (o instanceof CMYK) return this._RGBtoHSV(this._CMYKtoRGB(o));
    },
    toCMYK: function(o) {
        if (o instanceof CMYK) return o;
        if (o instanceof RGB) return this._RGBtoCMYK(o);
        if (o instanceof HSV) return this._RGBtoCMYK(this._HSVtoRGB(o));
    },
    toHexString: function(o) {
        if (o instanceof RGB) {
            let ha = parseInt('' + o.r).toString(16);
            let hb = parseInt('' + o.g).toString(16);
            let hc = parseInt('' + o.b).toString(16);
            if (ha.length == 1) ha = '0' + ha;
            if (hb.length == 1) hb = '0' + hb;
            if (hc.length == 1) hc = '0' + hc;
            return ha + hb + hc;
        }
    },
    toRgbStr: function(rgbObj) {
        return 'rgb(' + Math.round(rgbObj.r) + ', ' + Math.round(rgbObj.g) + ', ' + Math.round(rgbObj.b) + ')';
    },
    toRgbaStr: function(rgbaObj) {
        return 'rgba(' + Math.round(rgbaObj.r) + ', ' + Math.round(rgbaObj.g) + ', ' + Math.round(rgbaObj.b) + ', ' + rgbaObj.a + ')';
    },
    hexToRGB: function(hexStr) {
        hexStr = hexStr.trim();
        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
        const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hexStr = hexStr.replace(shorthandRegex, function(m, r, g, b) {
            return r + r + g + g + b + b;
        });
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hexStr);
        return result ? new RGB(parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)) : null;
    }
};
function testIsWhiteBestContrast(rgbObj) {
    return rgbObj.r * 0.299 + rgbObj.g * 0.587 + rgbObj.b * 0.114 < 125;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"RH5Pp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "appendTextDiv", ()=>appendTextDiv
);
/**
 * Is an input element focused.
 * Set attribute "data-ignore-focus" to "true" if its focus should be ignored.
 *
 * @param getAll - check all, even those with "data-ignore-focus" = "true"
 */ parcelHelpers.export(exports, "isInputFocused", ()=>isInputFocused
);
/**
 * clears text selection in window
 */ parcelHelpers.export(exports, "clearSelection", ()=>clearSelection
);
parcelHelpers.export(exports, "makeUnfocusable", ()=>makeUnfocusable
);
// window['els'] = els;
/**
 *
 * Create DOM element - div by default
 * params = {
 * 	    parent: someOtherDiv,
 * 	    css: {
 * 		    width: "500px",
 * 		    backgroundColor: "#fff"
 * 	    },
 * 	    content: "test", //or  content: [divA, divB, divC]   or content: someDiv
 * 	    className: "bla",
 *      id: "bla"
 * }
 *
 * @param params
 */ parcelHelpers.export(exports, "el", ()=>el
);
/**
 * removes event listeners for Elements created via el()
 * @param el
 */ parcelHelpers.export(exports, "destroyEl", ()=>destroyEl
);
var _eventListener = require("../input/event-listener");
var _base = require("./base");
var _bb = require("../bb");
function appendTextDiv(target, text) {
    const div = document.createElement('div');
    div.innerHTML = text;
    target.appendChild(div);
    return div;
}
function isInputFocused(getAll = false) {
    let result = document.activeElement && [
        'INPUT',
        'TEXTAREA'
    ].includes(document.activeElement.tagName);
    if (getAll) return result;
    else return result && !document.activeElement.getAttribute('data-ignore-focus');
}
function clearSelection() {
    if (window.getSelection) {
        const sel = window.getSelection();
        if (sel) {
            if (sel.empty) sel.empty();
            else if (sel.removeAllRanges) sel.removeAllRanges();
        }
    } else if ('selection' in document) document.selection.empty();
}
const makeUnfocusable = function() {
    function preventFocus(event) {
        event.preventDefault();
        let didFocusRelated = false;
        if (event.relatedTarget) try {
            event.relatedTarget.focus();
            didFocusRelated = true;
        } catch (e) {
            console.error('failed to focus');
        }
        if (!didFocusRelated) event.currentTarget.blur();
    }
    return function(el1) {
        el1.setAttribute('tabindex', '-1');
        _eventListener.addEventListener(el1, 'focus', preventFocus);
    };
}();
const els = [];
function el(params) {
    const div = document.createElement(params.tagName ? params.tagName : 'div');
    const arr = [];
    if (params.css) _base.css(div, params.css);
    if (params.content) {
        if (typeof params.content === "string") div.innerHTML = params.content;
        else if (Array.isArray(params.content)) _bb.BB.append(div, params.content);
        else div.appendChild(params.content);
    }
    if (params.textContent) div.textContent = params.textContent;
    if (params.className) div.className = params.className;
    if (params.id) div.id = params.id;
    if (params.parent) params.parent.appendChild(div);
    if ('title' in params && params.title !== undefined) div.title = params.title;
    const listeners = [];
    if ('onClick' in params) {
        _eventListener.addEventListener(div, 'click', params.onClick);
        listeners.push([
            'click',
            params.onClick
        ]);
    }
    if ('onChange' in params) {
        _eventListener.addEventListener(div, 'change', params.onChange);
        listeners.push([
            'change',
            params.onChange
        ]);
    }
    if (listeners.length > 0) els.push({
        el: div,
        listeners: listeners
    });
    if ('custom' in params) {
        const customKeyArr = Object.keys(params.custom);
        for(let i = 0; i < customKeyArr.length; i++)div.setAttribute(customKeyArr[i], params.custom[customKeyArr[i]]);
    }
    return div;
}
function destroyEl(el2) {
    for(let i = 0; i < els.length; i++){
        const item1 = els[i];
        if (item1.el === el2) {
            item1.listeners.forEach((item)=>{
                el2.removeEventListener(item[0], item[1]);
            });
            els.splice(i, 1);
            return;
        }
    }
    // not found
    return;
}

},{"../input/event-listener":"9MYB6","./base":"5EeOC","../bb":"e3nbn","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5OFfM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BbLog", ()=>BbLog
);
class BbLog {
    constructor(){
    }
    static subscribe(listener) {
        if (BbLog.listeners.includes(listener)) return;
        BbLog.listeners.push(listener);
    }
    static unsubscribe(listener) {
        for(let i = 0; i < BbLog.listeners.length; i++)if (listener === BbLog.listeners[i]) {
            BbLog.listeners.splice(i, 1);
            return;
        }
    }
    static emit(msg) {
        BbLog.listeners.forEach((item)=>{
            item(msg);
        });
    }
}
BbLog.listeners = [];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"iOEIY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * LocalStorage wrapper that does not throw exceptions.
 * If cookies disabled in Safari localStorage interactions throw exception "insecure operation"
 */ parcelHelpers.export(exports, "LocalStorage", ()=>LocalStorage
);
class LocalStorage {
    static getItem(key) {
        let result = null;
        try {
            result = localStorage.getItem(key);
        } catch (e) {
            this.error = e;
        }
        return result;
    }
    static setItem(key, value) {
        try {
            localStorage.setItem(key, value);
        } catch (e) {
            this.error = e;
        }
    }
    static removeItem(key) {
        try {
            localStorage.removeItem(key);
        } catch (e) {
            this.error = e;
        }
    }
    static getError() {
        return this.error;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3bnx1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "KL", ()=>KL
);
var _klHistory = require("./history/kl-history");
var _popup = require("./ui/modals/popup");
var _modalCount = require("./ui/modals/modal-count");
var _checkbox = require("./ui/base-components/checkbox");
var _input = require("./ui/base-components/input");
var _select = require("./ui/base-components/select");
var _imageToggle = require("./ui/base-components/image-toggle");
var _imageRadioList = require("./ui/base-components/image-radio-list");
var _penPressureToggle = require("./ui/base-components/pen-pressure-toggle");
var _klSlider = require("./ui/base-components/kl-slider");
var _sliderFalloff = require("./ui/base-components/slider-falloff");
var _colorSliderHexDialog = require("./ui/modals/color-slider-hex-dialog");
var _klColorSlider = require("./ui/base-components/kl-color-slider");
var _klColorSliderSmall = require("./ui/base-components/kl-color-slider-small");
var _pointSlider = require("./ui/base-components/point-slider");
var _colorOptions = require("./ui/base-components/color-options");
var _options = require("./ui/base-components/options");
var _statusOverlay = require("./ui/components/status-overlay");
var _exportDialogDeprecated = require("./ui/modals/export-dialog-deprecated");
var _cropCopy = require("./ui/components/crop-copy");
var _clipboardDialog = require("./ui/modals/clipboard-dialog");
var _klLayerManager = require("./ui/tool-tabs/kl-layer-manager");
var _workspaceSvgOverlay = require("./canvas-ui/workspace-svg-overlay");
var _klCanvasWorkspace = require("./canvas-ui/kl-canvas-workspace");
var _canvasPreview = require("./canvas-ui/canvas-preview");
var _freeTransform = require("./ui/components/free-transform");
var _freeTransformCanvas = require("./ui/components/free-transform-canvas");
var _cropper = require("./ui/components/cropper");
var _layerPreview = require("./ui/components/layer-preview");
var _showReminderToast = require("./ui/components/show-reminder-toast");
var _fittedImage = require("./ui/components/fitted-image");
var _showImportAsLayerDialog = require("./ui/modals/show-import-as-layer-dialog");
var _klImageDropper = require("./ui/components/kl-image-dropper");
var _overlayToolspace = require("./ui/components/overlay-toolspace");
var _toolspaceTopRow = require("./ui/components/toolspace-top-row");
var _toolDropdown = require("./ui/components/tool-dropdown");
var _toolspaceToolRow = require("./ui/components/toolspace-tool-row");
var _toolspaceStabilizerRow = require("./ui/components/toolspace-stabilizer-row");
var _tabRow = require("./ui/components/tab-row");
var _handUi = require("./ui/tool-tabs/hand-ui");
var _fillUi = require("./ui/tool-tabs/fill-ui");
var _textUi = require("./ui/tool-tabs/text-ui");
var _shapeUi = require("./ui/tool-tabs/shape-ui");
var _newImageDialog = require("./ui/modals/new-image-dialog");
var _toolspaceCollapser = require("./ui/components/toolspace-collapser");
var _renderText = require("./image-operations/render-text");
var _textToolDialog = require("./ui/modals/text-tool-dialog");
var _showImportImageDialog = require("./ui/modals/show-import-image-dialog");
var _floodFill = require("./image-operations/flood-fill");
var _psd = require("./storage/psd");
var _shapeTool = require("./image-operations/shape-tool");
var _klCanvas = require("./canvas/kl-canvas");
var _indexedDb = require("./storage/indexed-db");
var _filters = require("./filters/filters");
var _brushes = require("./brushes/brushes");
var _brushesUi = require("./brushes-ui/brushes-ui");
var _showIframePopup = require("./ui/modals/show-iframe-popup");
var _radioList = require("./ui/base-components/radio-list");
var _browserStorageUi = require("./ui/components/browser-storage-ui");
var _drawProject = require("./canvas/draw-project");
var _projectStore = require("./storage/project-store");
var _fileTab = require("./ui/tool-tabs/file-tab");
var _filterTab = require("./ui/tool-tabs/filter-tab");
var _imgurUpload = require("./ui/modals/imgur-upload");
var _agPsdWrapper = require("./storage/ag-psd-wrapper");
var _saveReminder = require("./ui/components/save-reminder");
var _saveToComputer = require("./storage/save-to-computer");
var _undoRedoCatchup = require("./history/undo-redo-catchup");
var _brushSettingService = require("./brushes-ui/brush-setting-service");
var _boxToggle = require("./ui/base-components/box-toggle");
var _settingsTab = require("./ui/tool-tabs/settings-tab");
var _toolspaceScroller = require("./ui/components/toolspace-scroller");
const KL = {
    brushes: // --- brushes ---
    _brushes.brushes,
    brushesUI: _brushesUi.brushesUI,
    BrushSettingService: _brushSettingService.BrushSettingService,
    KlCanvas: // --- canvas ---
    _klCanvas.KlCanvas,
    drawProject: _drawProject.drawProject,
    WorkspaceSvgOverlay: // --- canvas ui ---
    _workspaceSvgOverlay.WorkspaceSvgOverlay,
    KlCanvasWorkspace: _klCanvasWorkspace.KlCanvasWorkspace,
    KlCanvasPreview: _canvasPreview.KlCanvasPreview,
    filterLibStatus: // --- filters ---
    _filters.filterLibStatus,
    filterLib: _filters.filterLib,
    UndoRedoCatchup: // --- history ---
    _undoRedoCatchup.UndoRedoCatchup,
    renderText: // --- image operations ---
    _renderText.renderText,
    floodFillBits: _floodFill.floodFillBits,
    ShapeTool: _shapeTool.ShapeTool,
    drawShape: _shapeTool.drawShape,
    PSD: // --- storage ---
    _psd,
    setDbName: _indexedDb.setDbName,
    indexedDb: _indexedDb,
    ProjectStore: _projectStore.ProjectStore,
    loadAgPsd: _agPsdWrapper.loadAgPsd,
    SaveToComputer: _saveToComputer.SaveToComputer,
    calcSliderFalloffFactor: // --- ui - base components ---
    _sliderFalloff.calcSliderFalloffFactor,
    Checkbox: _checkbox.Checkbox,
    input: _input.input,
    Select: _select.Select,
    ImageToggle: _imageToggle.ImageToggle,
    ImageRadioList: _imageRadioList.ImageRadioList,
    RadioList: _radioList.RadioList,
    penPressureToggle: _penPressureToggle.penPressureToggle,
    KlSlider: _klSlider.KlSlider,
    HexColorDialog: _colorSliderHexDialog.HexColorDialog,
    KlColorSlider: _klColorSlider.KlColorSlider,
    KlSmallColorSlider: _klColorSliderSmall.KlSmallColorSlider,
    PointSlider: _pointSlider.PointSlider,
    ColorOptions: _colorOptions.ColorOptions,
    Options: _options.Options,
    BoxToggle: _boxToggle.BoxToggle,
    StatusOverlay: // --- ui - components ---
    _statusOverlay.StatusOverlay,
    CropCopy: _cropCopy.CropCopy,
    FreeTransform: _freeTransform.FreeTransform,
    FreeTransformCanvas: _freeTransformCanvas.FreeTransformCanvas,
    Cropper: _cropper.Cropper,
    LayerPreview: _layerPreview.LayerPreview,
    showSaveReminderToast: _showReminderToast.showSaveReminderToast,
    FittedImage: _fittedImage.FittedImage,
    KlImageDropper: _klImageDropper.KlImageDropper,
    OverlayToolspace: _overlayToolspace.OverlayToolspace,
    ToolspaceTopRow: _toolspaceTopRow.ToolspaceTopRow,
    ToolDropdown: _toolDropdown.ToolDropdown,
    ToolspaceToolRow: _toolspaceToolRow.ToolspaceToolRow,
    ToolspaceStabilizerRow: _toolspaceStabilizerRow.ToolspaceStabilizerRow,
    TabRow: _tabRow.TabRow,
    ToolspaceCollapser: _toolspaceCollapser.ToolspaceCollapser,
    BrowserStorageUi: _browserStorageUi.BrowserStorageUi,
    SaveReminder: _saveReminder.SaveReminder,
    ToolspaceScroller: _toolspaceScroller.ToolspaceScroller,
    dialogCounter: // --- ui - modals ---
    _modalCount.dialogCounter,
    popup: _popup.popup,
    Popup: _popup.Popup,
    exportDialog: _exportDialogDeprecated.exportDialog,
    clipboardDialog: _clipboardDialog.clipboardDialog,
    showImportAsLayerDialog: _showImportAsLayerDialog.showImportAsLayerDialog,
    newImageDialog: _newImageDialog.newImageDialog,
    textToolDialog: _textToolDialog.textToolDialog,
    showImportImageDialog: _showImportImageDialog.showImportImageDialog,
    showIframePopup: _showIframePopup.showIframePopup,
    imgurUpload: _imgurUpload.imgurUpload,
    HandUi: // --- ui - tool tabs ---
    _handUi.HandUi,
    FillUi: _fillUi.FillUi,
    TextUi: _textUi.TextUi,
    ShapeUi: _shapeUi.ShapeUi,
    FileTab: _fileTab.FileTab,
    FilterTab: _filterTab.FilterTab,
    SettingsTab: _settingsTab.SettingsTab,
    klLayerManager: _klLayerManager.klLayerManager,
    klHistory: _klHistory.klHistory,
    DecoyKlHistory: _klHistory.DecoyKlHistory
};

},{"./history/kl-history":"ai9zE","./ui/modals/popup":"7D028","./ui/modals/modal-count":"5hzLs","./ui/base-components/checkbox":"clzcQ","./ui/base-components/input":"1HM9r","./ui/base-components/select":"gIUAj","./ui/base-components/image-toggle":"85Ix1","./ui/base-components/image-radio-list":"jngG4","./ui/base-components/pen-pressure-toggle":"1AVub","./ui/base-components/kl-slider":"1Vedp","./ui/base-components/slider-falloff":"2HhBa","./ui/modals/color-slider-hex-dialog":"6s9Kq","./ui/base-components/kl-color-slider":"bb2MR","./ui/base-components/kl-color-slider-small":"5etHO","./ui/base-components/point-slider":"evhHh","./ui/base-components/color-options":"6ALHb","./ui/base-components/options":"b8ZKE","./ui/components/status-overlay":"jNNjC","./ui/modals/export-dialog-deprecated":"3f7X2","./ui/components/crop-copy":"fSFui","./ui/modals/clipboard-dialog":"hZ9ke","./ui/tool-tabs/kl-layer-manager":"8soTa","./canvas-ui/workspace-svg-overlay":"1QQyo","./canvas-ui/kl-canvas-workspace":"ekALo","./canvas-ui/canvas-preview":"9a0UP","./ui/components/free-transform":"gt2Ud","./ui/components/free-transform-canvas":"fVB2B","./ui/components/cropper":"eE4e1","./ui/components/layer-preview":"g26AQ","./ui/components/show-reminder-toast":"dKY7k","./ui/components/fitted-image":"ipe5S","./ui/modals/show-import-as-layer-dialog":"c9vtS","./ui/components/kl-image-dropper":"bpE7E","./ui/components/overlay-toolspace":"eLxes","./ui/components/toolspace-top-row":"5LPAW","./ui/components/tool-dropdown":"3p7MV","./ui/components/toolspace-tool-row":"7wDA7","./ui/components/toolspace-stabilizer-row":"lUTMl","./ui/components/tab-row":"kxZMh","./ui/tool-tabs/hand-ui":"am8Pr","./ui/tool-tabs/fill-ui":"axy3K","./ui/tool-tabs/text-ui":"LoWaK","./ui/tool-tabs/shape-ui":"cX1I2","./ui/modals/new-image-dialog":"fQl05","./ui/components/toolspace-collapser":"hgEFd","./image-operations/render-text":"amc9m","./ui/modals/text-tool-dialog":"5Cjgq","./ui/modals/show-import-image-dialog":"dtyfo","./image-operations/flood-fill":"hXVZJ","./storage/psd":"4VGUb","./image-operations/shape-tool":"22W2J","./canvas/kl-canvas":"7NlZB","./storage/indexed-db":"7mvlr","./filters/filters":"d4Ymd","./brushes/brushes":"34S30","./brushes-ui/brushes-ui":"icb0x","./ui/modals/show-iframe-popup":"gIAOL","./ui/base-components/radio-list":"67Kg4","./ui/components/browser-storage-ui":"4iUpn","./canvas/draw-project":"4pmbZ","./storage/project-store":"3f0UC","./ui/tool-tabs/file-tab":"gDKzx","./ui/tool-tabs/filter-tab":"8j5rC","./ui/modals/imgur-upload":"bCFNJ","./storage/ag-psd-wrapper":"iBRLF","./ui/components/save-reminder":"c0KDT","./storage/save-to-computer":"c9ARV","./history/undo-redo-catchup":"9mjxU","./brushes-ui/brush-setting-service":"6eJtU","./ui/base-components/box-toggle":"RbMtc","./ui/tool-tabs/settings-tab":"jwTKz","./ui/components/toolspace-scroller":"4YUOX","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ai9zE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DecoyKlHistory", ()=>DecoyKlHistory
);
parcelHelpers.export(exports, "KlHistory", ()=>KlHistory
);
parcelHelpers.export(exports, "klHistory", ()=>klHistory
);
let historyInstance = false;
class DecoyKlHistory {
    pause(b) {
    }
    addListener(l) {
    }
    push(e) {
    }
    undo() {
        return [];
    }
    redo() {
        return [];
    }
    getAll() {
        return [];
    }
    canRedo() {
        return false;
    }
    canUndo() {
        return false;
    }
    getState() {
        return 0;
    }
    getActionNumber() {
        return 0;
    }
}
class KlHistory {
    broadcast(p) {
        setTimeout(()=>{
            for(let i = 0; i < this.listeners.length; i++)this.listeners[i](p);
            this.state++;
        }, 1);
    }
    // ---- public ----
    constructor(){
        this.max // max number undo steps
         = 20;
        if (historyInstance) throw new Error('klHistory already instantiated');
        historyInstance = true;
        this.state = 0;
        this.dataArr = [];
        this.listeners = [];
        this.pauseStack = 0;
        this.maxState = -1;
        this.actionNumber = -1;
    }
    /**
     * you need pause because there are sometimes actions that would cause other
     * undo steps
     * for example a filter that does something crazy with two layers and then merges them
     * you want that to be one undo step, and prevent merging from causing its undo step.
     * so while that filter is doing its magic you should pause possible undo steps that
     * that are caused by a part of its code(in this example: merging layers)
     *
     * @param b
     */ pause(b) {
        if (b === false) this.pauseStack = Math.max(0, this.pauseStack - 1);
        else this.pauseStack++;
    }
    addListener(l) {
        this.listeners.push(l);
    }
    push(e) {
        if (this.pauseStack > 0) return;
        while(this.actionNumber < this.dataArr.length - 1)this.dataArr.pop();
        //taking care of actions that shouldn't cause a new undo step
        const top = this.dataArr[this.dataArr.length - 1];
        if (e.action === 'layerOpacity' && top && top.action === 'layerOpacity' && top.params[0] === e.params[0]) {
            this.dataArr[this.dataArr.length - 1] = e;
            this.state++; //still needs to increment because something changed
            return;
        }
        if (e.action === 'focusLayer' && top && top.action === 'focusLayer') {
            this.dataArr[this.dataArr.length - 1] = e;
            this.state++;
            return;
        }
        this.dataArr[this.dataArr.length] = e;
        this.actionNumber = this.dataArr.length - 1;
        const maxBefore = this.maxState;
        this.maxState = Math.max(this.maxState, this.actionNumber - this.max);
        if (maxBefore < this.maxState) this.broadcast({
            bufferUpdate: this.dataArr[this.maxState]
        });
        else this.broadcast(null);
        if (this.maxState >= 0) this.dataArr[this.maxState] = null; //to free some memory...imported images take a lot of space
    }
    undo() {
        let result;
        if (this.canUndo()) {
            result = [];
            for(let i = this.maxState + 1; i < this.actionNumber; i++)result.push(this.dataArr[i]);
            this.actionNumber--;
            this.broadcast(null);
        }
        return result;
    }
    redo() {
        const result = [];
        if (this.canRedo()) {
            this.actionNumber++;
            result.push(this.dataArr[this.actionNumber]);
            this.broadcast(null);
        }
        return result;
    }
    getAll() {
        return [].concat(this.dataArr);
    }
    canRedo() {
        return this.actionNumber < this.dataArr.length - 1;
    }
    canUndo() {
        return this.actionNumber > this.maxState;
    }
    getState() {
        return this.state;
    }
    /**
     * actionNumber - number of undo-able actions a user has done (e.g. if drawn 5 lines total -> 5)
     */ getActionNumber() {
        return this.actionNumber + 1;
    }
}
const klHistory = new KlHistory();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"7D028":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "popup", ()=>popup
);
parcelHelpers.export(exports, "Popup", ()=>Popup
);
var _modalCount = require("./modal-count");
var _bb = require("../../../bb/bb");
// @ts-ignore
var _checkSvg = require("url:~/src/app/img/ui/check.svg");
var _checkSvgDefault = parcelHelpers.interopDefault(_checkSvg);
// @ts-ignore
var _cancelSvg = require("url:~/src/app/img/ui/cancel.svg");
var _cancelSvgDefault = parcelHelpers.interopDefault(_cancelSvg);
var _language = require("../../../language/language");
window.onscroll = (e)=>{
    e.preventDefault();
};
function popup(p) {
    _modalCount.dialogCounter.increase();
    let isClosed = false;
    // need this extra layer because chrome mobile otherwise scrolls the page and then glitches as the address bar goes away
    const rootRootEl = _bb.BB.el({
        parent: document.body,
        css: {
            position: 'absolute',
            left: '0',
            top: '0',
            right: '0',
            bottom: '0',
            overflow: 'hidden'
        }
    });
    const rootEl = _bb.BB.el({
        parent: rootRootEl,
        className: 'kl-popup'
    });
    const scrollContent = _bb.BB.el({
        parent: rootEl,
        css: {
            width: '100%',
            minHeight: '100%',
            // padding: '10px 0',
            position: 'relative',
            display: 'flex',
            flexDirection: 'column',
            justifyContent: 'center',
            alignItems: 'center'
        }
    });
    const bgEl = _bb.BB.el({
        parent: scrollContent,
        onClick: ()=>{
            if (p.ignoreBackground) return;
            close('Cancel');
        },
        css: {
            position: 'absolute',
            left: '0',
            top: '0',
            zIndex: '0',
            width: '100%',
            height: '100%'
        }
    });
    const titleHeight = 40;
    const xButton = _bb.BB.el({
        tagName: 'button',
        className: 'popup-x',
        content: `<img alt="${_language.LANG('modal-close')}" height="20" src="${_cancelSvgDefault.default}">`,
        title: _language.LANG('modal-close'),
        onClick: ()=>{
            close('Cancel');
        },
        css: {
            width: titleHeight + 'px',
            height: titleHeight + 'px',
            lineHeight: titleHeight + 'px',
            position: 'absolute',
            right: '0',
            top: '0',
            background: 'none',
            boxShadow: 'none'
        }
    });
    const boxClasses = [
        'kl-popup-box'
    ];
    boxClasses.push('kl-popup-box--sm');
    const boxEl = _bb.BB.el({
        content: [
            xButton,
            _bb.BB.el({
                content: p.message,
                css: {
                    marginBottom: p.div ? '10px' : null,
                    marginRight: '15px'
                }
            }),
            p.div, 
        ],
        className: boxClasses.join(' '),
        css: p.style ? p.style : null
    });
    scrollContent.append(_bb.BB.el({
        css: {
            flex: '0.5'
        }
    }), boxEl, _bb.BB.el({
        css: {
            flex: '1'
        }
    }));
    if (p.type === 'error') _bb.BB.addClassName(boxEl, 'poperror');
    if (p.type === 'ok') _bb.BB.addClassName(boxEl, 'popok');
    if (p.type === 'warning') _bb.BB.addClassName(boxEl, 'popwarning');
    if (p.type === 'upload') _bb.BB.addClassName(boxEl, 'popupload');
    const keyListener = new _bb.BB.KeyListener({
        onDown: function(keyStr, e, comboStr) {
            if (isClosed) return;
            if (clickOnEnterBtn && comboStr === 'enter' && !_bb.BB.isInputFocused()) {
                e.stopPropagation();
                setTimeout(function() {
                    clickOnEnterBtn.click();
                }, 10);
            }
            if (comboStr === 'esc') {
                e.stopPropagation();
                close('Cancel');
            }
        }
    });
    // prevent ctrl scroll -> zooming page
    const wheelPrevent = (event)=>{
        if (keyListener.isPressed('ctrl')) event.preventDefault();
    };
    _bb.BB.addEventListener(rootEl, 'wheel', wheelPrevent);
    rootEl.onclick = _bb.BB.handleClick;
    let autoFocus = null;
    if (p.autoFocus) autoFocus = p.autoFocus;
    else if (p.autoFocus === false) autoFocus = null;
    else autoFocus = 'Ok';
    const buttonRowEl = p.buttons && p.buttons.length > 0 ? _bb.BB.el({
        parent: boxEl,
        css: {
            display: 'flex',
            flexWrap: 'wrap',
            justifyContent: 'flex-end',
            marginTop: '12px',
            marginLeft: '-8px'
        }
    }) : null;
    let clickOnEnterBtn;
    const btnElArr = [];
    if (p.buttons) p.buttons.forEach((buttonName)=>{
        const btnClasses = [
            'kl-popup__btn'
        ];
        if (buttonName === 'Ok' || p.primaries && p.primaries.includes(buttonName)) btnClasses.push('kl-button-primary');
        let iconUrl;
        let label = buttonName;
        if (buttonName === 'Ok') {
            label = _language.LANG('modal-ok');
            iconUrl = _checkSvgDefault.default;
        }
        if (buttonName === 'Cancel') {
            label = _language.LANG('modal-cancel');
            iconUrl = _cancelSvgDefault.default;
        }
        let iconImg = null;
        if (iconUrl) iconImg = _bb.BB.el({
            tagName: 'img',
            custom: {
                src: iconUrl,
                height: '17'
            }
        });
        const btn = _bb.BB.el({
            parent: buttonRowEl,
            tagName: 'button',
            className: btnClasses.join(' '),
            content: [
                iconImg,
                label
            ],
            onClick: ()=>{
                close(buttonName);
            }
        });
        btnElArr.push(btn);
        if (autoFocus === buttonName) {
            setTimeout(()=>{
                btn.focus();
                rootEl.scrollTo(0, 0);
            }, 10);
            setTimeout(()=>{
                // safari needs a separate timeout
                rootEl.scrollTo(0, 0);
            }, 20);
        }
        if (buttonName === p.clickOnEnter) clickOnEnterBtn = btn;
    });
    function close(value) {
        if (isClosed) return;
        isClosed = true;
        _bb.BB.clearSelection();
        document.body.removeChild(rootRootEl);
        _modalCount.dialogCounter.decrease();
        _bb.BB.destroyEl(xButton);
        _bb.BB.destroyEl(bgEl);
        keyListener.destroy();
        _bb.BB.removeEventListener(rootEl, 'wheel', wheelPrevent);
        rootEl.onclick = null;
        btnElArr.forEach((item)=>{
            _bb.BB.destroyEl(item);
        });
        btnElArr.splice(0, btnElArr.length);
        if (p.callback) p.callback(value);
    }
    if (p.closefunc) p.closefunc(function() {
        close('Cancel');
    });
}
const Popup = function(p) {
    _modalCount.dialogCounter.increase();
    const parent = document.body;
    const div = _bb.BB.el({
        parent: parent,
        className: 'g-root',
        css: {
            position: 'fixed',
            left: '0',
            top: '0',
            bottom: '0',
            right: '0',
            background: 'rgba(0, 0, 0, 0.45)',
            overflow: 'auto',
            animationName: 'consoleIn',
            animationDuration: '0.3s',
            animationTimingFunction: 'ease-out'
        }
    });
    div.onclick = _bb.BB.handleClick;
    let updateInterval;
    function close() {
        _modalCount.dialogCounter.decrease();
        div.onclick = null;
        parent.removeChild(div);
        clearInterval(updateInterval);
        window.removeEventListener('resize', updatePos);
        keyListener.destroy();
        _bb.BB.destroyEl(xButton);
        _bb.BB.destroyEl(bgEl);
        if (p.onClose) p.onClose();
    }
    //background element registering clicks
    const bgEl = _bb.BB.el({
        parent: div,
        css: {
            position: 'absolute',
            left: '0',
            top: '0',
            bottom: '0',
            right: '0'
        },
        onClick: close
    });
    //the actual popup box
    const popupEl = _bb.BB.el({
        parent: div,
        css: {
            position: 'absolute',
            width: _bb.BB.isCssMinMaxSupported() ? 'min(calc(100% - 40px), ' + (p.width ? p.width : 400) + 'px)' : (p.width ? p.width : 400) + 'px',
            height: 'calc(100% - 40px)',
            background: '#eee',
            borderRadius: '10px',
            overflow: 'hidden',
            boxShadow: 'rgba(0, 0, 0, 0.25) 0px 5px 60px'
        }
    });
    //x and y position via script. flex not powerful enough imo
    function updatePos() {
        const elW = popupEl.offsetWidth;
        const elH = popupEl.offsetHeight;
        _bb.BB.css(popupEl, {
            left: Math.max(0, (window.innerWidth - elW) / 2) + 'px',
            top: Math.max(20, (window.innerHeight - elH) / 2 - elH * 0.2) + 'px'
        });
    }
    //todo also update when popup changes size - resizeobserver and fallback
    //updateInterval = setInterval(updatePos, 100);
    updatePos();
    window.addEventListener('resize', updatePos);
    //title row in popup
    const titleHeight = 40;
    const titleEl = _bb.BB.el({
        parent: popupEl,
        css: {
            height: titleHeight + 'px',
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            paddingLeft: titleHeight / 2 + 'px'
        }
    });
    if (p.title) titleEl.appendChild(p.title);
    const xButton = _bb.BB.el({
        parent: titleEl,
        tagName: 'button',
        className: 'popup-x',
        content: `<img alt="${_language.LANG('modal-close')}" height="20" src="${_cancelSvgDefault.default}">`,
        title: _language.LANG('modal-close'),
        onClick: close,
        css: {
            width: titleHeight + 'px',
            height: titleHeight + 'px',
            lineHeight: titleHeight + 'px',
            background: 'none',
            boxShadow: 'none'
        },
        custom: {
            tabindex: '0'
        }
    });
    const contentEl = _bb.BB.el({
        parent: popupEl,
        css: {
            height: 'calc(100% - ' + titleHeight + 'px)'
        }
    });
    if (p.content) contentEl.appendChild(p.content);
    const keyListener = new _bb.BB.KeyListener({
        onDown: function(keyStr, e) {
            if (keyStr === 'esc') {
                e.stopPropagation();
                close();
            }
        }
    });
    // --- interface ---
    this.close = function() {
        close();
    };
};

},{"./modal-count":"5hzLs","../../../bb/bb":"e3nbn","url:~/src/app/img/ui/check.svg":"a5lFR","url:~/src/app/img/ui/cancel.svg":"bF8Yc","../../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5hzLs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// not the best
/**
 * how many modals are open
 */ parcelHelpers.export(exports, "DialogCounter", ()=>DialogCounter
);
parcelHelpers.export(exports, "dialogCounter", ()=>dialogCounter
);
class DialogCounter {
    emit() {
        this.listeners.forEach((item)=>{
            item(this.count);
        });
    }
    increase(v) {
        if (v !== undefined) this.count += v;
        else this.count++;
        this.emit();
    }
    decrease(v) {
        if (v !== undefined) this.count -= v;
        else this.count--;
        this.emit();
    }
    get() {
        return this.count;
    }
    subscribe(listener) {
        this.listeners.push(listener);
    }
    constructor(){
        this.listeners = [];
        this.count = 0;
    }
}
const dialogCounter = new DialogCounter();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"a5lFR":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "check.d6357ccb.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"chiK4":[function(require,module,exports) {
"use strict";
var bundleURL = {
};
function getBundleURLCached(id) {
    var value = bundleURL[id];
    if (!value) {
        value = getBundleURL();
        bundleURL[id] = value;
    }
    return value;
}
function getBundleURL() {
    try {
        throw new Error();
    } catch (err) {
        var matches = ('' + err.stack).match(/(https?|file|ftp):\/\/[^)\n]+/g);
        if (matches) // The first two stack frames will be this function and getBundleURLCached.
        // Use the 3rd one, which will be a runtime in the original bundle.
        return getBaseURL(matches[2]);
    }
    return '/';
}
function getBaseURL(url) {
    return ('' + url).replace(/^((?:https?|file|ftp):\/\/.+)\/[^/]+$/, '$1') + '/';
} // TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.
function getOrigin(url) {
    var matches = ('' + url).match(/(https?|file|ftp):\/\/[^/]+/);
    if (!matches) throw new Error('Origin not found');
    return matches[0];
}
exports.getBundleURL = getBundleURLCached;
exports.getBaseURL = getBaseURL;
exports.getOrigin = getOrigin;

},{}],"bF8Yc":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "cancel.5705f2ca.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"lvNW4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LS_LANGUAGE_KEY", ()=>LS_LANGUAGE_KEY
);
parcelHelpers.export(exports, "LanguageStrings", ()=>LanguageStrings
);
parcelHelpers.export(exports, "languageStrings", ()=>languageStrings
);
parcelHelpers.export(exports, "LANG", ()=>LANG
);
parcelHelpers.export(exports, "initLANG", ()=>initLANG
);
// @ts-ignore
var _languages = require("../../languages/languages");
const LS_LANGUAGE_KEY = 'klecks-language';
class LanguageStrings {
    // --- public ----
    constructor(){
        this.listeners = [];
        // need to use setLanguage for a different language
        this.data = {
            ..._languages.english
        };
        this.code = 'en';
    }
    async setLanguage(langCode) {
        if (langCode === 'en') this.data = {
            ..._languages.english
        };
        else this.data = {
            ..._languages.english,
            ...await _languages.loadLanguage(langCode)
        };
        this.code = langCode;
        document.documentElement.setAttribute("lang", langCode);
        this.listeners.forEach((item)=>{
            item();
        });
    }
    get(code) {
        if (!(code in this.data)) throw new Error('translation code doesn\'t exist: ' + code);
        return this.data[code];
    }
    getLanguage() {
        return _languages.languages.find((item)=>{
            return item.code === this.code;
        });
    }
    getCode() {
        return this.code;
    }
    // get notified on language change
    subscribe(subscriber) {
        if (this.listeners.includes(subscriber)) return;
        this.listeners.push(subscriber);
    }
    unsubscribe(subscriber) {
        for(let i = 0; i < this.listeners.length; i++)if (subscriber === this.listeners[i]) {
            this.listeners.splice(i, 1);
            return;
        }
    }
}
let activeLanguageCode = 'en'; // active language code
{
    const langs = []; // from highest to lowest priority
    const navLangs = navigator.languages ? navigator.languages : [
        navigator.language
    ];
    navLangs.forEach((item)=>{
        const split = item.split('-');
        langs.push(item);
        if (split.length === 2) langs.push(split[0]);
    });
    try {
        if (localStorage.getItem(LS_LANGUAGE_KEY)) langs.unshift(localStorage.getItem(LS_LANGUAGE_KEY));
    } catch (e) {
    // likely cookies disabled in Safari
    }
    for(let i = 0; i < langs.length; i++){
        const lang = langs[i];
        if (_languages.languages.find((item)=>{
            return item.code.toLowerCase() === lang.toLowerCase();
        })) {
            activeLanguageCode = lang;
            break;
        }
    }
}const languageStrings = new LanguageStrings();
const LANG = (code, replace)=>{
    if (replace) {
        let result = languageStrings.get(code);
        const keyArr = Object.keys(replace);
        keyArr.forEach((key)=>{
            result = result.replace(`{${key}}`, replace[key]);
        });
        return result;
    } else return languageStrings.get(code);
};
const initLANG = ()=>languageStrings.setLanguage(activeLanguageCode)
;

},{"../../languages/languages":"9233v","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9233v":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "english", ()=>english
);
parcelHelpers.export(exports, "languages", ()=>languages
);
parcelHelpers.export(exports, "loadLanguage", ()=>loadLanguage
);
// generated from src/languages. "npm run lang:build" to update
// @ts-ignore
var _enJson = require("./en.json");
var _enJsonDefault = parcelHelpers.interopDefault(_enJson);
const english = _enJsonDefault.default;
const languages = [
    {
        code: 'en',
        name: 'English'
    },
    {
        code: 'de',
        name: 'Deutsch'
    },
    {
        code: 'ja',
        name: '日本語'
    },
    {
        code: 'zh-CN',
        name: '简体中文'
    }
];
const loadLanguage = async (code)=>{
    if (code === 'en') return english;
    else if (code === 'de') // @ts-ignore
    return await require("50e65a6e5edeb844");
    else if (code === 'ja') // @ts-ignore
    return await require("cf3fbd951f47e4a");
    else if (code === 'zh-CN') // @ts-ignore
    return await require("70997586488a0826");
    throw new Error('unknown language code');
};

},{"./en.json":"8NLJY","50e65a6e5edeb844":"l2wpI","cf3fbd951f47e4a":"9n2FM","70997586488a0826":"9l15J","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8NLJY":[function(require,module,exports) {
module.exports = JSON.parse("{\"switch-ui-left-right\":\"Switch left/right UI\",\"toggle-show-tools\":\"Show/Hide Tools\",\"scroll\":\"Scroll\",\"donate\":\"Donate\",\"home\":\"Home\",\"modal-new-tab\":\"Open in new tab\",\"tab-layers\":\"Layers\",\"tab-edit\":\"Edit\",\"tab-file\":\"File\",\"tool-brush\":\"Brush\",\"tool-paint-bucket\":\"Paint Bucket\",\"tool-shape\":\"Shape\",\"tool-text\":\"Text\",\"tool-hand\":\"Hand Tool\",\"tool-zoom\":\"Zoom\",\"tool-undo-redo\":\"Undo / Redo\",\"undo\":\"Undo\",\"redo\":\"Redo\",\"brush-pen\":\"Pen\",\"brush-blend\":\"Blend\",\"brush-sketchy\":\"Sketchy\",\"brush-pixel\":\"Pixel\",\"brush-chemy\":\"Chemy\",\"brush-smudge\":\"Smudge\",\"brush-size\":\"Size\",\"brush-blending\":\"Blending\",\"brush-toggle-pressure\":\"Toggle Pressure Sensitivity\",\"brush-lock-alpha\":\"Lock Alpha\",\"brush-lock-alpha-title\":\"Locks layer's alpha channel\",\"brush-pen-circle\":\"Circle\",\"brush-pen-chalk\":\"Chalk\",\"brush-pen-calligraphy\":\"Calligraphy\",\"brush-pen-square\":\"Square\",\"brush-sketchy-scale\":\"Scale\",\"brush-pixel-dither\":\"Dither\",\"brush-chemy-fill\":\"Fill\",\"brush-chemy-stroke\":\"Stroke\",\"brush-chemy-mirror-x\":\"Horizontal Symmetry\",\"brush-chemy-mirror-y\":\"Vertical Symmetry\",\"brush-chemy-gradient\":\"Gradient\",\"brush-eraser-transparent-bg\":\"Transparent Background\",\"stabilizer\":\"Stabilizer\",\"stabilizer-title\":\"Stroke Stabilizer\",\"eyedropper\":\"Eyedropper\",\"secondary-color\":\"Secondary Color\",\"manual-color-input\":\"Manual Color Input\",\"mci-hex\":\"Hex\",\"mci-copy\":\"Copy\",\"modal-ok\":\"Ok\",\"modal-cancel\":\"Cancel\",\"modal-close\":\"Close\",\"layers-active-layer\":\"Active Layer\",\"layers-layer\":\"Layer\",\"layers-copy\":\"copy\",\"layers-blending\":\"Blending\",\"layers-new\":\"New Layer\",\"layers-remove\":\"Remove Layer\",\"layers-duplicate\":\"Duplicate Layer\",\"layers-merge\":\"Merge with layer below\",\"layers-rename\":\"Rename\",\"layers-blend-normal\":\"normal\",\"layers-blend-darken\":\"darken\",\"layers-blend-multiply\":\"multiply\",\"layers-blend-color-burn\":\"color burn\",\"layers-blend-lighten\":\"lighten\",\"layers-blend-screen\":\"screen\",\"layers-blend-color-dodge\":\"color dodge\",\"layers-blend-overlay\":\"overlay\",\"layers-blend-soft-light\":\"soft light\",\"layers-blend-hard-light\":\"hard light\",\"layers-blend-difference\":\"difference\",\"layers-blend-exclusion\":\"exclusion\",\"layers-blend-hue\":\"hue\",\"layers-blend-saturation\":\"saturation\",\"layers-blend-color\":\"color\",\"layers-blend-luminosity\":\"luminosity\",\"layers-rename-title\":\"Rename Layer\",\"layers-rename-name\":\"Name\",\"layers-rename-clear\":\"Clear Name\",\"layers-rename-sketch\":\"Sketch\",\"layers-rename-colors\":\"Colors\",\"layers-rename-lines\":\"Lines\",\"layers-rename-foreground\":\"Foreground\",\"layers-merge-modal-title\":\"Merge/Mix Layers\",\"layers-merge-description\":\"Merges the selected layer with the one underneath. Select the mix mode:\",\"file-no-autosave\":\"No autosave, no cloud storage\",\"file-new\":\"New\",\"file-import\":\"Import\",\"file-save\":\"Save\",\"file-save-png\":\"Save PNG\",\"file-save-psd\":\"Save PSD\",\"file-save-layers\":\"Save Layers\",\"file-copy\":\"Copy\",\"file-copy-title\":\"Copy To Clipboard\",\"file-share\":\"Share\",\"file-storage\":\"Browser Storage\",\"file-storage-thumb-title\":\"Restores when reopening page\",\"file-storage-about\":\"About Browser Storage\",\"file-storage-cant-access\":\"Can't access\",\"file-storage-empty\":\"Empty\",\"file-storage-store\":\"Store\",\"file-storage-clear\":\"Clear\",\"file-storage-storing\":\"Storing\",\"file-storage-overwrite\":\"Overwrite\",\"file-storage-min-ago\":\"{x}min ago\",\"file-storage-hours-ago\":\"{x}h ago\",\"file-storage-days-ago\":\"{x}d ago\",\"file-storage-month-ago\":\"> 1month ago\",\"file-storage-restored\":\"Restored from Browser Storage\",\"file-storage-stored\":\"Stored to Browser Storage\",\"file-storage-failed\":\"Failed to store to Browser Storage\",\"file-storage-failed-1\":\"Failed to store. Possible causes:\",\"file-storage-failed-2\":\"Out of disk space\",\"file-storage-failed-3\":\"Storage disabled in incognito tab\",\"file-storage-failed-4\":\"Browser doesn't support storage\",\"file-storage-failed-clear\":\"Failed to clear.\",\"file-upload\":\"Upload\",\"cleared-layer\":\"Cleared layer\",\"filled\":\"Filled\",\"new-title\":\"New Image\",\"new-current\":\"Current\",\"new-fit\":\"Fit\",\"new-oversize\":\"Oversize\",\"new-square\":\"Square\",\"new-landscape\":\"Landscape\",\"new-portrait\":\"Portrait\",\"new-screen\":\"Screen\",\"new-video\":\"Video\",\"new-din-paper\":\"DIN Paper\",\"new-px\":\"px\",\"new-ratio\":\"Ratio\",\"upload-title\":\"Upload to Imgur\",\"upload-link-notice\":\"Anyone with the link to your uploaded image will be able to view it.\",\"upload-name\":\"Title\",\"upload-title-untitled\":\"Untitled\",\"upload-caption\":\"Caption\",\"upload-tos\":\"Terms of Service\",\"upload-tos-2\":\"for imgur.com\",\"upload-submit\":\"Upload\",\"upload-uploading\":\"Uploading...\",\"upload-success\":\"Upload Successful\",\"upload-failed\":\"Upload failed.\",\"upload-delete\":\"To delete your image from Imgur visit:\",\"cropcopy-title-copy\":\"Copy To Clipboard\",\"cropcopy-title-crop\":\"Crop\",\"cropcopy-btn-copy\":\"To Clipboard\",\"cropcopy-copied\":\"Copied.\",\"cropcopy-btn-crop\":\"Apply Crop\",\"crop-drag-to-crop\":\"Drag to crop\",\"filter-crop-extend\":\"Crop/Extend\",\"filter-flip\":\"Flip\",\"filter-perspective\":\"Perspective\",\"filter-resize\":\"Resize\",\"filter-rotate\":\"Rotate\",\"filter-transform\":\"Transform\",\"filter-bright-contrast\":\"Bright/Contrast\",\"filter-curves\":\"Curves\",\"filter-hue-sat\":\"Hue/Saturation\",\"filter-invert\":\"Invert\",\"filter-tilt-shift\":\"Tilt Shift\",\"filter-to-alpha\":\"To Alpha\",\"filter-triangle-blur\":\"Triangle Blur\",\"filter-unsharp-mask\":\"Unsharp Mask\",\"filter-crop-title\":\"Crop / Extend\",\"filter-crop-description\":\"Crop or extend the image.\",\"filter-crop-left\":\"Left\",\"filter-crop-right\":\"Right\",\"filter-crop-top\":\"Top\",\"filter-crop-bottom\":\"Bottom\",\"filter-crop-rule-thirds\":\"Rule of Thirds\",\"filter-crop-fill\":\"Fill\",\"filter-flip-title\":\"Flip\",\"filter-flip-description\":\"Flips layer or whole image.\",\"filter-flip-horizontal\":\"Horizontal\",\"filter-flip-vertical\":\"Vertical\",\"filter-flip-image\":\"Flip Image\",\"filter-flip-layer\":\"Flip Layer\",\"filter-perspective-title\":\"Perspective\",\"filter-perspective-description\":\"Transforms the selected layer.\",\"filter-perspective-before\":\"Before\",\"filter-perspective-after\":\"After\",\"filter-resize-title\":\"Resize\",\"filter-resize-description\":\"Resizes the image.\",\"filter-rotate-title\":\"Rotate\",\"filter-rotate-description\":\"Rotates the image.\",\"filter-transform-empty\":\"Layer is empty.\",\"filter-transform-title\":\"Transform\",\"filter-transform-description\":\"Transforms selected layer. Hold Shift for additional behavior.\",\"filter-transform-rotation\":\"Rotation\",\"filter-transform-flip\":\"Flip\",\"filter-transform-center\":\"Center\",\"filter-transform-constrain\":\"Constrain\",\"filter-transform-snap\":\"Snap\",\"filter-transform-snap-title\":\"Snap Rotation And Position\",\"filter-bright-contrast-title\":\"Brightness / Contrast\",\"filter-bright-contrast-description\":\"Change brightness and contrast for the selected layer.\",\"filter-bright-contrast-brightness\":\"Brightness\",\"filter-bright-contrast-contrast\":\"Contrast\",\"filter-curves-title\":\"Curves\",\"filter-curves-description\":\"Apply curves on the selected layer.\",\"filter-curves-all\":\"All\",\"filter-hue-sat-title\":\"Hue / Saturation\",\"filter-hue-sat-description\":\"Change hue and saturation for the selected layer.\",\"filter-hue-sat-hue\":\"Hue\",\"filter-hue-sat-saturation\":\"Saturation\",\"filter-applied\":\"applied\",\"filter-tilt-shift-title\":\"Tilt Shift\",\"filter-tilt-shift-description\":\"Applies tilt shift on the selected layer.\",\"filter-tilt-shift-blur\":\"Blur Radius\",\"filter-tilt-shift-gradient\":\"Gradient Radius\",\"filter-to-alpha-title\":\"To Alpha\",\"filter-to-alpha-description\":\"Generates alpha channel for selected layer from:\",\"filter-to-alpha-inverted-lum\":\"Inverted Luminance\",\"filter-to-alpha-lum\":\"Luminance\",\"filter-to-alpha-replace\":\"Replace RGB\",\"filter-triangle-blur-title\":\"Triangle Blur\",\"filter-triangle-blur-description\":\"Applies triangle blur on the selected layer.\",\"filter-unsharp-mask-title\":\"Unsharp Mask\",\"filter-unsharp-mask-description\":\"Sharpens the selected layer by scaling pixels away from the average of their neighbors.\",\"filter-unsharp-mask-strength\":\"Strength\",\"import-opening\":\"Opening file...\",\"import-title\":\"Import Image\",\"import-too-large\":\"Image too large, will be downscaled.\",\"import-btn-as-layer\":\"As Layer\",\"import-btn-as-image\":\"As Image\",\"import-as-layer-title\":\"Import Image as New Layer\",\"import-as-layer-description\":\"Adjust the position of the imported image.\",\"import-as-layer-limit-reached\":\"Layer limit reached. Image will be placed on existing layer.\",\"import-as-layer-fit\":\"Fit\",\"import-flatten\":\"Flatten image\",\"import-unsupported-file\":\"Unsupported file type. See Help for supported types.\",\"import-broken-file\":\"Couldn't load image. File might be corrupted.\",\"import-psd-unsupported\":\"Unsupported features. PSD had to be flattened.\",\"import-psd-limited-support\":\"PSD support is limited. Flattened will more likely look correct.\",\"import-psd-too-large\":\"Image exceeds maximum dimensions of {x} x {x} pixels. Unable to import.\",\"import-psd-size\":\"Image size\",\"hand-reset\":\"Reset\",\"hand-fit\":\"Fit\",\"bucket-tolerance\":\"Tolerance\",\"bucket-sample\":\"Sample\",\"bucket-sample-title\":\"Which layers to sample color from\",\"bucket-sample-all\":\"All\",\"bucket-sample-active\":\"Active\",\"bucket-sample-above\":\"Above\",\"bucket-grow\":\"Grow\",\"bucket-grow-title\":\"Grow filled area (in pixels)\",\"bucket-contiguous\":\"Contiguous\",\"bucket-contiguous-title\":\"Only fill connected areas\",\"shape-stroke\":\"Stroke\",\"shape-fill\":\"Fill\",\"shape-rect\":\"Rectangle\",\"shape-ellipse\":\"Ellipse\",\"shape-line\":\"Line\",\"shape-line-width\":\"Line Width\",\"shape-outwards\":\"Outwards\",\"shape-fixed\":\"Fixed 1:1\",\"shape-snap\":\"Snap\",\"shape-snap-title\":\"45° Angle Snapping\",\"text-instruction\":\"Click canvas to place text\",\"text-title\":\"Add Text\",\"text-placeholder\":\"Your text (multiline Shift+Enter)\",\"text-color\":\"Color\",\"text-size\":\"Size\",\"text-left\":\"Left\",\"text-center\":\"Center\",\"text-right\":\"Right\",\"text-italic\":\"Italic\",\"text-bold\":\"Bold\",\"save-reminder-title\":\"Reminder to save\",\"save-reminder-text\":\"Unsaved work may get lost.\",\"submit\":\"Submit\",\"submit-title\":\"Submit Drawing\",\"submit-prompt\":\"Submit drawing?\",\"submit-submitting\":\"Submitting\",\"embed-init-loading\":\"Loading app\",\"embed-init-waiting\":\"Waiting for image\",\"unsaved\":\"Unsaved\",\"help\":\"Help\",\"tab-settings\":\"Settings\",\"settings-language\":\"Language\",\"settings-preferred-language\":\"Preferred Language\",\"settings-language-reload\":\"Will update after reloading.\",\"licenses\":\"Licenses\",\"source-code\":\"Source Code\",\"auto\":\"auto\",\"zoom-in\":\"Zoom In\",\"zoom-out\":\"Zoom Out\",\"radius\":\"Radius\",\"constrain-proportions\":\"Constrain Proportions\",\"width\":\"Width\",\"height\":\"Height\",\"opacity\":\"Opacity\",\"red\":\"Red\",\"green\":\"Green\",\"blue\":\"Blue\",\"eraser\":\"Eraser\",\"center\":\"Center\",\"background\":\"Background\",\"scaling-algorithm\":\"Scaling Algorithm\",\"algorithm-smooth\":\"Smooth\",\"algorithm-pixelated\":\"Pixelated\",\"preview\":\"Preview\"}");

},{}],"l2wpI":[function(require,module,exports) {
module.exports = require("./helpers/browser/js-loader")(require('./helpers/bundle-url').getBundleURL('bWfZe') + "de.d3af4902.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root('heH0f')
);

},{"./helpers/browser/js-loader":"285qT","./helpers/bundle-url":"chiK4"}],"285qT":[function(require,module,exports) {
"use strict";
var cacheLoader = require('../cacheLoader');
module.exports = cacheLoader(function(bundle) {
    return new Promise(function(resolve, reject) {
        // Don't insert the same script twice (e.g. if it was already in the HTML)
        var existingScripts = document.getElementsByTagName('script');
        if ([].concat(existingScripts).some(function isCurrentBundle(script) {
            return script.src === bundle;
        })) {
            resolve();
            return;
        }
        var script1 = document.createElement('script');
        script1.async = true;
        script1.type = 'text/javascript';
        script1.charset = 'utf-8';
        script1.src = bundle;
        script1.onerror = function(e) {
            var error = new TypeError("Failed to fetch dynamically imported module: ".concat(bundle, ". Error: ").concat(e.message));
            script1.onerror = script1.onload = null;
            script1.remove();
            reject(error);
        };
        script1.onload = function() {
            script1.onerror = script1.onload = null;
            resolve();
        };
        document.getElementsByTagName('head')[0].appendChild(script1);
    });
});

},{"../cacheLoader":"7AHIJ"}],"7AHIJ":[function(require,module,exports) {
"use strict";
var cachedBundles = {
};
var cachedPreloads = {
};
var cachedPrefetches = {
};
function getCache(type) {
    switch(type){
        case 'preload':
            return cachedPreloads;
        case 'prefetch':
            return cachedPrefetches;
        default:
            return cachedBundles;
    }
}
module.exports = function(loader, type) {
    return function(bundle) {
        var cache = getCache(type);
        if (cache[bundle]) return cache[bundle];
        return cache[bundle] = loader.apply(null, arguments).catch(function(e) {
            delete cache[bundle];
            throw e;
        });
    };
};

},{}],"9n2FM":[function(require,module,exports) {
module.exports = require("./helpers/browser/js-loader")(require('./helpers/bundle-url').getBundleURL('bWfZe') + "ja.f3849db9.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root('4fzfm')
);

},{"./helpers/browser/js-loader":"285qT","./helpers/bundle-url":"chiK4"}],"9l15J":[function(require,module,exports) {
module.exports = require("./helpers/browser/js-loader")(require('./helpers/bundle-url').getBundleURL('bWfZe') + "zh-CN.fd617d11.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root('6PSLK')
);

},{"./helpers/browser/js-loader":"285qT","./helpers/bundle-url":"chiK4"}],"clzcQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Checkbox - with label
 */ parcelHelpers.export(exports, "Checkbox", ()=>Checkbox
);
var _bb = require("../../../bb/bb");
class Checkbox {
    // --- public ---
    constructor(params){
        this.element = _bb.BB.el({
            className: 'kl-checkbox'
        });
        const innerEl = _bb.BB.el({
            parent: this.element,
            tagName: 'label',
            className: 'kl-checkbox__inner'
        });
        this.check = _bb.BB.el({
            parent: innerEl,
            tagName: 'input',
            css: {
                marginLeft: '0',
                display: 'inline-block'
            },
            custom: {
                type: 'checkbox'
            }
        });
        this.check.checked = params.init;
        if (params.doHighlight && this.check.checked) _bb.BB.addClassName(this.element, 'kl-checkbox--highlight');
        if (!params.allowTab) this.check.tabIndex = -1;
        if (params.title) innerEl.title = params.title;
        const label = document.createElement('div');
        label.style.display = 'inline-block';
        label.innerHTML = params.label;
        label.allowClick = true;
        innerEl.appendChild(label);
        this.check.onchange = ()=>{
            if (params.doHighlight) {
                if (this.check.checked) _bb.BB.addClassName(this.element, 'kl-checkbox--highlight');
                else _bb.BB.removeClassName(this.element, 'kl-checkbox--highlight');
            }
            params.callback(this.check.checked);
            setTimeout(()=>{
                this.check.blur();
            }, 0);
        };
        if (params.css) _bb.BB.css(this.element, params.css);
    }
    getValue() {
        return this.check.checked;
    }
    getElement() {
        return this.element;
    }
    destroy() {
        this.check.onchange = null;
    }
}

},{"../../../bb/bb":"e3nbn","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1HM9r":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "input", ()=>input
);
var _bb = require("../../../bb/bb");
const input = function(params) {
    const result = document.createElement('input');
    if (params.type) try {
        result.type = params.type;
    } catch (e) {
    } // ie can't deal with number
    else result.type = 'text';
    if (params.min !== undefined) result.min = '' + params.min;
    if (params.max !== undefined) result.max = '' + params.max;
    result.value = '' + params.init;
    if (params.callback) result.onchange = function() {
        params.callback(result.value);
    };
    if (params.css) _bb.BB.css(result, params.css);
    return result;
};

},{"../../../bb/bb":"e3nbn","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gIUAj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A select dropdown
 */ parcelHelpers.export(exports, "Select", ()=>Select
);
var _bb = require("../../../bb/bb");
class Select {
    // --- public ---
    constructor(p){
        this.destroy = ()=>{
            this.selectEl.removeEventListener('change', this.changeListener);
        };
        this.selectEl = _bb.BB.el({
            tagName: 'select',
            title: p.title,
            css: {
                cursor: 'pointer',
                fontSize: '15px',
                padding: '3px',
                background: '#fff',
                //webkitAppearance: 'none'
                colorScheme: 'only light'
            }
        });
        if (p.css) _bb.BB.css(this.selectEl, p.css);
        const isFocusable = p.isFocusable;
        if (!isFocusable) this.selectEl.tabIndex = -1;
        this.optionArr = p.optionArr;
        for(let i = 0; i < this.optionArr.length; i++){
            if (this.optionArr[i] === null) continue;
            const option = document.createElement('option');
            option.value = this.optionArr[i][0];
            option.textContent = this.optionArr[i][1];
            this.selectEl.append(option);
        }
        this.onChange = p.onChange;
        this.changeListener = (e)=>{
            if (!isFocusable) this.selectEl.blur();
            this.onChange(this.selectEl.value);
        };
        this.selectEl.addEventListener('change', this.changeListener);
        this.selectEl.value = 'initValue' in p ? p.initValue : null;
    }
    setValue(val) {
        this.selectEl.value = val;
    }
    getValue() {
        return this.selectEl.value;
    }
    setDeltaValue(delta) {
        let index = 0;
        for(let i = 0; i < this.optionArr.length; i++)if ('' + this.optionArr[i][0] === this.selectEl.value) {
            index = i;
            break;
        }
        index = Math.max(0, Math.min(this.optionArr.length - 1, index + delta));
        this.selectEl.value = this.optionArr[index][0];
        this.onChange(this.selectEl.value);
    }
    getElement() {
        return this.selectEl;
    }
}

},{"../../../bb/bb":"e3nbn","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"85Ix1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ImageToggle", ()=>ImageToggle
);
var _bb = require("../../../bb/bb");
const ImageToggle = function(p) {
    let isActive = !!p.initValue;
    const div = _bb.BB.el({
        className: 'image-toggle',
        title: p.title,
        css: {
            backgroundImage: "url('" + p.image + "')"
        },
        onClick: function(e) {
            e.preventDefault();
            if (p.isRadio && isActive) return;
            isActive = !isActive;
            update();
            p.onChange(isActive);
        }
    });
    function update() {
        if (isActive) _bb.BB.addClassName(div, 'image-toggle-active');
        else _bb.BB.removeClassName(div, 'image-toggle-active');
    }
    update();
    // --- interface ---
    this.setValue = function(b) {
        isActive = !!b;
        update();
    };
    this.getElement = function() {
        return div;
    };
    this.getValue = function() {
        return isActive;
    };
};

},{"../../../bb/bb":"e3nbn","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jngG4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ImageRadioList", ()=>ImageRadioList
);
var _bb = require("../../../bb/bb");
var _imageToggle = require("./image-toggle");
const ImageRadioList = function(p) {
    const div = _bb.BB.el({
        className: 'image-radio-wrapper',
        css: {
            display: 'flex'
        }
    });
    let activeIndex;
    const optionArr = [];
    function select(index, id) {
        activeIndex = index;
        for(let i = 0; i < optionArr.length; i++)optionArr[i].setValue(i === activeIndex);
        p.onChange(id);
    }
    function createOption(index, o) {
        if (o.id === p.initId) activeIndex = index;
        const radioEl = new _imageToggle.ImageToggle({
            image: o.image,
            title: o.title,
            initValue: o.id === p.initId,
            isRadio: true,
            onChange: function() {
                select(index, o.id);
            }
        });
        div.appendChild(radioEl.getElement());
        return radioEl;
    }
    for(let i1 = 0; i1 < p.optionArr.length; i1++)optionArr.push(createOption(i1, p.optionArr[i1]));
    // --- interface ---
    this.getElement = function() {
        return div;
    };
    this.getValue = function() {
        return p.optionArr[activeIndex].id;
    };
};

},{"../../../bb/bb":"e3nbn","./image-toggle":"85Ix1","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1AVub":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "penPressureToggle", ()=>penPressureToggle
);
var _bb = require("../../../bb/bb");
// @ts-ignore
var _brushPressureSvg = require("url:~/src/app/img/ui/brush-pressure.svg");
var _brushPressureSvgDefault = parcelHelpers.interopDefault(_brushPressureSvg);
var _language = require("../../../language/language");
const penPressureToggle = function(isChecked, changeCallback) {
    const toggleDiv = _bb.BB.el({
        css: {
            cssFloat: 'right',
            borderRadius: '3px',
            width: '18px',
            height: '18px',
            backgroundImage: 'url("' + _brushPressureSvgDefault.default + '")',
            backgroundSize: 'contain',
            backgroundRepeat: 'no-repeat',
            cursor: 'pointer',
            boxSizing: 'border-box',
            colorScheme: 'only light'
        }
    });
    if (!_bb.BB.hasPointerEvents) toggleDiv.style.display = 'none';
    function redraw() {
        if (isChecked) _bb.BB.css(toggleDiv, {
            backgroundColor: '#fff',
            opacity: '0.9',
            border: '1px solid var(--active-highlight-color)'
        });
        else _bb.BB.css(toggleDiv, {
            backgroundColor: 'transparent',
            opacity: '0.5',
            border: '1px solid #666'
        });
    }
    toggleDiv.title = _language.LANG('brush-toggle-pressure');
    toggleDiv.onclick = function() {
        isChecked = !isChecked;
        redraw();
        changeCallback(isChecked);
    };
    redraw();
    changeCallback(isChecked);
    return toggleDiv;
};

},{"../../../bb/bb":"e3nbn","url:~/src/app/img/ui/brush-pressure.svg":"bpmgI","../../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bpmgI":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "brush-pressure.900ec541.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"1Vedp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "KlSlider", ()=>KlSlider
);
var _bb = require("../../../bb/bb");
var _sliderFalloff = require("./slider-falloff");
var _language = require("../../../language/language");
const KlSlider = function(p) {
    const _this = this;
    let isEnabled = p.isEnabled !== false;
    let useSpline = !!p.curve;
    let splineInterpolator;
    if (!p.label || !p.onChange) throw 'PcSlider missing params';
    if (p.min != 0 && p.max != 0 && p.initValue != 0) {
        if (!p.min || !p.max || !p.initValue) throw 'PcSlider broken params';
    }
    if (p.min >= p.max) throw 'PcSlider broken params';
    const elementWidth = p.width;
    const elementHeight = p.height;
    const resolution = p.resolution ? p.resolution : elementWidth;
    let min = p.min;
    let max = p.max;
    const onChange = p.onChange;
    const isChangeOnFinal = !!p.isChangeOnFinal;
    const formatFunc = p.formatFunc;
    const eventResMs = p.eventResMs;
    if (useSpline) {
        const curveArr = p.curve === 'quadratic' ? _bb.BB.quadraticSplineInput(min, max, 0.1) : p.curve;
        splineInterpolator = new _bb.BB.SplineInterpolator(curveArr);
    }
    function toLinearValue(value) {
        if (useSpline) return splineInterpolator.findX(value, Math.floor(resolution * 1.5));
        return (value - min) / (max - min);
    }
    function toValue(pLinearValue) {
        let result = min + pLinearValue * (max - min);
        if (useSpline) result = splineInterpolator.interpolate(pLinearValue);
        return result;
    }
    const div = _bb.BB.el({
        className: 'sliderWrapper',
        css: {
            overflow: 'hidden',
            position: 'relative',
            width: elementWidth + 'px',
            height: elementHeight + 'px',
            userSelect: 'none'
        }
    });
    const labelCaption = p.label;
    const label = document.createElement('div');
    const control = document.createElement('div');
    const controlInner = document.createElement('div');
    let linearValue = toLinearValue(p.initValue); //0 - 1
    div.appendChild(control);
    div.appendChild(label);
    control.appendChild(controlInner);
    control.className = 'sliderInner';
    div.oncontextmenu = function() {
        return false;
    };
    //control.style.backgroundColor = "#aaa";
    label.innerHTML = labelCaption;
    control.style.position = 'absolute';
    control.style.left = '0';
    control.style.top = '0';
    control.style.width = linearValue * elementWidth + 'px';
    control.style.height = elementHeight + 'px';
    const labelFontSize = elementHeight - 14;
    _bb.BB.css(label, {
        position: 'absolute',
        left: '7px',
        top: elementHeight / 2 - labelFontSize / 2 + 1 + 'px',
        lineHeight: labelFontSize + 'px',
        fontSize: labelFontSize + 'px',
        pointerEvents: 'none'
    });
    function updateEnable() {
        if (isEnabled) _bb.BB.css(div, {
            opacity: null,
            pointerEvents: null
        });
        else _bb.BB.css(div, {
            opacity: '0.5',
            pointerEvents: 'none'
        });
    }
    updateEnable();
    function getOutsideVal() {
        let result = min + linearValue * (max - min);
        if (useSpline) result = splineInterpolator.interpolate(linearValue);
        return result;
    }
    function updateLabel() {
        let outVal = toValue(linearValue);
        outVal = formatFunc ? formatFunc(outVal) : parseInt(outVal);
        outVal = outVal.toLocaleString(_language.languageStrings.getCode());
        label.innerHTML = labelCaption + '&nbsp;&nbsp;<span style="font-weight:bold">' + outVal + '</span>';
        control.style.width = linearValue * elementWidth + 'px';
    }
    let lastCallbackTime = 0;
    function emit(isFinal) {
        if (!isFinal && isChangeOnFinal) return;
        if (eventResMs && !isFinal) {
            const now = performance.now();
            if (now - lastCallbackTime >= eventResMs) {
                lastCallbackTime = now;
                onChange(getOutsideVal());
            }
        } else onChange(getOutsideVal());
    }
    let virtualVal;
    function onPointer(event) {
        event.eventPreventDefault();
        if (!isEnabled) return;
        if (event.type === 'pointerdown') {
            div.className = 'sliderWrapper sliderWrapperActive';
            if (event.button === 'left') {
                linearValue = event.relX / elementWidth;
                linearValue = Math.max(0, Math.min(1, linearValue));
                updateLabel();
                emit(false);
            }
            virtualVal = linearValue;
        }
        if (event.type === 'pointermove' && [
            'left',
            'right'
        ].includes(event.button)) {
            let deltaX = event.dX;
            const deltaY = Math.abs(event.pageY - event.downPageY);
            const factor = _sliderFalloff.calcSliderFalloffFactor(deltaY, event.button === 'right');
            deltaX *= factor;
            deltaX /= elementWidth;
            virtualVal += deltaX;
            linearValue = Math.max(0, Math.min(1, virtualVal));
            updateLabel();
            emit(false);
        }
        if (event.type === 'pointerup') {
            div.className = 'sliderWrapper';
            emit(true);
        }
    }
    let pointerListener;
    const pointerListenerTimeout = setTimeout(()=>{
        pointerListener = new _bb.BB.PointerListener({
            target: div,
            maxPointers: 1,
            fixScribble: true,
            onPointer: onPointer,
            onWheel: function(event) {
                if (useSpline) {
                    linearValue += -event.deltaY * (splineInterpolator.getLastX() - splineInterpolator.getFirstX()) / 40;
                    linearValue = Math.max(splineInterpolator.getFirstX(), Math.min(splineInterpolator.getLastX(), linearValue));
                } else {
                    linearValue += -event.deltaY / 40;
                    linearValue = Math.max(0, Math.min(1, linearValue));
                }
                updateLabel();
                onChange(getOutsideVal());
            }
        });
        updateLabel();
    }, 1);
    // --- interface ---
    this.increaseValue = function(f) {
        linearValue = Math.min(1, linearValue + Math.abs(f));
        updateLabel();
        onChange(getOutsideVal());
    };
    this.decreaseValue = function(f) {
        linearValue = Math.max(0, linearValue - Math.abs(f));
        updateLabel();
        onChange(getOutsideVal());
    };
    this.setValue = function(v) {
        linearValue = toLinearValue(v);
        updateLabel();
    };
    this.getValue = function() {
        return getOutsideVal();
    };
    this.update = function(config) {
        min = config.min;
        max = config.max;
        useSpline = !!config.curve;
        if (useSpline) {
            const curveArr = config.curve === 'quadratic' ? _bb.BB.quadraticSplineInput(min, max, 0.1) : config.curve;
            splineInterpolator = new _bb.BB.SplineInterpolator(curveArr);
        } else splineInterpolator = null;
        _this.setIsEnabled(!config.isDisabled);
    };
    this.setIsEnabled = function(e) {
        isEnabled = !!e;
        updateEnable();
    };
    this.destroy = function() {
        clearTimeout(pointerListenerTimeout);
        if (pointerListener) pointerListener.destroy();
    };
    this.getElement = function() {
        return div;
    };
};

},{"../../../bb/bb":"e3nbn","./slider-falloff":"2HhBa","../../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"2HhBa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "calcSliderFalloffFactor", ()=>calcSliderFalloffFactor
);
const calcSliderFalloffFactor = function(deltaY, isRightButton) {
    let result = Math.min(10, 1 + Math.pow(Math.floor(deltaY / 50), 2));
    if (isRightButton) result *= 2;
    return 1 / result;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6s9Kq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "HexColorDialog", ()=>HexColorDialog
);
var _bb = require("../../../bb/bb");
var _input = require("../base-components/input");
var _popup = require("./popup");
var _language = require("../../../language/language");
// @ts-ignore
var _copySvg = require("url:~/src/app/img/ui/copy.svg");
var _copySvgDefault = parcelHelpers.interopDefault(_copySvg);
const HexColorDialog = function(p) {
    let lastValidRgb = new _bb.BB.RGB(p.color.r, p.color.g, p.color.b);
    const div = _bb.BB.el({
    });
    const previewEl = _bb.BB.el({
        css: {
            width: '20px',
            height: '20px',
            marginBottom: '10px',
            boxShadow: 'inset 0 0 0 1px #fff, 0 0 0 1px #000',
            background: '#' + _bb.BB.ColorConverter.toHexString(lastValidRgb),
            colorScheme: 'only light'
        }
    });
    div.appendChild(previewEl);
    // --- Hex ---
    const hexRowEl = _bb.BB.el({
        css: {
            display: 'flex',
            alignItems: 'center',
            marginBottom: '15px'
        }
    });
    const hexLabel = _bb.BB.el({
        content: _language.LANG('mci-hex'),
        css: {
            width: '60px'
        }
    });
    const hexInput = _input.input({
        init: '#' + _bb.BB.ColorConverter.toHexString(lastValidRgb),
        css: {
            width: '80px'
        },
        callback: function() {
            let rgbObj = _bb.BB.ColorConverter.hexToRGB(hexInput.value);
            if (rgbObj === null) {
                rgbObj = lastValidRgb;
                hexInput.value = '#' + _bb.BB.ColorConverter.toHexString(lastValidRgb);
            } else lastValidRgb = rgbObj;
            previewEl.style.background = '#' + _bb.BB.ColorConverter.toHexString(rgbObj);
            for(let i = 0; i < rgbArr.length; i++)rgbArr[i].update();
        }
    });
    const copyButton = _bb.BB.el({
        tagName: 'button',
        content: '<img src="' + _copySvgDefault.default + '" height="20"/>',
        title: _language.LANG('mci-copy'),
        css: {
            marginLeft: '10px'
        },
        onClick: function() {
            hexInput.select();
            document.execCommand('copy');
        }
    });
    hexRowEl.appendChild(hexLabel);
    hexRowEl.appendChild(hexInput);
    hexRowEl.appendChild(copyButton);
    div.appendChild(hexRowEl);
    setTimeout(function() {
        hexInput.focus();
        hexInput.select();
    }, 0);
    // --- R G B ---
    function createRgbInputRow(labelStr, attributeStr) {
        const result = {
        };
        const rowEl = _bb.BB.el({
            css: {
                display: 'flex',
                alignItems: 'center',
                marginTop: '5px'
            }
        });
        const labelEl = _bb.BB.el({
            content: labelStr,
            css: {
                width: '60px'
            }
        });
        const inputEl = _input.input({
            init: lastValidRgb[attributeStr],
            min: 0,
            max: 255,
            type: 'number',
            css: {
                width: '80px'
            },
            callback: function() {
                if (inputEl.value === '' || parseFloat(inputEl.value) < 0 || parseFloat(inputEl.value) > 255) {
                    result.update();
                    return;
                }
                inputEl.value = '' + Math.round(parseFloat(inputEl.value));
                lastValidRgb[attributeStr] = inputEl.value;
                previewEl.style.background = '#' + _bb.BB.ColorConverter.toHexString(lastValidRgb);
                hexInput.value = '#' + _bb.BB.ColorConverter.toHexString(lastValidRgb);
            }
        });
        rowEl.appendChild(labelEl);
        rowEl.appendChild(inputEl);
        div.appendChild(rowEl);
        result.update = function() {
            inputEl.value = lastValidRgb[attributeStr];
        };
        return result;
    }
    const rgbArr = [];
    rgbArr.push(createRgbInputRow(_language.LANG('red'), 'r'));
    rgbArr.push(createRgbInputRow(_language.LANG('green'), 'g'));
    rgbArr.push(createRgbInputRow(_language.LANG('blue'), 'b'));
    _popup.popup({
        target: document.body,
        message: `<b>${_language.LANG('manual-color-input')}</b>`,
        div: div,
        autoFocus: false,
        clickOnEnter: 'Ok',
        buttons: [
            'Ok',
            'Cancel'
        ],
        callback: function(resultStr) {
            let rgbObj = null;
            if (resultStr === 'Ok') rgbObj = _bb.BB.ColorConverter.hexToRGB(hexInput.value);
            p.onClose(rgbObj);
        }
    });
};

},{"../../../bb/bb":"e3nbn","../base-components/input":"1HM9r","./popup":"7D028","../../../language/language":"lvNW4","url:~/src/app/img/ui/copy.svg":"g1jIg","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"g1jIg":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "copy.3a9cbd53.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"bb2MR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "KlColorSlider", ()=>KlColorSlider
);
var _bb = require("../../../bb/bb");
var _colorSliderHexDialog = require("../modals/color-slider-hex-dialog");
var _sliderFalloff = require("./slider-falloff");
// @ts-ignore
var _toolPickerSvg = require("url:~/src/app/img/ui/tool-picker.svg");
var _toolPickerSvgDefault = parcelHelpers.interopDefault(_toolPickerSvg);
var _language = require("../../../language/language");
const KlColorSlider = function(p) {
    const _this = this;
    let pickCallback = function(result) {
    };
    const div = document.createElement('div');
    div.style.position = 'relative';
    div.className = 'colorSlider';
    const outputDiv = _bb.BB.el({
        css: {
            display: 'flex',
            alignItems: 'center'
        }
    });
    const width = p.width;
    let svHeight = p.svHeight;
    const height = p.height;
    const emitColor = p.onPick;
    let primaryColorRGB = {
        r: parseInt(p.startValue.r, 10),
        g: parseInt(p.startValue.g, 10),
        b: parseInt(p.startValue.b, 10)
    };
    let primaryColorHSV = _bb.BB.ColorConverter.toHSV(p.startValue); // BB.HSV
    let secondaryColorRGB = {
        r: 255,
        g: 255,
        b: 255
    };
    let secondaryColorHSV = _bb.BB.ColorConverter._RGBtoHSV(secondaryColorRGB); // BB.HSV
    const svWrapper = _bb.BB.el({
    });
    const svSvg = new DOMParser().parseFromString('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" preserveAspectRatio="none"> <defs> <linearGradient id="value" gradientTransform="rotate(90)"> <stop offset="0" stop-color="rgba(0,0,0,0)"/> <stop offset="100%" stop-color="rgba(0,0,0,1)"/> </linearGradient> <linearGradient id="hue" gradientTransform="rotate(0)"> <stop offset="0" stop-color="#fff"/> <stop id="hue-stop" offset="100%" stop-color="#f00"/> </linearGradient> </defs> <rect x="0" y="0" width="100" height="100" fill="url(\'#hue\')"/> <rect x="0" y="0" width="100" height="100" fill="url(\'#value\')"/></svg>', 'image/svg+xml').documentElement;
    const hueStop = svSvg.getElementById('hue-stop');
    _bb.BB.setAttributes(hueStop, {
        'stop-color': '#f0f'
    });
    _bb.BB.css(svSvg, {
        width: width + 'px',
        height: svHeight + 'px'
    });
    svWrapper.appendChild(svSvg);
    const divH = document.createElement('div');
    _bb.BB.css(divH, {
        position: 'relative',
        height: height + 'px'
    });
    const divPreview = document.createElement('div');
    const controlH = document.createElement('div');
    const enabled = true;
    function updatePrimaryHSV(hsv) {
        if (hsv.s === 0) primaryColorHSV = new _bb.BB.HSV(primaryColorHSV.h, hsv.s, hsv.v);
        else primaryColorHSV = new _bb.BB.HSV(hsv.h, hsv.s, hsv.v);
    }
    function createHueBg(targetEl) {
        const im = new Image();
        _bb.BB.css(im, {
            position: 'absolute',
            left: '0',
            top: '0',
            display: 'none',
            pointerEvents: 'none'
        });
        const cv = _bb.BB.canvas(width, height);
        const ctx = cv.getContext('2d');
        const gradH = ctx.createLinearGradient(0, 0, width, 0);
        for(let i = 0; i < 1; i += 0.01){
            const col = _bb.BB.ColorConverter.toRGB(new _bb.BB.HSV(i * 360, 100, 100));
            let ha = parseInt('' + col.r).toString(16);
            let hb = parseInt('' + col.g).toString(16);
            let hc = parseInt('' + col.b).toString(16);
            if (ha.length === 1) ha = '0' + ha;
            if (hb.length === 1) hb = '0' + hb;
            if (hc.length === 1) hc = '0' + hc;
            gradH.addColorStop(i, '#' + ha + hb + hc);
        }
        ctx.fillStyle = gradH;
        ctx.fillRect(0, 0, width, height);
        targetEl.appendChild(im);
        im.alt = 'hue';
        im.src = cv.toDataURL('image/png');
        im.style.display = 'block';
    }
    function updateSVCanvas() {
        const rgb = _bb.BB.ColorConverter.toRGB(new _bb.BB.HSV(primaryColorHSV.h, 100, 100));
        _bb.BB.setAttributes(hueStop, {
            'stop-color': '#' + _bb.BB.ColorConverter.toHexString(rgb)
        });
    }
    function updateSVPointer() {
        const left = primaryColorHSV.s / 100 * width - 7;
        const top = (1 - primaryColorHSV.v / 100) * svHeight - 6;
        _bb.BB.css(pointerSV, {
            left: left + 'px',
            top: top + 'px'
        });
    }
    function setColPreview() {
        divPreview.style.backgroundColor = 'rgb(' + primaryColorRGB.r + ',' + primaryColorRGB.g + ',' + primaryColorRGB.b + ')';
        if (_bb.BB.testIsWhiteBestContrast(primaryColorRGB)) {
            _bb.BB.css(pickerButton, {
                filter: 'invert(1)'
            });
            _bb.BB.css(hexButton, {
                filter: 'invert(1)'
            });
        } else {
            _bb.BB.css(pickerButton, {
                filter: ''
            });
            _bb.BB.css(hexButton, {
                filter: ''
            });
        }
    }
    updateSVCanvas();
    div.style.width = width + 'px';
    div.oncontextmenu = function() {
        return false;
    };
    const SVContainer = document.createElement('div');
    _bb.BB.css(SVContainer, {
        width: width + 'px',
        height: svHeight + 'px',
        overflow: 'hidden',
        display: 'block',
        position: 'relative',
        cursor: 'crosshair',
        boxShadow: 'rgb(188, 188, 188) 0 0 0 1px'
    });
    const pointerSV = document.createElement('div');
    _bb.BB.css(pointerSV, {
        width: '12px',
        height: '12px',
        borderRadius: '6px',
        position: 'absolute',
        pointerEvents: 'none',
        boxShadow: '0px 0px 0 1px #000, inset 0px 0px 0 1px #fff'
    });
    SVContainer.appendChild(svWrapper);
    SVContainer.appendChild(pointerSV);
    updateSVPointer();
    div.appendChild(SVContainer);
    div.appendChild(divH);
    outputDiv.appendChild(divPreview);
    _bb.BB.css(divPreview, {
        display: 'flex',
        justifyContent: 'space-between',
        width: height * 2.5 + 'px',
        height: height + 'px',
        //position: "relative",
        boxShadow: 'rgb(188, 188, 188) 0 0 0 1px',
        colorScheme: 'only light'
    });
    _bb.BB.css(divH, {
        overflow: 'hidden',
        position: 'relative',
        width: width + 'px',
        height: height + 'px',
        cursor: 'ew-resize',
        boxShadow: 'rgb(188, 188, 188) 0 0 0 1px',
        marginTop: '1px',
        marginBottom: '1px'
    });
    //divH.className = "svSlider";
    _bb.BB.css(controlH, {
        width: '1px',
        height: height + 'px',
        background: '#000',
        borderLeft: '1px solid #fff',
        position: 'absolute',
        top: '0',
        left: parseInt('' + (primaryColorHSV.h / 360 * width - 1)) + 'px'
    });
    const virtualHSV = {
        h: 0,
        s: 0,
        v: 0
    };
    let svPointerListener;
    let hPointerListener;
    const pickerButton = _bb.BB.el({
        title: _language.LANG('eyedropper') + ' [Alt]',
        className: 'color-picker-preview-button',
        css: {
            width: '30px',
            height: '30px',
            backgroundImage: 'url(' + _toolPickerSvgDefault.default + ')',
            backgroundRepeat: 'no-repeat',
            backgroundSize: '70%',
            backgroundPosition: 'center'
        }
    });
    let isPicking = false;
    pickerButton.onclick = function() {
        if (isPicking === false) {
            _bb.BB.removeClassName(pickerButton, 'color-picker-preview-button-hover');
            _bb.BB.addClassName(pickerButton, 'color-picker-preview-button-active');
            isPicking = true;
            pickCallback(true);
        } else {
            pickCallback(false);
            _this.pickingDone();
        }
    };
    const pickerButtonPointerListener = new _bb.BB.PointerListener({
        target: pickerButton,
        onEnterLeave: function(isOver) {
            if (isPicking) return;
            if (isOver) _bb.BB.addClassName(pickerButton, 'color-picker-preview-button-hover');
            else _bb.BB.removeClassName(pickerButton, 'color-picker-preview-button-hover');
        }
    });
    divPreview.appendChild(pickerButton);
    const hexButton = _bb.BB.el({
        content: '#',
        className: 'color-picker-preview-button',
        title: _language.LANG('manual-color-input'),
        css: {
            height: '100%',
            width: height + 'px',
            lineHeight: height + 'px',
            fontSize: height * 0.65 + 'px'
        },
        onClick: function() {
            _colorSliderHexDialog.HexColorDialog({
                color: new _bb.BB.RGB(primaryColorRGB.r, primaryColorRGB.g, primaryColorRGB.b),
                onClose: function(rgbObj) {
                    if (!rgbObj) return;
                    _this.setColor(rgbObj);
                    emitColor(new _bb.BB.RGB(primaryColorRGB.r, primaryColorRGB.g, primaryColorRGB.b));
                }
            });
        }
    });
    const hexButtonPointerListener = new _bb.BB.PointerListener({
        target: hexButton,
        onEnterLeave: function(isOver) {
            if (isOver) _bb.BB.addClassName(hexButton, 'color-picker-preview-button-hover');
            else _bb.BB.removeClassName(hexButton, 'color-picker-preview-button-hover');
        }
    });
    divPreview.appendChild(hexButton);
    setColPreview();
    setTimeout(function() {
        createHueBg(divH);
        divH.appendChild(controlH);
        svPointerListener = new _bb.BB.PointerListener({
            target: svWrapper,
            maxPointers: 1,
            fixScribble: true,
            onPointer: function(event) {
                if (event.type === 'pointerdown') {
                    _bb.BB.css(SVContainer, {
                        boxShadow: '0px 0px 0px 1px rgb(255,255,255)',
                        zIndex: '1'
                    });
                    if (event.button === 'left') {
                        virtualHSV.s = event.relX / width * 100;
                        virtualHSV.v = 100 - event.relY / svHeight * 100;
                        primaryColorHSV = new _bb.BB.HSV(primaryColorHSV.h, virtualHSV.s, virtualHSV.v);
                        primaryColorRGB = _bb.BB.ColorConverter.toRGB(primaryColorHSV);
                        updateSVPointer();
                        setColPreview();
                        emitColor(_bb.BB.ColorConverter.toRGB(primaryColorHSV));
                    } else {
                        virtualHSV.s = primaryColorHSV.s;
                        virtualHSV.v = primaryColorHSV.v;
                    }
                }
                if (event.type === 'pointermove' && [
                    'left',
                    'right'
                ].includes(event.button)) {
                    let factor = 1;
                    if (event.button === 'right') factor = 0.5;
                    virtualHSV.s += event.dX / width * 100 * factor;
                    virtualHSV.v -= event.dY / svHeight * 100 * factor;
                    primaryColorHSV = new _bb.BB.HSV(primaryColorHSV.h, virtualHSV.s, virtualHSV.v);
                    primaryColorRGB = _bb.BB.ColorConverter.toRGB(primaryColorHSV);
                    updateSVPointer();
                    setColPreview();
                    emitColor(_bb.BB.ColorConverter.toRGB(primaryColorHSV));
                }
                if (event.type === 'pointerup') _bb.BB.css(SVContainer, {
                    boxShadow: '0 0 0 1px rgb(188, 188, 188)',
                    zIndex: '0'
                });
            }
        });
        hPointerListener = new _bb.BB.PointerListener({
            target: divH,
            maxPointers: 1,
            fixScribble: true,
            onPointer: function(event) {
                if (event.type === 'pointerdown') {
                    _bb.BB.css(divH, {
                        boxShadow: '0px 0px 0px 1px rgba(255,255,255,1)'
                    });
                    if (event.button === 'left') {
                        virtualHSV.h = event.relX / width * 359.99;
                        primaryColorHSV = new _bb.BB.HSV(virtualHSV.h, primaryColorHSV.s, primaryColorHSV.v);
                        primaryColorRGB = _bb.BB.ColorConverter.toRGB(primaryColorHSV);
                        controlH.style.left = Math.round(primaryColorHSV.h / 359.99 * width) - 1 + 'px';
                        updateSVCanvas();
                        setColPreview();
                        emitColor(_bb.BB.ColorConverter.toRGB(primaryColorHSV));
                    } else virtualHSV.h = primaryColorHSV.h;
                }
                if (event.type === 'pointermove' && [
                    'left',
                    'right'
                ].includes(event.button)) {
                    const deltaY = Math.abs(event.pageY - event.downPageY);
                    const factor = _sliderFalloff.calcSliderFalloffFactor(deltaY, event.button === 'right');
                    virtualHSV.h += event.dX / width * 359.99 * factor;
                    if (event.button === 'right') {
                        virtualHSV.h = virtualHSV.h % 359.99;
                        if (virtualHSV.h < 0) virtualHSV.h += 359.99;
                    }
                    virtualHSV.h = Math.min(359.99, virtualHSV.h);
                    primaryColorHSV = new _bb.BB.HSV(virtualHSV.h, primaryColorHSV.s, primaryColorHSV.v);
                    primaryColorRGB = _bb.BB.ColorConverter.toRGB(primaryColorHSV);
                    controlH.style.left = Math.round(primaryColorHSV.h / 359.99 * width) - 1 + 'px';
                    updateSVCanvas();
                    setColPreview();
                    emitColor(_bb.BB.ColorConverter.toRGB(primaryColorHSV));
                }
                if (event.type === 'pointerup') _bb.BB.css(divH, {
                    boxShadow: 'rgb(188, 188, 188) 0 0 0 1px'
                });
            }
        });
    }, 1);
    // --- second color ---
    const secondaryColorBtn = _bb.BB.el({
        parent: outputDiv,
        title: _language.LANG('secondary-color') + ' [X]',
        css: {
            cursor: 'pointer',
            marginLeft: '5px',
            width: '22px',
            height: '22px',
            boxShadow: 'rgb(188, 188, 188) 0px 0px 0px 1px',
            colorScheme: 'only light'
        },
        onClick: function(e) {
            e.preventDefault();
            swapColors();
        }
    });
    function updateSecondaryColor() {
        secondaryColorBtn.style.backgroundColor = _bb.BB.ColorConverter.toRgbStr(secondaryColorRGB);
    }
    function swapColors() {
        // swap hsv
        let tmp = secondaryColorHSV;
        secondaryColorHSV = primaryColorHSV;
        updatePrimaryHSV(tmp);
        // swap rgb
        tmp = secondaryColorRGB;
        secondaryColorRGB = primaryColorRGB;
        primaryColorRGB = tmp;
        controlH.style.left = parseInt('' + (primaryColorHSV.h / 359 * width - 1)) + 'px';
        updateSVCanvas();
        updateSVPointer();
        setColPreview();
        updateSecondaryColor();
        emitColor(new _bb.BB.RGB(primaryColorRGB.r, primaryColorRGB.g, primaryColorRGB.b));
    }
    updateSecondaryColor();
    // --- interface ---
    this.setColor = function(c) {
        primaryColorRGB = {
            r: parseInt(c.r, 10),
            g: parseInt(c.g, 10),
            b: parseInt(c.b, 10)
        };
        updatePrimaryHSV(_bb.BB.ColorConverter.toHSV(c));
        controlH.style.left = parseInt('' + (primaryColorHSV.h / 359 * width - 1)) + 'px';
        updateSVCanvas();
        updateSVPointer();
        setColPreview();
    };
    this.getColor = function() {
        return new _bb.BB.RGB(primaryColorRGB.r, primaryColorRGB.g, primaryColorRGB.b);
    };
    this.getSecondaryRGB = function() {
        return new _bb.BB.RGB(secondaryColorRGB.r, secondaryColorRGB.g, secondaryColorRGB.b);
    };
    this.setPickCallback = function(func) {
        pickCallback = func;
    };
    this.pickingDone = function() {
        if (!isPicking) return;
        isPicking = false;
        _bb.BB.removeClassName(pickerButton, 'color-picker-preview-button-active');
    };
    this.enable = function(e) {
        if (e) {
            div.style.pointerEvents = '';
            div.style.opacity = '1';
            outputDiv.style.pointerEvents = '';
            outputDiv.style.opacity = '1';
        } else {
            div.style.pointerEvents = 'none';
            div.style.opacity = '0.5';
            outputDiv.style.pointerEvents = 'none';
            outputDiv.style.opacity = '0.5';
        }
    };
    this.setHeight = function(h) {
        h = parseInt('' + (h - height * 2 - 3), 10);
        if (h === svHeight) return;
        svHeight = h;
        _bb.BB.css(svSvg, {
            width: width + 'px',
            height: svHeight + 'px'
        });
        SVContainer.style.height = svHeight + 'px';
        updateSVPointer();
    };
    this.swapColors = function() {
        swapColors();
    };
    this.getElement = function() {
        return div;
    };
    this.getOutputElement = function() {
        return outputDiv;
    };
};

},{"../../../bb/bb":"e3nbn","../modals/color-slider-hex-dialog":"6s9Kq","./slider-falloff":"2HhBa","url:~/src/app/img/ui/tool-picker.svg":"8djEk","../../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8djEk":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "tool-picker.174261e4.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"5etHO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "KlSmallColorSlider", ()=>KlSmallColorSlider
);
var _bb = require("../../../bb/bb");
var _sliderFalloff = require("./slider-falloff");
const KlSmallColorSlider = function(params) {
    const div = document.createElement('div');
    div.oncontextmenu = function(e) {
        e.preventDefault();
    };
    let color = _bb.BB.ColorConverter.toHSV(new _bb.BB.RGB(params.color.r, params.color.g, params.color.b));
    _bb.BB.css(div, {
        width: params.width + 'px',
        position: 'relative',
        overflow: 'hidden',
        userSelect: 'none'
    });
    const canvasSV = _bb.BB.canvas(10, 10);
    canvasSV.style.width = params.width + 'px';
    canvasSV.style.height = params.heightSV + 'px';
    canvasSV.style.cursor = 'crosshair';
    function updateSV() {
        const ctx = canvasSV.getContext('2d');
        for(let i = 0; i < canvasSV.height; i += 1){
            const gradient1 = ctx.createLinearGradient(0, 0, canvasSV.width, 0);
            const colleft = _bb.BB.ColorConverter.toRGB(new _bb.BB.HSV(color.h, 1, 100 - i / canvasSV.height * 100));
            const colright = _bb.BB.ColorConverter.toRGB(new _bb.BB.HSV(color.h, 100, 100 - i / canvasSV.height * 100));
            gradient1.addColorStop(0, '#' + _bb.BB.ColorConverter.toHexString(colleft));
            gradient1.addColorStop(1, '#' + _bb.BB.ColorConverter.toHexString(colright));
            ctx.fillStyle = '#ff0000'; //needed for chrome...otherwise alpha problem
            ctx.fillStyle = gradient1;
            ctx.fillRect(0, i, canvasSV.width, 1);
        }
    }
    updateSV();
    const canvasH = _bb.BB.canvas(params.width, params.heightH);
    canvasH.style.cursor = 'ew-resize';
    (function() {
        const ctx = canvasH.getContext('2d');
        const gradH = ctx.createLinearGradient(0, 0, params.width, 0);
        for(let i = 0; i < 1; i += 0.01){
            const col = _bb.BB.ColorConverter.toRGB(new _bb.BB.HSV(i * 360, 100, 100));
            gradH.addColorStop(i, 'rgba(' + parseInt('' + col.r) + ', ' + parseInt('' + col.g) + ', ' + parseInt('' + col.b) + ', 1)');
        }
        ctx.fillStyle = gradH;
        ctx.fillRect(0, 0, params.width, params.heightH);
    })();
    _bb.BB.css(canvasSV, {
        width: params.width + 'px',
        height: params.heightSV + 'px',
        overflow: 'hidden',
        position: 'relative'
    });
    canvasSV.style.cssFloat = 'left';
    canvasH.style.cssFloat = 'left';
    div.appendChild(canvasSV);
    div.appendChild(canvasH);
    const pointerSV = document.createElement('div');
    _bb.BB.css(pointerSV, {
        width: '8px',
        height: '8px',
        borderRadius: '8px',
        position: 'absolute',
        pointerEvents: 'none',
        boxShadow: '0 0 0 1px #000, inset 0 0 0 1px #fff'
    });
    div.appendChild(pointerSV);
    const pointerH = document.createElement('div');
    _bb.BB.css(pointerH, {
        width: '0',
        height: params.heightH + 'px',
        borderLeft: '1px solid #fff',
        borderRight: '1px solid #000',
        position: 'absolute',
        top: params.heightSV + 'px',
        pointerEvents: 'none'
    });
    div.appendChild(pointerH);
    function updateSVPointer() {
        const left = color.s / 100 * params.width - 4;
        const top = (1 - color.v / 100) * params.heightSV - 4;
        _bb.BB.css(pointerSV, {
            left: left + 'px',
            top: top + 'px'
        });
    /*if (top < params.heightSV/3) {
        pointerSV.style.border = "1px solid rgba(0,0,0,1)";
    } else {
        pointerSV.style.border = "1px solid rgba(255,255,255,1)";
    }*/ }
    function updateHPointer() {
        pointerH.style.left = color.h / 359.999 * params.width - 1 + 'px';
    }
    updateSVPointer();
    updateHPointer();
    const virtualHSV = {
        h: 0,
        s: 0,
        v: 0
    };
    let svPointerId = null;
    const svPointerListener = new _bb.BB.PointerListener({
        target: canvasSV,
        maxPointers: 1,
        fixScribble: true,
        onPointer: function(event) {
            if (event.type === 'pointerdown') {
                svPointerId = event.pointerId;
                if (event.button === 'left') {
                    virtualHSV.s = event.relX / params.width * 100;
                    virtualHSV.v = 100 - event.relY / params.heightSV * 100;
                    color = new _bb.BB.HSV(color.h, virtualHSV.s, virtualHSV.v);
                    updateSVPointer();
                    params.callback(_bb.BB.ColorConverter.toRGB(color));
                } else {
                    virtualHSV.s = color.s;
                    virtualHSV.v = color.v;
                }
            }
            if (event.type === 'pointermove' && [
                'left',
                'right'
            ].includes(event.button) && svPointerId === event.pointerId) {
                let factor = 1;
                if (event.button === 'right') factor = 0.5;
                virtualHSV.s += event.dX / params.width * 100 * factor;
                virtualHSV.v -= event.dY / params.heightSV * 100 * factor;
                color = new _bb.BB.HSV(color.h, virtualHSV.s, virtualHSV.v);
                updateSVPointer();
                params.callback(_bb.BB.ColorConverter.toRGB(color));
            }
            if (event.type === 'pointerup') svPointerId = null;
        }
    });
    let hPointerId = null;
    const hPointerListener = new _bb.BB.PointerListener({
        target: canvasH,
        maxPointers: 1,
        fixScribble: true,
        onPointer: function(event) {
            if (event.type === 'pointerdown') {
                hPointerId = event.pointerId;
                if (event.button === 'left') {
                    virtualHSV.h = event.relX / params.width * 359.99;
                    color = new _bb.BB.HSV(virtualHSV.h, color.s, color.v);
                    updateSV();
                    updateHPointer();
                    params.callback(_bb.BB.ColorConverter.toRGB(color));
                } else virtualHSV.h = color.h;
            }
            if (event.type === 'pointermove' && [
                'left',
                'right'
            ].includes(event.button) && hPointerId === event.pointerId) {
                const deltaY = Math.abs(event.pageY - event.downPageY);
                const factor = _sliderFalloff.calcSliderFalloffFactor(deltaY, event.button === 'right');
                virtualHSV.h += event.dX / params.width * 359.99 * factor;
                if (event.button === 'right') {
                    virtualHSV.h = virtualHSV.h % 359.99;
                    if (virtualHSV.h < 0) virtualHSV.h += 359.99;
                }
                virtualHSV.h = Math.min(359.99, virtualHSV.h);
                color = new _bb.BB.HSV(virtualHSV.h, color.s, color.v);
                updateSV();
                updateHPointer();
                params.callback(_bb.BB.ColorConverter.toRGB(color));
            }
            if (event.type === 'pointerup') hPointerId = null;
        }
    });
    const cleardiv = document.createElement('div');
    cleardiv.style.clear = 'both';
    div.appendChild(cleardiv);
    // --- interface ---
    this.setColor = function(c) {
        color = _bb.BB.ColorConverter.toHSV(new _bb.BB.RGB(c.r, c.g, c.b));
        updateSV();
        updateSVPointer();
        updateHPointer();
    };
    this.getColor = function() {
        return _bb.BB.ColorConverter.toRGB(color);
    };
    this.getElement = function() {
        return div;
    };
    this.destroy = function() {
        svPointerListener.destroy();
        hPointerListener.destroy();
    };
    this.end = function() {
        svPointerId = null;
        hPointerId = null;
    };
};

},{"../../../bb/bb":"e3nbn","./slider-falloff":"2HhBa","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"evhHh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PointSlider", ()=>PointSlider
);
var _bb = require("../../../bb/bb");
const PointSlider = function(param) {
    const div = document.createElement('div');
    div.style.position = 'relative';
    const sliderLine = _bb.BB.el({
    });
    const sliderPoint = _bb.BB.el({
        css: {
            colorScheme: 'only light'
        }
    });
    div.appendChild(sliderLine);
    div.appendChild(sliderPoint);
    let sliderPos;
    let isDragging = false;
    _bb.BB.css(sliderLine, {
        marginTop: parseInt('' + (param.pointSize / 2 - 1)) + 'px',
        height: '2px',
        background: '#aaa',
        width: param.width + 'px'
    });
    //sliderPoint
    const touchAreaEl = _bb.BB.el({
        parent: sliderPoint,
        css: {
            // background: 'rgba(255,0,0,0.4)',
            margin: '-7px 0 0 -7px',
            width: 'calc(100% + 14px)',
            height: 'calc(100% + 7px)'
        }
    });
    function redrawPoint() {
        sliderPoint.style.left = sliderPos + 'px';
        if (isDragging) sliderPoint.style.boxShadow = '0 0 6px rgba(0,0,0,1)';
        else sliderPoint.style.boxShadow = '0 0 3px rgba(0,0,0,0.8)';
    }
    function getValue() {
        return sliderPos / (param.width - param.pointSize);
    }
    let pointerListener;
    {
        let isFirst;
        sliderPos = _bb.BB.clamp(param.init * (param.width - param.pointSize), 0, param.width - param.pointSize);
        _bb.BB.css(sliderPoint, {
            position: 'absolute',
            top: '0px',
            backgroundColor: '#eaeaea',
            boxShadow: '0 0 3px rgba(0,0,0,0.8)',
            width: param.pointSize + 'px',
            height: param.pointSize + 'px',
            borderRadius: param.pointSize + 'px',
            cursor: 'ew-resize',
            transition: 'box-shadow 0.2s ease-in-out'
        });
        redrawPoint();
        let imaginaryPos;
        pointerListener = new _bb.BB.PointerListener({
            target: sliderPoint,
            fixScribble: true,
            onPointer: function(event) {
                if (event.type === 'pointerdown' && event.button === 'left') {
                    isFirst = true;
                    isDragging = true;
                    imaginaryPos = sliderPos;
                    redrawPoint();
                    event.eventStopPropagation();
                } else if (event.type === 'pointermove' && event.button === 'left') {
                    event.eventStopPropagation();
                    imaginaryPos = imaginaryPos + event.dX;
                    sliderPos = parseInt('' + _bb.BB.clamp(imaginaryPos, 0, param.width - param.pointSize));
                    redrawPoint();
                    param.callback(getValue(), isFirst, false);
                    isFirst = false;
                }
                if (event.type === 'pointerup') {
                    event.eventStopPropagation();
                    isDragging = false;
                    redrawPoint();
                    param.callback(getValue(), false, true);
                }
            }
        });
    }
    // --- interface ---
    this.getEl = function() {
        return div;
    };
    this.setActive = function(isActive) {
        if (isActive) sliderPoint.style.backgroundColor = '#fff';
        else sliderPoint.style.backgroundColor = '#eaeaea';
    };
    this.destroy = function() {
        pointerListener.destroy();
    };
};

},{"../../../bb/bb":"e3nbn","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6ALHb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ColorOptions", ()=>ColorOptions
);
var _bb = require("../../../bb/bb");
const ColorOptions = function(p) {
    const div = _bb.BB.el({
        content: p.label ? p.label : '',
        css: {
            display: 'flex',
            alignItems: 'center',
            colorScheme: 'only light'
        }
    });
    let selectedIndex = 0;
    const colorArr = [];
    const buttonArr = [];
    const buttonSize = 22;
    const checkerUrl = _bb.BB.createCheckerDataUrl(5);
    // build colorArr while removing duplicates
    for(let i2 = 0; i2 < p.colorArr.length; i2++){
        const item = p.colorArr[i2];
        let found = false;
        for(let e = 0; e < colorArr.length; e++){
            const sItem = colorArr[e];
            if (sItem === null || item === null) continue;
            if (sItem.r === item.r && sItem.g === item.g && sItem.b === item.b && sItem.a === item.a) {
                found = true;
                break;
            }
        }
        if (found) continue;
        colorArr.push(item);
        if ('initialIndex' in p && p.initialIndex === i2) selectedIndex = colorArr.length - 1;
    }
    for(let i1 = 0; i1 < colorArr.length; i1++)(function(i) {
        const colorButton = _bb.BB.el({
            content: colorArr[i] ? '' : 'X',
            css: {
                width: buttonSize + 'px',
                height: buttonSize + 'px',
                backgroundColor: colorArr[i] ? _bb.BB.ColorConverter.toRgbaStr(colorArr[i]) : 'transparent',
                marginLeft: '7px',
                boxShadow: '0 0 0 1px #aaa',
                cursor: 'pointer',
                userSelect: 'none',
                textAlign: 'center',
                lineHeight: buttonSize + 1 + 'px',
                color: '#aaa'
            }
        });
        if (colorArr[i] && colorArr[i].a === 0) colorButton.style.backgroundImage = 'url(' + checkerUrl + ')';
        colorButton.onclick = function(e) {
            e.preventDefault();
            selectedIndex = i;
            update();
            p.onChange(colorArr[i]);
        };
        colorButton.setIsSelected = function(b) {
            if (b) _bb.BB.css(colorButton, {
                boxShadow: '0 0 0 2px var(--active-highlight-color), 0 0 5px 0 var(--active-highlight-color)',
                pointerEvents: 'none'
            });
            else _bb.BB.css(colorButton, {
                boxShadow: '0 0 0 1px #aaa',
                pointerEvents: ''
            });
        };
        div.appendChild(colorButton);
        buttonArr.push(colorButton);
    })(i1);
    function update() {
        for(let i = 0; i < buttonArr.length; i++)buttonArr[i].setIsSelected(i === selectedIndex);
    }
    update();
    // --- interface ---
    this.getElement = function() {
        return div;
    };
    this.destroy = ()=>{
        buttonArr.forEach((item)=>{
            item.onclick = null;
        });
        buttonArr.splice(0, buttonArr.length);
    };
};

},{"../../../bb/bb":"e3nbn","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"b8ZKE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Options", ()=>Options
);
var _bb = require("../../../bb/bb");
const Options = function(p) {
    const div = _bb.BB.el({
    });
    const wrapperEl = _bb.BB.el({
        parent: div,
        className: 'kl-option-wrapper',
        css: {
            display: 'flex'
        }
    });
    const optionArr = [];
    let selectedId = 'initialId' in p ? p.initialId : p.optionArr[0].id;
    function createOption(o) {
        const optionObj = {
            id: o.id,
            el: null
        };
        const classArr = [
            'kl-option'
        ];
        if (p.isSmall) classArr.push('kl-option--small');
        if (typeof o.label !== 'string') {
            classArr.push('kl-option--custom-el');
            _bb.BB.css(o.label, {
                display: 'block',
                pointerEvents: 'none'
            });
        }
        optionObj.el = _bb.BB.el({
            parent: wrapperEl,
            content: o.label,
            className: classArr.join(' '),
            onClick: function() {
                if (selectedId !== optionObj.id) {
                    selectedId = optionObj.id;
                    update();
                    p.onChange(selectedId);
                }
            }
        });
        if (o.title) optionObj.el.title = o.title;
        optionArr.push(optionObj);
    }
    function update() {
        for(let i = 0; i < optionArr.length; i++)if (optionArr[i].id === selectedId) _bb.BB.addClassName(optionArr[i].el, 'kl-option-selected');
        else _bb.BB.removeClassName(optionArr[i].el, 'kl-option-selected');
    }
    for(let i1 = 0; i1 < p.optionArr.length; i1++)createOption(p.optionArr[i1]);
    update();
    if (p.changeOnInit) setTimeout(function() {
        p.onChange(selectedId);
    }, 0);
    function getIndex() {
        for(let i = 0; i < optionArr.length; i++){
            if (optionArr[i].id === selectedId) return i;
        }
    }
    // --- interface ---
    this.getElement = function() {
        return div;
    };
    this.getValue = function() {
        return selectedId;
    };
    this.next = function() {
        selectedId = optionArr[(getIndex() + 1) % optionArr.length].id;
        update();
        p.onChange(selectedId);
    };
    this.previous = function() {
        selectedId = optionArr[(optionArr.length + getIndex() - 1) % optionArr.length].id;
        update();
        p.onChange(selectedId);
    };
    this.destroy = ()=>{
        optionArr.forEach((item)=>{
            _bb.BB.destroyEl(item.el);
        });
        optionArr.splice(0, optionArr.length);
    };
};

},{"../../../bb/bb":"e3nbn","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jNNjC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * display little messages at the top of KlWorkspace
 */ parcelHelpers.export(exports, "StatusOverlay", ()=>StatusOverlay
);
var _bb = require("../../../bb/bb");
// @ts-ignore
var _angleSvg = require("url:~/src/app/img/ui/angle.svg");
var _angleSvgDefault = parcelHelpers.interopDefault(_angleSvg);
class StatusOverlay {
    updateUiState() {
        if (!this.el) return;
        setTimeout(()=>{
        }, 100);
        if (this.uiState === 'left') this.el.style.left = '271px';
        else this.el.style.removeProperty('left');
    }
    init() {
        this.el = _bb.BB.el({
            className: "top-overlay g-root",
            onClick: _bb.BB.handleClick
        });
        if (this.isWide) this.el.style.width = '100%';
        this.updateUiState();
        this.innerEl = _bb.BB.el({
            className: 'top-overlay-inner'
        });
        this.angleIm = new Image();
        this.angleIm.src = _angleSvgDefault.default;
        _bb.BB.css(this.angleIm, {
            verticalAlign: 'bottom',
            width: '20px',
            height: '20px',
            marginLeft: '5px',
            borderRadius: '10px'
        });
        this.innerInnerEl = document.createElement('div');
        this.innerInnerEl.style.display = 'inline-block';
        this.innerEl.appendChild(this.innerInnerEl);
        this.innerEl.appendChild(this.angleIm);
        this.el.appendChild(this.innerEl);
        document.body.appendChild(this.el);
        this.el.style.display = "none";
    }
    // --- public ---
    constructor(){
        this.init();
    }
    setWide(b) {
        this.isWide = !!b;
        if (!this.el) return;
        if (this.isWide) {
            this.el.style.width = '100%';
            this.el.style.left = '';
        } else {
            this.el.style.removeProperty('width');
            this.el.style.left = this.uiState === 'left' ? '271px' : '';
        }
    }
    setUiState(state) {
        this.uiState = state;
        this.updateUiState();
    }
    out(msg, doPulse) {
        if (msg && typeof msg === 'object') {
            if (msg.type === 'transform') {
                this.angleIm.style.display = 'inline-block';
                this.angleIm.style.transform = 'rotate(' + msg.angleDeg + 'deg)';
                if (msg.angleDeg % 90 === 0) this.angleIm.style.boxShadow = 'inset 0 0 0 1px rgba(255, 255, 255, 0.7)';
                else this.angleIm.style.boxShadow = '';
                this.innerInnerEl.innerHTML = Math.round(msg.scale * 100) + "%";
            } else this.angleIm.style.display = 'none';
        } else if (typeof msg === 'string') {
            this.angleIm.style.display = 'none';
            this.innerInnerEl.innerHTML = msg;
        }
        if (doPulse) {
            this.innerEl.style.animation = '';
            setTimeout(()=>this.innerEl.style.animation = 'top-overlay-pulse 0.5s ease-out'
            , 20);
            if (this.timeout3) clearTimeout(this.timeout3);
            this.timeout3 = window.setTimeout(()=>this.innerEl.style.animation = ''
            , 520);
        }
        if (this.timeout) clearTimeout(this.timeout);
        if (this.timeout2) clearTimeout(this.timeout2);
        this.el.style.animationName = doPulse ? 'consoleInFast' : "consoleIn";
        this.el.style.opacity = "1";
        this.timeout = window.setTimeout(()=>{
            this.el.style.opacity = "0";
            this.el.style.animationName = "consoleOut";
            this.timeout2 = window.setTimeout(()=>{
                this.el.style.display = "none";
                this.timeout2 = 0;
            }, 450);
            this.timeout = 0;
        }, 1200);
        this.el.style.display = "flex";
    }
}

},{"../../../bb/bb":"e3nbn","url:~/src/app/img/ui/angle.svg":"5sOrq","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5sOrq":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "angle.0222c684.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"3f7X2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "exportDialog", ()=>exportDialog
);
var _bb = require("../../../bb/bb");
var _popup = require("./popup");
function exportDialog(parent, image) {
    let boxSize, aboutCloseFunc, aboutDiv, closed, aniToggle, imageContainer, coverImage, coverSize, text, holding, aniTimeout, halfBoxSize;
    boxSize = 44;
    halfBoxSize = 22;
    aboutCloseFunc = function() {
    };
    closed = false;
    aniToggle = false;
    aboutDiv = document.createElement("div");
    _bb.BB.css(aboutDiv, {
        width: 7 * boxSize + "px"
    });
    imageContainer = document.createElement("div");
    coverImage = new Image();
    coverImage.src = image.src;
    imageContainer.appendChild(coverImage);
    imageContainer.appendChild(image);
    _bb.BB.css(imageContainer, {
        width: 6 * boxSize + "px",
        height: 4 * boxSize + "px",
        marginTop: boxSize / 2 - 1 + "px",
        marginLeft: boxSize / 2 - 1 + "px",
        position: "relative",
        overflow: "hidden",
        boxShadow: "0 0 10px 4px rgba(255,255,255, 0)",
        border: "1px solid rgba(255, 255, 255, 1)",
        transition: "box-shadow 0.7s linear"
    });
    _bb.BB.css(image, {
        position: "absolute",
        left: '0',
        top: '0',
        width: 6 * boxSize + "px",
        height: 4 * boxSize + "px",
        opacity: '0'
    });
    coverSize = {
        width: 6 * boxSize,
        height: 6 * boxSize / image.width * image.height
    };
    if (coverSize.height < 4 * boxSize) {
        coverSize.height = 4 * boxSize;
        coverSize.width = coverSize.height / image.height * image.width;
    }
    _bb.BB.css(coverImage, {
        position: "absolute",
        top: 2 * boxSize + "px",
        left: 3 * boxSize + "px",
        width: coverSize.width + "px",
        height: coverSize.height + "px",
        marginLeft: -coverSize.width / 2 + "px",
        marginTop: -coverSize.height / 2 + "px"
    });
    function animation() {
        if (closed) return;
        aniToggle = !aniToggle;
        if (aniToggle) _bb.BB.css(imageContainer, {
            border: "1px solid rgba(0, 0, 0, 1)"
        });
        else _bb.BB.css(imageContainer, {
            border: "1px solid rgba(200, 200, 200, 1)"
        });
        setTimeout(animation, 510);
    }
    animation();
    text = document.createElement("div");
    text.innerHTML = "Right-Click or Press-Hold on the image, then save.";
    text.ontouchstart = function() {
        return false;
    };
    _bb.BB.css(text, {
        fontSize: boxSize / 2.5 + "px",
        color: "#666",
        padding: "10px",
        textAlign: "center"
    });
    aboutDiv.appendChild(imageContainer);
    aboutDiv.appendChild(text);
    holding = false;
    image.ontouchstart = function() {
        _bb.BB.css(imageContainer, {
            boxShadow: "0 0 10px 8px rgba(0,255,255, 1)"
        });
        holding = true;
        aniTimeout = setTimeout(function() {
            holding = false;
            _bb.BB.css(imageContainer, {
                boxShadow: "0 0 10px 4px rgba(0,255,255, 0)"
            });
        }, 1500);
    };
    image.ontouchmove = function() {
        _bb.BB.css(imageContainer, {
            boxShadow: "0 0 10px 4px rgba(0,255,255, 0)"
        });
        holding = false;
        clearTimeout(aniTimeout);
    };
    image.ontouchend = function() {
        _bb.BB.css(imageContainer, {
            boxShadow: "0 0 10px 4px rgba(0,255,255, 0)"
        });
        holding = false;
        clearTimeout(aniTimeout);
    };
    _popup.popup({
        target: parent,
        message: "<b>Save Image</b>",
        div: aboutDiv,
        buttons: [
            "Close"
        ],
        callback: function(result) {
            closed = true;
        }
    });
}

},{"../../../bb/bb":"e3nbn","./popup":"7D028","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fSFui":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * element that lets you crop an image and copy it via right click
 *
 * param = {
 *     width: number,
 *     height: number,
 *     canvas: image | canvas,
 *     isNotCopy: boolean,
 *     onChange: function(width, height)
 * }
 *
 * @param param object
 * @constructor
 */ parcelHelpers.export(exports, "CropCopy", ()=>CropCopy
);
var _bb = require("../../../bb/bb");
function CropCopy(param) {
    const div = document.createElement('div');
    _bb.BB.css(div, {
        position: 'relative',
        height: param.height + 'px',
        width: param.width + 'px',
        overflow: 'hidden',
        colorScheme: 'only light'
    });
    div.style.position = 'relative';
    let crop;
    function resetCrop() {
        crop = {
            x: 0,
            y: 0,
            width: param.canvas.width,
            height: param.canvas.height
        };
    }
    resetCrop();
    function updateCroppedCanvas() {
        croppedCanvas.width = Math.round(crop.width);
        croppedCanvas.height = Math.round(crop.height);
        let ctx = croppedCanvas.getContext('2d');
        ctx.drawImage(param.canvas, Math.round(-crop.x), Math.round(-crop.y));
        if (croppedImage) croppedImage.src = croppedCanvas.toDataURL('image/png');
        if (param.onChange) param.onChange(croppedCanvas.width, croppedCanvas.height);
    }
    function updateSelectionRect() {
        _bb.BB.css(selectionRect, {
            left: thumbX + crop.x * scaleW + 'px',
            top: thumbY + crop.y * scaleH + 'px',
            width: crop.width * scaleW + 'px',
            height: crop.height * scaleH + 'px'
        });
        if (param.onChange) param.onChange(Math.round(crop.width), Math.round(crop.height));
    }
    function isInsideSelectionRect(p) {
        let rect = {
            x: Math.round(thumbX + crop.x * scaleW),
            y: Math.round(thumbY + crop.y * scaleH),
            width: Math.round(crop.width * scaleW),
            height: Math.round(crop.height * scaleH)
        };
        return rect.x <= p.x && p.x <= rect.x + rect.width && rect.y <= p.y && p.y <= rect.y + rect.height;
    }
    const croppedCanvas = _bb.BB.canvas();
    let eventTarget = croppedCanvas;
    let croppedImage = null;
    if (!param.isNotCopy) {
        croppedImage = new Image();
        eventTarget = croppedImage;
    }
    _bb.BB.css(eventTarget, {
        height: param.height + 'px',
        width: param.width + 'px'
    });
    div.appendChild(eventTarget);
    updateCroppedCanvas();
    const padding = 20;
    const previewWrapper = _bb.BB.el({
        css: {
            width: param.width + 'px',
            height: param.height + 'px',
            position: 'absolute',
            left: '0',
            top: '0',
            pointerEvents: 'none'
        }
    });
    div.appendChild(previewWrapper);
    _bb.BB.createCheckerDataUrl(4, function(v) {
        previewWrapper.style.backgroundImage = 'url(' + v + ')';
    });
    const thumbSize = _bb.BB.fitInto(param.canvas.width, param.canvas.height, param.width - padding * 2, param.height - padding * 2, 1);
    const thumbCanvas = _bb.BB.canvas(Math.round(thumbSize.width), Math.round(thumbSize.height));
    thumbCanvas.style.imageRendering = 'pixelated';
    const scaleW = thumbCanvas.width / param.canvas.width;
    const scaleH = thumbCanvas.height / param.canvas.height;
    const thumbCtx = thumbCanvas.getContext('2d');
    thumbCtx.imageSmoothingEnabled = false;
    thumbCtx.drawImage(param.canvas, 0, 0, thumbCanvas.width, thumbCanvas.height);
    previewWrapper.appendChild(thumbCanvas);
    const thumbX = parseInt('' + (param.width - thumbCanvas.width) / 2);
    const thumbY = parseInt('' + (param.height - thumbCanvas.height) / 2);
    _bb.BB.css(thumbCanvas, {
        position: 'absolute',
        left: thumbX + "px",
        top: thumbY + "px"
    });
    const selectionRect = _bb.BB.el({
        css: {
            position: 'absolute',
            boxShadow: '0 0 0 1px #fff, 0 0 0 2px #000, 0 0 40px 1px #000'
        }
    });
    previewWrapper.appendChild(selectionRect);
    updateSelectionRect();
    function toOriginalSpace(p) {
        return {
            x: _bb.BB.clamp((p.x - thumbX) / scaleW, 0, param.canvas.width),
            y: _bb.BB.clamp((p.y - thumbY) / scaleH, 0, param.canvas.height)
        };
    }
    //gen crop from thumb-space points
    function genCrop(p1, p2) {
        let topLeftP = {
            x: Math.min(p1.x, p2.x),
            y: Math.min(p1.y, p2.y)
        };
        let bottomRightP = {
            x: Math.max(p1.x, p2.x),
            y: Math.max(p1.y, p2.y)
        };
        let origTopLeftP = toOriginalSpace(topLeftP);
        let origBottomRightP = toOriginalSpace(bottomRightP);
        origTopLeftP.x = Math.floor(origTopLeftP.x);
        origTopLeftP.y = Math.floor(origTopLeftP.y);
        origBottomRightP.x = Math.ceil(origBottomRightP.x);
        origBottomRightP.y = Math.ceil(origBottomRightP.y);
        return {
            x: origTopLeftP.x,
            y: origTopLeftP.y,
            width: origBottomRightP.x - origTopLeftP.x,
            height: origBottomRightP.y - origTopLeftP.y
        };
    }
    function isReset() {
        return crop.x === 0 && crop.y === 0 && crop.width === param.canvas.width && crop.height === param.canvas.height;
    }
    let startP;
    let startCrop = null;
    let isDragging = false;
    let didMove = false;
    let updateCropTimeout;
    const pointerListener = new _bb.BB.PointerListener({
        target: eventTarget,
        fixScribble: true,
        onPointer: function(event) {
            let fullPos;
            if (event.type === 'pointerdown' && event.button === 'left') {
                event.eventPreventDefault();
                isDragging = true;
                startP = {
                    x: event.relX,
                    y: event.relY
                };
                if (!isReset() && isInsideSelectionRect(startP)) startCrop = {
                    x: crop.x,
                    y: crop.y,
                    width: crop.width,
                    height: crop.height
                };
                else crop = genCrop(startP, startP);
            } else if (event.type === 'pointermove' && event.button === 'left') {
                event.eventPreventDefault();
                didMove = true;
                if (startCrop) {
                    crop.x = startCrop.x + Math.round((event.relX - startP.x) / scaleW);
                    crop.y = startCrop.y + Math.round((event.relY - startP.y) / scaleH);
                    crop.x = _bb.BB.clamp(crop.x, 0, param.canvas.width - crop.width);
                    crop.y = _bb.BB.clamp(crop.y, 0, param.canvas.height - crop.height);
                } else crop = genCrop(startP, {
                    x: event.relX,
                    y: event.relY
                });
                updateSelectionRect();
            } else if (event.type === 'pointerup' && startP) {
                event.eventPreventDefault();
                isDragging = false;
                startCrop = null;
                startP = null;
                if (crop.width === 0 || crop.height === 0 || !didMove) {
                    resetCrop();
                    updateSelectionRect();
                }
                didMove = false;
                updateCropTimeout = setTimeout(updateCroppedCanvas, 1);
            }
        }
    });
    const keyListener = new _bb.BB.KeyListener({
        onDown: function(keyStr, e, comboStr) {
            if (isDragging) return;
            let doUpdate = false;
            let stepSize = Math.max(1, 1 / scaleW);
            let shiftIsPressed = keyListener.isPressed('shift');
            if (keyStr === 'left') {
                if (shiftIsPressed) crop.width = _bb.BB.clamp(crop.width - stepSize, 1, param.canvas.width - crop.x);
                else crop.x = _bb.BB.clamp(crop.x - stepSize, 0, param.canvas.width - crop.width);
                doUpdate = true;
            }
            if (keyStr === 'right') {
                if (shiftIsPressed) crop.width = _bb.BB.clamp(crop.width + stepSize, 1, param.canvas.width - crop.x);
                else crop.x = _bb.BB.clamp(crop.x + stepSize, 0, param.canvas.width - crop.width);
                doUpdate = true;
            }
            if (keyStr === 'up') {
                if (shiftIsPressed) crop.height = _bb.BB.clamp(crop.height - stepSize, 1, param.canvas.height - crop.y);
                else crop.y = _bb.BB.clamp(crop.y - stepSize, 0, param.canvas.height - crop.height);
                doUpdate = true;
            }
            if (keyStr === 'down') {
                if (shiftIsPressed) crop.height = _bb.BB.clamp(crop.height + stepSize, 1, param.canvas.height - crop.y);
                else crop.y = _bb.BB.clamp(crop.y + stepSize, 0, param.canvas.height - crop.height);
                doUpdate = true;
            }
            if (doUpdate) {
                e.preventDefault();
                updateSelectionRect();
                clearTimeout(updateCropTimeout);
                updateCropTimeout = setTimeout(updateCroppedCanvas, 100);
            }
        }
    });
    this.getEl = function() {
        return div;
    };
    this.reset = function() {
        resetCrop();
        updateCroppedCanvas();
        updateSelectionRect();
    };
    this.destroy = function() {
        eventTarget.style.removeProperty('width');
        eventTarget.style.removeProperty('height');
        keyListener.destroy();
        pointerListener.destroy();
    };
    this.isReset = function() {
        return isReset();
    };
    this.getRect = function() {
        return JSON.parse(JSON.stringify(crop));
    };
    this.getCroppedImage = function() {
        return croppedCanvas;
    };
}

},{"../../../bb/bb":"e3nbn","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hZ9ke":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/// <reference path="./types.d.ts" />
/**
 *
 * @param parent
 * @param fullCanvas
 * @param cropCallback
 * @param output - BB.Output
 * @param showCrop - boolean - show crop button
 */ parcelHelpers.export(exports, "clipboardDialog", ()=>clipboardDialog
);
var _bb = require("../../../bb/bb");
var _popup = require("./popup");
var _cropCopy = require("../components/crop-copy");
var _language = require("../../../language/language");
function clipboardDialog(parent, fullCanvas, cropCallback, output, showCrop) {
    const div = document.createElement("div");
    const isSmall = window.innerWidth < 550 || window.innerHeight < 550;
    let topWrapper = _bb.BB.el({
        content: _language.LANG('crop-drag-to-crop'),
        css: {
            textAlign: 'center'
        }
    });
    div.appendChild(topWrapper);
    let cropCopy = new _cropCopy.CropCopy({
        width: isSmall ? 340 : 540,
        height: isSmall ? 300 : 350,
        canvas: fullCanvas
    });
    _bb.BB.css(cropCopy.getEl(), {
        marginTop: '10px',
        marginLeft: '-20px',
        borderTop: '1px solid #bbb',
        borderBottom: '1px solid #bbb'
    });
    div.appendChild(cropCopy.getEl());
    function toClipboard() {
        const imgURL = cropCopy.getCroppedImage().toDataURL('image/png');
        setTimeout(async function() {
            try {
                const data = await fetch(imgURL);
                const blob = await data.blob();
                await navigator.clipboard.write([
                    new ClipboardItem({
                        [blob.type]: blob
                    }) // todo check is possible?
                ]);
                setTimeout(function() {
                    output.out(_language.LANG('cropcopy-copied'), true);
                }, 200);
            } catch (err) {
                console.error(err.name, err.message);
            }
        }, 0);
    }
    let keyListener = new _bb.BB.KeyListener({
        onDown: function(keyStr, KeyEvent, comboStr) {
            if (comboStr === 'ctrl+c') {
                toClipboard();
                closefunc();
            }
        }
    });
    let closefunc;
    function blur() {
        closefunc();
    }
    _bb.BB.addEventListener(window, "blur", blur);
    _popup.popup({
        target: parent,
        message: '<b>' + (showCrop ? `${_language.LANG('cropcopy-title-copy')} / ${_language.LANG('cropcopy-title-crop')}` : `${_language.LANG('cropcopy-title-copy')}`) + '</b>',
        div: div,
        style: isSmall ? {
        } : {
            width: "500px"
        },
        buttons: showCrop ? [
            _language.LANG('cropcopy-btn-copy'),
            _language.LANG('cropcopy-btn-crop'),
            'Cancel'
        ] : [
            _language.LANG('cropcopy-btn-copy'),
            'Cancel'
        ],
        primaries: [
            _language.LANG('cropcopy-btn-copy')
        ],
        callback: function(result) {
            if (result === _language.LANG('cropcopy-btn-copy')) toClipboard();
            else if (result === _language.LANG('cropcopy-btn-crop')) {
                let rectObj = cropCopy.getRect();
                cropCallback({
                    left: Math.round(-rectObj.x),
                    right: Math.round(rectObj.x + rectObj.width - fullCanvas.width),
                    top: Math.round(-rectObj.y),
                    bottom: Math.round(rectObj.y + rectObj.height - fullCanvas.height)
                });
            }
            _bb.BB.removeEventListener(window, "blur", blur);
            cropCopy.destroy();
            keyListener.destroy();
        },
        clickOnEnter: _language.LANG('cropcopy-btn-copy'),
        closefunc: function(func) {
            closefunc = func;
        }
    });
}

},{"../../../bb/bb":"e3nbn","./popup":"7D028","../components/crop-copy":"fSFui","../../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8soTa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "klLayerManager", ()=>klLayerManager
);
var _bb = require("../../../bb/bb");
var _popup = require("../modals/popup");
var _klHistory = require("../../history/kl-history");
var _options = require("../base-components/options");
var _select = require("../base-components/select");
var _pointSlider = require("../base-components/point-slider");
// @ts-ignore
var _addLayerSvg = require("url:~/src/app/img/ui/add-layer.svg");
var _addLayerSvgDefault = parcelHelpers.interopDefault(_addLayerSvg);
// @ts-ignore
var _duplicateLayerSvg = require("url:~/src/app/img/ui/duplicate-layer.svg");
var _duplicateLayerSvgDefault = parcelHelpers.interopDefault(_duplicateLayerSvg);
// @ts-ignore
var _mergeLayersSvg = require("url:~/src/app/img/ui/merge-layers.svg");
var _mergeLayersSvgDefault = parcelHelpers.interopDefault(_mergeLayersSvg);
// @ts-ignore
var _removeLayerSvg = require("url:~/src/app/img/ui/remove-layer.svg");
var _removeLayerSvgDefault = parcelHelpers.interopDefault(_removeLayerSvg);
// @ts-ignore
var _renameLayerSvg = require("url:~/src/app/img/ui/rename-layer.svg");
var _renameLayerSvgDefault = parcelHelpers.interopDefault(_renameLayerSvg);
var _klCanvas = require("../../canvas/kl-canvas");
var _language = require("../../../language/language");
var _translateBlending = require("../../canvas/translate-blending");
function klLayerManager(p_canvas, p_func, p_rootDiv) {
    let klCanvas = p_canvas;
    let layerElArr = [];
    let layerHeight = 35;
    let layerSpacing = 0;
    let width = 250;
    let oldHistoryState;
    let updatefunc = p_func;
    let uiState = 'right'; // 'left | 'right'
    let largeThumbDiv = _bb.BB.el({
        onClick: _bb.BB.handleClick,
        css: {
            position: "absolute",
            right: "280px",
            top: "500px",
            background: "#aaa",
            boxShadow: "1px 1px 3px rgba(0,0,0,0.3)",
            pointerEvents: "none",
            padding: '0',
            border: "1px solid #aaa",
            transition: "opacity 0.3s ease-out",
            userSelect: 'none',
            colorScheme: 'only light'
        }
    });
    _bb.BB.createCheckerDataUrl(4, function(url) {
        largeThumbDiv.style.backgroundImage = "url(" + url + ")";
    });
    let largeThumbCanvas = document.createElement("canvas");
    largeThumbCanvas.style.display = "block";
    largeThumbCanvas.width = 200;
    largeThumbCanvas.height = 200;
    largeThumbDiv.appendChild(largeThumbCanvas);
    let largeThumbTimeout, largeThumbInTimeout;
    let largeThumbInDocument = false;
    let klCanvasLayerArr = klCanvas.getLayers();
    let selectedSpotIndex = klCanvasLayerArr.length - 1;
    let div1 = document.createElement("div");
    div1.style.marginRight = "10px";
    div1.style.marginBottom = "10px";
    div1.style.marginLeft = "10px";
    div1.style.marginTop = "10px";
    div1.style.cursor = "default";
    let listdiv = document.createElement("div");
    _bb.BB.css(listdiv, {
        width: width + "px",
        position: "relative"
    });
    function renameLayer(layer) {
        let div = document.createElement('div');
        let label = _bb.BB.el({
            content: _language.LANG('layers-rename-name') + ':',
            css: {
                marginRight: '5px'
            }
        });
        const row = _bb.BB.el({
            css: {
                display: 'flex'
            }
        });
        let input = document.createElement('input');
        input.value = klCanvas.getLayer(layer).name;
        input.setAttribute('data-ignore-focus', 'true');
        const clearBtn = _bb.BB.el({
            tagName: 'Button',
            content: '<img src="' + _removeLayerSvgDefault.default + '" height="20"/>',
            title: _language.LANG('layers-rename-clear'),
            css: {
                marginLeft: '10px'
            },
            onClick: ()=>{
                input.value = '';
                input.focus();
            }
        });
        const suggestions = [
            _language.LANG('layers-rename-sketch'),
            _language.LANG('layers-rename-colors'),
            _language.LANG('layers-rename-lines'),
            _language.LANG('background'),
            _language.LANG('layers-rename-foreground'), 
        ];
        const suggestionBtns = [];
        const row2 = _bb.BB.el({
            css: {
                display: 'flex',
                flexWrap: 'wrap',
                marginTop: '5px',
                marginLeft: '-5px'
            }
        });
        suggestions.forEach((item)=>{
            const btn = _bb.BB.el({
                parent: row2,
                tagName: 'Button',
                content: item,
                onClick: ()=>{
                    input.value = btn.textContent;
                },
                css: {
                    margin: '5px 0 0 5px'
                }
            });
            suggestionBtns.push(btn);
        });
        div.appendChild(label);
        label.append(row, row2);
        row.append(input, clearBtn);
        setTimeout(function() {
            input.focus();
            input.select();
        }, 10);
        _popup.popup({
            target: p_rootDiv,
            message: `<b>${_language.LANG('layers-rename-title')}</b>`,
            div: div,
            buttons: [
                _language.LANG('layers-rename'),
                'Cancel'
            ],
            primaries: [
                _language.LANG('layers-rename')
            ],
            callback: function(val) {
                _bb.BB.destroyEl(clearBtn);
                suggestionBtns.forEach((item)=>{
                    _bb.BB.destroyEl(item);
                });
                suggestionBtns.splice(0, suggestionBtns.length);
                if (val === _language.LANG('layers-rename')) {
                    if (input.value === klCanvas.getLayer(layer).name) return;
                    klCanvas.renameLayer(layer, input.value);
                    createLayerList();
                    _klHistory.klHistory.pause(true);
                    updatefunc(layer);
                    _klHistory.klHistory.pause(false);
                }
            },
            clickOnEnter: _language.LANG('layers-rename')
        });
    }
    let layerListEl = _bb.BB.el({
    });
    div1.disableButtons = function() {
    }; //probably remove
    div1.enableButtons = function() {
    }; //probably remove
    let addnewBtn = document.createElement("button");
    let duplicateBtn = document.createElement("button");
    let mergeBtn = document.createElement("button");
    let removeBtn = document.createElement("button");
    let renameBtn = document.createElement("button");
    function createButtons() {
        let div2 = document.createElement("div");
        function async() {
            _bb.BB.makeUnfocusable(addnewBtn);
            _bb.BB.makeUnfocusable(duplicateBtn);
            _bb.BB.makeUnfocusable(mergeBtn);
            _bb.BB.makeUnfocusable(removeBtn);
            _bb.BB.makeUnfocusable(renameBtn);
            addnewBtn.style.cssFloat = 'left';
            duplicateBtn.style.cssFloat = 'left';
            mergeBtn.style.cssFloat = 'left';
            removeBtn.style.cssFloat = 'left';
            renameBtn.style.cssFloat = 'left';
            addnewBtn.title = _language.LANG('layers-new');
            duplicateBtn.title = _language.LANG('layers-duplicate');
            removeBtn.title = _language.LANG('layers-remove');
            mergeBtn.title = _language.LANG('layers-merge');
            renameBtn.title = _language.LANG('layers-rename-title');
            addnewBtn.style.paddingLeft = "5px";
            addnewBtn.style.paddingRight = "3px";
            removeBtn.style.paddingLeft = "5px";
            removeBtn.style.paddingRight = "3px";
            duplicateBtn.style.paddingLeft = "5px";
            duplicateBtn.style.paddingRight = "3px";
            mergeBtn.style.paddingLeft = "5px";
            mergeBtn.style.paddingRight = "3px";
            renameBtn.style.height = "30px";
            renameBtn.style.lineHeight = "20px";
            addnewBtn.innerHTML = "<img src='" + _addLayerSvgDefault.default + "' height='20'/>";
            duplicateBtn.innerHTML = "<img src='" + _duplicateLayerSvgDefault.default + "' height='20'/>";
            mergeBtn.innerHTML = "<img src='" + _mergeLayersSvgDefault.default + "' height='20'/>";
            removeBtn.innerHTML = "<img src='" + _removeLayerSvgDefault.default + "' height='20'/>";
            renameBtn.innerHTML = "<img src='" + _renameLayerSvgDefault.default + "' height='20'/>";
            addnewBtn.style.marginRight = "5px";
            removeBtn.style.marginRight = "5px";
            duplicateBtn.style.marginRight = "5px";
            mergeBtn.style.marginRight = "5px";
            div2.appendChild(addnewBtn);
            div2.appendChild(removeBtn);
            div2.appendChild(duplicateBtn);
            div2.appendChild(mergeBtn);
            div2.appendChild(renameBtn);
            div2.appendChild(_bb.BB.el({
                css: {
                    clear: 'both'
                }
            }));
            let clearboth = document.createElement("div");
            clearboth.style.clear = "both";
            clearboth.style.height = "10px";
            div2.appendChild(clearboth);
            addnewBtn.onclick = function() {
                if (klCanvas.addLayer(selectedSpotIndex) === false) return;
                klCanvasLayerArr = klCanvas.getLayers();
                if (klCanvasLayerArr.length === _klCanvas.MAX_LAYERS) {
                    addnewBtn.disabled = true;
                    duplicateBtn.disabled = true;
                }
                removeBtn.disabled = false;
                selectedSpotIndex = selectedSpotIndex + 1;
                createLayerList();
                _klHistory.klHistory.pause(true);
                updatefunc(selectedSpotIndex);
                _klHistory.klHistory.pause(false);
            };
            duplicateBtn.onclick = function() {
                if (klCanvas.duplicateLayer(selectedSpotIndex) === false) return;
                klCanvasLayerArr = klCanvas.getLayers();
                if (klCanvasLayerArr.length === _klCanvas.MAX_LAYERS) {
                    addnewBtn.disabled = true;
                    duplicateBtn.disabled = true;
                }
                removeBtn.disabled = false;
                selectedSpotIndex++;
                createLayerList();
                _klHistory.klHistory.pause(true);
                updatefunc(selectedSpotIndex);
                _klHistory.klHistory.pause(false);
            };
            removeBtn.onclick = function() {
                if (layerElArr.length <= 1) return;
                klCanvas.removeLayer(selectedSpotIndex);
                if (selectedSpotIndex > 0) selectedSpotIndex--;
                klCanvasLayerArr = klCanvas.getLayers();
                createLayerList();
                _klHistory.klHistory.pause(true);
                updatefunc(selectedSpotIndex);
                _klHistory.klHistory.pause(false);
                if (klCanvasLayerArr.length === 1) removeBtn.disabled = true;
                if (klCanvasLayerArr.length < _klCanvas.MAX_LAYERS) {
                    addnewBtn.disabled = false;
                    duplicateBtn.disabled = false;
                }
            };
            mergeBtn.onclick = function() {
                if (selectedSpotIndex <= 0) return;
                function mergeDialog(p) {
                    let div = document.createElement("div");
                    div.innerHTML = _language.LANG('layers-merge-description');
                    let options = new _options.Options({
                        optionArr: [
                            {
                                id: p.mixModeStr,
                                label: _translateBlending.translateBlending(p.mixModeStr)
                            },
                            {
                                id: 'source-in',
                                label: 'source-in'
                            },
                            {
                                id: 'source-out',
                                label: 'source-out'
                            },
                            {
                                id: 'source-atop',
                                label: 'source-atop'
                            },
                            {
                                id: 'destination-in',
                                label: 'destination-in'
                            },
                            {
                                id: 'destination-out',
                                label: 'destination-out'
                            },
                            {
                                id: 'destination-atop',
                                label: 'destination-atop'
                            },
                            {
                                id: 'xor',
                                label: 'xor'
                            }
                        ],
                        initId: p.mixModeStr,
                        onChange: function(id) {
                            update();
                        },
                        isSmall: true
                    });
                    options.getElement().style.marginTop = '5px';
                    div.appendChild(options.getElement());
                    let preview = document.createElement("canvas");
                    preview.title = _language.LANG('preview');
                    let spacer = document.createElement("div");
                    spacer.innerHTML = "<br/>";
                    spacer.style.clear = "both";
                    div.appendChild(spacer);
                    div.appendChild(preview);
                    let thumbDimensions = _bb.BB.fitInto(p.topCanvas.width, p.topCanvas.height, 200, 200, 1);
                    preview.width = thumbDimensions.width;
                    preview.height = thumbDimensions.height;
                    _bb.BB.css(preview, {
                        display: "block",
                        marginLeft: "auto",
                        marginRight: "auto",
                        colorScheme: 'only light'
                    });
                    preview.style.boxShadow = "0 0 3px rgba(0,0,0,0.5)";
                    _bb.BB.createCheckerDataUrl(4, function(url) {
                        preview.style.backgroundImage = "url(" + url + ")";
                    });
                    let alphaCanvas = _bb.BB.copyCanvas(preview);
                    alphaCanvas.getContext("2d").drawImage(p.topCanvas, 0, 0, alphaCanvas.width, alphaCanvas.height);
                    _bb.BB.convertToAlphaChannelCanvas(alphaCanvas);
                    function update() {
                        let ctx = preview.getContext("2d");
                        ctx.save();
                        ctx.clearRect(0, 0, preview.width, preview.height);
                        if (preview.width > p.topCanvas.width) ctx.imageSmoothingEnabled = false;
                        ctx.drawImage(p.bottomCanvas, 0, 0, preview.width, preview.height);
                        if (options.getValue() === 'as-alpha') {
                            ctx.globalCompositeOperation = 'destination-in';
                            ctx.globalAlpha = p.topOpacity;
                            ctx.drawImage(alphaCanvas, 0, 0, preview.width, preview.height);
                        } else {
                            ctx.globalCompositeOperation = options.getValue();
                            ctx.globalAlpha = p.topOpacity;
                            ctx.drawImage(p.topCanvas, 0, 0, preview.width, preview.height);
                        }
                        ctx.restore();
                    }
                    update();
                    let keyListener = new _bb.BB.KeyListener({
                        onDown: function(keyStr) {
                            if (keyStr === 'right') options.next();
                            if (keyStr === 'left') options.previous();
                        }
                    });
                    _popup.popup({
                        target: p_rootDiv,
                        message: `<b>${_language.LANG('layers-merge-modal-title')}</b>`,
                        div: div,
                        buttons: [
                            "Ok",
                            "Cancel"
                        ],
                        clickOnEnter: 'Ok',
                        callback: function(val) {
                            keyListener.destroy();
                            options.destroy();
                            if (val === "Ok") p.callback(options.getValue());
                        }
                    });
                }
                mergeDialog({
                    topCanvas: klCanvasLayerArr[selectedSpotIndex].context.canvas,
                    bottomCanvas: klCanvasLayerArr[selectedSpotIndex - 1].context.canvas,
                    topOpacity: klCanvas.getLayer(selectedSpotIndex).opacity,
                    mixModeStr: klCanvasLayerArr[selectedSpotIndex].mixModeStr,
                    callback: function(mode) {
                        klCanvas.mergeLayers(selectedSpotIndex, selectedSpotIndex - 1, mode);
                        klCanvasLayerArr = klCanvas.getLayers();
                        selectedSpotIndex--;
                        if (klCanvasLayerArr.length === 1) removeBtn.disabled = true;
                        if (klCanvasLayerArr.length < _klCanvas.MAX_LAYERS) {
                            addnewBtn.disabled = false;
                            duplicateBtn.disabled = false;
                        }
                        createLayerList();
                        _klHistory.klHistory.pause(true);
                        updatefunc(selectedSpotIndex);
                        _klHistory.klHistory.pause(false);
                    }
                });
            };
            renameBtn.onclick = function() {
                renameLayer(selectedSpotIndex);
            };
        }
        setTimeout(async, 1);
        return div2;
    }
    div1.appendChild(createButtons());
    let modeWrapper;
    let modeSelect;
    modeWrapper = _bb.BB.el({
        content: _language.LANG('layers-blending') + '&nbsp;',
        css: {
            fontSize: '15px'
        }
    });
    modeSelect = new _select.Select({
        optionArr: [
            'source-over',
            null,
            'darken',
            'multiply',
            'color-burn',
            null,
            'lighten',
            'screen',
            'color-dodge',
            null,
            'overlay',
            'soft-light',
            'hard-light',
            null,
            'difference',
            'exclusion',
            null,
            'hue',
            'saturation',
            'color',
            'luminosity', 
        ].map((item)=>{
            return item ? [
                item,
                _translateBlending.translateBlending(item)
            ] : null;
        }),
        onChange: function(val) {
            klCanvas.setMixMode(selectedSpotIndex, val);
            div1.update(selectedSpotIndex);
        },
        css: {
            marginBottom: '10px'
        }
    });
    modeWrapper.appendChild(modeSelect.getElement());
    div1.appendChild(modeWrapper);
    function createLayerList() {
        oldHistoryState = _klHistory.klHistory.getState();
        function createLayerEntry(index) {
            let layerName = klCanvas.getLayer(index).name;
            let opacity = klCanvasLayerArr[index].opacity;
            let layercanvas = klCanvasLayerArr[index].context.canvas;
            let layer = document.createElement("div");
            layer.className = "layerBox";
            layerElArr[index] = layer;
            layer.posY = (klCanvasLayerArr.length - 1) * 35 - index * 35;
            _bb.BB.css(layer, {
                width: "250px",
                height: "34px",
                backgroundColor: "rgb( 220, 220, 220)",
                border: "1px solid #aaa",
                position: "absolute",
                left: "0 px",
                top: layer.posY + "px",
                transition: "all 0.1s linear",
                borderRadius: "5px",
                boxSizing: 'border-box'
            });
            let innerLayer = document.createElement("div");
            _bb.BB.css(innerLayer, {
                position: "relative"
            });
            let container1 = document.createElement("div");
            _bb.BB.css(container1, {
                width: "250px",
                height: "34px"
            });
            let container2 = document.createElement("div");
            layer.appendChild(innerLayer);
            innerLayer.appendChild(container1);
            innerLayer.appendChild(container2);
            layer.spot = index;
            //thumb
            {
                let thumbDimensions = _bb.BB.fitInto(layercanvas.width, layercanvas.height, 30, 30, 1);
                let thumb = layer.thumb = _bb.BB.canvas(thumbDimensions.width, thumbDimensions.height);
                let thc = thumb.getContext("2d");
                thc.save();
                if (thumb.width > layercanvas.width) thc.imageSmoothingEnabled = false;
                thc.drawImage(layercanvas, 0, 0, thumb.width, thumb.height);
                thc.restore();
                _bb.BB.css(layer.thumb, {
                    position: "absolute",
                    left: (32 - layer.thumb.width) / 2 + "px",
                    top: (32 - layer.thumb.height) / 2 + "px",
                    colorScheme: 'only light'
                });
                _bb.BB.createCheckerDataUrl(4, function(url) {
                    thumb.style.backgroundImage = "url(" + url + ")";
                });
            }
            layer.label = document.createElement("div");
            layer.lname = layerName;
            layer.label.append(layer.lname);
            _bb.BB.css(layer.label, {
                position: "absolute",
                left: "38px",
                top: "1px",
                fontSize: "13px",
                width: "170px",
                height: "20px",
                overflow: "hidden",
                color: "#666",
                whiteSpace: 'nowrap'
            });
            layer.label.ondblclick = function() {
                renameLayer(layer.spot);
            };
            layer.opacityLabel = document.createElement("div");
            layer.opacity = opacity;
            layer.opacityLabel.append(parseInt('' + layer.opacity * 100) + "%");
            _bb.BB.css(layer.opacityLabel, {
                position: "absolute",
                left: "194px",
                top: "1px",
                fontSize: "13px",
                textAlign: "right",
                width: "50px",
                color: "#666",
                transition: "color 0.2s ease-in-out"
            });
            let oldOpacity;
            let opacitySlider = new _pointSlider.PointSlider({
                init: layer.opacity,
                width: 204,
                pointSize: 14,
                callback: function(sliderValue, isFirst, isLast) {
                    if (isFirst) {
                        oldOpacity = klCanvas.getLayer(layer.spot).opacity;
                        _klHistory.klHistory.pause(true);
                        return;
                    }
                    if (isLast) {
                        _klHistory.klHistory.pause(false);
                        if (oldOpacity !== sliderValue) klCanvas.layerOpacity(layer.spot, sliderValue);
                        return;
                    }
                    layer.opacityLabel.innerHTML = Math.round(sliderValue * 100) + "%";
                    klCanvas.layerOpacity(layer.spot, sliderValue);
                }
            });
            _bb.BB.css(opacitySlider.getEl(), {
                position: 'absolute',
                left: '39px',
                top: '17px'
            });
            layer.opacitySlider = opacitySlider;
            //larger layer preview - hover
            _bb.BB.setEventListener(layer.thumb, 'onpointerover', function(e) {
                if (e.buttons !== 0 && (!e.pointerType || e.pointerType !== 'touch')) return;
                let thumbDimensions = _bb.BB.fitInto(layercanvas.width, layercanvas.height, 250, 250, 1);
                if (largeThumbCanvas.width !== thumbDimensions.width || largeThumbCanvas.height !== thumbDimensions.height) {
                    largeThumbCanvas.width = thumbDimensions.width;
                    largeThumbCanvas.height = thumbDimensions.height;
                }
                let ctx = largeThumbCanvas.getContext("2d");
                ctx.save();
                if (largeThumbCanvas.width > layercanvas.width) ctx.imageSmoothingEnabled = false;
                ctx.imageSmoothingQuality = 'high';
                ctx.clearRect(0, 0, largeThumbCanvas.width, largeThumbCanvas.height);
                ctx.drawImage(layercanvas, 0, 0, largeThumbCanvas.width, largeThumbCanvas.height);
                ctx.restore();
                _bb.BB.css(largeThumbDiv, {
                    top: e.clientY - largeThumbCanvas.height / 2 + "px",
                    opacity: '0'
                });
                if (largeThumbInDocument === false) {
                    document.body.appendChild(largeThumbDiv);
                    largeThumbInDocument = true;
                }
                clearTimeout(largeThumbInTimeout);
                largeThumbInTimeout = setTimeout(function() {
                    _bb.BB.css(largeThumbDiv, {
                        opacity: '1'
                    });
                }, 20);
                clearTimeout(largeThumbTimeout);
            });
            _bb.BB.setEventListener(layer.thumb, 'onpointerout', function() {
                clearTimeout(largeThumbInTimeout);
                _bb.BB.css(largeThumbDiv, {
                    opacity: '0'
                });
                clearTimeout(largeThumbTimeout);
                largeThumbTimeout = setTimeout(function() {
                    if (!largeThumbInDocument) return;
                    document.body.removeChild(largeThumbDiv);
                    largeThumbInDocument = false;
                }, 300);
            });
            container1.appendChild(layer.thumb);
            container1.appendChild(layer.label);
            container1.appendChild(layer.opacityLabel);
            container1.appendChild(opacitySlider.getEl());
            let dragstart = false;
            let freshSelection = false;
            //events for moving layers up and down
            function dragEventHandler(event) {
                if (event.type === 'pointerdown' && event.button === 'left') {
                    _bb.BB.css(layer, {
                        transition: "box-shadow 0.3s ease-in-out"
                    });
                    //dragContainer.appendChild(layer);
                    layer.style.zIndex = '1';
                    lastpos = layer.spot;
                    freshSelection = false;
                    if (!layer.isSelected) {
                        freshSelection = true;
                        div1.activateLayer(layer.spot);
                    }
                    dragstart = true;
                } else if (event.type === 'pointermove' && event.button === 'left') {
                    if (dragstart) {
                        dragstart = false;
                        _bb.BB.css(layer, {
                            boxShadow: "1px 3px 5px rgba(0,0,0,0.4)"
                        });
                    }
                    layer.posY += event.dY;
                    let corrected = Math.max(0, Math.min((klCanvasLayerArr.length - 1) * 35, layer.posY));
                    layer.style.top = corrected + "px";
                    updateLayersVerticalPosition(layer.spot, posToSpot(layer.posY));
                }
                if (event.type === 'pointerup') {
                    _bb.BB.css(layer, {
                        transition: "all 0.1s linear"
                    });
                    setTimeout(function() {
                        _bb.BB.css(layer, {
                            boxShadow: ""
                        });
                    }, 20);
                    layer.posY = Math.max(0, Math.min((klCanvasLayerArr.length - 1) * 35, layer.posY));
                    //regularContainer.appendChild(layer);
                    layer.style.zIndex = "";
                    let newSpot = posToSpot(layer.posY);
                    let oldSpot = layer.spot;
                    move(layer.spot, newSpot);
                    if (oldSpot != newSpot) {
                        _klHistory.klHistory.pause(true);
                        updatefunc(selectedSpotIndex);
                        _klHistory.klHistory.pause(false);
                    }
                    if (oldSpot === newSpot && freshSelection) updatefunc(selectedSpotIndex);
                    freshSelection = false;
                }
            }
            layer.pointerListener = new _bb.BB.PointerListener({
                target: container1,
                maxPointers: 1,
                onPointer: dragEventHandler
            });
            layerListEl.appendChild(layer);
        }
        layerElArr = [];
        while(layerListEl.firstChild){
            let child = layerListEl.firstChild;
            child.pointerListener.destroy();
            child.opacitySlider.destroy();
            layerListEl.removeChild(child);
        }
        for(let i = 0; i < klCanvasLayerArr.length; i++)createLayerEntry(i);
        div1.activateLayer(selectedSpotIndex);
        updateHeight();
    }
    listdiv.appendChild(layerListEl);
    div1.appendChild(listdiv);
    function posToSpot(p) {
        let result = parseInt('' + (p / (layerHeight + layerSpacing) + 0.5));
        result = Math.min(klCanvasLayerArr.length - 1, Math.max(0, result));
        result = klCanvasLayerArr.length - result - 1;
        return result;
    }
    let lastpos = 0;
    //update css position of all layers that are not being dragged, while dragging
    function updateLayersVerticalPosition(id, newspot) {
        newspot = Math.min(klCanvasLayerArr.length - 1, Math.max(0, newspot));
        if (newspot === lastpos) return;
        for(let i = 0; i < klCanvasLayerArr.length; i++){
            if (layerElArr[i].spot === id) continue;
            let posy = layerElArr[i].spot;
            if (layerElArr[i].spot > id) posy--;
            if (posy >= newspot) posy++;
            layerElArr[i].posY = (layerHeight + layerSpacing) * (klCanvasLayerArr.length - posy - 1);
            layerElArr[i].style.top = layerElArr[i].posY + "px";
        }
        lastpos = newspot;
    }
    function move(oldSpotIndex, newSpotIndex) {
        if (isNaN(oldSpotIndex) || isNaN(newSpotIndex)) throw 'layermanager - invalid move';
        for(let i = 0; i < klCanvasLayerArr.length; i++)(function(i) {
            let posy = layerElArr[i].spot; // <- here
            if (layerElArr[i].spot === oldSpotIndex) posy = newSpotIndex;
            else {
                if (layerElArr[i].spot > oldSpotIndex) posy--;
                if (posy >= newSpotIndex) posy++;
            }
            layerElArr[i].spot = posy;
            layerElArr[i].posY = (layerHeight + layerSpacing) * (klCanvasLayerArr.length - posy - 1);
            layerElArr[i].style.top = layerElArr[i].posY + "px";
        })(i);
        if (oldSpotIndex === newSpotIndex) return;
        klCanvas.moveLayer(selectedSpotIndex, newSpotIndex - oldSpotIndex);
        klCanvasLayerArr = klCanvas.getLayers();
        selectedSpotIndex = newSpotIndex;
        mergeBtn.disabled = selectedSpotIndex === 0;
    }
    //updating the thumbs in interval
    //don't update when: manager not visible || layer didn't change || is drawing
    let updateThumbsInterval = setInterval(function() {
        if (div1.style.display !== "block") return;
        let historyState = _klHistory.klHistory.getState();
        if (historyState === oldHistoryState) return;
        oldHistoryState = historyState;
        for(let i = 0; i < layerElArr.length; i++)if (selectedSpotIndex === layerElArr[i].spot && klCanvasLayerArr[layerElArr[i].spot]) {
            let ctx = layerElArr[i].thumb.getContext("2d");
            ctx.save();
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            if (klCanvasLayerArr[layerElArr[i].spot].context.canvas.width < layerElArr[i].thumb.width) ctx.imageSmoothingEnabled = false;
            ctx.drawImage(klCanvasLayerArr[layerElArr[i].spot].context.canvas, 0, 0, layerElArr[i].thumb.width, layerElArr[i].thumb.height);
            ctx.restore();
        }
    }, 1);
    function updateHeight() {
        layerListEl.style.height = layerElArr.length * 35 + 'px';
    }
    // ---- interface ----
    div1.update = function(activeLayerSpotIndex) {
        klCanvasLayerArr = klCanvas.getLayers();
        if (activeLayerSpotIndex || activeLayerSpotIndex === 0) selectedSpotIndex = activeLayerSpotIndex;
        removeBtn.disabled = klCanvasLayerArr.length === 1;
        if (klCanvasLayerArr.length === _klCanvas.MAX_LAYERS) {
            addnewBtn.disabled = true;
            duplicateBtn.disabled = true;
        } else {
            addnewBtn.disabled = false;
            duplicateBtn.disabled = false;
        }
        setTimeout(function() {
            createLayerList();
        }, 1);
    };
    div1.getSelected = function() {
        return selectedSpotIndex;
    };
    div1.activateLayer = function(spotIndex) {
        if (spotIndex < 0 || spotIndex > layerElArr.length - 1) throw 'invalid spotIndex ' + spotIndex + ', layerElArr.length ' + layerElArr.length;
        selectedSpotIndex = spotIndex;
        modeSelect.setValue(klCanvasLayerArr[selectedSpotIndex].mixModeStr);
        for(let i = 0; i < layerElArr.length; i++)if (selectedSpotIndex === layerElArr[i].spot) {
            layerElArr[i].style.backgroundColor = "rgb( 250, 250, 250)";
            layerElArr[i].label.style.color = "#000";
            layerElArr[i].style.boxShadow = "";
            layerElArr[i].style.border = "1px solid var(--active-highlight-color)";
            layerElArr[i].opacitySlider.setActive(true);
            layerElArr[i].isSelected = true;
        } else {
            layerElArr[i].style.backgroundColor = "rgb( 220, 220, 220)";
            layerElArr[i].label.style.color = "#666";
            layerElArr[i].style.boxShadow = "";
            layerElArr[i].style.border = "1px solid rgb(158, 158, 158)";
            layerElArr[i].opacitySlider.setActive(false);
            layerElArr[i].isSelected = false;
        }
        mergeBtn.disabled = selectedSpotIndex === 0;
    };
    div1.setUiState = function(stateStr) {
        uiState = '' + stateStr;
        if (uiState === 'left') _bb.BB.css(largeThumbDiv, {
            left: '280px',
            right: ''
        });
        else _bb.BB.css(largeThumbDiv, {
            left: '',
            right: '280px'
        });
    };
    createLayerList();
    return div1;
}

},{"../../../bb/bb":"e3nbn","../modals/popup":"7D028","../../history/kl-history":"ai9zE","../base-components/options":"b8ZKE","../base-components/select":"gIUAj","../base-components/point-slider":"evhHh","url:~/src/app/img/ui/add-layer.svg":"hQVOZ","url:~/src/app/img/ui/duplicate-layer.svg":"cccpR","url:~/src/app/img/ui/merge-layers.svg":"jPubG","url:~/src/app/img/ui/remove-layer.svg":"96CFw","url:~/src/app/img/ui/rename-layer.svg":"2TIIh","../../canvas/kl-canvas":"7NlZB","../../../language/language":"lvNW4","../../canvas/translate-blending":"1Vla8","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hQVOZ":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "add-layer.8932c9d1.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"cccpR":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "duplicate-layer.acae2511.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"jPubG":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "merge-layers.d186e3af.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"96CFw":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "remove-layer.825e55c7.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"2TIIh":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "rename-layer.85a94119.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"7NlZB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MAX_LAYERS", ()=>MAX_LAYERS
);
/**
 * The image/canvas that the user paints on
 * Has layers. layers have names and opacity.
 *
 * Interacts with the history you specify (for undo/redo)
 */ parcelHelpers.export(exports, "KlCanvas", ()=>KlCanvas
);
var _bb = require("../../bb/bb");
var _floodFill = require("../image-operations/flood-fill");
var _shapeTool = require("../image-operations/shape-tool");
var _renderText = require("../image-operations/render-text");
var _klHistory = require("../history/kl-history");
var _drawProject = require("./draw-project");
var _language = require("../../language/language");
const allowedMixModes = [
    'source-over',
    'darken',
    'multiply',
    'color-burn',
    'lighten',
    'screen',
    'color-dodge',
    'overlay',
    'soft-light',
    'hard-light',
    'difference',
    'exclusion',
    'hue',
    'saturation',
    'color',
    'luminosity', 
];
const MAX_LAYERS = 16;
class KlCanvas {
    init(w, h) {
        if (!w || !h || isNaN(w) || isNaN(h) || w < 1 || h < 1) throw new Error('init - invalid canvas size');
        this.width = w;
        this.height = h;
    }
    emitChange() {
        // some changes don't get captured by the history - e.g. changing opacity as the user drags the slider
        this.changeListenerArr.forEach((item)=>item()
        );
    }
    updateIndices() {
        this.layerCanvasArr.forEach((item, index)=>{
            item.index = index;
        });
    }
    // ---- public ----
    constructor(params, layerNrOffset = 0){
        this.layerNrOffset = layerNrOffset;
        this.layerCanvasArr = [];
        this.pickCanvas = _bb.BB.canvas(1, 1);
        this.history = new _klHistory.DecoyKlHistory();
        if ('copy' in params) {
            this.width = 1;
            this.height = 1;
        } else if ('width' in params && 'height' in params) {
            this.width = params.width;
            this.height = params.height;
        } else {
            this.width = 1;
            this.height = 1;
        }
        this.init(this.width, this.height);
        this.changeListenerArr = [];
        if ('copy' in params) this.copy(params.copy);
        else if ('projectObj' in params) {
            const origLayers = [].concat(params.projectObj.layers);
            this.init(params.projectObj.width, params.projectObj.height);
            if (!origLayers.length) throw new Error('project.layers needs at least 1 layer');
            for(let i = 0; i < origLayers.length; i++){
                if (origLayers[i].mixModeStr && !allowedMixModes.includes(origLayers[i].mixModeStr)) throw new Error('unknown mixModeStr ' + origLayers[i].mixModeStr);
                this.addLayer();
                this.layerOpacity(i, origLayers[i].opacity);
                this.layerCanvasArr[i].name = origLayers[i].name;
                this.layerCanvasArr[i].mixModeStr = origLayers[i].mixModeStr ? origLayers[i].mixModeStr : 'source-over';
                this.layerCanvasArr[i].getContext("2d").drawImage(origLayers[i].image, 0, 0);
            }
        }
        this.updateIndices();
    }
    setHistory(h) {
        this.history = h;
    }
    /**
     * Resets canvas -> 1 layer, 100% opacity,
     * unless layers provided.
     * @param p
     */ reset(p) {
        if (!p.width || !p.height || p.width < 1 || p.height < 1 || isNaN(p.width) || isNaN(p.height)) throw new Error('invalid canvas size');
        this.history.pause(true);
        this.width = p.width;
        this.height = p.height;
        this.layerCanvasArr.splice(1, Math.max(0, this.layerCanvasArr.length - 1));
        if (p.layers) for(let i = 0; i < p.layers.length; i++){
            let item = p.layers[i];
            if (!this.layerCanvasArr[i]) this.addLayer();
            this.layerCanvasArr[i].name = item.name;
            this.layerCanvasArr[i].width = this.width;
            this.layerCanvasArr[i].height = this.height;
            this.layerCanvasArr[i].mixModeStr = item.mixModeStr ? item.mixModeStr : 'source-over';
            this.layerCanvasArr[i].getContext("2d").drawImage(item.image, 0, 0);
            this.layerOpacity(i, item.opacity);
        }
        else {
            this.layerCanvasArr[0].name = p.layerName ? p.layerName : _language.LANG('layers-layer') + " 1";
            this.layerCanvasArr[0].width = this.width;
            this.layerCanvasArr[0].height = this.height;
            this.layerCanvasArr[0].mixModeStr = 'source-over';
            this.layerOpacity(0, 1);
            if (p.color) this.layerFill(0, p.color);
            else if (p.image) this.layerCanvasArr[0].getContext("2d").drawImage(p.image, 0, 0);
        }
        this.updateIndices();
        this.history.pause(false);
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "reset",
            params: [
                p
            ] // dont screw with p
        });
        return this.layerCanvasArr.length - 1;
    }
    isLayerLimitReached() {
        return this.layerCanvasArr.length >= MAX_LAYERS;
    }
    getWidth() {
        return this.width;
    }
    getHeight() {
        return this.height;
    }
    copy(toCopyCanvas) {
        if (toCopyCanvas.getWidth() < 1 || toCopyCanvas.getHeight() < 1 || isNaN(toCopyCanvas.getWidth()) || isNaN(toCopyCanvas.getHeight())) throw new Error('invalid canvas size');
        // keep existing canvases
        let origLayers = toCopyCanvas.getLayers();
        while(this.layerCanvasArr.length > origLayers.length)this.removeLayer(this.layerCanvasArr.length - 1);
        if (toCopyCanvas.getWidth() != this.width || toCopyCanvas.getHeight() != this.height) this.init(toCopyCanvas.getWidth(), toCopyCanvas.getHeight());
        for(let i = 0; i < origLayers.length; i++){
            if (i >= this.layerCanvasArr.length) this.addLayer();
            else {
                this.layerCanvasArr[i].width = this.width;
                this.layerCanvasArr[i].height = this.height;
            }
            this.layerOpacity(i, origLayers[i].opacity);
            this.layerCanvasArr[i].name = origLayers[i].name;
            this.layerCanvasArr[i].mixModeStr = origLayers[i].mixModeStr;
            this.layerCanvasArr[i].getContext("2d").drawImage(origLayers[i].context.canvas, 0, 0);
        }
        this.updateIndices();
    }
    getLayerCount() {
        return this.layerCanvasArr.length;
    }
    resize(w, h, algorithm = 'smooth') {
        if (!w || !h || w === this.width && h === this.height || isNaN(w) || isNaN(h) || w < 1 || h < 1) return false;
        w = Math.max(w, 1);
        h = Math.max(h, 1);
        let tmp1, tmp2;
        if (algorithm === 'pixelated') {
            tmp1 = _bb.BB.canvas(w, h);
            let tmp1Ctx = tmp1.getContext('2d');
            tmp1Ctx.imageSmoothingEnabled = false;
            for(let i = 0; i < this.layerCanvasArr.length; i++){
                if (i > 0) tmp1Ctx.clearRect(0, 0, w, h);
                let layerCanvas = this.layerCanvasArr[i];
                tmp1Ctx.drawImage(layerCanvas, 0, 0, w, h);
                layerCanvas.width = w;
                layerCanvas.height = h;
                let layerContext = layerCanvas.getContext('2d');
                layerContext.drawImage(tmp1, 0, 0);
            }
        } else if (algorithm === 'smooth') {
            tmp1 = _bb.BB.canvas();
            tmp2 = _bb.BB.canvas();
            for(let i = 0; i < this.layerCanvasArr.length; i++)_bb.BB.resizeCanvas(this.layerCanvasArr[i], w, h, tmp1, tmp2);
        } else throw new Error('unknown resize algorithm');
        this.width = w;
        this.height = h;
        return true;
    }
    /**
     * crop / extend
     * @param p
     */ resizeCanvas(p) {
        const newW = Math.round(p.left) + this.width + Math.round(p.right);
        const newH = Math.round(p.top) + this.height + Math.round(p.bottom);
        const offX = Math.round(p.left);
        const offY = Math.round(p.top);
        if (isNaN(newW) || isNaN(newH) || newW < 1 || newH < 1) throw new Error('KlCanvas.resizeCanvas - invalid canvas size');
        for(let i = 0; i < this.layerCanvasArr.length; i++){
            const ctemp = _bb.BB.canvas(this.width, this.height);
            let layerCanvas = this.layerCanvasArr[i];
            let layerCtx = this.layerCanvasArr[i].getContext("2d");
            ctemp.getContext("2d").drawImage(layerCanvas, 0, 0);
            this.layerCanvasArr[i].width = newW;
            this.layerCanvasArr[i].height = newH;
            layerCtx.save();
            if (i === 0 && p.fillColor) {
                layerCtx.fillStyle = _bb.BB.ColorConverter.toRgbStr(p.fillColor);
                layerCtx.fillRect(0, 0, newW, newH);
                layerCtx.clearRect(offX, offY, this.width, this.height);
            }
            layerCtx.drawImage(ctemp, offX, offY);
            layerCtx.restore();
        }
        this.width = newW;
        this.height = newH;
    }
    /**
     * will be inserted on top of selected
     * @param selected
     */ addLayer(selected) {
        if (this.isLayerLimitReached()) return false;
        let canvas = _bb.BB.canvas(this.width, this.height);
        canvas.mixModeStr = 'source-over';
        if (selected === undefined) {
            this.layerCanvasArr[this.layerCanvasArr.length] = canvas;
            selected = Math.max(0, this.layerCanvasArr.length - 1);
        } else {
            this.layerCanvasArr.splice(selected + 1, 0, canvas);
            selected++;
        }
        canvas.name = _language.LANG('layers-layer') + " " + (this.layerCanvasArr.length + this.layerNrOffset);
        this.history.pause(true);
        this.layerOpacity(selected, 1);
        this.history.pause(false);
        this.updateIndices();
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "addLayer",
            params: [
                selected - 1
            ]
        });
        return selected;
    }
    duplicateLayer(i) {
        if (!this.layerCanvasArr[i] || this.isLayerLimitReached()) return false;
        let canvas = _bb.BB.canvas(this.width, this.height);
        this.layerCanvasArr.splice(i + 1, 0, canvas);
        canvas.name = this.layerCanvasArr[i].name + " " + _language.LANG('layers-copy');
        canvas.mixModeStr = this.layerCanvasArr[i].mixModeStr;
        canvas.getContext("2d").drawImage(this.layerCanvasArr[i], 0, 0);
        this.history.pause(true);
        this.layerOpacity(i + 1, this.layerCanvasArr[i].opacity);
        this.history.pause(false);
        this.updateIndices();
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "duplicateLayer",
            params: [
                i
            ]
        });
        return i + 1;
    }
    getLayerContext(i, doReturnNull) {
        if (this.layerCanvasArr[i]) return this.layerCanvasArr[i].getContext("2d");
        if (doReturnNull) return null;
        throw new Error("layer of index " + i + " not found (in " + this.layerCanvasArr.length + " layers)");
    }
    removeLayer(i) {
        if (this.layerCanvasArr[i]) {
            this.layerCanvasArr.splice(i, 1);
            this.updateIndices();
        } else return false;
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "removeLayer",
            params: [
                i
            ]
        });
        return Math.max(0, i - 1);
    }
    renameLayer(i, name) {
        if (this.layerCanvasArr[i]) this.layerCanvasArr[i].name = name;
        else return false;
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "renameLayer",
            params: [
                i,
                name
            ]
        });
        return true;
    }
    layerOpacity(i, o) {
        if (!this.layerCanvasArr[i]) return;
        o = Math.max(0, Math.min(1, o));
        this.layerCanvasArr[i].opacity = o;
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "layerOpacity",
            params: [
                i,
                o
            ]
        });
        this.emitChange();
    }
    moveLayer(i, d) {
        if (d === 0) return;
        if (this.layerCanvasArr[i]) {
            const temp = this.layerCanvasArr[i];
            this.layerCanvasArr.splice(i, 1);
            const targetIndex = Math.max(0, Math.min(i + d, this.layerCanvasArr.length));
            this.layerCanvasArr.splice(targetIndex, 0, temp);
            this.updateIndices();
            this.history.push({
                tool: [
                    "canvas"
                ],
                action: "moveLayer",
                params: [
                    i,
                    d
                ]
            });
            return targetIndex;
        }
    }
    mergeLayers(layerBottomIndex, layerTopIndex, mixModeStr) {
        if (!this.layerCanvasArr[layerBottomIndex] || !this.layerCanvasArr[layerTopIndex] || layerBottomIndex === layerTopIndex) return;
        //order messed up
        if (layerBottomIndex > layerTopIndex) {
            let temp = layerBottomIndex;
            layerBottomIndex = layerTopIndex;
            layerTopIndex = temp;
        }
        let topOpacity = this.layerCanvasArr[layerTopIndex].opacity;
        if (topOpacity !== 0 && topOpacity) {
            let ctx = this.layerCanvasArr[layerBottomIndex].getContext("2d");
            ctx.save();
            if (mixModeStr === 'as-alpha') {
                _bb.BB.convertToAlphaChannelCanvas(this.layerCanvasArr[layerTopIndex]);
                ctx.globalCompositeOperation = 'destination-in';
                ctx.globalAlpha = topOpacity;
                this.layerCanvasArr[layerBottomIndex].getContext("2d").drawImage(this.layerCanvasArr[layerTopIndex], 0, 0);
            } else {
                if (mixModeStr) ctx.globalCompositeOperation = mixModeStr;
                ctx.globalAlpha = topOpacity;
                this.layerCanvasArr[layerBottomIndex].getContext("2d").drawImage(this.layerCanvasArr[layerTopIndex], 0, 0);
            }
            ctx.restore();
            // workaround for chrome bug https://bugs.chromium.org/p/chromium/issues/detail?id=1281185
            // TODO remove if chrome updated
            if (mixModeStr) {
                ctx.save();
                ctx.fillStyle = "rgba(0,0,0,0.01)";
                ctx.fillRect(-0.9999999, -0.9999999, 1, 1);
                ctx.restore();
            }
        }
        this.updateIndices();
        this.history.pause(true);
        this.removeLayer(layerTopIndex);
        this.history.pause(false);
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "mergeLayers",
            params: [
                layerBottomIndex,
                layerTopIndex,
                mixModeStr
            ]
        });
        return layerBottomIndex;
    }
    rotate(deg) {
        while(deg < 0)deg += 360;
        deg %= 360;
        if (deg % 90 != 0 || deg === 0) return;
        let temp = _bb.BB.canvas();
        if (deg === 0 || deg === 180) {
            temp.width = this.width;
            temp.height = this.height;
        } else if (deg === 90 || deg === 270) {
            temp.width = this.height;
            temp.height = this.width;
        }
        let ctx = temp.getContext("2d");
        for(let i = 0; i < this.layerCanvasArr.length; i++){
            ctx.clearRect(0, 0, temp.width, temp.height);
            ctx.save();
            ctx.translate(temp.width / 2, temp.height / 2);
            ctx.rotate(deg * Math.PI / 180);
            if (deg === 180) ctx.drawImage(this.layerCanvasArr[i], -temp.width / 2, -temp.height / 2);
            else if (deg === 90 || deg === 270) ctx.drawImage(this.layerCanvasArr[i], -temp.height / 2, -temp.width / 2);
            this.layerCanvasArr[i].width = temp.width;
            this.layerCanvasArr[i].height = temp.height;
            this.layerCanvasArr[i].getContext("2d").clearRect(0, 0, this.layerCanvasArr[i].width, this.layerCanvasArr[i].height);
            this.layerCanvasArr[i].getContext("2d").drawImage(temp, 0, 0);
            ctx.restore();
        }
        this.width = temp.width;
        this.height = temp.height;
    }
    flip(isHorizontal, isVertical, layerIndex) {
        if (!isHorizontal && !isVertical) return;
        let temp = _bb.BB.canvas(this.width, this.height);
        temp.width = this.width;
        temp.height = this.height;
        let tempCtx = temp.getContext("2d");
        for(let i = 0; i < this.layerCanvasArr.length; i++){
            if ((layerIndex || layerIndex === 0) && i !== layerIndex) continue;
            tempCtx.save();
            tempCtx.clearRect(0, 0, temp.width, temp.height);
            tempCtx.translate(temp.width / 2, temp.height / 2);
            tempCtx.scale(isHorizontal ? -1 : 1, isVertical ? -1 : 1);
            tempCtx.drawImage(this.layerCanvasArr[i], -temp.width / 2, -temp.height / 2);
            tempCtx.restore();
            this.layerCanvasArr[i].getContext("2d").clearRect(0, 0, this.layerCanvasArr[i].width, this.layerCanvasArr[i].height);
            this.layerCanvasArr[i].getContext("2d").drawImage(temp, 0, 0);
        }
    }
    layerFill(layerIndex, colorObj, compositeOperation) {
        let ctx = this.layerCanvasArr[layerIndex].getContext("2d");
        ctx.save();
        if (compositeOperation) ctx.globalCompositeOperation = compositeOperation;
        ctx.fillStyle = "rgba(" + colorObj.r + "," + colorObj.g + "," + colorObj.b + ",1)";
        ctx.fillRect(0, 0, this.layerCanvasArr[layerIndex].width, this.layerCanvasArr[layerIndex].height);
        ctx.restore();
        // workaround for chrome bug https://bugs.chromium.org/p/chromium/issues/detail?id=1281185
        // TODO remove if chrome updated
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,0.01)";
        ctx.fillRect(-0.9999999, -0.9999999, 1, 1);
        ctx.restore();
        /*if (!document.getElementById('testocanvas')) {
            layerCanvasArr[layerIndex].id = 'testocanvas';
            document.body.appendChild(layerCanvasArr[layerIndex]);
            BB.css(layerCanvasArr[layerIndex], {
                position: 'fixed',
                left: '0',
                top: '0',
                zIndex: '1111111',
                transform: 'scale(0.2)',
                border: '10px solid red',
            });
        }
        if (!document.getElementById('testocanvas')) {
            let c = document.createElement('canvas');
            c.width = 1000;
            c.height = 1000;
            let ctx2 = c.getContext('2d');
            ctx2.drawImage(layerCanvasArr[layerIndex], 0, 0);
            c.id = 'testocanvas';
            document.body.appendChild(c);
            BB.css(c, {
                position: 'fixed',
                left: '0',
                top: '0',
                zIndex: '1111111',
                transform: 'scale(0.2)',
                border: '10px solid red',
            });
        }*/ this.history.push({
            tool: [
                "canvas"
            ],
            action: "layerFill",
            params: [
                layerIndex,
                colorObj,
                compositeOperation
            ]
        });
    }
    floodFill(layerIndex, x, y, rgb, opacity, tolerance, sampleStr, grow, isContiguous) {
        if (x < 0 || y < 0 || x >= this.width || y >= this.height || opacity === 0) return;
        tolerance = Math.round(tolerance);
        if (![
            'above',
            'current',
            'all'
        ].includes(sampleStr)) throw new Error('invalid sampleStr');
        let result;
        let srcCtx;
        let srcImageData;
        let srcData;
        let targetCtx;
        let targetImageData;
        let targetData;
        if (sampleStr === 'all') {
            let srcCanvas = this.layerCanvasArr.length === 1 ? this.layerCanvasArr[0] : this.getCompleteCanvas(1);
            srcCtx = srcCanvas.getContext('2d');
            srcImageData = srcCtx.getImageData(0, 0, this.width, this.height);
            srcData = srcImageData.data;
            result = _floodFill.floodFillBits(srcData, this.width, this.height, x, y, tolerance, Math.round(grow), isContiguous);
            srcCanvas = null;
            srcCtx = null;
            srcImageData = null;
            srcData = null;
            targetCtx = this.layerCanvasArr[layerIndex].getContext('2d');
            targetImageData = targetCtx.getImageData(0, 0, this.width, this.height);
        } else {
            let srcIndex = sampleStr === 'above' ? layerIndex + 1 : layerIndex;
            if (srcIndex >= this.layerCanvasArr.length) return;
            srcCtx = this.layerCanvasArr[srcIndex].getContext('2d');
            srcImageData = srcCtx.getImageData(0, 0, this.width, this.height);
            srcData = srcImageData.data;
            result = _floodFill.floodFillBits(srcData, this.width, this.height, x, y, tolerance, Math.round(grow), isContiguous);
            if (layerIndex !== srcIndex) {
                srcCtx = null;
                srcImageData = null;
                srcData = null;
            }
            targetCtx = layerIndex === srcIndex ? srcCtx : this.layerCanvasArr[layerIndex].getContext('2d');
            targetImageData = layerIndex === srcIndex ? srcImageData : targetCtx.getImageData(0, 0, this.width, this.height);
        }
        targetData = targetImageData.data;
        if (opacity === 1) {
            for(let i = 0; i < this.width * this.height; i++)if (result.data[i] === 255) {
                targetData[i * 4] = rgb.r;
                targetData[i * 4 + 1] = rgb.g;
                targetData[i * 4 + 2] = rgb.b;
                targetData[i * 4 + 3] = 255;
            }
        } else {
            for(let i = 0; i < this.width * this.height; i++)if (result.data[i] === 255) {
                targetData[i * 4] = _bb.BB.mix(targetData[i * 4], rgb.r, opacity);
                targetData[i * 4 + 1] = _bb.BB.mix(targetData[i * 4 + 1], rgb.g, opacity);
                targetData[i * 4 + 2] = _bb.BB.mix(targetData[i * 4 + 2], rgb.b, opacity);
                targetData[i * 4 + 3] = _bb.BB.mix(targetData[i * 4 + 3], 255, opacity);
            }
        }
        targetCtx.putImageData(targetImageData, 0, 0);
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "replaceLayer",
            params: [
                layerIndex,
                targetImageData
            ]
        });
    }
    /**
     * draw shape via BB.drawShape
     * @param layerIndex
     * @param shapeObj
     */ drawShape(layerIndex, shapeObj) {
        _shapeTool.drawShape(this.layerCanvasArr[layerIndex].getContext("2d"), shapeObj);
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "drawShape",
            params: [
                layerIndex,
                _bb.BB.copyObj(shapeObj)
            ]
        });
    }
    text(layerIndex, p) {
        _renderText.renderText(this.layerCanvasArr[layerIndex], _bb.BB.copyObj(p));
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "text",
            params: [
                layerIndex,
                _bb.BB.copyObj(p)
            ]
        });
    }
    replaceLayer(layerIndex, imageData) {
        let ctx = this.layerCanvasArr[layerIndex].getContext("2d");
        ctx.putImageData(imageData, 0, 0);
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "replaceLayer",
            params: [
                layerIndex,
                imageData
            ]
        });
    }
    clearLayer(layerIndex) {
        let ctx = this.layerCanvasArr[layerIndex].getContext("2d");
        ctx.save();
        ctx.clearRect(0, 0, this.layerCanvasArr[layerIndex].width, this.layerCanvasArr[layerIndex].height);
        ctx.restore();
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "clearLayer",
            params: [
                layerIndex
            ]
        });
    }
    getLayers() {
        return this.layerCanvasArr.map((item)=>{
            return {
                context: item.getContext("2d"),
                opacity: item.opacity,
                name: item.name,
                mixModeStr: item.mixModeStr
            };
        });
    }
    getLayersFast() {
        return this.layerCanvasArr.map((item)=>{
            return {
                canvas: item,
                opacity: item.opacity,
                name: item.name,
                mixModeStr: item.mixModeStr
            };
        });
    }
    getLayerIndex(canvasObj, doReturnNull) {
        for(let i = 0; i < this.layerCanvasArr.length; i++){
            if (this.layerCanvasArr[i] === canvasObj) return i;
        }
        if (!doReturnNull) throw new Error("layer not found (in " + this.layerCanvasArr.length + " layers)");
        return null;
    }
    getLayer(index, doReturnNull) {
        if (this.layerCanvasArr[index]) return {
            context: this.layerCanvasArr[index].getContext("2d"),
            opacity: this.layerCanvasArr[index].opacity,
            name: this.layerCanvasArr[index].name,
            id: index
        };
        if (!doReturnNull) throw new Error("layer of index " + index + " not found (in " + this.layerCanvasArr.length + " layers)");
        return null;
    }
    getColorAt(x, y) {
        x = Math.floor(x);
        y = Math.floor(y);
        let ctx = this.pickCanvas.getContext("2d");
        ctx.save();
        ctx.imageSmoothingEnabled = false;
        ctx.clearRect(0, 0, 1, 1);
        for(let i = 0; i < this.layerCanvasArr.length; i++){
            ctx.globalAlpha = this.layerCanvasArr[i].opacity;
            ctx.globalCompositeOperation = this.layerCanvasArr[i].mixModeStr;
            ctx.drawImage(this.layerCanvasArr[i], -x, -y);
        }
        ctx.restore();
        let imData = ctx.getImageData(0, 0, 1, 1);
        return new _bb.BB.RGB(imData.data[0], imData.data[1], imData.data[2]);
    }
    getCompleteCanvas(factor) {
        return _drawProject.drawProject(this.getProject(), factor);
    }
    getProject() {
        return {
            width: this.width,
            height: this.height,
            layers: this.layerCanvasArr.map((layer)=>{
                return {
                    name: layer.name,
                    opacity: layer.opacity,
                    mixModeStr: layer.mixModeStr,
                    image: layer
                };
            })
        };
    }
    addChangeListener(func) {
        if (this.changeListenerArr.includes(func)) return;
        this.changeListenerArr.push(func);
    }
    removeChangeListener(func) {
        for(let i = 0; i < this.changeListenerArr.length; i++)if (this.changeListenerArr[i] === func) {
            this.changeListenerArr.splice(i, 1);
            return;
        }
    }
    setMixMode(layerIndex, mixModeStr) {
        if (!this.layerCanvasArr[layerIndex]) throw new Error('invalid layer');
        this.layerCanvasArr[layerIndex].mixModeStr = mixModeStr;
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "setMixMode",
            params: [
                layerIndex,
                '' + mixModeStr
            ]
        });
    }
    /**
     * Set composite drawing step for KlCanvasWorkspace.
     * To apply temporary manipulations to a layer.
     *
     * @param layerIndex
     * @param compositeObj
     */ setComposite(layerIndex, compositeObj) {
        if (!this.layerCanvasArr[layerIndex]) throw new Error('invalid layer');
        this.layerCanvasArr[layerIndex].compositeObj = compositeObj;
    }
}

},{"../../bb/bb":"e3nbn","../image-operations/flood-fill":"hXVZJ","../image-operations/shape-tool":"22W2J","../image-operations/render-text":"amc9m","../history/kl-history":"ai9zE","./draw-project":"4pmbZ","../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hXVZJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Does flood fill, and returns that. an array - 0 not filled. 255 filled
 *
 * returns {
 *     data: Uint8Array
 * }
 *
 * @param rgbaArr Uint8Array rgba
 * @param width int
 * @param height int
 * @param x int
 * @param y int
 * @param tolerance int 0 - 255
 * @param grow int >= 0
 * @param isContiguous boolean
 * @returns {{data: Uint8Array}}
 */ parcelHelpers.export(exports, "floodFillBits", ()=>floodFillBits
);
/**
 * Flood fill. Tried https://github.com/binarymax/floodfill.js/ but it implemented tolerance wrong, and had bugs.
 * So, my own implementation. can handle tolerance, grow, opacity.
 * Needs to be optimized.
 */ /**
 * Set values in data within rect to 254, unless they're 255
 *
 * @param data Uint8Array
 * @param width int
 * @param x0 int
 * @param y0 int
 * @param x1 int >x0
 * @param y1 int >y0
 */ function fillRect(data, width, x0, y0, x1, y1) {
    for(let x = x0; x <= x1; x++)for(let y = y0; y <= y1; y++){
        if (data[y * width + x] === 255) continue;
        data[y * width + x] = 254;
    }
}
let mx, my;
/**
 * Get index i moved by dX, dY. in array with dimensions width height.
 * Returns null if outside bounds.
 *
 * @param width int
 * @param height int
 * @param i int
 * @param dX int
 * @param dY int
 * @returns {null|*}
 */ function moveIndex(width, height, i, dX, dY) {
    mx = i % width + dX;
    my = Math.floor(i / width) + dY;
    if (mx < 0 || my < 0 || mx >= width || my >= height) return null;
    return my * width + mx;
}
/**
 * If pixel can be filled (within tolerance) will be set 255 and returns true.
 * returns false if already filled, or i is null
 *
 * @param srcArr Uint8Array rgba
 * @param targetArr Uint8Array
 * @param width int
 * @param height int
 * @param initRgba rgba
 * @param tolerance int 0 - 255
 * @param i int - srcArr index
 * @returns {boolean}
 */ function testAndFill(srcArr, targetArr, width, height, initRgba, tolerance, i) {
    if (i === null || targetArr[i] === 255) return false;
    if (srcArr[i * 4] === initRgba[0] && srcArr[i * 4 + 1] === initRgba[1] && srcArr[i * 4 + 2] === initRgba[2] && srcArr[i * 4 + 3] === initRgba[3]) {
        targetArr[i] = 255;
        return true;
    }
    if (tolerance > 0 && Math.abs(srcArr[i * 4] - initRgba[0]) <= tolerance && Math.abs(srcArr[i * 4 + 1] - initRgba[1]) <= tolerance && Math.abs(srcArr[i * 4 + 2] - initRgba[2]) <= tolerance && Math.abs(srcArr[i * 4 + 3] - initRgba[3]) <= tolerance) {
        targetArr[i] = 255;
        return true;
    }
    return false;
}
/**
 *
 * @param srcArr Uint8Array rgba
 * @param targetArr Uint8Array
 * @param width int
 * @param height int
 * @param px int
 * @param py int
 * @param tolerance int 0 - 255
 * @param grow int >= 0
 * @param isContiguous boolean
 */ function floodFill(srcArr, targetArr, width, height, px, py, tolerance, grow, isContiguous) {
    let initRgba = [
        srcArr[(py * width + px) * 4],
        srcArr[(py * width + px) * 4 + 1],
        srcArr[(py * width + px) * 4 + 2],
        srcArr[(py * width + px) * 4 + 3]
    ];
    if (isContiguous) {
        let q = [];
        q.push(py * width + px);
        targetArr[py * width + px] = 255;
        let i, e;
        while(q.length){
            i = q.pop();
            // queue up unfilled neighbors
            e = moveIndex(width, height, i, -1, 0); // left
            testAndFill(srcArr, targetArr, width, height, initRgba, tolerance, e) && q.push(e);
            e = moveIndex(width, height, i, 1, 0); // right
            testAndFill(srcArr, targetArr, width, height, initRgba, tolerance, e) && q.push(e);
            e = moveIndex(width, height, i, 0, -1); // up
            testAndFill(srcArr, targetArr, width, height, initRgba, tolerance, e) && q.push(e);
            e = moveIndex(width, height, i, 0, 1); // bottom
            testAndFill(srcArr, targetArr, width, height, initRgba, tolerance, e) && q.push(e);
        }
    } else for(let i = 0; i < width * height; i++)testAndFill(srcArr, targetArr, width, height, initRgba, tolerance, i);
    // grow
    if (grow === 0) return;
    // how does it grow? it finds all pixel at the edge.
    // then depending on what kind of edge it is, it draws a rectangle into target
    // the rectangle has the value 254, or else it mess it all up.
    // after it's all done, replaces it with 255
    let x0, x1, y0, y1;
    let l, tl, t, tr, r, br, b, bl; // left, top left, top, top right, etc.
    for(let x = 0; x < width; x++)for(let y = 0; y < height; y++){
        if (targetArr[y * width + x] !== 255) continue;
        // bounds of rectangle
        x0 = x;
        x1 = x;
        y0 = y;
        y1 = y;
        l = targetArr[y * width + x - 1] !== 255;
        tl = targetArr[(y - 1) * width + x - 1] !== 255;
        t = targetArr[(y - 1) * width + x] !== 255;
        tr = targetArr[(y - 1) * width + x + 1] !== 255;
        r = targetArr[y * width + x + 1] !== 255;
        br = targetArr[(y + 1) * width + x + 1] !== 255;
        b = targetArr[(y + 1) * width + x] !== 255;
        bl = targetArr[(y + 1) * width + x - 1] !== 255;
        if (l) x0 = x - grow;
        if (l && tl && t) {
            x0 = x - grow;
            y0 = y - grow;
        }
        if (t) y0 = Math.min(y0, y - grow);
        if (t && tr && r) {
            y0 = Math.min(y0, y - grow);
            x1 = x + grow;
        }
        if (r) x1 = Math.max(x1, x + 1 * grow);
        if (r && br && b) {
            x1 = Math.max(x1, x + 1 * grow);
            y1 = Math.max(y1, y + 1 * grow);
        }
        if (b) y1 = Math.max(y1, y + 1 * grow);
        if (b && bl && l) {
            x0 = Math.min(x0, x - 1 * grow);
            y1 = Math.max(y1, y + 1 * grow);
        }
        if (!l && !tl && !t && !tr && !r && !br && !b && !bl) continue;
        fillRect(targetArr, width, Math.max(0, x0), Math.max(0, y0), Math.min(width - 1, x1), Math.min(height - 1, y1));
    }
    for(let i1 = 0; i1 < width * height; i1++)if (targetArr[i1] === 254) targetArr[i1] = 255;
}
function floodFillBits(rgbaArr, width, height, x, y, tolerance, grow, isContiguous) {
    x = Math.round(x);
    y = Math.round(y);
    let resultArr = new Uint8Array(new ArrayBuffer(width * height));
    floodFill(rgbaArr, resultArr, width, height, x, y, tolerance, grow, isContiguous);
    return {
        data: resultArr
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"22W2J":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Input processor for shape tool.
 * Coordinates are in canvas space.
 * angleRad is the angle of the canvas.
 *
 * @param p - {onShape: func(isDone, x1, y1, x2, y2, angleRad)}
 * @constructor
 */ parcelHelpers.export(exports, "ShapeTool", ()=>ShapeTool
);
/**
 * Draw a shape (rectangle, ellipse, line)
 *
 * @param ctx
 * @param shapeObj
 */ parcelHelpers.export(exports, "drawShape", ()=>drawShape
);
var _bb = require("../../bb/bb");
function ShapeTool(p) {
    let downX, downY, downAngleRad;
    this.onDown = function(x, y, angleRad) {
        downX = x;
        downY = y;
        downAngleRad = angleRad;
    };
    this.onMove = function(x, y) {
        p.onShape(false, downX, downY, x, y, downAngleRad);
    };
    this.onUp = function(x, y) {
        p.onShape(true, downX, downY, x, y, downAngleRad);
    };
}
function drawShape(ctx, shapeObj) {
    if ([
        'rect',
        'ellipse',
        'line'
    ].includes(shapeObj.type)) {
        const lineWidth = Math.round(shapeObj.lineWidth);
        const angleDeg = shapeObj.angleRad * 180 / Math.PI;
        // --- prep canvas ---
        ctx.save();
        if (shapeObj.opacity) ctx.globalAlpha = shapeObj.opacity;
        if (shapeObj.isEraser) ctx.globalCompositeOperation = 'destination-out';
        ctx.rotate(-shapeObj.angleRad);
        if (shapeObj.fillRgb) ctx.fillStyle = _bb.BB.ColorConverter.toRgbStr(shapeObj.fillRgb);
        else if (shapeObj.strokeRgb) {
            ctx.strokeStyle = _bb.BB.ColorConverter.toRgbStr(shapeObj.strokeRgb);
            ctx.lineWidth = lineWidth;
        }
        let x1 = shapeObj.x1;
        let y1 = shapeObj.y1;
        let x2 = shapeObj.x2;
        let y2 = shapeObj.y2;
        // --- angle snapping ---
        if (shapeObj.isAngleSnap) {
            let r1 = _bb.BB.rotate(x1, y1, shapeObj.angleRad / Math.PI * 180);
            let r2 = _bb.BB.rotate(x2, y2, shapeObj.angleRad / Math.PI * 180);
            let pAngleDeg = _bb.BB.pointsToAngleDeg(r1, r2) + 90;
            let pAngleDegSnapped = Math.round(pAngleDeg / 45) * 45;
            let rotated = _bb.BB.rotateAround({
                x: x1,
                y: y1
            }, {
                x: x2,
                y: y2
            }, pAngleDegSnapped - pAngleDeg);
            x2 = rotated.x;
            y2 = rotated.y;
            // needs to be perfect if p1->p2 aligns with canvas x- or y-axis
            if ((angleDeg + pAngleDegSnapped) % 90 === 0) {
                if (Math.round((angleDeg - pAngleDegSnapped) / 90) % 2 === 0) x2 = x1;
                else y2 = y1;
            }
        }
        let x = x1;
        let y = y1;
        let dX = x2 - x1;
        let dY = y2 - y1;
        // --- 1:1 ratio ---
        if (shapeObj.type !== 'line' && shapeObj.isFixedRatio) {
            let r1 = _bb.BB.rotate(shapeObj.x1, shapeObj.y1, shapeObj.angleRad / Math.PI * 180);
            let r2 = _bb.BB.rotate(shapeObj.x2, shapeObj.y2, shapeObj.angleRad / Math.PI * 180);
            let rx = r1.x;
            let ry = r1.y;
            let rdX = r2.x - r1.x;
            let rdY = r2.y - r1.y;
            if (Math.abs(rdX) < Math.abs(rdY)) rdY = Math.abs(rdX) * (rdY < 0 ? -1 : 1);
            else rdX = Math.abs(rdY) * (rdX < 0 ? -1 : 1);
            r2.x = rx + rdX;
            r2.y = ry + rdY;
            r1 = _bb.BB.rotate(r1.x, r1.y, -shapeObj.angleRad / Math.PI * 180);
            r2 = _bb.BB.rotate(r2.x, r2.y, -shapeObj.angleRad / Math.PI * 180);
            x1 = r1.x;
            y1 = r1.y;
            x2 = r2.x;
            y2 = r2.y;
            x = x1;
            y = y1;
            dX = x2 - x1;
            dY = y2 - y1;
        }
        // outwards modifier
        if (shapeObj.isOutwards) {
            x -= dX;
            y -= dY;
            dX *= 2;
            dY *= 2;
            x1 = x;
            y1 = y;
            x2 = x + dX;
            y2 = y + dY;
        }
        let p1;
        let p2;
        if (shapeObj.type === 'line') {
            // rounded
            const x1r = Math.round(x1);
            const y1r = Math.round(y1);
            const x2r = Math.round(x2);
            const y2r = Math.round(y2);
            // floored
            const x1f = Math.floor(x1);
            const y1f = Math.floor(y1);
            const x2f = Math.floor(x2);
            const y2f = Math.floor(y2);
            if (lineWidth % 2 === 0) {
                if (y1r === y2r) {
                    p1 = {
                        x: x1f,
                        y: y1r
                    };
                    p2 = {
                        x: x2f,
                        y: y2r
                    };
                    if (x1f < x2f) p2.x += 1;
                    else p1.x += 1;
                } else if (x1r === x2r) {
                    p1 = {
                        x: x1r,
                        y: y1f
                    };
                    p2 = {
                        x: x2r,
                        y: y2f
                    };
                    if (y1f < y2f) p2.y += 1;
                    else p1.y += 1;
                } else {
                    p1 = {
                        x: x1,
                        y: y1
                    };
                    p2 = {
                        x: x2,
                        y: y2
                    };
                }
            } else {
                p1 = {
                    x: x1f,
                    y: y1f
                };
                p2 = {
                    x: x2f,
                    y: y2f
                };
                if (y1f === y2f) {
                    if (x1f < x2f) p2.x += 1;
                    else p1.x += 1;
                    p1.y += 0.5;
                    p2.y += 0.5;
                } else if (x1f === x2f) {
                    if (y1f < y2f) p2.y += 1;
                    else p1.y += 1;
                    p1.x += 0.5;
                    p2.x += 0.5;
                } else {
                    p1.x = x1;
                    p1.y = y1;
                    p2.x = x2;
                    p2.y = y2;
                }
            }
            p1 = _bb.BB.rotate(p1.x, p1.y, shapeObj.angleRad / Math.PI * 180);
            p2 = _bb.BB.rotate(p2.x, p2.y, shapeObj.angleRad / Math.PI * 180);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        } else if (shapeObj.type === 'rect') {
            // floored
            const x1f = Math.floor(x1);
            const y1f = Math.floor(y1);
            const x2f = Math.floor(x2);
            const y2f = Math.floor(y2);
            if (angleDeg % 90 === 0) {
                if (shapeObj.fillRgb) {
                    if (x1 % 1 === 0) x1 += 1;
                    if (y1 % 1 === 0) y1 += 1;
                    if (x2 % 1 === 0) x2 += 1;
                    if (y2 % 1 === 0) y2 += 1;
                    p1 = {
                        x: x1 < x2 ? x1f : x2f,
                        y: y1 < y2 ? y1f : y2f
                    };
                    p2 = {
                        x: Math.ceil((x1 < x2 ? x2 : x1) - p1.x),
                        y: Math.ceil((y1 < y2 ? y2 : y1) - p1.y)
                    };
                    p2.x = p1.x + p2.x;
                    p2.y = p1.y + p2.y;
                } else if (lineWidth % 2 === 0) {
                    p1 = {
                        x: x1f,
                        y: y1f
                    };
                    p2 = {
                        x: x2f,
                        y: y2f
                    };
                } else {
                    p1 = {
                        x: x1f + 0.5,
                        y: y1f + 0.5
                    };
                    p2 = {
                        x: x2f + 0.5,
                        y: y2f + 0.5
                    };
                }
            } else {
                p1 = {
                    x: x1,
                    y: y1
                };
                p2 = {
                    x: x2,
                    y: y2
                };
            }
            p1 = _bb.BB.rotate(p1.x, p1.y, shapeObj.angleRad / Math.PI * 180);
            p2 = _bb.BB.rotate(p2.x, p2.y, shapeObj.angleRad / Math.PI * 180);
            p2.x = p2.x - p1.x;
            p2.y = p2.y - p1.y;
            if (shapeObj.fillRgb) ctx.fillRect(p1.x, p1.y, p2.x, p2.y);
            else ctx.strokeRect(p1.x, p1.y, p2.x, p2.y);
        } else {
            p1 = _bb.BB.rotate(x1, y1, shapeObj.angleRad / Math.PI * 180);
            p2 = _bb.BB.rotate(x2, y2, shapeObj.angleRad / Math.PI * 180);
            x = p1.x;
            y = p1.y;
            dX = p2.x - p1.x;
            dY = p2.y - p1.y;
            ctx.beginPath();
            ctx.ellipse(x + dX / 2, y + dY / 2, Math.abs(dX / 2), Math.abs(dY / 2), 0, 0, Math.PI * 2);
            if (shapeObj.fillRgb) ctx.fill();
            else ctx.stroke();
        }
        ctx.restore();
    } else throw new Error('unknown shape');
}

},{"../../bb/bb":"e3nbn","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"amc9m":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Draw text on a canvas.
 *
 * @param canvas
 * @param p
 * @returns - bounds. coords relative to p.x p.y
 */ parcelHelpers.export(exports, "renderText", ()=>renderText
);
var _bb = require("../../bb/bb");
function renderText(canvas, p) {
    // always at least a space. so bounds aren't just a dot
    let textStr = p.textStr === '' ? ' ' : p.textStr;
    // --- create el ---
    // create an actual dom element. figure out where exactly each letter is positioned.
    // that way multiline is feasible. canvas can't do multiline or text-align
    let outer = _bb.BB.el({
        css: {
            position: 'fixed',
            left: '0',
            top: '0',
            width: '100000px',
            fontSize: p.size + 'px',
            lineHeight: p.lineHeight ? p.lineHeight + 'px' : 'default'
        }
    });
    let div = _bb.BB.el({
        parent: outer,
        css: {
            display: 'inline-block',
            textAlign: p.align ? p.align : 'left',
            fontFamily: p.font ? p.font : 'sans-serif',
            fontSize: p.size + 'px',
            fontWeight: p.isBold ? 'bold' : 'normal',
            fontStyle: p.isItalic ? 'italic' : 'normal',
            lineHeight: p.lineHeight ? p.lineHeight + 'px' : 'default',
            opacity: '0',
            pointerEvents: 'none'
        }
    });
    let spanStr = '';
    let replaceObj = {
        "\n": '<br>',
        " ": '&nbsp;',
        "	": '&nbsp;&nbsp;&nbsp;&nbsp;'
    };
    for(let i = 0; i < textStr.length; i++){
        if (textStr[i] === "\n") {
            div.appendChild(_bb.BB.el({
                tagName: 'span',
                textContent: spanStr,
                css: {
                    whiteSpace: 'pre'
                }
            }));
            spanStr = '';
            div.appendChild(_bb.BB.el({
                tagName: 'br'
            }));
            continue;
        }
        spanStr += textStr[i].replace("\t", '    ');
    }
    div.appendChild(_bb.BB.el({
        tagName: 'span',
        textContent: spanStr,
        css: {
            whiteSpace: 'pre'
        }
    }));
    document.body.appendChild(outer);
    // --- determine bounds ---
    let bounds = {
        x0: 99999999,
        y0: 99999999,
        x1: 0,
        y1: 0
    };
    for(let i1 = 0; i1 < div.children.length; i1++){
        let el = div.children[i1];
        bounds.x0 = Math.min(bounds.x0, el.offsetLeft);
        bounds.y0 = Math.min(bounds.y0, el.offsetTop);
        bounds.x1 = Math.max(bounds.x1, el.offsetLeft + el.offsetWidth);
        bounds.y1 = Math.max(bounds.y1, el.offsetTop + el.offsetHeight);
    }
    // --- draw ---
    let ctx = canvas.getContext('2d');
    ctx.save();
    let font = [];
    if (p.isItalic) font.push('italic');
    if (p.isBold) font.push('bold');
    font.push(p.size + 'px ' + (p.font ? p.font : 'sans-serif'));
    ctx.font = font.join(' ');
    ctx.fillStyle = p.color ? p.color : '#000';
    let x = p.x;
    let y = p.y;
    if (p.align === 'right') x += -bounds.x1 + bounds.x0;
    if (p.align === 'center') x += (-bounds.x1 + bounds.x0) / 2;
    ctx.translate(p.x, p.y);
    ctx.rotate(p.angleRad ? -p.angleRad : 0);
    ctx.translate(-p.x, -p.y);
    ctx.translate(x, y);
    // fill
    for(let i2 = 0; i2 < div.children.length; i2++){
        let el = div.children[i2];
        //ctx.fillText(el.innerText, 0, 0);
        ctx.fillText(el.innerText, el.offsetLeft, el.offsetTop);
    }
    if (p.isDebug) {
        ctx.lineWidth = 1;
        ctx.strokeRect(0, -p.size * 0.85, bounds.x1, bounds.y1);
        ctx.restore();
        ctx.fillRect(p.x - 1, p.y - 1, 2, 2);
    } else ctx.restore();
    document.body.removeChild(outer);
    return {
        x: x - p.x,
        y: y - p.y - p.size * 0.85,
        width: bounds.x1 - bounds.x0,
        height: bounds.y1 - bounds.y0
    };
}

},{"../../bb/bb":"e3nbn","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4pmbZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "drawProject", ()=>drawProject
);
var _bb = require("../../bb/bb");
function drawProject(project, factor) {
    let resultCanvas = _bb.BB.canvas(Math.max(1, Math.round(project.width * factor)), Math.max(1, Math.round(project.height * factor)));
    let ctx = resultCanvas.getContext("2d");
    ctx.save();
    if (factor > 1) ctx.imageSmoothingEnabled = false;
    for(let i = 0; i < project.layers.length; i++){
        if (project.layers[i].opacity === 0) continue;
        ctx.globalAlpha = project.layers[i].opacity;
        ctx.globalCompositeOperation = project.layers[i].mixModeStr ? project.layers[i].mixModeStr : 'source-over';
        ctx.drawImage(project.layers[i].image, 0, 0, resultCanvas.width, resultCanvas.height);
    }
    ctx.restore();
    return resultCanvas;
}

},{"../../bb/bb":"e3nbn","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1Vla8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "translateBlending", ()=>translateBlending
);
var _language = require("../../language/language");
function translateBlending(blendMode) {
    if (!blendMode) return _language.LANG('layers-blend-normal');
    const codes = {
        'source-over': 'layers-blend-normal',
        'darken': 'layers-blend-darken',
        'multiply': 'layers-blend-multiply',
        'color-burn': 'layers-blend-color-burn',
        'lighten': 'layers-blend-lighten',
        'screen': 'layers-blend-screen',
        'color-dodge': 'layers-blend-color-dodge',
        'overlay': 'layers-blend-overlay',
        'soft-light': 'layers-blend-soft-light',
        'hard-light': 'layers-blend-hard-light',
        'difference': 'layers-blend-difference',
        'exclusion': 'layers-blend-exclusion',
        'hue': 'layers-blend-hue',
        'saturation': 'layers-blend-saturation',
        'color': 'layers-blend-color',
        'luminosity': 'layers-blend-luminosity'
    };
    if (!(blendMode in codes)) throw new Error('unknown blend mode');
    return _language.LANG(codes[blendMode]);
}

},{"../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1QQyo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Overlay for KlCanvasWorkspace.
 * - brush circle
 * - eyedropper circle
 * - compass needle (rotation hud)
 */ parcelHelpers.export(exports, "WorkspaceSvgOverlay", ()=>WorkspaceSvgOverlay
);
var _bb = require("../../bb/bb");
class WorkspaceSvgOverlay {
    // ---- public ----
    constructor(p){
        this.rootElement = _bb.BB.createSvg({
            elementType: 'svg',
            width: '' + p.width,
            height: '' + p.height
        });
        _bb.BB.css(this.rootElement, {
            position: 'absolute',
            left: '0',
            top: '0',
            pointerEvents: 'none',
            userSelect: 'none'
        });
        //brush circles
        this.brushCircleOuter = _bb.BB.createSvg({
            elementType: 'circle',
            r: '10',
            stroke: 'rgba(0,0,0,0.7)',
            'stroke-width': '1',
            fill: 'none'
        });
        this.brushCircleInner = _bb.BB.createSvg({
            elementType: 'circle',
            r: '9',
            stroke: 'rgba(255,255,255,0.7)',
            'stroke-width': '1',
            fill: 'none'
        });
        this.rootElement.append(this.brushCircleOuter, this.brushCircleInner);
        //color picker preview circle
        this.pickerPreviewBorder = _bb.BB.createSvg({
            elementType: 'circle',
            r: '47',
            stroke: 'black',
            'stroke-width': '22',
            fill: 'none'
        });
        this.pickerPreviewBorder.style.opacity = '0';
        this.pickerPreviewCol = _bb.BB.createSvg({
            elementType: 'circle',
            r: '47',
            stroke: 'black',
            'stroke-width': '20',
            fill: 'none'
        });
        this.pickerPreviewCol.style.opacity = '0';
        this.rootElement.append(this.pickerPreviewBorder, this.pickerPreviewCol);
        //rotation compass
        this.compassSize = 30;
        this.compass = _bb.BB.createSvg({
            elementType: 'g',
            transform: 'translate(' + p.width / 2 + ', ' + p.height / 2 + ')'
        });
        _bb.BB.css(this.compass, {
            transition: 'opacity 0.25s ease-in-out',
            opacity: '0'
        });
        this.compassInner = _bb.BB.createSvg({
            elementType: 'g',
            transform: 'rotate(45)'
        });
        this.compassBaseCircle = _bb.BB.createSvg({
            elementType: 'circle',
            fill: 'rgba(0,0,0,0.9)',
            stroke: 'none',
            cx: '0',
            cy: '0',
            r: '' + this.compassSize
        });
        this.compassLineCircle = _bb.BB.createSvg({
            elementType: 'circle',
            fill: 'none',
            stroke: 'rgba(255,255,255,0.75)',
            'stroke-width': '1',
            cx: '0',
            cy: '0',
            r: '' + this.compassSize * 0.9
        });
        this.compassUpperTriangle = _bb.BB.createSvg({
            elementType: 'path',
            fill: '#f00',
            stroke: 'none',
            d: 'M -' + this.compassSize * 0.25 + ',0 ' + this.compassSize * 0.25 + ',0 0,-' + this.compassSize * 0.9 + ' z'
        });
        this.compassLowerTriangle = _bb.BB.createSvg({
            elementType: 'path',
            fill: '#fff',
            stroke: 'none',
            d: 'M -' + this.compassSize * 0.25 + ',0 ' + this.compassSize * 0.25 + ',0 0,' + this.compassSize * 0.9 + ' z'
        });
        this.compassInner.append(this.compassBaseCircle, this.compassLineCircle, this.compassUpperTriangle, this.compassLowerTriangle);
        this.compass.append(this.compassInner);
        this.rootElement.append(this.compass);
    }
    getElement() {
        return this.rootElement;
    }
    setSize(width, height) {
        this.rootElement.setAttribute('width', '' + width);
        this.rootElement.setAttribute('height', '' + height);
        this.compass.setAttribute('transform', 'translate(' + width / 2 + ', ' + height / 2 + ')');
    }
    updateCursor(p) {
        if ('x' in p) {
            this.brushCircleOuter.setAttribute('cx', '' + p.x);
            this.brushCircleInner.setAttribute('cx', '' + p.x);
        }
        if ('y' in p) {
            this.brushCircleOuter.setAttribute('cy', '' + p.y);
            this.brushCircleInner.setAttribute('cy', '' + p.y);
        }
        if ('radius' in p) {
            this.brushCircleOuter.setAttribute('r', '' + Math.max(0, p.radius));
            this.brushCircleInner.setAttribute('r', '' + Math.max(0, p.radius - 1));
        }
        if ('isVisible' in p) {
            this.brushCircleOuter.style.opacity = p.isVisible ? '1' : '0';
            this.brushCircleInner.style.opacity = p.isVisible ? '1' : '0';
        }
    }
    updateColorPreview(p) {
        if ('x' in p) {
            this.pickerPreviewCol.setAttribute('cx', '' + p.x);
            this.pickerPreviewBorder.setAttribute('cx', '' + p.x);
        }
        if ('y' in p) {
            this.pickerPreviewCol.setAttribute('cy', '' + p.y);
            this.pickerPreviewBorder.setAttribute('cy', '' + p.y);
        }
        if ('color' in p) {
            this.pickerPreviewCol.setAttribute('stroke', _bb.BB.ColorConverter.toRgbStr(p.color));
            let borderColor = _bb.BB.testIsWhiteBestContrast(p.color) ? 'rgba(255,255,255,0.5)' : 'rgba(0,0,0,0.5)';
            this.pickerPreviewBorder.setAttribute('stroke', borderColor);
        }
        if ('isVisible' in p) {
            this.pickerPreviewCol.style.opacity = p.isVisible ? '1' : '0';
            this.pickerPreviewBorder.style.opacity = p.isVisible ? '1' : '0';
        }
    }
    updateCompass(p) {
        if ('angleDeg' in p) {
            this.compassInner.setAttribute('transform', 'rotate(' + p.angleDeg + ')');
            this.compassLineCircle.style.opacity = p.angleDeg % 90 === 0 ? '1' : '0';
        }
        if ('isVisible' in p) this.compass.style.opacity = p.isVisible ? '1' : '0';
    }
}

},{"../../bb/bb":"e3nbn","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ekALo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Work area that displays the KlCanvas.
 * - pan, zoom, rotate (also via multi-touch)
 * - input modes: drawing, hand, pick, fill, text // transform, select
 * - drawing input events
 * - view change events
 * - eyedropper input events (pick)
 * - draws cursor, eyedropper overlay
 *
 * subscribes to klCanvas changes
 * listens to kl history for changes
 * and you can manually trigger redraw
 */ parcelHelpers.export(exports, "KlCanvasWorkspace", ()=>KlCanvasWorkspace
);
var _bb = require("../../bb/bb");
var _workspaceSvgOverlay = require("./workspace-svg-overlay");
var _klHistory = require("../history/kl-history");
// @ts-ignore
var _cursorPickerPng = require("url:~/src/app/img/ui/cursor-picker.png");
var _cursorPickerPngDefault = parcelHelpers.interopDefault(_cursorPickerPng);
// @ts-ignore
var _cursorZoomEwPng = require("url:~/src/app/img/ui/cursor-zoom-ew.png");
var _cursorZoomEwPngDefault = parcelHelpers.interopDefault(_cursorZoomEwPng);
// @ts-ignore
var _cursorFillPng = require("url:~/src/app/img/ui/cursor-fill.png");
var _cursorFillPngDefault = parcelHelpers.interopDefault(_cursorFillPng);
// @ts-ignore
var _cursorTextPng = require("url:~/src/app/img/ui/cursor-text.png");
var _cursorTextPngDefault = parcelHelpers.interopDefault(_cursorTextPng);
const MIN_SCALE = 0.0625;
const MAX_SCALE = 64;
let TMode;
(function(TMode1) {
    TMode1[TMode1["Draw"] = 0] = "Draw";
    TMode1[TMode1["Hand"] = 1] = "Hand";
    TMode1[TMode1["HandGrabbing"] = 2] = "HandGrabbing";
    TMode1[TMode1["Pick"] = 3] = "Pick";
    TMode1[TMode1["Zoom"] = 4] = "Zoom";
    TMode1[TMode1["Rotate"] = 5] = "Rotate";
    TMode1[TMode1["Rotating"] = 6] = "Rotating";
    TMode1[TMode1["Fill"] = 7] = "Fill";
    TMode1[TMode1["Text"] = 8] = "Text";
    TMode1[TMode1["Shape"] = 9] = "Shape";
})(TMode || (TMode = {
}));
const ANIMATION_SPEED = 0.3; // rate of transition towards targetTransform
class KlCanvasWorkspace {
    getRenderedTransform() {
        // rounded x & y so canvas is less blurry.
        const result = this.renderedTransformObj;
        result.x = this.highResTransformObj.x;
        result.y = this.highResTransformObj.y;
        result.scale = this.highResTransformObj.scale;
        result.angle = this.highResTransformObj.angle;
        if (result.angle % (Math.PI / 2) === 0 && result.scale % 1 === 0) {
            result.x = Math.round(result.x);
            result.y = Math.round(result.y);
        }
        return result;
    }
    updateChangeListener() {
        this.klCanvas.addChangeListener(()=>{
            this.lastRenderedState = -1;
            this.reqFrame();
        });
    }
    updateCursor(modeInt, doForce) {
        if (modeInt === this.currentMode && !doForce) return;
        const oldMode = this.currentMode;
        this.currentMode = modeInt;
        this.lastRenderedState = -1;
        if (this.currentMode === TMode.Draw) this.rootEl.style.cursor = 'crosshair';
        else if (this.currentMode === TMode.Hand) this.rootEl.style.cursor = 'grab';
        else if (this.currentMode === TMode.HandGrabbing) this.rootEl.style.cursor = 'grabbing';
        else if (this.currentMode === TMode.Pick) this.rootEl.style.cursor = "url('" + _cursorPickerPngDefault.default + "') 0 15, crosshair";
        else if (this.currentMode === TMode.Zoom) this.rootEl.style.cursor = "url('" + _cursorZoomEwPngDefault.default + "') 7 7, zoom-in";
        else if (this.currentMode === TMode.Rotate) this.rootEl.style.cursor = "grab";
        else if (this.currentMode === TMode.Rotating) this.rootEl.style.cursor = "grabbing";
        else if (this.currentMode === TMode.Fill) this.rootEl.style.cursor = "url('" + _cursorFillPngDefault.default + "') 1 12, crosshair";
        else if (this.currentMode === TMode.Text) this.rootEl.style.cursor = "url('" + _cursorTextPngDefault.default + "') 1 12, crosshair";
        else if (this.currentMode === TMode.Shape) this.rootEl.style.cursor = 'crosshair';
        if ([
            TMode.Draw,
            TMode.Pick,
            TMode.Fill,
            TMode.Text,
            TMode.Shape
        ].includes(this.globalMode)) {
            const oldIsHand = [
                TMode.Hand,
                TMode.HandGrabbing
            ].includes(oldMode);
            const currentIsHand = [
                TMode.Hand,
                TMode.HandGrabbing
            ].includes(this.currentMode);
            if (!oldIsHand && currentIsHand) this.mainDoubleTapper.setAllowedPointerTypeArr([
                'mouse',
                'pen',
                'touch'
            ]);
            if (oldIsHand && !currentIsHand) this.mainDoubleTapper.setAllowedPointerTypeArr([
                'touch'
            ]);
        }
        if (this.currentMode !== TMode.Pick) this.svgOverlay.updateColorPreview({
            isVisible: false
        });
    }
    /**
     * returns false if no change of zoom
     * @param stepNum
     * @param centerX
     * @param centerY
     * @private
     */ internalZoomByStep(stepNum, centerX, centerY) {
        const step = Math.log2(this.targetTransformObj.scale);
        let newStep = step / Math.abs(stepNum);
        newStep += stepNum > 0 ? 1 : -1;
        newStep = Math.round(newStep);
        newStep *= Math.abs(stepNum);
        const newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, Math.pow(2, newStep)));
        //has zoomed?
        if (newScale === this.targetTransformObj.scale) return false;
        const effectiveFactor = newScale / this.targetTransformObj.scale;
        this.targetTransformObj.scale = newScale;
        let matrix = _bb.BB.Matrix.getIdentity();
        matrix = _bb.BB.Matrix.multiplyMatrices(matrix, _bb.BB.Matrix.createTranslationMatrix(centerX, centerY));
        matrix = _bb.BB.Matrix.multiplyMatrices(matrix, _bb.BB.Matrix.createScaleMatrix(effectiveFactor));
        matrix = _bb.BB.Matrix.multiplyMatrices(matrix, _bb.BB.Matrix.createTranslationMatrix(-centerX, -centerY));
        let origin = [
            this.targetTransformObj.x,
            this.targetTransformObj.y,
            0,
            1
        ];
        origin = _bb.BB.Matrix.multiplyMatrixAndPoint(matrix, origin);
        this.targetTransformObj.x = origin[0];
        this.targetTransformObj.y = origin[1];
        this.transformIsDirty = true;
        return true;
    }
    /**
     * mixes two transform objects. modifies A
     * @param transformA
     * @param transformB
     * @param blendFactor 0 -> A, 1 -> B
     * @private
     */ mixTransformObj(transformA, transformB, blendFactor) {
        if (transformA.angle === transformB.angle) {
            transformA.scale = _bb.BB.mix(transformA.scale, transformB.scale, blendFactor);
            transformA.x = _bb.BB.mix(transformA.x, transformB.x, blendFactor);
            transformA.y = _bb.BB.mix(transformA.y, transformB.y, blendFactor);
            transformA.angle = _bb.BB.mix(transformA.angle, transformB.angle, blendFactor);
            return;
        }
        const w = this.klCanvas.getWidth();
        const h = this.klCanvas.getHeight();
        // --- determine centerPosA, centerPosB ---
        const centerPosA = this.canvasToWorkspaceCoord({
            x: w / 2,
            y: h / 2
        }, transformA);
        const centerPosB = this.canvasToWorkspaceCoord({
            x: w / 2,
            y: h / 2
        }, transformB);
        // --- centerPosMixed ---
        transformA.x = _bb.BB.mix(centerPosA.x, centerPosB.x, blendFactor);
        transformA.y = _bb.BB.mix(centerPosA.y, centerPosB.y, blendFactor);
        // --- scale and angle ---
        transformA.scale = _bb.BB.mix(transformA.scale, transformB.scale, blendFactor);
        transformA.angle = _bb.BB.mix(transformA.angle, transformB.angle, blendFactor);
        // --- x and y ---
        const mixedPos = this.canvasToWorkspaceCoord({
            x: -w / 2,
            y: -h / 2
        }, transformA);
        transformA.x = mixedPos.x;
        transformA.y = mixedPos.y;
    }
    render() {
        if (this.doResizeCanvas) {
            this.doResizeCanvas = false;
            this.renderTargetCanvas.width = this.renderWidth;
            this.renderTargetCanvas.height = this.renderHeight;
        }
        this.renderContext(this.renderTargetCtx);
    }
    /**
     * is the gray background that surrounds canvas visible?
     * @private
     */ testBgVisible() {
        //bring workspace points (corners of workspace) into canvas coordinate system
        //then check if any corner point is outside of the canvas -> that means the bg is visible
        const workspacePointArr = [
            [
                0,
                0
            ],
            [
                this.renderWidth,
                0
            ],
            [
                this.renderWidth,
                this.renderHeight
            ],
            [
                0,
                this.renderHeight
            ]
        ];
        const art = this.getRenderedTransform();
        //setup transformation matrix
        let matrix = _bb.BB.Matrix.getIdentity();
        matrix = _bb.BB.Matrix.multiplyMatrices(matrix, _bb.BB.Matrix.createScaleMatrix(1 / art.scale));
        matrix = _bb.BB.Matrix.multiplyMatrices(matrix, _bb.BB.Matrix.createRotationMatrix(-art.angle));
        matrix = _bb.BB.Matrix.multiplyMatrices(matrix, _bb.BB.Matrix.createTranslationMatrix(-art.x, -art.y));
        //transform points, then test if outside of canvas
        for(let i = 0; i < workspacePointArr.length; i++){
            let coords = [
                workspacePointArr[i][0],
                workspacePointArr[i][1],
                0,
                1
            ];
            coords = _bb.BB.Matrix.multiplyMatrixAndPoint(matrix, coords);
            if (!(0 <= coords[0] && coords[0] <= this.klCanvas.getWidth() && 0 <= coords[1] && coords[1] <= this.klCanvas.getHeight())) //if not inside -> bg visible
            return true;
        }
        return false;
    }
    renderContext(ctx) {
        const w = this.klCanvas.getWidth();
        const h = this.klCanvas.getHeight();
        const art = this.getRenderedTransform();
        if (art.scale >= 4 || art.scale === 1 && art.angle === 0) ctx.imageSmoothingEnabled = false;
        else {
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'low'; // art.scale >= 1 ? 'low' : 'medium';
        }
        //ctx.imageSmoothingEnabled = false;
        //renderTargetCtx.globalCompositeOperation  = 'multiply';
        ctx.save();
        {
            if (this.bgVisible) {
                ctx.fillStyle = 'rgb(158,158,158)'; // 'rgb(185,185,185)';
                ctx.fillRect(0, 0, this.renderWidth, this.renderHeight);
            } else ctx.clearRect(0, 0, this.renderWidth, this.renderHeight);
            if (this.bgVisible) {
                ctx.save();
                ctx.translate(art.x, art.y);
                ctx.scale(art.scale, art.scale);
                ctx.rotate(art.angle);
                ctx.imageSmoothingEnabled = false;
                //outline
                const borderSize = 1;
                ctx.globalAlpha = 0.2;
                ctx.drawImage(this.emptyCanvas, -borderSize / art.scale, -borderSize / art.scale, w + borderSize * 2 / art.scale, h + borderSize * 2 / art.scale);
                ctx.globalAlpha = 1;
                //erase
                ctx.globalCompositeOperation = 'destination-out';
                ctx.drawImage(this.emptyCanvas, 0, 0, w, h);
                ctx.restore();
            }
            /*const region = new Path2D();
            region.rect(80, 10, 20, 130);
            ctx.clip(region);*/ ctx.translate(art.x, art.y);
            ctx.scale(art.scale, art.scale);
            ctx.rotate(art.angle);
            const layerArr = this.klCanvas.getLayersFast();
            for(let i = 0; i < layerArr.length; i++)if (layerArr[i].opacity > 0) {
                ctx.globalAlpha = layerArr[i].opacity;
                ctx.globalCompositeOperation = layerArr[i].mixModeStr;
                if (layerArr[i].canvas.compositeObj) {
                    if (this.compositeCanvas.width !== layerArr[i].canvas.width || this.compositeCanvas.height !== layerArr[i].canvas.height) {
                        this.compositeCanvas.width = layerArr[i].canvas.width;
                        this.compositeCanvas.height = layerArr[i].canvas.height;
                    } else this.compositeCtx.clearRect(0, 0, this.compositeCanvas.width, this.compositeCanvas.height);
                    this.compositeCtx.drawImage(layerArr[i].canvas, 0, 0);
                    layerArr[i].canvas.compositeObj.draw(this.compositeCtx);
                    ctx.drawImage(this.compositeCanvas, 0, 0, w, h);
                } else ctx.drawImage(layerArr[i].canvas, 0, 0, w, h);
            }
            ctx.globalAlpha = 1;
        }
        ctx.restore();
        // rotation hud
        if (TMode.Rotate === this.currentMode || TMode.Rotating === this.currentMode) this.svgOverlay.updateCompass({
            isVisible: true,
            angleDeg: art.angle / Math.PI * 180
        });
        else this.svgOverlay.updateCompass({
            isVisible: false
        });
    }
    workspaceToCanvasCoord(p) {
        const art = this.getRenderedTransform();
        let matrix = _bb.BB.Matrix.getIdentity();
        matrix = _bb.BB.Matrix.multiplyMatrices(matrix, _bb.BB.Matrix.createScaleMatrix(1 / art.scale));
        matrix = _bb.BB.Matrix.multiplyMatrices(matrix, _bb.BB.Matrix.createRotationMatrix(-art.angle));
        matrix = _bb.BB.Matrix.multiplyMatrices(matrix, _bb.BB.Matrix.createTranslationMatrix(-art.x, -art.y));
        let coords = [
            p.x,
            p.y,
            0,
            1
        ];
        coords = _bb.BB.Matrix.multiplyMatrixAndPoint(matrix, coords);
        return {
            x: coords[0],
            y: coords[1]
        };
    }
    canvasToWorkspaceCoord(p, transformObj) {
        let matrix = _bb.BB.Matrix.getIdentity();
        matrix = _bb.BB.Matrix.multiplyMatrices(matrix, _bb.BB.Matrix.createTranslationMatrix(transformObj.x, transformObj.y));
        matrix = _bb.BB.Matrix.multiplyMatrices(matrix, _bb.BB.Matrix.createRotationMatrix(transformObj.angle));
        matrix = _bb.BB.Matrix.multiplyMatrices(matrix, _bb.BB.Matrix.createScaleMatrix(transformObj.scale));
        let coords = [
            p.x,
            p.y,
            0,
            1
        ];
        coords = _bb.BB.Matrix.multiplyMatrixAndPoint(matrix, coords);
        return {
            x: coords[0],
            y: coords[1]
        };
    }
    snapAngleRad(angleRad, snapDegIncrement, maxDistDeg) {
        let angleDeg = angleRad * 180 / Math.PI;
        const modDeg = Math.abs(angleDeg % snapDegIncrement);
        const dist = Math.min(modDeg, snapDegIncrement - modDeg);
        if (dist <= maxDistDeg) angleDeg = Math.round(angleDeg / snapDegIncrement) * snapDegIncrement;
        return angleDeg / 180 * Math.PI;
    }
    /**
     * angle always in range [-PI, PI]
     * @param angleRad
     * @private
     */ minimizeAngleRad(angleRad) {
        angleRad = angleRad % (2 * Math.PI);
        if (angleRad > Math.PI) angleRad -= 2 * Math.PI;
        else if (angleRad < -Math.PI) angleRad += 2 * Math.PI;
        return angleRad;
    }
    resetInputProcessor() {
        this.currentInputProcessor = null;
        this.updateCursor(this.globalMode);
        this.reqFrame(true);
    }
    reqFrame(doRedrawCanvas) {
        this.animationFrameRequested = true;
        if (doRedrawCanvas) this.lastRenderedState = -1;
    }
    updateLoop() {
        window.requestAnimationFrame(()=>this.updateLoop()
        );
        const newState = _klHistory.klHistory.getState();
        const doRender = this.lastRenderedState < newState;
        //handle variable framerate
        const nowTime = performance.now();
        const elapsedFrames = (nowTime - this.lastRenderTime) * 60 / 1000; //how many frames elapsed since last render if fps were 60fps
        this.lastRenderTime = nowTime;
        if (this.animationFrameRequested || doRender) {
            this.animationFrameRequested = false;
            this.checkChange(elapsedFrames);
        }
    }
    checkChange(elapsedFrames) {
        const newState = _klHistory.klHistory.getState();
        const doRender = this.lastRenderedState < newState || this.highResTransformObj.scale !== this.targetTransformObj.scale || this.highResTransformObj.x !== this.targetTransformObj.x || this.highResTransformObj.y !== this.targetTransformObj.y;
        //update transform
        if (!this.doAnimateTranslate && (this.highResTransformObj.scale === this.targetTransformObj.scale || Math.abs(this.highResTransformObj.scale - this.targetTransformObj.scale) < 0.008 * this.targetTransformObj.scale)) {
            this.highResTransformObj.scale = this.targetTransformObj.scale;
            this.highResTransformObj.x = this.targetTransformObj.x;
            this.highResTransformObj.y = this.targetTransformObj.y;
            this.highResTransformObj.angle = this.targetTransformObj.angle;
            if (this.transformIsDirty) {
                this.transformIsDirty = false;
                this.bgVisible = this.testBgVisible();
            }
            this.svgOverlay.updateCursor({
                radius: this.brushRadius * this.highResTransformObj.scale
            });
        } else if ((this.highResTransformObj.x === this.targetTransformObj.x || Math.abs(this.highResTransformObj.x - this.targetTransformObj.x) < 0.5) && (this.highResTransformObj.y === this.targetTransformObj.y || Math.abs(this.highResTransformObj.y - this.targetTransformObj.y) < 0.5) && (this.highResTransformObj.scale === this.targetTransformObj.scale || Math.abs(this.highResTransformObj.scale - this.targetTransformObj.scale) < 0.008 * this.targetTransformObj.scale)) {
            this.highResTransformObj.scale = this.targetTransformObj.scale;
            this.highResTransformObj.x = this.targetTransformObj.x;
            this.highResTransformObj.y = this.targetTransformObj.y;
            this.highResTransformObj.angle = this.targetTransformObj.angle;
            this.doAnimateTranslate = false;
            if (this.transformIsDirty) {
                this.transformIsDirty = false;
                this.bgVisible = this.testBgVisible();
            }
            this.svgOverlay.updateCursor({
                radius: this.brushRadius * this.highResTransformObj.scale
            });
        } else {
            this.reqFrame(); //probably needs another frame
            const blendFactor = Math.min(1, ANIMATION_SPEED * elapsedFrames);
            this.mixTransformObj(this.highResTransformObj, this.targetTransformObj, blendFactor);
            this.bgVisible = true; // spare yourself the calculation
            this.svgOverlay.updateCursor({
                radius: this.brushRadius * this.highResTransformObj.scale
            });
        }
        if (this.pointer && this.currentMode == TMode.Draw && !this.usesCssCursor) this.svgOverlay.updateCursor({
            x: this.pointer.x,
            y: this.pointer.y,
            isVisible: true
        });
        else this.svgOverlay.updateCursor({
            isVisible: false
        });
        if (doRender) {
            //console.log('scale', this.renderedTransform.scale, 'x', this.renderedTransform.x, 'y', this.renderedTransform.y);
            this.lastRenderedState = newState;
            const start = performance.now();
            this.render();
            this.renderTime = _bb.BB.mix(this.renderTime, performance.now() - start, 0.05);
        }
    }
    // ---- public ----
    constructor(p){
        const _this = this;
        this.rootEl = _bb.BB.el({
            css: {
                position: 'absolute',
                left: '0',
                right: '0',
                top: '0',
                bottom: '0',
                cursor: 'crosshair',
                userSelect: 'none',
                colorScheme: 'only light'
            }
        });
        this.klCanvas = p.klCanvas;
        this.onViewChange = p.onViewChange;
        this.renderTargetCanvas = _bb.BB.canvas(p.width, p.height);
        this.renderTargetCtx = this.renderTargetCanvas.getContext('2d');
        this.renderWidth = p.width;
        this.renderHeight = p.height;
        this.compositeCanvas = _bb.BB.canvas(1, 1); // for drawing klcanvas layer composite
        this.compositeCtx = this.compositeCanvas.getContext('2d');
        this.doResizeCanvas = false;
        this.oldTransformObj = null;
        this.targetTransformObj = {
            x: 0,
            y: 0,
            scale: 1,
            angle: 0
        };
        this.highResTransformObj = {
            x: 0,
            y: 0,
            scale: 1,
            angle: 0
        };
        this.renderedTransformObj = {
            x: null,
            y: null,
            scale: null,
            angle: null
        };
        this.cursorPos = {
            x: 0,
            y: 0
        };
        this.usesCssCursor = false;
        this.bgVisible = true;
        this.transformIsDirty = true;
        this.doAnimateTranslate = true;
        this.svgOverlay = new _workspaceSvgOverlay.WorkspaceSvgOverlay({
            width: p.width,
            height: p.height
        });
        _bb.BB.css(this.renderTargetCanvas, {
            userSelect: 'none',
            pointerEvents: 'none'
        });
        _bb.BB.createCheckerDataUrl(8, (url)=>{
            this.renderTargetCanvas.style.background = "url(" + url + ")";
        });
        this.rootEl.appendChild(this.renderTargetCanvas);
        this.rootEl.appendChild(this.svgOverlay.getElement());
        _bb.BB.addEventListener(this.rootEl, 'touchend', (e)=>{
            e.preventDefault();
            return false;
        });
        _bb.BB.addEventListener(this.rootEl, 'contextmenu', (e)=>{
            e.preventDefault();
            return false;
        });
        _bb.BB.addEventListener(this.rootEl, 'dragstart', (e)=>{
            e.preventDefault();
            return false;
        });
        this.emptyCanvas = _bb.BB.canvas(1, 1);
        {
            const ctx = this.emptyCanvas.getContext('2d');
            ctx.fillRect(0, 0, 1, 1);
        }
        this.keyListener = new _bb.BB.KeyListener({
            onDown: (keyStr, event, comboStr, isRepeat)=>{
                if (keyStr === 'alt') event.preventDefault();
                if (isRepeat) return;
                if (this.currentInputProcessor) this.currentInputProcessor.onKeyDown(keyStr, event, comboStr, isRepeat);
                else {
                    if ([
                        TMode.Draw,
                        TMode.Pick,
                        TMode.Fill,
                        TMode.Text,
                        TMode.Shape
                    ].includes(this.globalMode) && comboStr === 'space') {
                        this.currentInputProcessor = this.inputProcessorObj.spaceHand;
                        this.currentInputProcessor.onKeyDown(keyStr, event, comboStr, isRepeat);
                        return;
                    }
                    if ([
                        TMode.Draw,
                        TMode.Hand,
                        TMode.Fill,
                        TMode.Text,
                        TMode.Shape
                    ].includes(this.globalMode) && comboStr === 'alt') {
                        this.currentInputProcessor = this.inputProcessorObj.altPicker;
                        this.currentInputProcessor.onKeyDown(keyStr, event, comboStr, isRepeat);
                        return;
                    }
                    if ([
                        'r',
                        'shift+r'
                    ].includes(comboStr)) {
                        this.currentInputProcessor = this.inputProcessorObj.rotate;
                        this.currentInputProcessor.onKeyDown(keyStr, event, comboStr, isRepeat);
                        return;
                    }
                    if ('z' === comboStr) {
                        this.currentInputProcessor = this.inputProcessorObj.zoom;
                        this.currentInputProcessor.onKeyDown(keyStr, event, comboStr, isRepeat);
                        return;
                    }
                }
            },
            onUp: (keyStr, event, oldComboStr)=>{
                if (this.currentInputProcessor) this.currentInputProcessor.onKeyUp(keyStr, event, oldComboStr);
            }
        });
        this.updateChangeListener();
        this.currentMode = TMode.Draw;
        this.globalMode = TMode.Draw;
        this.renderTime = 0;
        this.lastDrawEvent = null;
        this.linetoolProcessor = new _bb.BB.EventChain.LinetoolProcessor({
            onDraw: (event)=>{
                const getMatrix = ()=>{
                    const art = this.getRenderedTransform();
                    let matrix = _bb.BB.Matrix.getIdentity();
                    matrix = _bb.BB.Matrix.multiplyMatrices(matrix, _bb.BB.Matrix.createScaleMatrix(1 / art.scale));
                    matrix = _bb.BB.Matrix.multiplyMatrices(matrix, _bb.BB.Matrix.createRotationMatrix(-art.angle));
                    matrix = _bb.BB.Matrix.multiplyMatrices(matrix, _bb.BB.Matrix.createTranslationMatrix(-art.x, -art.y));
                    return matrix;
                };
                if (event.type === 'line' && !this.lastDrawEvent) {
                    const matrix = getMatrix();
                    let coords = [
                        event.x1,
                        event.y1,
                        0,
                        1
                    ];
                    coords = _bb.BB.Matrix.multiplyMatrixAndPoint(matrix, coords);
                    this.lastDrawEvent = {
                        x: coords[0],
                        y: coords[1],
                        pressure: event.pressure1
                    };
                    return;
                }
                if ('x' in event || 'x0' in event) {
                    const matrix = getMatrix();
                    if ('x' in event) {
                        let coords = [
                            event.x,
                            event.y,
                            0,
                            1
                        ];
                        coords = _bb.BB.Matrix.multiplyMatrixAndPoint(matrix, coords);
                        event.x = coords[0];
                        event.y = coords[1];
                    }
                    if ('x0' in event) {
                        event.x0 = this.lastDrawEvent.x;
                        event.y0 = this.lastDrawEvent.y;
                        event.pressure0 = this.lastDrawEvent.pressure;
                        let coords = [
                            event.x1,
                            event.y1,
                            0,
                            1
                        ];
                        coords = _bb.BB.Matrix.multiplyMatrixAndPoint(matrix, coords);
                        event.x1 = coords[0];
                        event.y1 = coords[1];
                        this.lastDrawEvent = {
                            x: event.x1,
                            y: event.y1,
                            pressure: event.pressure1
                        };
                    }
                }
                if ([
                    'down',
                    'move'
                ].includes(event.type)) this.lastDrawEvent = event;
                p.onDraw(event);
            }
        });
        this.pointer = null;
        this.isDrawing = false;
        this.inputProcessorObj = {
            draw: {
                onPointer: (val)=>{
                    this.reqFrame();
                    this.updateCursor(TMode.Draw);
                    const comboStr = this.keyListener.getComboStr();
                    const event = {
                        scale: this.highResTransformObj.scale
                    };
                    event.shiftIsPressed = comboStr === 'shift';
                    event.pressure = val.pressure;
                    event.isCoalesced = !!val.isCoalesced;
                    if (val.type === 'pointerdown') {
                        this.isDrawing = true;
                        event.type = 'down';
                    } else if (val.button) event.type = 'move';
                    else if (val.type === 'pointerup') {
                        this.isDrawing = false;
                        event.type = 'up';
                        this.linetoolProcessor.process(event);
                        this.resetInputProcessor();
                        return;
                    } else return;
                    event.x = val.relX;
                    event.y = val.relY;
                    this.linetoolProcessor.process(event);
                },
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{
                },
                onKeyUp: (keyStr, event, oldComboStr)=>{
                }
            },
            fill: {
                onPointer: (event)=>{
                    this.reqFrame();
                    this.updateCursor(TMode.Fill);
                    if (event.type === 'pointerdown') {
                        const coord = this.workspaceToCanvasCoord({
                            x: event.relX,
                            y: event.relY
                        });
                        p.onFill(Math.floor(coord.x), Math.floor(coord.y));
                    } else if (event.type === 'pointerup') {
                        this.resetInputProcessor();
                        return;
                    }
                },
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{
                },
                onKeyUp: (keyStr, event, oldComboStr)=>{
                }
            },
            text: {
                onPointer: (event)=>{
                    this.reqFrame();
                    this.updateCursor(TMode.Text);
                    if (event.type === 'pointerdown') {
                        const coord = this.workspaceToCanvasCoord({
                            x: event.relX,
                            y: event.relY
                        });
                        p.onText(Math.floor(coord.x), Math.floor(coord.y), this.renderedTransformObj.angle);
                    } else if (event.type === 'pointerup') {
                        this.resetInputProcessor();
                        return;
                    }
                },
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{
                },
                onKeyUp: (keyStr, event, oldComboStr)=>{
                }
            },
            shape: {
                onPointer: (event)=>{
                    this.reqFrame();
                    this.updateCursor(TMode.Shape);
                    const coord = this.workspaceToCanvasCoord({
                        x: event.relX,
                        y: event.relY
                    });
                    if (event.type === 'pointerdown') {
                        this.isDrawing = true;
                        p.onShape('down', coord.x, coord.y, this.renderedTransformObj.angle);
                    } else if (event.type === 'pointermove') p.onShape('move', coord.x, coord.y, this.renderedTransformObj.angle);
                    else if (event.type === 'pointerup') {
                        this.isDrawing = false;
                        p.onShape('up', coord.x, coord.y, this.renderedTransformObj.angle);
                        this.resetInputProcessor();
                    }
                },
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{
                },
                onKeyUp: (keyStr, event, oldComboStr)=>{
                }
            },
            hand: {
                onPointer: (event)=>{
                    this.updateCursor(TMode.Hand);
                    if ([
                        'left',
                        'middle'
                    ].includes(event.button)) {
                        this.updateCursor(TMode.HandGrabbing);
                        this.targetTransformObj.x += event.dX;
                        this.targetTransformObj.y += event.dY;
                        this.highResTransformObj = JSON.parse(JSON.stringify(this.targetTransformObj));
                        this.doAnimateTranslate = false;
                        this.transformIsDirty = true;
                        this.reqFrame(true);
                    } else if (event.type === 'pointerup') this.resetInputProcessor();
                },
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{
                },
                onKeyUp: (keyStr, event, oldComboStr)=>{
                }
            },
            spaceHand: {
                onPointer: (event)=>{
                    this.updateCursor(TMode.Hand);
                    if ([
                        'left',
                        'middle'
                    ].includes(event.button)) {
                        this.updateCursor(TMode.HandGrabbing);
                        this.targetTransformObj.x += event.dX;
                        this.targetTransformObj.y += event.dY;
                        this.highResTransformObj = JSON.parse(JSON.stringify(this.targetTransformObj));
                        this.doAnimateTranslate = false;
                        this.transformIsDirty = true;
                        this.reqFrame(true);
                    }
                },
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{
                    if (comboStr !== 'space') this.resetInputProcessor();
                    else this.updateCursor(TMode.Hand);
                },
                onKeyUp: (keyStr, event, oldComboStr)=>{
                    this.resetInputProcessor();
                }
            },
            zoom: {
                onPointer: (event)=>{
                    this.updateCursor(TMode.Zoom);
                    if (event.button === 'left' && !event.isCoalesced && event.dX != 0) {
                        const offsetX = event.pageX - event.relX;
                        const offsetY = event.pageY - event.relY;
                        this.internalZoomByStep(event.dX / 175, event.downPageX - offsetX, event.downPageY - offsetY);
                        this.highResTransformObj = JSON.parse(JSON.stringify(this.targetTransformObj));
                        this.lastRenderedState = -1;
                        this.reqFrame();
                        this.onViewChange({
                            changed: [
                                'scale'
                            ],
                            angle: this.targetTransformObj.angle,
                            scale: this.targetTransformObj.scale
                        });
                    }
                },
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{
                    if (comboStr !== 'z') this.resetInputProcessor();
                    else this.updateCursor(TMode.Zoom);
                },
                onKeyUp: (keyStr, event, oldComboStr)=>{
                    this.resetInputProcessor();
                }
            },
            picker: {
                onPointer: (event)=>{
                    this.updateCursor(TMode.Pick);
                    if ([
                        'left',
                        'right'
                    ].includes(event.button) && !event.isCoalesced || event.type === 'pointerup') {
                        const coord = this.workspaceToCanvasCoord({
                            x: event.relX,
                            y: event.relY
                        });
                        const pickedColor = this.klCanvas.getColorAt(coord.x, coord.y);
                        p.onPick(pickedColor, event.type === 'pointerup');
                        this.svgOverlay.updateColorPreview({
                            x: event.relX,
                            y: event.relY,
                            color: pickedColor,
                            isVisible: event.type !== 'pointerup'
                        });
                        if (event.type === 'pointerup') this.resetInputProcessor();
                    }
                },
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{
                },
                onKeyUp: (keyStr, event, oldComboStr)=>{
                }
            },
            altPicker: {
                onPointer: (event)=>{
                    this.updateCursor(TMode.Pick);
                    if ([
                        'left',
                        'right'
                    ].includes(event.button) && !event.isCoalesced || event.type === 'pointerup') {
                        const coord = this.workspaceToCanvasCoord({
                            x: event.relX,
                            y: event.relY
                        });
                        const pickedColor = this.klCanvas.getColorAt(coord.x, coord.y);
                        p.onPick(pickedColor, event.type === 'pointerup');
                        this.svgOverlay.updateColorPreview({
                            x: event.relX,
                            y: event.relY,
                            color: pickedColor,
                            isVisible: event.type !== 'pointerup'
                        });
                    }
                },
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{
                    if (comboStr !== 'alt') this.resetInputProcessor();
                    else this.updateCursor(TMode.Pick);
                },
                onKeyUp: (keyStr, event, oldComboStr)=>{
                    this.resetInputProcessor();
                }
            },
            rotate: {
                onPointer: (event)=>{
                    this.updateCursor(event.button === 'left' ? TMode.Rotating : TMode.Rotate);
                    if (event.type === 'pointerdown' && event.button === 'left') this.oldTransformObj = JSON.parse(JSON.stringify(this.targetTransformObj));
                    else if (event.button === 'left' && !event.isCoalesced && this.oldTransformObj) {
                        const offsetX = event.pageX - event.relX;
                        const offsetY = event.pageY - event.relY;
                        //rotation done around center
                        const centerObj = {
                            x: this.renderWidth / 2,
                            y: this.renderHeight / 2
                        };
                        const startAngleRad = _bb.BB.Vec2.angle(centerObj, {
                            x: event.downPageX - offsetX,
                            y: event.downPageY - offsetY
                        });
                        const angleRad = _bb.BB.Vec2.angle(centerObj, {
                            x: event.pageX - offsetX,
                            y: event.pageY - offsetY
                        });
                        let dAngleRad = angleRad - startAngleRad;
                        //apply angle
                        this.targetTransformObj = JSON.parse(JSON.stringify(this.oldTransformObj));
                        this.targetTransformObj.angle += dAngleRad;
                        if (this.keyListener.isPressed('shift')) {
                            this.targetTransformObj.angle = Math.round(this.targetTransformObj.angle / Math.PI * 8) * Math.PI / 8; //snap the angle to 45/2 degs
                            dAngleRad = this.targetTransformObj.angle - this.oldTransformObj.angle;
                        }
                        this.targetTransformObj.angle = this.minimizeAngleRad(this.targetTransformObj.angle);
                        //rotate transform.xy
                        let matrix = _bb.BB.Matrix.getIdentity();
                        matrix = _bb.BB.Matrix.multiplyMatrices(matrix, _bb.BB.Matrix.createTranslationMatrix(centerObj.x, centerObj.y));
                        //matrix = BB.Matrix.multiplyMatrices(matrix, BB.Matrix.createScaleMatrix(effectiveFactor));
                        matrix = _bb.BB.Matrix.multiplyMatrices(matrix, _bb.BB.Matrix.createRotationMatrix(dAngleRad));
                        matrix = _bb.BB.Matrix.multiplyMatrices(matrix, _bb.BB.Matrix.createTranslationMatrix(-centerObj.x, -centerObj.y));
                        //matrix = multiplyMatrices(matrix, createTranslationMatrix(val.x - val.startX, val.y - val.startY));
                        let origin = [
                            this.targetTransformObj.x,
                            this.targetTransformObj.y,
                            0,
                            1
                        ];
                        origin = _bb.BB.Matrix.multiplyMatrixAndPoint(matrix, origin);
                        this.targetTransformObj.x = origin[0];
                        this.targetTransformObj.y = origin[1];
                        this.highResTransformObj = JSON.parse(JSON.stringify(this.targetTransformObj));
                        this.transformIsDirty = true;
                        this.lastRenderedState = -1;
                        this.reqFrame();
                        this.onViewChange({
                            changed: [
                                'angle'
                            ],
                            scale: this.targetTransformObj.scale,
                            angle: this.targetTransformObj.angle
                        });
                    }
                },
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{
                    if ([
                        'r',
                        'r+shift',
                        'shift+r',
                        'r+left',
                        'r+right',
                        'r+left+right',
                        'r+right+left',
                        'r+up'
                    ].includes(comboStr)) this.updateCursor(TMode.Rotate);
                    else this.resetInputProcessor();
                },
                onKeyUp: (keyStr, event, oldComboStr)=>{
                    const comboStr = this.keyListener.getComboStr();
                    if ([
                        'r',
                        'r+shift',
                        'shift+r',
                        'r+left',
                        'r+right',
                        'r+left+right',
                        'r+right+left',
                        'r+up'
                    ].includes(comboStr)) this.updateCursor(TMode.Rotate);
                    else this.resetInputProcessor();
                }
            }
        };
        this.currentInputProcessor = null;
        this.angleIsExtraSticky = false;
        this.pinchZoomer = new _bb.BB.EventChain.PinchZoomer({
            onPinch: (event)=>{
                if (event.type === 'move') {
                    if (!this.oldTransformObj) {
                        this.oldTransformObj = JSON.parse(JSON.stringify(this.targetTransformObj));
                        this.angleIsExtraSticky = this.targetTransformObj.angle % (Math.PI / 2) === 0;
                    }
                    this.targetTransformObj = JSON.parse(JSON.stringify(this.oldTransformObj));
                    event.scale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, this.targetTransformObj.scale * event.scale)) / this.targetTransformObj.scale;
                    this.targetTransformObj.scale *= event.scale;
                    this.targetTransformObj.angle += event.angleRad;
                    this.targetTransformObj.angle = this.minimizeAngleRad(this.snapAngleRad(this.targetTransformObj.angle, 90, this.angleIsExtraSticky ? 12 : 4));
                    if (this.targetTransformObj.angle % (Math.PI / 2) !== 0) this.angleIsExtraSticky = false;
                    //targetTransformObj.angle = minimizeAngleRad(snapAngleRad(targetTransformObj.angle, 90, 7));
                    event.angleRad = this.targetTransformObj.angle - this.oldTransformObj.angle;
                    //calc translation
                    {
                        let matrix = _bb.BB.Matrix.getIdentity();
                        matrix = _bb.BB.Matrix.multiplyMatrices(matrix, _bb.BB.Matrix.createTranslationMatrix(event.relX, event.relY));
                        matrix = _bb.BB.Matrix.multiplyMatrices(matrix, _bb.BB.Matrix.createScaleMatrix(event.scale));
                        matrix = _bb.BB.Matrix.multiplyMatrices(matrix, _bb.BB.Matrix.createRotationMatrix(event.angleRad));
                        matrix = _bb.BB.Matrix.multiplyMatrices(matrix, _bb.BB.Matrix.createTranslationMatrix(-event.relX, -event.relY));
                        matrix = _bb.BB.Matrix.multiplyMatrices(matrix, _bb.BB.Matrix.createTranslationMatrix(event.relX - event.downRelX, event.relY - event.downRelY));
                        let origin = [
                            this.targetTransformObj.x,
                            this.targetTransformObj.y,
                            0,
                            1
                        ];
                        origin = _bb.BB.Matrix.multiplyMatrixAndPoint(matrix, origin);
                        this.targetTransformObj.x = origin[0];
                        this.targetTransformObj.y = origin[1];
                    }
                    this.highResTransformObj = _bb.BB.copyObj(this.targetTransformObj);
                    //if (event.scale !== 1) {
                    this.onViewChange({
                        changed: [
                            'scale',
                            'angle'
                        ],
                        scale: this.targetTransformObj.scale,
                        angle: this.targetTransformObj.angle
                    });
                    //}
                    this.reqFrame();
                    this.transformIsDirty = true;
                    this.lastRenderedState = -1;
                } else if (event.type === 'end') this.oldTransformObj = null;
            }
        });
        const onDoubleTap = ()=>{
            let oldTransform = JSON.parse(JSON.stringify(this.targetTransformObj));
            _this.fitView();
            //_this.resetView(true);
            this.lastRenderedState = -1;
            this.reqFrame();
            if (oldTransform.scale !== this.targetTransformObj.scale || oldTransform.angle !== this.targetTransformObj.angle) this.onViewChange({
                changed: [
                    'scale',
                    'angle'
                ],
                angle: this.targetTransformObj.angle,
                scale: this.targetTransformObj.scale
            });
        };
        this.mainDoubleTapper = new _bb.BB.EventChain.DoubleTapper({
            onDoubleTap
        });
        this.middleDoubleTapper = new _bb.BB.EventChain.DoubleTapper({
            onDoubleTap
        });
        this.middleDoubleTapper.setAllowedButtonArr([
            'middle'
        ]);
        this.twoFingerTap = new _bb.BB.EventChain.NFingerTapper({
            fingers: 2,
            onTap: ()=>{
                p.onUndo();
            }
        });
        this.threeFingerTap = new _bb.BB.EventChain.NFingerTapper({
            fingers: 3,
            onTap: ()=>{
                p.onRedo();
            }
        });
        this.pointerEventChain = new _bb.BB.EventChain.EventChain({
            chainArr: [
                this.twoFingerTap,
                this.threeFingerTap,
                this.mainDoubleTapper,
                this.middleDoubleTapper,
                this.pinchZoomer,
                new _bb.BB.EventChain.OnePointerLimiter(),
                new _bb.BB.EventChain.CoalescedExploder()
            ]
        });
        this.pointerEventChain.setChainOut((event)=>{
            this.cursorPos.x = event.relX;
            this.cursorPos.y = event.relY;
            if (event.type === 'pointerup' && event.pointerType === 'touch') {
                this.pointer = null;
                this.lastRenderedState = -1;
                this.reqFrame();
            } else {
                if (!this.pointer) this.pointer = {
                    x: 0,
                    y: 0
                };
                this.pointer.x = event.relX;
                this.pointer.y = event.relY;
            }
            if (this.currentInputProcessor) this.currentInputProcessor.onPointer(event);
            else {
                let comboStr = this.keyListener.getComboStr();
                if (this.globalMode === TMode.Draw) {
                    if ([
                        '',
                        'shift',
                        'ctrl'
                    ].includes(comboStr) && event.type === 'pointerdown' && event.button === 'left') {
                        this.currentInputProcessor = this.inputProcessorObj.draw;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ''
                    ].includes(comboStr) && event.type === 'pointerdown' && event.button === 'right') {
                        this.currentInputProcessor = this.inputProcessorObj.picker;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ''
                    ].includes(comboStr) && event.type === 'pointerdown' && event.button === 'middle') {
                        this.currentInputProcessor = this.inputProcessorObj.hand;
                        this.currentInputProcessor.onPointer(event);
                    } else {
                        this.updateCursor(TMode.Draw);
                        this.reqFrame();
                    }
                } else if (this.globalMode === TMode.Hand) {
                    if (event.type === 'pointerdown' && [
                        'left',
                        'middle'
                    ].includes(event.button)) {
                        this.currentInputProcessor = this.inputProcessorObj.hand;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ''
                    ].includes(comboStr) && event.type === 'pointerdown' && event.button === 'right') {
                        this.currentInputProcessor = this.inputProcessorObj.picker;
                        this.currentInputProcessor.onPointer(event);
                    } else this.updateCursor(TMode.Hand);
                } else if (this.globalMode === TMode.Pick) {
                    if (event.type === 'pointerdown' && [
                        'left',
                        'right'
                    ].includes(event.button)) {
                        this.currentInputProcessor = this.inputProcessorObj.picker;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ''
                    ].includes(comboStr) && event.type === 'pointerdown' && event.button === 'middle') {
                        this.currentInputProcessor = this.inputProcessorObj.hand;
                        this.currentInputProcessor.onPointer(event);
                    } else this.updateCursor(TMode.Pick);
                } else if (this.globalMode === TMode.Fill) {
                    if (event.type === 'pointerdown' && event.button === 'left') {
                        this.currentInputProcessor = this.inputProcessorObj.fill;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ''
                    ].includes(comboStr) && event.type === 'pointerdown' && event.button === 'right') {
                        this.currentInputProcessor = this.inputProcessorObj.picker;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ''
                    ].includes(comboStr) && event.type === 'pointerdown' && event.button === 'middle') {
                        this.currentInputProcessor = this.inputProcessorObj.hand;
                        this.currentInputProcessor.onPointer(event);
                    } else {
                        this.updateCursor(TMode.Fill);
                        this.reqFrame();
                    }
                } else if (this.globalMode === TMode.Text) {
                    if (event.type === 'pointerdown' && event.button === 'left') {
                        this.currentInputProcessor = this.inputProcessorObj.text;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ''
                    ].includes(comboStr) && event.type === 'pointerdown' && event.button === 'right') {
                        this.currentInputProcessor = this.inputProcessorObj.picker;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ''
                    ].includes(comboStr) && event.type === 'pointerdown' && event.button === 'middle') {
                        this.currentInputProcessor = this.inputProcessorObj.hand;
                        this.currentInputProcessor.onPointer(event);
                    } else {
                        this.updateCursor(TMode.Text);
                        this.reqFrame();
                    }
                } else if (this.globalMode === TMode.Shape) {
                    if ([
                        '',
                        'shift',
                        'ctrl'
                    ].includes(comboStr) && event.type === 'pointerdown' && event.button === 'left') {
                        this.currentInputProcessor = this.inputProcessorObj.shape;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ''
                    ].includes(comboStr) && event.type === 'pointerdown' && event.button === 'right') {
                        this.currentInputProcessor = this.inputProcessorObj.picker;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ''
                    ].includes(comboStr) && event.type === 'pointerdown' && event.button === 'middle') {
                        this.currentInputProcessor = this.inputProcessorObj.hand;
                        this.currentInputProcessor.onPointer(event);
                    } else {
                        this.updateCursor(TMode.Shape);
                        this.reqFrame();
                    }
                }
            }
        });
        //prevent ctrl scroll -> zooming page
        _bb.BB.addEventListener(this.rootEl, 'wheel', (event)=>{
            event.preventDefault();
        });
        setTimeout(()=>{
            this.pointerListener = new _bb.BB.PointerListener({
                target: this.rootEl,
                fixScribble: true,
                onPointer: (e)=>{
                    if (e.type === 'pointerdown' && e.button === 'middle') try {
                        e.eventPreventDefault();
                    } catch (e1) {
                    }
                    /*if (e.type === 'pointermove') {
                        BB.throwOut(JSON.stringify(e));
                    }*/ this.pointerEventChain.chainIn(e);
                },
                onWheel: (wheelEvent)=>{
                    if (this.isDrawing) return;
                    this.reqFrame();
                    let didZoom = this.internalZoomByStep(-wheelEvent.deltaY / (this.keyListener.isPressed('shift') ? 8 : 2), wheelEvent.relX, wheelEvent.relY);
                    if (didZoom) this.onViewChange({
                        changed: [
                            'scale'
                        ],
                        angle: this.targetTransformObj.angle,
                        scale: this.targetTransformObj.scale
                    });
                    //updateCursor(TMode.Draw, true);
                    this.lastRenderedState = -1;
                },
                onEnterLeave: (isOver)=>{
                    if (!isOver) {
                        if (!this.isDrawing) {
                            this.pointer = null;
                            this.lastRenderedState = -1;
                        }
                    }
                },
                maxPointers: 4
            });
        }, 1);
        this.brushRadius = 1;
        this.animationFrameRequested = false;
        //setup rendering
        this.lastRenderedState = -2;
        this.lastRenderTime = performance.now();
        window.requestAnimationFrame(()=>this.updateLoop()
        );
        this.resetView();
    }
    getElement() {
        return this.rootEl;
    }
    setCanvas(klC) {
        this.klCanvas = klC;
        this.lastDrawEvent = null;
        this.resetView();
        this.updateChangeListener();
        this.lastRenderedState = -1;
        this.reqFrame();
    }
    /**
     * set size of workspace area in pixels
     * @param width
     * @param height
     */ setSize(width, height) {
        const oldWidth = this.renderWidth;
        const oldHeight = this.renderHeight;
        if (width === oldWidth && height === oldHeight) return;
        this.doResizeCanvas = true;
        this.renderWidth = width;
        this.renderHeight = height;
        this.svgOverlay.setSize(width, height);
        this.targetTransformObj.x += (width - oldWidth) / 2;
        this.targetTransformObj.y += (height - oldHeight) / 2;
        this.highResTransformObj.x = this.targetTransformObj.x;
        this.highResTransformObj.y = this.targetTransformObj.y;
        this.bgVisible = this.testBgVisible();
        this.lastRenderedState = -1;
        this.reqFrame();
    }
    setMode(modeStr) {
        //only sets the base mode
        if (modeStr === 'draw') {
            this.globalMode = TMode.Draw;
            this.mainDoubleTapper.setAllowedPointerTypeArr([
                'touch'
            ]);
        }
        if (modeStr === 'fill') {
            this.globalMode = TMode.Fill;
            this.mainDoubleTapper.setAllowedPointerTypeArr([
                'touch'
            ]);
        }
        if (modeStr === 'text') {
            this.globalMode = TMode.Text;
            this.mainDoubleTapper.setAllowedPointerTypeArr([
                'touch'
            ]);
        }
        if (modeStr === 'shape') {
            this.globalMode = TMode.Shape;
            this.mainDoubleTapper.setAllowedPointerTypeArr([
                'touch'
            ]);
        }
        if (modeStr === 'hand') {
            this.globalMode = TMode.Hand;
            this.mainDoubleTapper.setAllowedPointerTypeArr([
                'mouse',
                'pen',
                'touch'
            ]);
        }
        if (modeStr === 'pick') {
            this.globalMode = TMode.Pick;
            this.mainDoubleTapper.setAllowedPointerTypeArr([
                'touch'
            ]);
        }
    }
    setEnabled(b) {
    // todo
    }
    setCursorSize(diameter) {
        this.brushRadius = diameter / 2;
        this.svgOverlay.updateCursor({
            radius: this.brushRadius * this.highResTransformObj.scale
        });
        if (this.pointer === null) {
            clearTimeout(this.hideBrushCursorTimeout);
            this.svgOverlay.updateCursor({
                x: this.renderWidth / 2,
                y: this.renderHeight / 2,
                isVisible: true
            });
            // @ts-ignore
            this.hideBrushCursorTimeout = setTimeout(()=>{
                if (this.pointer !== null) return;
                this.svgOverlay.updateCursor({
                    isVisible: false
                });
            }, 500);
        }
    }
    zoomByStep(stepNum) {
        if (!this.internalZoomByStep(stepNum, this.renderWidth / 2, this.renderHeight / 2)) return;
        this.lastRenderedState = -1;
        this.reqFrame();
        this.onViewChange({
            changed: [
                'scale'
            ],
            angle: this.targetTransformObj.angle,
            scale: this.targetTransformObj.scale
        });
    }
    resetView(doAnimate) {
        this.targetTransformObj.scale = 1;
        this.targetTransformObj.angle = 0;
        this.targetTransformObj.x = (this.renderWidth - this.klCanvas.getWidth()) / 2;
        this.targetTransformObj.y = (this.renderHeight - this.klCanvas.getHeight()) / 2;
        if (!doAnimate) this.highResTransformObj = JSON.parse(JSON.stringify(this.targetTransformObj));
        else {
            this.doAnimateTranslate = true;
            this.transformIsDirty = true;
        }
        this.bgVisible = this.testBgVisible();
        this.reqFrame();
        if (doAnimate) this.onViewChange({
            changed: [
                'scale',
                'angle'
            ],
            scale: this.targetTransformObj.scale,
            angle: this.targetTransformObj.angle
        });
    }
    fitView() {
        //fit into view. center. keep angle. margin of 10px
        //calc width and height of bounds
        const canvasPointsArr = [
            [
                0,
                0
            ],
            [
                this.klCanvas.getWidth(),
                0
            ],
            [
                this.klCanvas.getWidth(),
                this.klCanvas.getHeight()
            ],
            [
                0,
                this.klCanvas.getHeight()
            ],
            [
                this.klCanvas.getWidth() / 2,
                this.klCanvas.getHeight() / 2
            ]
        ];
        //setup transformation matrix
        let matrix = _bb.BB.Matrix.getIdentity();
        matrix = _bb.BB.Matrix.multiplyMatrices(matrix, _bb.BB.Matrix.createRotationMatrix(this.targetTransformObj.angle));
        //rotate points
        for(let i = 0; i < canvasPointsArr.length; i++){
            let coords = [
                canvasPointsArr[i][0],
                canvasPointsArr[i][1],
                0,
                1
            ];
            coords = _bb.BB.Matrix.multiplyMatrixAndPoint(matrix, coords);
            canvasPointsArr[i][0] = coords[0];
            canvasPointsArr[i][1] = coords[1];
        }
        const boundsObj = {
            x0: null,
            y0: null,
            x1: null,
            y1: null
        };
        for(let i1 = 0; i1 < canvasPointsArr.length; i1++){
            if (boundsObj.x0 === null || canvasPointsArr[i1][0] < boundsObj.x0) boundsObj.x0 = canvasPointsArr[i1][0];
            if (boundsObj.y0 === null || canvasPointsArr[i1][1] < boundsObj.y0) boundsObj.y0 = canvasPointsArr[i1][1];
            if (boundsObj.x1 === null || canvasPointsArr[i1][0] > boundsObj.x1) boundsObj.x1 = canvasPointsArr[i1][0];
            if (boundsObj.y1 === null || canvasPointsArr[i1][1] > boundsObj.y1) boundsObj.y1 = canvasPointsArr[i1][1];
        }
        const boundsWidth = boundsObj.x1 - boundsObj.x0;
        const boundsHeight = boundsObj.y1 - boundsObj.y0;
        //fit bounds
        const padding = 40;
        const fit = _bb.BB.fitInto(boundsWidth, boundsHeight, this.renderWidth - padding, this.renderHeight - padding, 1);
        //determine scale
        const factor = fit.width / boundsWidth;
        //center
        this.targetTransformObj.x = this.renderWidth / 2 - (canvasPointsArr[4][0] - canvasPointsArr[0][0]) * factor;
        this.targetTransformObj.y = this.renderHeight / 2 - (canvasPointsArr[4][1] - canvasPointsArr[0][1]) * factor;
        this.targetTransformObj.scale = factor;
        this.doAnimateTranslate = true;
        this.transformIsDirty = true;
        this.reqFrame();
        this.onViewChange({
            changed: [
                'scale',
                'angle'
            ],
            scale: this.targetTransformObj.scale,
            angle: this.targetTransformObj.angle
        });
    }
    setAngle(angleDeg, isRelative) {
        //rotation done around center
        const centerObj = {
            x: this.renderWidth / 2,
            y: this.renderHeight / 2
        };
        const oldAngleRad = this.targetTransformObj.angle;
        const angleRad = angleDeg / 180 * Math.PI;
        if (isRelative) this.targetTransformObj.angle += angleRad;
        else this.targetTransformObj.angle = angleRad;
        this.targetTransformObj.angle = this.minimizeAngleRad(this.snapAngleRad(this.targetTransformObj.angle, 90, 4));
        //rotate transform.xy
        let matrix = _bb.BB.Matrix.getIdentity();
        matrix = _bb.BB.Matrix.multiplyMatrices(matrix, _bb.BB.Matrix.createTranslationMatrix(centerObj.x, centerObj.y));
        matrix = _bb.BB.Matrix.multiplyMatrices(matrix, _bb.BB.Matrix.createRotationMatrix(this.targetTransformObj.angle - oldAngleRad));
        matrix = _bb.BB.Matrix.multiplyMatrices(matrix, _bb.BB.Matrix.createTranslationMatrix(-centerObj.x, -centerObj.y));
        let origin = [
            this.targetTransformObj.x,
            this.targetTransformObj.y,
            0,
            1
        ];
        origin = _bb.BB.Matrix.multiplyMatrixAndPoint(matrix, origin);
        this.targetTransformObj.x = origin[0];
        this.targetTransformObj.y = origin[1];
        this.highResTransformObj = JSON.parse(JSON.stringify(this.targetTransformObj));
        this.transformIsDirty = true;
        this.reqFrame(true);
    }
    /**
     * translate canvas by viewport pixels
     * @param tx
     * @param ty
     */ translateView(tx, ty) {
        const scale = 40;
        this.targetTransformObj.x += tx * scale;
        this.targetTransformObj.y += ty * scale;
        this.transformIsDirty = true;
        this.doAnimateTranslate = true;
        this.reqFrame(true);
    }
    getIsDrawing() {
        return this.isDrawing;
    }
    getScale() {
        return this.targetTransformObj.scale;
    }
    getAngleDeg() {
        return this.targetTransformObj.angle * 180 / Math.PI;
    }
    getMaxScale() {
        return MAX_SCALE;
    }
    getMinScale() {
        return MIN_SCALE;
    }
    requestFrame() {
        this.lastRenderedState = -1;
        this.reqFrame();
    }
    setLastDrawEvent(x, y, pressure) {
        if (x === null) {
            this.lastDrawEvent = null;
            return;
        }
        if (!this.lastDrawEvent) this.lastDrawEvent = {
            x: 0,
            y: 0,
            pressure: 0
        };
        this.lastDrawEvent.x = x;
        this.lastDrawEvent.y = y;
        this.lastDrawEvent.pressure = pressure;
    }
}

},{"../../bb/bb":"e3nbn","./workspace-svg-overlay":"1QQyo","../history/kl-history":"ai9zE","url:~/src/app/img/ui/cursor-picker.png":"5zTYL","url:~/src/app/img/ui/cursor-zoom-ew.png":"adysO","url:~/src/app/img/ui/cursor-fill.png":"d6V0p","url:~/src/app/img/ui/cursor-text.png":"8joYP","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5zTYL":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "cursor-picker.00f00099.png" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"adysO":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "cursor-zoom-ew.b7dab878.png" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"d6V0p":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "cursor-fill.c1473e5c.png" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"8joYP":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "cursor-text.272d0bdb.png" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"9a0UP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * preview of image with layers. can do mix modes and opacity.
 * creates a canvas.
 *
 * p = {
 *     width: 123,
 *     height: 123,
 *     layers: [// can be changed after the fact
 *         {
 *             image: Canvas,
 *             opacity: 1,
 *             mixModeStr: 'source-over'
 *         }
 *     ]
 * }
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "KlCanvasPreview", ()=>KlCanvasPreview
);
var _bb = require("../../bb/bb");
function KlCanvasPreview(p) {
    const scale = p.width / p.layers[0].image.width;
    const width = scale > 1 ? p.layers[0].image.width : p.width;
    const height = scale > 1 ? p.layers[0].image.height : p.height;
    let canvas = _bb.BB.canvas(width, height);
    canvas.style.backgroundImage = 'url(' + _bb.BB.createCheckerDataUrl(8) + ')';
    let ctx = canvas.getContext('2d');
    _bb.BB.css(canvas, {
        width: '100%',
        height: '100%',
        imageRendering: scale > 1 ? 'pixelated' : null
    });
    function render() {
        ctx.save();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for(let i = 0; i < p.layers.length; i++){
            ctx.globalAlpha = p.layers[i].opacity;
            ctx.globalCompositeOperation = p.layers[i].mixModeStr;
            if (canvas.width > p.layers[i].image.width) ctx.imageSmoothingEnabled = false;
            ctx.drawImage(p.layers[i].image, 0, 0, canvas.width, canvas.height);
        }
        ctx.restore();
    }
    setTimeout(render, 0);
    // --- interface ---
    this.getElement = function() {
        return canvas;
    };
    this.render = function() {
        render();
    };
}

},{"../../bb/bb":"e3nbn","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gt2Ud":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Free Transform UI
 * rotate, scale, translate
 *
 * - if rotation is multiple of 90° it will snap to pixels, to be more useful for pixel art
 * - when rotation goes from non-multiple of 90° to a multiple, it will snap position and width height to pixels
 * - transform.x, transform.y can sit between pixels (by 0.5) if width or height is odd number.
 *      - this is what complicates things
 * - if transform region small, corner grips move out of the way
 *
 * iX iY, iP.x, iP.y - i indicates image space
 * tX tY, tP.x, tP.y - t indicates transform space
 *
 * Not sure if can be used for navigable canvas. (especially if canvas rotates view)
 * Probably can't be extended for distort. Needs a different approach.
 *
 * --- DOM structure ---
 * rootEl {
 * 	transEl [
 * 		boundsEl
 * 		edges[]
 * 		corners[] - round grips in the corner of transform region
 * 		angleGrip
 * 	]
 * }
 *
 */ parcelHelpers.export(exports, "FreeTransform", ()=>FreeTransform
);
var _bb = require("../../../bb/bb");
// @ts-ignore
var _cursorRotatePng = require("url:~/src/app/img/ui/cursor-rotate.png");
var _cursorRotatePngDefault = parcelHelpers.interopDefault(_cursorRotatePng);
/**
 * snap entire transform to pixel grid. changes transform
 *
 * for x y:
 * If a dimension has an even size, it be an integer.
 * If it's uneven, it's sits exactly half way between two pixels.
 *
 * @param transform
 */ function snapToPixel(transform) {
    if (Math.abs(transform.angleDeg) % 90 !== 0) return;
    transform.width = Math.round(transform.width);
    transform.height = Math.round(transform.height);
    // 0° is original orientation.
    // At 90° and 270° width and height become swapped due to different orientation.
    const whSwapped = Math.abs(transform.angleDeg - 90) % 180 === 0;
    transform.x = (whSwapped ? transform.height : transform.width) % 2 === 0 ? Math.round(transform.x) : Math.round(transform.x - 0.5) + 0.5;
    transform.y = (whSwapped ? transform.width : transform.height) % 2 === 0 ? Math.round(transform.y) : Math.round(transform.y - 0.5) + 0.5;
}
function copyTransform(transform) {
    return {
        x: transform.x,
        y: transform.y,
        width: transform.width,
        height: transform.height,
        angleDeg: transform.angleDeg
    };
}
/**
 * image space to transform space
 * - origin of transform space is at center of transform bounds.
 * - same scale as image space. -> one unit is x: 1/width, y: 1/height
 * - up is where transform points up
 * - x goes right
 * - y goes down
 * @param x
 * @param y
 * @param transform
 */ function toTransformSpace(x, y, transform) {
    let px, py;
    px = x - transform.x;
    py = y - transform.y;
    const rot = _bb.BB.rotateAround({
        x: 0,
        y: 0
    }, {
        x: px,
        y: py
    }, -transform.angleDeg);
    px = rot.x;
    py = rot.y;
    return {
        x: px,
        y: py
    };
}
/**
 * transform space to image space
 * @param x
 * @param y
 * @param transform
 */ function toImageSpace(x, y, transform) {
    const rot = _bb.BB.rotateAround({
        x: 0,
        y: 0
    }, {
        x: x,
        y: y
    }, transform.angleDeg);
    return {
        x: rot.x + transform.x,
        y: rot.y + transform.y
    };
}
class FreeTransform {
    updateScaled() {
        this.scaled.x = this.transform.x * this.scale;
        this.scaled.y = this.transform.y * this.scale;
        this.scaled.width = this.transform.width * this.scale;
        this.scaled.height = this.transform.height * this.scale;
        this.scaled.corners = this.corners.map((item)=>{
            return {
                x: item.x * this.scale,
                y: item.y * this.scale
            };
        });
    }
    /**
     * Returns snapped point, if ix, iy snaps. If no snapping, returns point unchanged.
     * both in image space
     *
     * @param iX - image space
     * @param iY - image space
     * @private
     */ snapCorner(iX, iY) {
        if (!this.snappingEnabled) return {
            x: iX,
            y: iY
        };
        let dist;
        const snap = {
            x: null,
            y: null,
            dist: {
                x: null,
                y: null
            }
        };
        for(let e = 0; e < this.snapX.length; e++){
            dist = Math.abs(iX - this.snapX[e]);
            if (dist < this.minSnapDist / this.scale) {
                if (snap.x === null || dist < snap.dist.x) {
                    snap.x = this.snapX[e];
                    snap.dist.x = dist;
                }
            }
        }
        for(let e1 = 0; e1 < this.snapY.length; e1++){
            dist = Math.abs(iY - this.snapY[e1]);
            if (dist < this.minSnapDist / this.scale) {
                if (snap.y === null || dist < snap.dist.y) {
                    snap.y = this.snapY[e1];
                    snap.dist.y = dist;
                }
            }
        }
        if (snap.x === null && snap.y === null) return {
            x: iX,
            y: iY
        };
        return {
            x: snap.x === null ? iX : snap.x,
            y: snap.y === null ? iY : snap.y
        };
    }
    /**
     * If constrained return nearest corner pos that fits aspect ratio
     *
     * @param cornerIndex
     * @param iX
     * @param iY
     * @private
     */ constrainCorner(cornerIndex, iX, iY) {
        if (!this.isConstrained) return {
            x: iX,
            y: iY
        };
        const flip = this.transform.width * this.transform.height < 0 ? -1 : 1;
        return _bb.BB.projectPointOnLine({
            x: this.transform.x,
            y: this.transform.y
        }, toImageSpace(this.ratio, flip * ([
            0,
            2
        ].includes(cornerIndex) ? 1 : -1), this.transform), {
            x: iX,
            y: iY
        });
    }
    /**
     * Update corners according to width height.
     * Not their DOM.
     */ updateCornerPositions() {
        this.corners[0].x = -this.transform.width / 2; // top left
        this.corners[0].y = -this.transform.height / 2;
        this.corners[1].x = this.transform.width / 2; // top right
        this.corners[1].y = -this.transform.height / 2;
        this.corners[2].x = this.transform.width / 2; // bottom right
        this.corners[2].y = this.transform.height / 2;
        this.corners[3].x = -this.transform.width / 2; // bottom left
        this.corners[3].y = this.transform.height / 2;
    }
    /**
     * If constrained and dragging an edge, restore aspect ratio
     * Updates corner positions.
     *
     * @param widthChanged
     * @param heightChanged
     * @private
     */ restoreRatio(widthChanged, heightChanged) {
        if (!this.isConstrained) return;
        const angle90 = Math.abs(this.transform.angleDeg) % 90 === 0;
        const whSwapped = Math.abs(this.transform.angleDeg - 90) % 180 === 0;
        if (heightChanged && !widthChanged) {
            const newHeight = Math.abs(this.corners[3].y - this.corners[0].y);
            let newWidth = this.ratio * newHeight;
            if (angle90) newWidth = (whSwapped ? this.transform.y % 1 : this.transform.x % 1) === 0 ? _bb.BB.roundEven(newWidth) : _bb.BB.roundUneven(newWidth);
            if (this.corners[1].x - this.corners[0].x < 0) newWidth *= -1;
            this.corners[0].x = -newWidth / 2;
            this.corners[3].x = -newWidth / 2;
            this.corners[1].x = newWidth / 2;
            this.corners[2].x = newWidth / 2;
        }
        if (!heightChanged && widthChanged) {
            const newWidth = Math.abs(this.corners[0].x - this.corners[1].x);
            let newHeight = newWidth / this.ratio;
            if (angle90) newHeight = (whSwapped ? this.transform.x % 1 : this.transform.y % 1) === 0 ? _bb.BB.roundEven(newHeight) : _bb.BB.roundUneven(newHeight);
            if (this.corners[3].y - this.corners[0].y < 0) newHeight *= -1;
            this.corners[0].y = -newHeight / 2;
            this.corners[1].y = -newHeight / 2;
            this.corners[2].y = newHeight / 2;
            this.corners[3].y = newHeight / 2;
        }
    }
    /**
     * update transform based on corners
     * @private
     */ updateTransformViaCorners() {
        // calc transform center in image space
        const rot = _bb.BB.rotateAround({
            x: 0,
            y: 0
        }, {
            x: (this.corners[0].x + this.corners[1].x) / 2,
            y: (this.corners[0].y + this.corners[3].y) / 2
        }, this.transform.angleDeg);
        this.transform.x = rot.x + this.transform.x;
        this.transform.y = rot.y + this.transform.y;
        // update size
        this.transform.width = this.corners[1].x - this.corners[0].x;
        this.transform.height = this.corners[3].y - this.corners[0].y;
        // new center means corners changed their position
        this.updateCornerPositions();
        this.updateDOM();
    }
    /**
     * updates DOM according to transform
     * @param skipCallback
     */ updateDOM(skipCallback) {
        this.updateScaled();
        _bb.BB.css(this.transEl, {
            left: this.scaled.x + "px",
            top: this.scaled.y + "px",
            transformOrigin: "0 0",
            transform: "rotate(" + this.transform.angleDeg + "deg)"
        });
        _bb.BB.css(this.boundsEl, {
            width: Math.abs(this.scaled.width) + "px",
            height: Math.abs(this.scaled.height) + "px",
            left: Math.min(this.scaled.corners[0].x, this.scaled.corners[1].x) + "px",
            top: Math.min(this.scaled.corners[0].y, this.scaled.corners[3].y) + "px"
        });
        this.corners[0].updateDOM();
        this.corners[1].updateDOM();
        this.corners[2].updateDOM();
        this.corners[3].updateDOM();
        this.edges[0].updateDOM();
        this.edges[1].updateDOM();
        this.edges[2].updateDOM();
        this.edges[3].updateDOM();
        this.angleGrip.x = 0;
        this.angleGrip.y = -Math.abs(this.transform.height * this.scale) / 2 - 20;
        this.angleGrip.updateDOM();
        if (!skipCallback) {
            if (this.callback) this.callback(copyTransform(this.transform));
        }
    }
    // --- public ---
    constructor(params){
        this.scaled = {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            corners: [
                {
                    x: 0,
                    y: 0
                }
            ]
        };
        this.minSnapDist // minimal snapping distance in px screenspace
         = 7;
        this.cornerCursors = [
            'nw',
            'n',
            'ne',
            'e',
            'se',
            's',
            'sw',
            'w'
        ];
        this.gripSize = 14;
        this.edgeSize = 10;
        this.corners = [];
        this.edges = [];
        this.transform = {
            x: params.x,
            y: params.y,
            width: params.width,
            height: params.height,
            angleDeg: params.angleDeg
        };
        this.isConstrained = !!params.isConstrained;
        this.snapX = params.snapX;
        this.snapY = params.snapY;
        this.callback = params.callback;
        this.scale = params.scale;
        this.snappingEnabled = true;
        this.ratio = this.transform.width / this.transform.height;
        this.rootEl = _bb.BB.el({
            className: 'kl-free-transform',
            css: {
                userSelect: 'none'
            }
        });
        this.transEl = _bb.BB.el({
            parent: this.rootEl,
            css: {
                position: 'absolute'
            }
        });
        this.boundsEl = _bb.BB.el({
            css: {
                position: 'absolute',
                cursor: 'move',
                boxShadow: 'rgba(255, 255, 255, 0.5) 0 0 0 1px inset, rgba(0, 0, 0, 0.5) 0 0 0 1px'
            }
        });
        const pointerRemainder = {
            x: 0,
            y: 0
        };
        function resetRemainder() {
            pointerRemainder.x = 0;
            pointerRemainder.y = 0;
        }
        this.keyListener = new _bb.BB.KeyListener({
        });
        let boundsStartP = {
            x: 0,
            y: 0
        };
        this.boundsPointerListener = new _bb.BB.PointerListener({
            target: this.boundsEl,
            fixScribble: true,
            onPointer: (event)=>{
                event.eventPreventDefault();
                if (event.type === 'pointerdown') boundsStartP = {
                    x: this.transform.x,
                    y: this.transform.y
                };
                if (event.type === 'pointermove' && event.button === 'left') {
                    this.transform.x = boundsStartP.x + (event.pageX - event.downPageX) / this.scale;
                    this.transform.y = boundsStartP.y + (event.pageY - event.downPageY) / this.scale;
                    let dist;
                    let snap = {
                    };
                    if (this.snappingEnabled) {
                        let i;
                        for(i = 0; i < this.snapX.length; i++){
                            dist = Math.abs(this.transform.x - this.snapX[i]);
                            if (dist < this.minSnapDist / this.scale) {
                                if (!snap.x || dist < snap.distX) {
                                    snap.x = this.snapX[i];
                                    snap.distX = dist;
                                }
                            }
                        }
                        for(i = 0; i < this.snapY.length; i++){
                            dist = Math.abs(this.transform.y - this.snapY[i]);
                            if (dist < this.minSnapDist / this.scale) {
                                if (!snap.y || dist < snap.distY) {
                                    snap.y = this.snapY[i];
                                    snap.distY = dist;
                                }
                            }
                        }
                        let iP;
                        for(i = 0; i < 4; i++){
                            iP = toImageSpace(this.corners[i].x, this.corners[i].y, this.transform);
                            let j;
                            for(j = 0; j < this.snapX.length; j++){
                                dist = Math.abs(iP.x - this.snapX[j]);
                                if (dist < this.minSnapDist / this.scale) {
                                    if (!snap.x || dist < snap.distX) {
                                        snap.x = this.snapX[j] - (iP.x - this.transform.x);
                                        snap.distX = dist;
                                    }
                                }
                            }
                            for(j = 0; j < this.snapY.length; j++){
                                dist = Math.abs(iP.y - this.snapY[j]);
                                if (dist < this.minSnapDist / this.scale) {
                                    if (!snap.y || dist < snap.distY) {
                                        snap.y = this.snapY[j] - (iP.y - this.transform.y);
                                        snap.distY = dist;
                                    }
                                }
                            }
                        }
                    }
                    if (this.keyListener.getComboStr() === 'shift') {
                        let projected = _bb.BB.projectPointOnLine({
                            x: 0,
                            y: boundsStartP.y
                        }, {
                            x: 10,
                            y: boundsStartP.y
                        }, {
                            x: this.transform.x,
                            y: this.transform.y
                        });
                        let dist = _bb.BB.dist(projected.x, projected.y, this.transform.x, this.transform.y);
                        snap = {
                        };
                        snap.x = projected.x;
                        snap.y = projected.y;
                        snap.distX = dist;
                        snap.distY = dist;
                        projected = _bb.BB.projectPointOnLine({
                            x: boundsStartP.x,
                            y: 0
                        }, {
                            x: boundsStartP.x,
                            y: 10
                        }, {
                            x: this.transform.x,
                            y: this.transform.y
                        });
                        dist = _bb.BB.dist(projected.x, projected.y, this.transform.x, this.transform.y);
                        if (dist < snap.distX) {
                            snap.x = projected.x;
                            snap.y = projected.y;
                            snap.distX = dist;
                            snap.distY = dist;
                        }
                        projected = _bb.BB.projectPointOnLine({
                            x: boundsStartP.x,
                            y: boundsStartP.y
                        }, {
                            x: boundsStartP.x + 1,
                            y: boundsStartP.y + 1
                        }, {
                            x: this.transform.x,
                            y: this.transform.y
                        });
                        dist = _bb.BB.dist(projected.x, projected.y, this.transform.x, this.transform.y);
                        if (dist < snap.distX) {
                            snap.x = projected.x;
                            snap.y = projected.y;
                            snap.distX = dist;
                            snap.distY = dist;
                        }
                        projected = _bb.BB.projectPointOnLine({
                            x: boundsStartP.x,
                            y: boundsStartP.y
                        }, {
                            x: boundsStartP.x + 1,
                            y: boundsStartP.y - 1
                        }, {
                            x: this.transform.x,
                            y: this.transform.y
                        });
                        dist = _bb.BB.dist(projected.x, projected.y, this.transform.x, this.transform.y);
                        if (dist < snap.distX) {
                            snap.x = projected.x;
                            snap.y = projected.y;
                            snap.distX = dist;
                            snap.distY = dist;
                        }
                    }
                    if (snap.x != undefined) this.transform.x = snap.x;
                    if (snap.y != undefined) this.transform.y = snap.y;
                    // snap to pixels
                    if (Math.abs(this.transform.angleDeg) % 90 === 0) {
                        snapToPixel(this.transform);
                        this.updateCornerPositions();
                    }
                    this.updateDOM();
                }
            }
        });
        for(let i2 = 0; i2 < 4; i2++)((i)=>{
            const g = this.corners[i] = {
                i: i,
                el: _bb.BB.el({
                    css: {
                        width: this.gripSize + 'px',
                        height: this.gripSize + 'px',
                        background: '#fff',
                        /*background: [
                                '#ff0000',
                                '#00ff00',
                                '#0000ff',
                                '#ff00ff',
                            ][i],*/ borderRadius: this.gripSize + 'px',
                        position: 'absolute',
                        boxShadow: 'inset 0 0 0 2px #000'
                    }
                }),
                x: 0,
                y: 0,
                virtualPos: {
                    x: 0,
                    y: 0
                },
                updateDOM: null,
                pointerListener: null
            };
            g.updateDOM = ()=>{
                // grip position
                // if gets small, offset grips, so easier to handle
                const offsetArr = [
                    [
                        -1,
                        -1
                    ],
                    [
                        1,
                        -1
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        -1,
                        1
                    ]
                ].map((item)=>{
                    item[0] *= this.transform.width > 0 ? 1 : -1;
                    item[1] *= this.transform.height > 0 ? 1 : -1;
                    return item;
                });
                const tinyOffset = Math.abs(this.scaled.width) < 20 || Math.abs(this.scaled.height) < 20 ? 10 : 0;
                _bb.BB.css(g.el, {
                    left: this.scaled.corners[g.i].x - this.gripSize / 2 + offsetArr[i][0] * tinyOffset + 'px',
                    top: this.scaled.corners[g.i].y - this.gripSize / 2 + offsetArr[i][1] * tinyOffset + 'px'
                });
                // cursor
                let angle = _bb.BB.pointsToAngleDeg({
                    x: this.transform.x,
                    y: this.transform.y
                }, toImageSpace(g.x, g.y, this.transform)) + 135; // offset so nw is 0
                while(angle < 0)angle += 360;
                let index = Math.round(angle / 45) % this.cornerCursors.length;
                _bb.BB.css(g.el, {
                    cursor: this.cornerCursors[index] + '-resize'
                });
            };
            g.pointerListener = new _bb.BB.PointerListener({
                target: this.corners[i].el,
                fixScribble: true,
                onPointer: (event)=>{
                    event.eventPreventDefault();
                    if (event.type === 'pointerdown' && event.button === 'left') this.corners[i].virtualPos = toImageSpace(this.corners[i].x, this.corners[i].y, this.transform);
                    else if (event.type === 'pointermove' && event.button === 'left') {
                        this.corners[i].virtualPos.x += event.dX / this.scale;
                        this.corners[i].virtualPos.y += event.dY / this.scale;
                        let iP = {
                            x: this.corners[i].virtualPos.x,
                            y: this.corners[i].virtualPos.y
                        };
                        iP = this.constrainCorner(i, iP.x, iP.y);
                        if (!this.isConstrained) iP = this.snapCorner(iP.x, iP.y);
                        if (Math.abs(this.transform.angleDeg) % 90 === 0) {
                            iP.x = Math.round(iP.x);
                            iP.y = Math.round(iP.y);
                        }
                        const tP = toTransformSpace(iP.x, iP.y, this.transform);
                        const dX = tP.x - this.corners[i].x;
                        const dY = tP.y - this.corners[i].y;
                        this.corners[i].x = tP.x;
                        this.corners[i].y = tP.y;
                        let indexes = [];
                        if (i === 0) indexes = [
                            3,
                            1,
                            2
                        ];
                        else if (i === 1) indexes = [
                            2,
                            0,
                            3
                        ];
                        else if (i === 2) indexes = [
                            1,
                            3,
                            0
                        ];
                        else if (i === 3) indexes = [
                            0,
                            2,
                            1
                        ];
                        this.corners[indexes[0]].x = this.corners[i].x;
                        this.corners[indexes[1]].y = this.corners[i].y;
                        if (this.keyListener.isPressed('shift')) {
                            this.corners[indexes[2]].x -= dX;
                            this.corners[indexes[2]].y -= dY;
                            this.corners[indexes[1]].x = this.corners[indexes[2]].x;
                            this.corners[indexes[0]].y = this.corners[indexes[2]].y;
                        }
                        this.updateTransformViaCorners();
                    }
                }
            });
        })(i2);
        this.updateCornerPositions();
        this.updateScaled();
        let isInverted;
        for(let i1 = 0; i1 < 4; i1++)((i)=>{
            this.edges[i] = {
                el: _bb.BB.el({
                    css: {
                        width: this.edgeSize + 'px',
                        height: this.edgeSize + 'px',
                        /*background: [
                                '#ff000044',
                                '#00ff0044',
                                '#0000ff44',
                                '#ff00ff44',
                            ][i],*/ position: 'absolute'
                    }
                }),
                updateDOM: null,
                pointerListener: null
            };
            const g = this.edges[i];
            g.updateDOM = ()=>{
                if (i === 0) _bb.BB.css(g.el, {
                    left: Math.min(this.scaled.corners[0].x, this.scaled.corners[1].x) + 'px',
                    top: Math.min(this.scaled.corners[0].y, this.scaled.corners[3].y) - this.edgeSize + 'px',
                    width: Math.abs(this.scaled.width) + 'px',
                    height: this.edgeSize + 'px'
                });
                else if (i === 1) _bb.BB.css(g.el, {
                    left: Math.max(this.scaled.corners[0].x, this.scaled.corners[1].x) + 'px',
                    top: Math.min(this.scaled.corners[1].y, this.scaled.corners[2].y) + 'px',
                    width: this.edgeSize + 'px',
                    height: Math.abs(this.scaled.height) + 'px'
                });
                else if (i === 2) _bb.BB.css(g.el, {
                    left: Math.min(this.scaled.corners[3].x, this.scaled.corners[2].x) + 'px',
                    top: Math.max(this.scaled.corners[0].y, this.scaled.corners[3].y) + 'px',
                    width: Math.abs(this.scaled.width) + 'px',
                    height: this.edgeSize + 'px'
                });
                else if (i === 3) _bb.BB.css(g.el, {
                    left: Math.min(this.scaled.corners[0].x, this.scaled.corners[1].x) - this.edgeSize + 'px',
                    top: Math.min(this.scaled.corners[0].y, this.scaled.corners[3].y) + 'px',
                    width: this.edgeSize + 'px',
                    height: Math.abs(this.scaled.height) + 'px'
                });
                let angleOffset = Math.round(this.transform.angleDeg / 45);
                while(angleOffset < 0)angleOffset += 8;
                angleOffset = (i * 2 + 1 + angleOffset) % this.cornerCursors.length;
                g.el.style.cursor = this.cornerCursors[angleOffset] + '-resize';
            };
            const isVertical = [
                0,
                2
            ].includes(i);
            g.pointerListener = new _bb.BB.PointerListener({
                target: this.edges[i].el,
                fixScribble: true,
                onPointer: (event)=>{
                    event.eventPreventDefault();
                    if (event.type === 'pointerdown' && event.button === 'left') {
                        if (isVertical) isInverted = this.corners[0].y >= this.corners[3].y;
                        else isInverted = this.corners[0].x >= this.corners[1].x;
                        resetRemainder();
                    }
                    if (event.type === 'pointermove' && event.button === 'left') {
                        const tfD = _bb.BB.rotateAround({
                            x: 0,
                            y: 0
                        }, {
                            x: event.dX / this.scale,
                            y: event.dY / this.scale
                        }, -this.transform.angleDeg);
                        let ti = {
                            dX: tfD.x,
                            dY: tfD.y
                        };
                        if (Math.abs(this.transform.angleDeg) % 90 === 0) ti = _bb.BB.intDxy(pointerRemainder, tfD.x, tfD.y);
                        let indexes = [];
                        if (i === 0) indexes = [
                            2,
                            3,
                            0,
                            1
                        ];
                        else if (i === 1) indexes = [
                            0,
                            3,
                            1,
                            2
                        ];
                        else if (i === 2) indexes = [
                            0,
                            1,
                            2,
                            3
                        ];
                        else if (i === 3) indexes = [
                            1,
                            2,
                            0,
                            3
                        ];
                        let dimension = isVertical ? 'y' : 'x';
                        let d = isVertical ? ti.dY : ti.dX;
                        if (isInverted) {
                            this.corners[indexes[0]][dimension] += d;
                            this.corners[indexes[1]][dimension] += d;
                        } else {
                            this.corners[indexes[2]][dimension] += d;
                            this.corners[indexes[3]][dimension] += d;
                        }
                        if (this.keyListener.isPressed('shift')) {
                            if (isInverted) {
                                this.corners[indexes[2]][dimension] -= d;
                                this.corners[indexes[3]][dimension] -= d;
                            } else {
                                this.corners[indexes[0]][dimension] -= d;
                                this.corners[indexes[1]][dimension] -= d;
                            }
                        }
                        if (isVertical) this.restoreRatio(false, true);
                        else this.restoreRatio(true, false);
                        this.updateTransformViaCorners();
                    }
                }
            });
        })(i1);
        this.angleGrip = {
            el: _bb.BB.el({
                css: {
                    cursor: 'url(' + _cursorRotatePngDefault.default + ') 10 10, move',
                    width: this.gripSize + 'px',
                    height: this.gripSize + 'px',
                    background: '#0ff',
                    borderRadius: this.gripSize + 'px',
                    position: 'absolute',
                    boxShadow: 'inset 0 0 0 2px #000'
                }
            }),
            x: 0,
            y: 0,
            snap: false,
            updateDOM: ()=>{
                _bb.BB.css(this.angleGrip.el, {
                    left: this.angleGrip.x - this.gripSize / 2 + 'px',
                    top: this.angleGrip.y - this.gripSize / 2 + 'px'
                });
            }
        };
        _bb.BB.el({
            parent: this.angleGrip.el,
            css: {
                width: '2px',
                height: '13px',
                left: this.gripSize / 2 - 1 + 'px',
                top: this.gripSize + 'px',
                background: '#0ff',
                position: 'absolute'
            }
        });
        this.anglePointerListener = new _bb.BB.PointerListener({
            target: this.angleGrip.el,
            fixScribble: true,
            onPointer: (event)=>{
                event.eventPreventDefault();
                if (event.type === 'pointermove' && event.button === 'left') {
                    const bounds = this.rootEl.getBoundingClientRect();
                    const offset = {
                        x: bounds.left - this.rootEl.scrollLeft,
                        y: bounds.top - this.rootEl.scrollTop
                    };
                    const iP = {
                        x: (event.clientX - offset.x) / this.scale,
                        y: (event.clientY - offset.y) / this.scale
                    };
                    const a = _bb.BB.pointsToAngleDeg({
                        x: this.transform.x,
                        y: this.transform.y
                    }, iP) + 90;
                    this.transform.angleDeg = a;
                    const snapDeg = Math.round(a / 360 * 8) * 45;
                    if (this.keyListener.getComboStr() === 'shift') this.transform.angleDeg = snapDeg;
                    else if (this.snappingEnabled && Math.abs(snapDeg - a) < 8) this.transform.angleDeg = snapDeg;
                    this.updateDOM();
                }
                if (event.type === 'pointerup') {
                    if (Math.abs(this.transform.angleDeg) % 90 === 0) {
                        snapToPixel(this.transform);
                        this.updateCornerPositions();
                        this.updateDOM();
                    }
                }
            }
        });
        snapToPixel(this.transform);
        this.updateDOM(true);
        _bb.BB.append(this.transEl, [
            this.boundsEl,
            this.edges[0].el,
            this.edges[1].el,
            this.edges[2].el,
            this.edges[3].el,
            this.corners[0].el,
            this.corners[1].el,
            this.corners[2].el,
            this.corners[3].el,
            this.angleGrip.el, 
        ]);
    }
    getTransform() {
        return copyTransform(this.transform);
    }
    setConstrained(b) {
        this.isConstrained = !!b;
        if (b && this.transform.width !== 0 && this.transform.height !== 0) this.ratio = Math.abs(this.transform.width / this.transform.height);
    }
    setSnapping(s) {
        this.snappingEnabled = !!s;
    }
    setPos(p) {
        this.transform.x = p.x;
        this.transform.y = p.y;
        this.updateDOM(true);
    }
    move(dX, dY) {
        this.transform.x += dX;
        this.transform.y += dY;
        this.updateDOM(false);
    }
    setSize(w, h) {
        this.transform.width = w;
        this.transform.height = h;
        if (Math.abs(this.transform.angleDeg) % 90 === 0) snapToPixel(this.transform);
        this.updateCornerPositions();
        this.updateDOM(false);
    }
    setAngleDeg(a) {
        this.transform.angleDeg = a;
        if (Math.abs(this.transform.angleDeg) % 90 === 0) {
            snapToPixel(this.transform);
            this.updateCornerPositions();
        }
        this.updateDOM(true);
    }
    getElement() {
        return this.rootEl;
    }
    getRatio() {
        return this.ratio;
    }
    destroy() {
        this.keyListener.destroy();
        this.boundsPointerListener.destroy();
        this.corners[0].pointerListener.destroy();
        this.corners[1].pointerListener.destroy();
        this.corners[2].pointerListener.destroy();
        this.corners[3].pointerListener.destroy();
        this.edges[0].pointerListener.destroy();
        this.edges[1].pointerListener.destroy();
        this.edges[2].pointerListener.destroy();
        this.edges[3].pointerListener.destroy();
        this.anglePointerListener.destroy();
    }
}

},{"../../../bb/bb":"e3nbn","url:~/src/app/img/ui/cursor-rotate.png":"herqb","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"herqb":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "cursor-rotate.ac884c87.png" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"fVB2B":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * a basic canvas where you can transform one layer(move around, rotate, scale)
 *
 * @param params
 * @returns {HTMLDivElement}
 * @constructor
 */ parcelHelpers.export(exports, "FreeTransformCanvas", ()=>FreeTransformCanvas
);
var _bb = require("../../../bb/bb");
var _canvasPreview = require("../../canvas-ui/canvas-preview");
var _freeTransform = require("./free-transform");
function FreeTransformCanvas(params) {
    /*
    div
        innerWrapper
            klCanvasPreview
            transform.div
    */ let previewFit = _bb.BB.fitInto(params.imageWidth, params.imageHeight, params.elementWidth - 20, params.elementHeight - 60, 1);
    let scale = previewFit.width / params.imageWidth;
    let div = _bb.BB.el({
        css: {
            width: params.elementWidth + "px",
            height: params.elementHeight + "px",
            backgroundColor: "#9e9e9e",
            boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
            overflow: "hidden",
            userSelect: "none",
            position: "relative",
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            colorScheme: 'only light'
        }
    });
    div.oncontextmenu = function() {
        return false;
    };
    let innerWrapper = _bb.BB.el({
        css: {
            position: 'relative',
            boxShadow: '0 0 5px rgba(0,0,0,0.5)',
            width: previewFit.width + 'px',
            height: previewFit.height + 'px'
        }
    });
    div.appendChild(innerWrapper);
    let previewLayerArr = params.layers.map((item)=>{
        return {
            image: item.image,
            mixModeStr: item.mixModeStr,
            opacity: item.opacity
        };
    });
    previewLayerArr[previewLayerArr.length - 1].image = _bb.BB.canvas(scale > 1 ? params.imageWidth : previewFit.width, scale > 1 ? params.imageHeight : previewFit.height);
    let klCanvasPreview = new _canvasPreview.KlCanvasPreview({
        width: previewFit.width,
        height: previewFit.height,
        layers: previewLayerArr
    });
    innerWrapper.appendChild(klCanvasPreview.getElement());
    let freeTransform;
    let initTransform;
    function updatePreview() {
        if (!freeTransform) return;
        let transform = freeTransform.getTransform();
        if (scale < 1) {
            transform.x *= scale;
            transform.y *= scale;
            transform.width *= scale;
            transform.height *= scale;
        }
        let destCanvas = previewLayerArr[params.transformIndex].image;
        let ctx = destCanvas.getContext('2d');
        ctx.save();
        ctx.clearRect(0, 0, destCanvas.width, destCanvas.height);
        _bb.BB.drawTransformedImageWithBounds(ctx, params.layers[params.transformIndex].image, transform, null, _bb.BB.testShouldPixelate(transform, transform.width / initTransform.width, transform.height / initTransform.height));
        ctx.restore();
        klCanvasPreview.render();
    }
    {
        let transformSize = {
            width: params.layers[params.transformIndex].image.width * scale,
            height: params.layers[params.transformIndex].image.height * scale
        };
        if (transformSize.width > previewFit.width || transformSize.height > previewFit.height) transformSize = _bb.BB.fitInto(params.layers[params.transformIndex].image.width, params.layers[params.transformIndex].image.height, previewFit.width, previewFit.height, 1);
        initTransform = {
            x: params.imageWidth / 2,
            y: params.imageHeight / 2,
            width: params.layers[params.transformIndex].image.width,
            height: params.layers[params.transformIndex].image.height
        };
        freeTransform = new _freeTransform.FreeTransform({
            x: initTransform.x,
            y: initTransform.y,
            width: initTransform.width,
            height: initTransform.height,
            angleDeg: 0,
            isConstrained: true,
            snapX: [
                0,
                params.imageWidth
            ],
            snapY: [
                0,
                params.imageHeight
            ],
            scale: scale,
            callback: (transform)=>{
                updatePreview();
            }
        });
    }
    _bb.BB.css(freeTransform.getElement(), {
        position: 'absolute',
        left: '0',
        top: '0'
    });
    innerWrapper.appendChild(freeTransform.getElement());
    setTimeout(updatePreview, 0);
    // --- interface ---
    this.move = function(dX, dY) {
        freeTransform.move(dX, dY);
    };
    this.reset = function() {
        let w = params.layers[params.transformIndex].image.width;
        let h = params.layers[params.transformIndex].image.height;
        freeTransform.setSize(w, h);
        freeTransform.setPos({
            x: w / 2,
            y: h / 2
        });
        freeTransform.setAngleDeg(0);
        updatePreview();
    };
    this.setTransformFit = function() {
        let fit = _bb.BB.fitInto(params.layers[params.transformIndex].image.width, params.layers[params.transformIndex].image.height, params.imageWidth, params.imageHeight, 1);
        freeTransform.setSize(fit.width, fit.height);
        freeTransform.setPos({
            x: fit.width / 2,
            y: fit.height / 2
        });
        freeTransform.setAngleDeg(0);
        updatePreview();
    };
    this.setTransformCenter = function() {
        freeTransform.setPos({
            x: params.imageWidth / 2,
            y: params.imageHeight / 2
        });
        freeTransform.setAngleDeg(0);
        updatePreview();
    };
    //gives you the transformation in the original scale
    this.getTransformation = function() {
        if (!freeTransform) return false;
        return freeTransform.getTransform();
    };
    this.getIsPixelated = ()=>{
        const transform = freeTransform.getTransform();
        return _bb.BB.testShouldPixelate(transform, transform.width / initTransform.width, transform.height / initTransform.height);
    };
    this.getElement = function() {
        return div;
    };
    this.destroy = function() {
        freeTransform.destroy();
    };
}

},{"../../../bb/bb":"e3nbn","../../canvas-ui/canvas-preview":"9a0UP","./free-transform":"gt2Ud","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"eE4e1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/*
	Cropper params
	{
		x: int, //pos in relation zum bild
		y: int,
		w: int,
		h: int,
		scale: float, //zoom
		callback: function //wenn sich was ändert
	}
	the div that you append this to must be relative
*/ parcelHelpers.export(exports, "Cropper", ()=>Cropper
);
var _bb = require("../../../bb/bb");
function Cropper(params) {
    let x = params.x, y = params.y, width = params.width, height = params.height, scale = params.scale, callback = params.callback, maxW = params.maxW, maxH = params.maxH;
    let div = document.createElement("div");
    let gripCursors = [
        'nw',
        'n',
        'ne',
        'e',
        'se',
        's',
        'sw',
        'w'
    ];
    let keyListener = new _bb.BB.KeyListener({
    });
    _bb.BB.css(div, {
        position: "absolute",
        left: x * scale + "px",
        top: y * scale + "px"
    });
    let outline = document.createElement("div");
    _bb.BB.css(outline, {
        position: "absolute",
        border: "1px dashed #fff",
        cursor: "move"
    });
    outline.update = function() {
        _bb.BB.css(outline, {
            left: grips[0].x * scale - 1 + "px",
            top: grips[0].y * scale - 1 + "px",
            width: (grips[2].x - grips[0].x) * scale + "px",
            height: (grips[2].y - grips[0].y) * scale + "px"
        });
    };
    let pointerRemainder = {
        x: 0,
        y: 0
    };
    let outlinePointerListener = new _bb.BB.PointerListener({
        target: outline,
        onPointer: function(event) {
            event.eventPreventDefault();
            if (event.type === 'pointermove' && event.button === 'left') {
                const { dX , dY  } = _bb.BB.intDxy(pointerRemainder, event.dX / scale, event.dY / scale);
                grips[0].x += dX;
                grips[0].y += dY;
                grips[1].x += dX;
                grips[1].y += dY;
                grips[2].x += dX;
                grips[2].y += dY;
                grips[3].x += dX;
                grips[3].y += dY;
                update();
            }
            if (event.type === 'pointerup') commit();
        }
    });
    let thirdsHorizontal = document.createElement("div");
    _bb.BB.css(thirdsHorizontal, {
        position: "absolute",
        borderTop: "1px solid #0ff",
        borderBottom: "1px solid #0ff"
    });
    thirdsHorizontal.update = function() {
        _bb.BB.css(thirdsHorizontal, {
            left: grips[0].x * scale + "px",
            top: (grips[0].y + (grips[2].y - grips[0].y) / 3) * scale + "px",
            width: (grips[2].x - grips[0].x) * scale + "px",
            height: (grips[2].y - grips[0].y) / 3 * scale + "px"
        });
    };
    let thirdsVertical = document.createElement("div");
    _bb.BB.css(thirdsVertical, {
        position: "absolute",
        borderLeft: "1px solid #0ff",
        borderRight: "1px solid #0ff"
    });
    thirdsVertical.update = function() {
        _bb.BB.css(thirdsVertical, {
            left: (grips[0].x + (grips[2].x - grips[0].x) / 3) * scale + "px",
            top: grips[0].y * scale + "px",
            width: (grips[2].x - grips[0].x) / 3 * scale + "px",
            height: (grips[2].y - grips[0].y) * scale + "px"
        });
    };
    const gripSize = 40;
    const gripOverlay = 10;
    let grips = [
        {
            x: 0,
            y: 0
        },
        {
            x: width,
            y: 0
        },
        {
            x: width,
            y: height
        },
        {
            x: 0,
            y: height
        }
    ];
    function transformTop(dY) {
        grips[0].y += dY;
        grips[0].y = Math.max(grips[3].y - maxH, Math.min(grips[3].y - 1, grips[0].y));
        grips[1].y = grips[0].y;
    }
    function transformRight(dX) {
        grips[1].x += dX;
        grips[1].x = Math.min(grips[0].x + maxW, Math.max(grips[0].x + 1, grips[1].x));
        grips[2].x = grips[1].x;
    }
    function transformBottom(dY) {
        grips[2].y += dY;
        grips[2].y = Math.min(grips[1].y + maxH, Math.max(grips[1].y + 1, grips[2].y));
        grips[3].y = grips[2].y;
    }
    function transformLeft(dX) {
        grips[0].x += dX;
        grips[0].x = Math.max(grips[1].x - maxW, Math.min(grips[1].x - 1, grips[0].x));
        grips[3].x = grips[0].x;
    }
    function commit() {
        pointerRemainder.x = 0;
        pointerRemainder.y = 0;
        callback(getTransform());
    }
    let edges = [];
    for(let i2 = 0; i2 < 4; i2++)(function(i) {
        edges[i] = document.createElement("div");
        let g = edges[i];
        g.style.width = gripSize + "px";
        g.style.height = gripSize + "px";
        //g.style.background = "#0f0";
        g.style.position = "absolute";
        g.update = function() {
            if (i === 0) {
                g.style.left = grips[0].x * scale + gripOverlay + "px";
                g.style.top = grips[0].y * scale - gripSize * 2 + gripOverlay + "px";
                g.style.width = (grips[1].x - grips[0].x) * scale - gripOverlay * 2 + "px";
                g.style.height = gripSize * 2 + "px";
            } else if (i === 1) {
                g.style.left = grips[1].x * scale - gripOverlay + "px";
                g.style.top = grips[1].y * scale + gripOverlay + "px";
                g.style.width = gripSize * 2 + "px";
                g.style.height = (grips[2].y - grips[1].y) * scale - gripOverlay * 2 + "px";
            } else if (i === 2) {
                g.style.left = grips[3].x * scale + gripOverlay + "px";
                g.style.top = grips[3].y * scale - gripOverlay + "px";
                g.style.width = (grips[2].x - grips[3].x) * scale - gripOverlay * 2 + "px";
                g.style.height = gripSize * 2 + "px";
            } else if (i === 3) {
                g.style.left = grips[0].x * scale - gripSize * 2 + gripOverlay + "px";
                g.style.top = grips[0].y * scale + gripOverlay + "px";
                g.style.width = gripSize * 2 + "px";
                g.style.height = (grips[3].y - grips[0].y) * scale - gripOverlay * 2 + "px";
            }
            let angleOffset = i * 2 + 1;
            g.style.cursor = gripCursors[angleOffset] + "-resize";
        };
    })(i2);
    let darken = [];
    for(let i1 = 0; i1 < 4; i1++)(function(i) {
        darken[i] = document.createElement("div");
        let g = darken[i];
        g.style.position = "absolute";
        g.style.background = "#000";
        g.style.opacity = "0.5";
        g.update = function() {
            if (i === 0) {
                g.style.left = grips[0].x * scale + "px";
                g.style.top = grips[0].y * scale - 8000 + "px";
                g.style.width = (grips[1].x - grips[0].x) * scale + "px";
                g.style.height = "8000px";
            } else if (i === 1) {
                g.style.left = grips[1].x * scale + "px";
                g.style.top = grips[1].y * scale - 8000 + "px";
                g.style.width = "8000px";
                g.style.height = "16000px";
            } else if (i === 2) {
                g.style.left = grips[3].x * scale + "px";
                g.style.top = grips[3].y * scale + "px";
                g.style.width = (grips[2].x - grips[3].x) * scale + "px";
                g.style.height = "8000px";
            } else if (i === 3) {
                g.style.left = grips[0].x * scale - 8000 + "px";
                g.style.top = grips[0].y * scale - 8000 + "px";
                g.style.width = "8000px";
                g.style.height = "16000px";
            }
        };
    })(i1);
    let edge0PointerListener = new _bb.BB.PointerListener({
        target: edges[0],
        fixScribble: true,
        onPointer: function(event) {
            event.eventPreventDefault();
            if (event.type === 'pointermove' && event.button === 'left') {
                const { dX , dY  } = _bb.BB.intDxy(pointerRemainder, event.dX / scale, event.dY / scale);
                transformTop(dY);
                if (keyListener.isPressed('shift')) transformBottom(-dY);
                update();
            }
            if (event.type === 'pointerup') commit();
        }
    });
    let edge1PointerListener = new _bb.BB.PointerListener({
        target: edges[1],
        fixScribble: true,
        onPointer: function(event) {
            event.eventPreventDefault();
            if (event.type === 'pointermove' && event.button === 'left') {
                const { dX , dY  } = _bb.BB.intDxy(pointerRemainder, event.dX / scale, event.dY / scale);
                transformRight(dX);
                if (keyListener.isPressed('shift')) transformLeft(-dX);
                update();
            }
            if (event.type === 'pointerup') commit();
        }
    });
    let edge2PointerListener = new _bb.BB.PointerListener({
        target: edges[2],
        fixScribble: true,
        onPointer: function(event) {
            event.eventPreventDefault();
            if (event.type === 'pointermove' && event.button === 'left') {
                const { dX , dY  } = _bb.BB.intDxy(pointerRemainder, event.dX / scale, event.dY / scale);
                transformBottom(dY);
                if (keyListener.isPressed('shift')) transformTop(-dY);
                update();
            }
            if (event.type === 'pointerup') commit();
        }
    });
    let edge3PointerListener = new _bb.BB.PointerListener({
        target: edges[3],
        fixScribble: true,
        onPointer: function(event) {
            event.eventPreventDefault();
            if (event.type === 'pointermove' && event.button === 'left') {
                const { dX , dY  } = _bb.BB.intDxy(pointerRemainder, event.dX / scale, event.dY / scale);
                transformLeft(dX);
                if (keyListener.isPressed('shift')) transformRight(-dX);
                update();
            }
            if (event.type === 'pointerup') commit();
        }
    });
    let cornerElArr = [];
    (function() {
        for(let i3 = 0; i3 < 4; i3++)(function(i) {
            cornerElArr[i] = document.createElement("div");
            let g = cornerElArr[i];
            _bb.BB.css(g, {
                //background: '#f00',
                width: gripSize * 2 + 'px',
                height: gripSize * 2 + 'px',
                position: 'absolute'
            });
            g.style.cursor = [
                'nwse-resize',
                'nesw-resize'
            ][i % 2];
            g.update = function() {
                if (i === 0) _bb.BB.css(g, {
                    left: grips[0].x * scale - gripSize * 2 + gripOverlay + "px",
                    top: grips[0].y * scale - gripSize * 2 + gripOverlay + "px"
                });
                else if (i === 1) _bb.BB.css(g, {
                    left: grips[1].x * scale - gripOverlay + "px",
                    top: grips[1].y * scale - gripSize * 2 + gripOverlay + "px"
                });
                else if (i === 2) _bb.BB.css(g, {
                    left: grips[1].x * scale - gripOverlay + "px",
                    top: grips[2].y * scale - gripOverlay + "px"
                });
                else if (i === 3) _bb.BB.css(g, {
                    left: grips[0].x * scale - gripSize * 2 + gripOverlay + "px",
                    top: grips[2].y * scale - gripOverlay + "px"
                });
            };
        })(i3);
    })();
    //top left
    let corner0PointerListener = new _bb.BB.PointerListener({
        target: cornerElArr[0],
        fixScribble: true,
        onPointer: function(event) {
            event.eventPreventDefault();
            if (event.type === 'pointermove' && event.button === 'left') {
                const { dX , dY  } = _bb.BB.intDxy(pointerRemainder, event.dX / scale, event.dY / scale);
                transformLeft(dX);
                transformTop(dY);
                if (keyListener.isPressed('shift')) {
                    transformRight(-dX);
                    transformBottom(-dY);
                }
                update();
            }
            if (event.type === 'pointerup') commit();
        }
    });
    //top right
    let corner1PointerListener = new _bb.BB.PointerListener({
        target: cornerElArr[1],
        fixScribble: true,
        onPointer: function(event) {
            event.eventPreventDefault();
            if (event.type === 'pointermove' && event.button === 'left') {
                const { dX , dY  } = _bb.BB.intDxy(pointerRemainder, event.dX / scale, event.dY / scale);
                transformRight(dX);
                transformTop(dY);
                if (keyListener.isPressed('shift')) {
                    transformLeft(-dX);
                    transformBottom(-dY);
                }
                update();
            }
            if (event.type === 'pointerup') commit();
        }
    });
    //bottom right
    let corner2PointerListener = new _bb.BB.PointerListener({
        target: cornerElArr[2],
        fixScribble: true,
        onPointer: function(event) {
            event.eventPreventDefault();
            if (event.type === 'pointermove' && event.button === 'left') {
                const { dX , dY  } = _bb.BB.intDxy(pointerRemainder, event.dX / scale, event.dY / scale);
                transformRight(dX);
                transformBottom(dY);
                if (keyListener.isPressed('shift')) {
                    transformLeft(-dX);
                    transformTop(-dY);
                }
                update();
            }
            if (event.type === 'pointerup') commit();
        }
    });
    //bottom left
    let corner3PointerListener = new _bb.BB.PointerListener({
        target: cornerElArr[3],
        fixScribble: true,
        onPointer: function(event) {
            event.eventPreventDefault();
            if (event.type === 'pointermove' && event.button === 'left') {
                const { dX , dY  } = _bb.BB.intDxy(pointerRemainder, event.dX / scale, event.dY / scale);
                transformLeft(dX);
                transformBottom(dY);
                if (keyListener.isPressed('shift')) {
                    transformRight(-dX);
                    transformTop(-dY);
                }
                update();
            }
            if (event.type === 'pointerup') commit();
        }
    });
    function getTransform() {
        grips[1].x -= grips[0].x;
        grips[1].y -= grips[0].y;
        grips[2].x -= grips[0].x;
        grips[2].y -= grips[0].y;
        grips[3].x -= grips[0].x;
        grips[3].y -= grips[0].y;
        x += grips[0].x;
        y += grips[0].y;
        grips[0].x = 0;
        grips[0].y = 0;
        return {
            x: x,
            y: y,
            width: grips[1].x,
            height: grips[2].y
        };
    }
    div.append(darken[1], darken[0], darken[2], darken[3], thirdsHorizontal, thirdsVertical, outline, edges[1], edges[0], edges[2], edges[3], cornerElArr[0], cornerElArr[1], cornerElArr[2], cornerElArr[3]);
    function update() {
        edges[0].update();
        edges[1].update();
        edges[2].update();
        edges[3].update();
        cornerElArr[0].update();
        cornerElArr[1].update();
        cornerElArr[2].update();
        cornerElArr[3].update();
        darken[0].update();
        darken[1].update();
        darken[2].update();
        darken[3].update();
        outline.update();
        thirdsHorizontal.update();
        thirdsVertical.update();
    }
    update();
    // --- interface ---
    this.getTransform = getTransform;
    this.setTransform = function(p) {
        x = p.x;
        y = p.y;
        width = p.width;
        height = p.height;
        _bb.BB.css(div, {
            left: x * scale + "px",
            top: y * scale + "px"
        });
        grips[0].x = 0;
        grips[0].y = 0;
        grips[1].x = width;
        grips[1].y = 0;
        grips[2].x = width;
        grips[2].y = height;
        grips[3].x = 0;
        grips[3].y = height;
        update();
        commit();
    };
    this.setScale = function(s) {
        scale = s;
        _bb.BB.css(div, {
            left: x * scale + "px",
            top: y * scale + "px"
        });
        update();
    };
    this.showThirds = function(b) {
        if (b) {
            thirdsHorizontal.style.display = "block";
            thirdsVertical.style.display = "block";
        } else {
            thirdsHorizontal.style.display = "none";
            thirdsVertical.style.display = "none";
        }
    };
    this.getElement = function() {
        return div;
    };
    this.destroy = function() {
        keyListener.destroy();
        outlinePointerListener.destroy();
        corner0PointerListener.destroy();
        corner1PointerListener.destroy();
        corner2PointerListener.destroy();
        corner3PointerListener.destroy();
        edge0PointerListener.destroy();
        edge1PointerListener.destroy();
        edge2PointerListener.destroy();
        edge3PointerListener.destroy();
    };
}

},{"../../../bb/bb":"e3nbn","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"g26AQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Previews currently active layer
 * thumbnail (hover shows bigger preview), layername, opacity
 *
 * internally listens to kl history. updates when there's a change.
 * but you need to update it when the active layer changed. (different canvas object)
 *
 * update visibility for performance
 *
 * p = {
 *     onClick: function() // when clicking on layer name
 *     klRootEl: klRootEl,
 * }
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "LayerPreview", ()=>LayerPreview
);
var _bb = require("../../../bb/bb");
var _klHistory = require("../../history/kl-history");
var _language = require("../../../language/language");
function LayerPreview(p) {
    // internally redraws with in an interval. checks history is something changed
    // this update will be animated
    // it will not be animated if the resolution changed
    // also redraws when you call updateLayer - not animated
    // syncs via updateLayer, and internally updates layer opacity via a hack
    let div = _bb.BB.el({
    });
    let layerObj;
    let isVisible = true;
    const height = 40;
    const canvasSize = height - 10;
    const largeCanvasSize = 300;
    let lastDrawnState = -2;
    let lastDrawnSize = {
        width: 0,
        height: 0
    };
    let animationCanvas = _bb.BB.canvas(); // to help animate the transition
    let animationCanvasCtx = animationCanvas.getContext('2d');
    const animationLength = 30;
    let animationCount = 0; // >0 means it's animating
    let largeCanvasIsVisible = false;
    let largeCanvasAnimationTimeout;
    const largeCanvasAnimationDurationMs = 300;
    let uiState = 'right'; // 'left' | 'right'
    // --- setup dom ---
    let contentWrapperEl = _bb.BB.el({
        css: {
            display: 'flex',
            alignItems: 'center',
            height: height + 'px',
            color: '#666'
        }
    });
    let canvasWrapperEl = _bb.BB.el({
        css: {
            //background: '#f00',
            minWidth: height + 'px',
            height: height + 'px',
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center'
        }
    });
    let canvas = _bb.BB.canvas(canvasSize, canvasSize);
    let canvasCtx = canvas.getContext('2d');
    canvas.title = _language.LANG('layers-active-layer');
    _bb.BB.css(canvas, {
        boxShadow: '0 0 0 1px #9e9e9e',
        colorScheme: 'only light'
    });
    let nameWrapper = _bb.BB.el({
        css: {
            //background: '#ff0',
            flexGrow: '1',
            paddingLeft: '10px',
            fontSize: '13px',
            overflow: 'hidden',
            position: 'relative'
        }
    });
    let nameLabelEl = _bb.BB.el({
        content: '',
        css: {
            cssFloat: 'left',
            whiteSpace: 'nowrap'
        }
    });
    let nameFadeEl = _bb.BB.el({
        css: {
            backgroundImage: 'linear-gradient(to right, rgba(221,221,221,0) 0%, rgba(221,221,221,0.8) 100%)',
            position: 'absolute',
            right: "0",
            top: "0",
            width: "50px",
            height: '100%'
        }
    });
    let clickableEl = _bb.BB.el({
        css: {
            //background: 'rgba(0,255,0,0.6)',
            position: 'absolute',
            left: "10px",
            top: "0",
            width: "90px",
            height: '100%'
        }
    });
    if (p.onClick) {
        _bb.BB.addEventListener(clickableEl, 'click', function() {
            p.onClick();
        });
        _bb.BB.addEventListener(canvas, 'click', function() {
            p.onClick();
        });
    }
    let opacityEl = _bb.BB.el({
        content: _language.LANG('opacity') + '<br>100%',
        css: {
            minWidth: '60px',
            fontSize: '12px',
            textAlign: 'center',
            background: '#dddddd',
            color: '#555'
        }
    });
    const largeCanvasWrapper = _bb.BB.el({
        onClick: _bb.BB.handleClick,
        css: {
            pointerEvents: 'none',
            background: '#fff',
            position: 'absolute',
            right: '280px',
            top: '10px',
            border: '1px solid #aaa',
            boxShadow: '1px 1px 3px rgba(0,0,0,0.3)',
            transition: 'opacity ' + largeCanvasAnimationDurationMs + 'ms ease-in-out',
            userSelect: 'none',
            display: 'block',
            webkitTouchCallout: 'none',
            colorScheme: 'only light'
        }
    });
    let largeCanvas = _bb.BB.canvas(largeCanvasSize, largeCanvasSize);
    largeCanvasWrapper.append(largeCanvas);
    let largeCanvasCtx = largeCanvas.getContext('2d');
    _bb.BB.css(largeCanvas, {
        display: 'block'
    });
    div.appendChild(contentWrapperEl);
    contentWrapperEl.appendChild(canvasWrapperEl);
    canvasWrapperEl.appendChild(canvas);
    contentWrapperEl.appendChild(nameWrapper);
    nameWrapper.appendChild(nameLabelEl);
    nameWrapper.appendChild(nameFadeEl);
    nameWrapper.appendChild(clickableEl);
    contentWrapperEl.appendChild(opacityEl);
    let animationCanvasCheckerPattern = animationCanvasCtx.createPattern(_bb.BB.createCheckerCanvas(4), 'repeat');
    let largeCanvasCheckerPattern = canvasCtx.createPattern(_bb.BB.createCheckerCanvas(4), 'repeat');
    // --- update logic ---
    function animate() {
        if (animationCount === 0) return;
        animationCount--;
        canvasCtx.save();
        canvasCtx.globalAlpha = Math.pow((animationLength - animationCount) / animationLength, 2);
        canvasCtx.drawImage(animationCanvas, 0, 0);
        canvasCtx.restore();
        if (animationCount > 0) requestAnimationFrame(animate);
    }
    function draw(isInstant) {
        if (!isVisible) return;
        nameLabelEl.textContent = layerObj.name;
        opacityEl.innerHTML = _language.LANG('opacity') + '<br>' + Math.round(layerObj.opacity * 100) + '%';
        let layerCanvas = layerObj.context.canvas;
        if (layerCanvas.width !== lastDrawnSize.width || layerCanvas.height !== lastDrawnSize.height) {
            let canvasDimensions = _bb.BB.fitInto(layerCanvas.width, layerCanvas.height, canvasSize, canvasSize, 1);
            canvas.width = Math.round(canvasDimensions.width);
            canvas.height = Math.round(canvasDimensions.height);
            isInstant = true;
        }
        animationCanvas.width = canvas.width;
        animationCanvas.height = canvas.height;
        animationCanvasCtx.save();
        animationCanvasCtx.imageSmoothingEnabled = false;
        animationCanvasCtx.fillStyle = animationCanvasCheckerPattern;
        animationCanvasCtx.fillRect(0, 0, animationCanvas.width, animationCanvas.height);
        animationCanvasCtx.drawImage(layerCanvas, 0, 0, animationCanvas.width, animationCanvas.height);
        animationCanvasCtx.restore();
        if (isInstant) {
            animationCount = 0;
            canvasCtx.save();
            canvasCtx.drawImage(animationCanvas, 0, 0);
            canvasCtx.restore();
        } else {
            animationCount = animationLength;
            animate();
        }
        drawLargeCanvas();
        lastDrawnState = _klHistory.klHistory.getState();
        lastDrawnSize.width = layerCanvas.width;
        lastDrawnSize.height = layerCanvas.height;
    }
    function update() {
        draw(true);
    }
    setInterval(function() {
        if (!layerObj) return;
        let currentState = _klHistory.klHistory.getState();
        if (currentState === lastDrawnState) return;
        //update opacity w hack
        layerObj.opacity = layerObj.context.canvas.opacity;
        draw(false);
    }, 2000);
    //is always instant
    function drawLargeCanvas() {
        if (!largeCanvasIsVisible || !layerObj) return;
        let layerCanvas = layerObj.context.canvas;
        let canvasDimensions = _bb.BB.fitInto(layerCanvas.width, layerCanvas.height, largeCanvasSize, largeCanvasSize, 1);
        largeCanvas.width = Math.round(canvasDimensions.width);
        largeCanvas.height = Math.round(canvasDimensions.height);
        largeCanvasCtx.save();
        if (largeCanvas.width > layerCanvas.width) largeCanvasCtx.imageSmoothingEnabled = false;
        else {
            largeCanvasCtx.imageSmoothingEnabled = true;
            largeCanvasCtx.imageSmoothingQuality = 'high';
        }
        largeCanvasCtx.fillStyle = largeCanvasCheckerPattern;
        largeCanvasCtx.fillRect(0, 0, largeCanvas.width, largeCanvas.height);
        largeCanvasCtx.drawImage(layerCanvas, 0, 0, largeCanvas.width, largeCanvas.height);
        largeCanvasCtx.restore();
        const bounds = div.getBoundingClientRect();
        _bb.BB.css(largeCanvasWrapper, {
            top: Math.max(10, bounds.top + height / 2 - largeCanvas.height / 2) + "px"
        });
    }
    function removeLargeCanvas() {
        try {
            p.klRootEl.removeChild(largeCanvasWrapper);
        } catch (e) {
        }
    }
    function showLargeCanvas(b) {
        if (largeCanvasIsVisible === b) return;
        clearTimeout(largeCanvasAnimationTimeout);
        largeCanvasIsVisible = b;
        if (b) largeCanvasAnimationTimeout = setTimeout(function() {
            drawLargeCanvas();
            largeCanvasWrapper.style.opacity = '0';
            p.klRootEl.appendChild(largeCanvasWrapper);
            setTimeout(function() {
                largeCanvasWrapper.style.opacity = '1';
            }, 20);
        }, 250);
        else {
            largeCanvasWrapper.style.opacity = '0';
            largeCanvasAnimationTimeout = setTimeout(removeLargeCanvas, largeCanvasAnimationDurationMs + 20);
        }
    }
    let pointerListener = new _bb.BB.PointerListener({
        target: canvas,
        onEnterLeave: function(b) {
            showLargeCanvas(b);
        }
    });
    // --- interface ---
    this.getElement = function() {
        return div;
    };
    this.setIsVisible = function(b) {
        if (isVisible === b) return;
        isVisible = b;
        contentWrapperEl.style.display = isVisible ? 'flex' : 'none';
        div.style.marginBottom = isVisible ? '' : '10px';
        let currentState = _klHistory.klHistory.getState();
        if (b && lastDrawnState !== currentState) update();
    };
    //when the layer might have changed
    this.setLayer = function(klCanvasLayerObj) {
        layerObj = klCanvasLayerObj;
        update();
    };
    this.setUiState = function(stateStr) {
        uiState = '' + stateStr;
        if (uiState === 'left') _bb.BB.css(largeCanvasWrapper, {
            left: '280px',
            right: ''
        });
        else _bb.BB.css(largeCanvasWrapper, {
            left: '',
            right: '280px'
        });
    };
}

},{"../../../bb/bb":"e3nbn","../../history/kl-history":"ai9zE","../../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"dKY7k":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * fades in a little message that reminds user to save their draw
 * goes away by itself. stays a few seconds
 */ parcelHelpers.export(exports, "showSaveReminderToast", ()=>showSaveReminderToast
);
var _bb = require("../../../bb/bb");
var _language = require("../../../language/language");
function showSaveReminderToast(remindersShowed) {
    let inner = _bb.BB.el({
        content: _language.LANG('save-reminder-title') + '<br>' + _language.LANG('save-reminder-text')
    });
    let div = _bb.BB.el({
        content: inner,
        className: "reminder-toast g-root",
        css: {
            opacity: '0',
            top: '-20px'
        }
    });
    let transitionMs = 300;
    let durationMs = 2500;
    let mix = Math.min(1, remindersShowed / 5);
    let colA = [
        0,
        0,
        0
    ];
    let colB = [
        50,
        0,
        0
    ];
    let col = [
        Math.round(_bb.BB.mix(colA[0], colB[0], mix)),
        Math.round(_bb.BB.mix(colA[1], colB[1], mix)),
        Math.round(_bb.BB.mix(colA[2], colB[2], mix))
    ];
    inner.style.background = 'rgba(' + col[0] + ',' + col[1] + ',' + col[2] + ', 0.5)';
    document.body.appendChild(div);
    setTimeout(function() {
        div.style.opacity = '1';
        div.style.top = '10px';
    }, 22);
    setTimeout(function() {
        div.style.opacity = '0';
    }, durationMs + transitionMs);
    setTimeout(function() {
        document.body.removeChild(div);
    }, durationMs + 2 * transitionMs);
}

},{"../../../bb/bb":"e3nbn","../../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ipe5S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * fits image into a size
 * params: {
 *    image: image,
 *    width: int,
 *    height: int
 * }
 *
 * methods:
 * getDiv()
 *
 * @param params
 * @constructor
 */ parcelHelpers.export(exports, "FittedImage", ()=>FittedImage
);
var _bb = require("../../../bb/bb");
function FittedImage(params) {
    let fit = _bb.BB.fitInto(params.image.width, params.image.height, params.width, params.height, 1);
    let w = parseInt('' + fit.width);
    let h = parseInt('' + fit.height);
    let canvas = _bb.BB.canvas(w, h);
    canvas.getContext("2d").drawImage(params.image, 0, 0, w, h);
    _bb.BB.css(canvas, {
        display: "block",
        boxShadow: "0 0 0 1px #aaa"
    });
    this.getElement = function() {
        return canvas;
    };
}

},{"../../../bb/bb":"e3nbn","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"c9vtS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "showImportAsLayerDialog", ()=>showImportAsLayerDialog
);
var _bb = require("../../../bb/bb");
var _freeTransformCanvas = require("../components/free-transform-canvas");
var _popup = require("./popup");
var _language = require("../../../language/language");
function showImportAsLayerDialog(params) {
    let div = document.createElement("div");
    _bb.BB.appendTextDiv(div, _language.LANG('import-as-layer-description'));
    if (params.klCanvas.isLayerLimitReached()) {
        let noteEl = _bb.BB.el({
            content: _language.LANG('import-as-layer-limit-reached'),
            css: {
                background: '#ff0',
                padding: '10px',
                marginTop: '5px',
                marginBottom: '5px',
                border: '1px solid #e7d321',
                borderRadius: '5px'
            }
        });
        div.appendChild(noteEl);
    }
    let isSmall = window.innerWidth < 550;
    let buttonRowEl = _bb.BB.el({
        css: {
            display: 'flex'
        }
    });
    let originalSizeBtn = _bb.BB.el({
        tagName: 'button',
        content: '1:1',
        css: {
            marginRight: '10px'
        },
        onClick: function() {
            freeTransformCanvas.reset();
        }
    });
    let fitSizeBtn = _bb.BB.el({
        tagName: 'button',
        content: _language.LANG('import-as-layer-fit'),
        css: {
            marginRight: '10px'
        },
        onClick: function() {
            freeTransformCanvas.setTransformFit();
        }
    });
    let centerBtn = _bb.BB.el({
        tagName: 'button',
        content: _language.LANG('center'),
        css: {
            marginRight: '10px'
        },
        onClick: function() {
            freeTransformCanvas.setTransformCenter();
        }
    });
    buttonRowEl.appendChild(originalSizeBtn);
    buttonRowEl.appendChild(fitSizeBtn);
    buttonRowEl.appendChild(centerBtn);
    div.appendChild(buttonRowEl);
    let layers = [];
    {
        let klCanvasLayerArr = params.klCanvas.getLayers();
        for(let i = 0; i < klCanvasLayerArr.length; i++)layers.push({
            image: klCanvasLayerArr[i].context.canvas,
            opacity: klCanvasLayerArr[i].opacity,
            mixModeStr: klCanvasLayerArr[i].mixModeStr
        });
    }
    layers.push({
        image: params.importImage,
        opacity: 1,
        mixModeStr: 'source-over'
    });
    let freeTransformCanvas = new _freeTransformCanvas.FreeTransformCanvas({
        elementWidth: isSmall ? 340 : 540,
        elementHeight: isSmall ? 280 : 350,
        imageWidth: params.klCanvas.getLayerContext(0).canvas.width,
        imageHeight: params.klCanvas.getLayerContext(0).canvas.height,
        layers: layers,
        transformIndex: layers.length - 1
    });
    _bb.BB.css(freeTransformCanvas.getElement(), {
        marginTop: '10px',
        marginLeft: '-20px'
    });
    div.appendChild(freeTransformCanvas.getElement());
    function move(x, y) {
        freeTransformCanvas.move(x, y);
    }
    let keyListener = new _bb.BB.KeyListener({
        onDown: function(keyStr) {
            if (keyStr === 'left') move(-1, 0);
            if (keyStr === 'right') move(1, 0);
            if (keyStr === 'up') move(0, -1);
            if (keyStr === 'down') move(0, 1);
        }
    });
    _popup.popup({
        target: params.target,
        message: `<b>${_language.LANG('import-as-layer-title')}</b>`,
        div: div,
        style: isSmall ? null : {
            width: '500px'
        },
        buttons: [
            "Ok",
            "Cancel"
        ],
        clickOnEnter: 'Ok',
        callback: function(buttonStr) {
            keyListener.destroy();
            freeTransformCanvas.destroy();
            _bb.BB.destroyEl(originalSizeBtn);
            _bb.BB.destroyEl(fitSizeBtn);
            _bb.BB.destroyEl(centerBtn);
            if (buttonStr === 'Ok') params.callback(freeTransformCanvas.getTransformation(), freeTransformCanvas.getIsPixelated());
            else params.callback();
        }
    });
}

},{"../../../bb/bb":"e3nbn","../components/free-transform-canvas":"fVB2B","./popup":"7D028","../../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bpE7E":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Not really generalized. UI when you drag/drop an image into window.
 * The moment you create it, it will listen.
 *
 * @param p object {onDrop: func(files, optionStr), target: DOM Element, enabledTest: func -> bool} - optionStr: 'default'|'layer'|'image'
 * @constructor
 */ parcelHelpers.export(exports, "KlImageDropper", ()=>KlImageDropper
);
var _bb = require("../../../bb/bb");
function KlImageDropper(p) {
    //set up DOM
    let rootEl = _bb.BB.el({
        content: 'Drop to import',
        css: {
            paddingTop: '100px',
            position: 'fixed',
            left: '0',
            top: '0',
            width: '100%',
            height: '100%',
            background: 'rgba(50, 50, 50, 0.7)',
            color: '#fff',
            textShadow: '2px 2px #000',
            textAlign: 'center',
            fontSize: '25px'
        }
    });
    let wrapperEl = _bb.BB.el({
        css: {
            'marginTop': '50px',
            'display': 'flex',
            'justifyContent': 'center'
        }
    });
    let optionStyle = {
        width: '200px',
        padding: '50px',
        margin: '10px',
        //opacity: 0.5,
        borderRadius: '20px',
        border: '1px dashed #fff',
        background: '#00aefe',
        fontWeight: 'bold'
    };
    let optionLayerEl = _bb.BB.el({
        content: 'As Layer',
        css: optionStyle
    });
    let optionImageEl = _bb.BB.el({
        content: 'As New Image',
        css: optionStyle
    });
    rootEl.appendChild(wrapperEl);
    wrapperEl.appendChild(optionLayerEl);
    wrapperEl.appendChild(optionImageEl);
    let rootCounter = 0;
    let optionLayerCounter = 0;
    let optionImageCounter = 0;
    function destroy() {
        rootCounter = 0;
        optionLayerCounter = 0;
        optionImageCounter = 0;
        try {
            p.target.removeChild(rootEl);
        } catch (e) {
        }
    }
    function testAcceptType(event) {
        try {
            return !event.dataTransfer.types.includes('text/plain');
        } catch (e) {
        }
        return false;
    }
    function updateOptions() {
        let boxShadow = '0 0 20px 4px #fff';
        if (optionLayerCounter > 0) {
            optionLayerEl.style.boxShadow = boxShadow;
            optionImageEl.style.boxShadow = '';
        } else if (optionImageCounter > 0) {
            optionLayerEl.style.boxShadow = '';
            optionImageEl.style.boxShadow = boxShadow;
        } else {
            optionLayerEl.style.boxShadow = '';
            optionImageEl.style.boxShadow = '';
        }
    }
    _bb.BB.addEventListener(optionLayerEl, 'dragenter', function() {
        optionLayerCounter++;
        updateOptions();
    });
    _bb.BB.addEventListener(optionLayerEl, 'dragleave', function() {
        optionLayerCounter--;
        updateOptions();
    });
    _bb.BB.addEventListener(optionImageEl, 'dragenter', function() {
        optionImageCounter++;
        updateOptions();
    });
    _bb.BB.addEventListener(optionImageEl, 'dragleave', function() {
        optionImageCounter--;
        updateOptions();
    });
    function rootDragOver(event) {
        if (!testAcceptType(event)) return;
        event.stopPropagation();
        event.preventDefault();
    }
    function rootDragEnter(event) {
        if (!p.enabledTest() || !testAcceptType(event)) return;
        if (rootCounter === 0) p.target.appendChild(rootEl);
        rootCounter++;
    }
    function rootDragLeave(event) {
        if (!testAcceptType(event) || rootCounter === 0) return;
        rootCounter = Math.max(0, rootCounter - 1);
        if (rootCounter === 0) p.target.removeChild(rootEl);
    }
    function rootDrop(event) {
        if (!testAcceptType(event) || event.dataTransfer.files.length === 0) {
            destroy();
            return;
        }
        event.stopPropagation();
        event.preventDefault();
        let optionStr = 'default';
        if (optionLayerCounter > 0) optionStr = 'layer';
        else if (optionImageCounter > 0) optionStr = 'image';
        p.onDrop(event.dataTransfer.files, optionStr);
        if (rootCounter > 0) p.target.removeChild(rootEl);
        rootCounter = 0;
        optionLayerCounter = 0;
        optionImageCounter = 0;
        updateOptions();
    }
    _bb.BB.addEventListener(window, 'dragover', rootDragOver, false);
    _bb.BB.addEventListener(window, 'dragenter', rootDragEnter, false);
    _bb.BB.addEventListener(window, 'dragleave', rootDragLeave, false);
    _bb.BB.addEventListener(window, 'drop', rootDrop, false);
    // if something goes wrong and you're stuck with overlay
    _bb.BB.addEventListener(rootEl, 'pointerdown', function() {
        destroy();
    });
    let keyListener = new _bb.BB.KeyListener({
        onDown: function(keyStr) {
            if (rootCounter > 0 && keyStr === 'esc') destroy();
        }
    });
}

},{"../../../bb/bb":"e3nbn","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"eLxes":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Compressed HUD toolspace. When you hold ctrl+alt.
 * small color picker, brush settings
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "OverlayToolspace", ()=>OverlayToolspace
);
var _bb = require("../../../bb/bb");
var _klColorSliderSmall = require("../base-components/kl-color-slider-small");
var _klSlider = require("../base-components/kl-slider");
var _language = require("../../../language/language");
function OverlayToolspace(p) {
    const sizeObj = {
        width: 150,
        svHeight: 90,
        hHeight: 20,
        sliderHeight: 25
    };
    let isVisible = false;
    const div = _bb.BB.el({
        css: {
            position: 'absolute',
            left: '500px',
            top: '500px',
            background: 'rgb(221, 221, 221)',
            display: 'none',
            border: '1px solid #fff',
            boxShadow: '0 0 10px rgba(0,0,0,0.5)',
            colorScheme: 'only light'
        }
    });
    const queuedObj = {
        color: null,
        size: null,
        opacity: null
    };
    // --- inputs ---
    //color selection
    const colorSlider = new _klColorSliderSmall.KlSmallColorSlider({
        width: sizeObj.width,
        heightSV: sizeObj.svHeight,
        heightH: sizeObj.hHeight,
        color: p.brushSettingService.getColor(),
        callback: function(rgbObj) {
            selectedColorEl.style.backgroundColor = "rgb(" + rgbObj.r + "," + rgbObj.g + "," + rgbObj.b + ")";
            p.brushSettingService.setColor(rgbObj, subscriptionFunc);
        }
    });
    const selectedColorEl = _bb.BB.el({
        css: {
            width: sizeObj.width + 'px',
            height: sizeObj.hHeight + 'px',
            pointerEvents: 'none'
        }
    });
    {
        const initialColor = p.brushSettingService.getColor();
        selectedColorEl.style.backgroundColor = "rgb(" + initialColor.r + "," + initialColor.g + "," + initialColor.b + ")";
    }
    div.appendChild(selectedColorEl);
    div.appendChild(colorSlider.getElement());
    function updateColor(rgbObj) {
        colorSlider.setColor(rgbObj);
        selectedColorEl.style.backgroundColor = "rgb(" + rgbObj.r + "," + rgbObj.g + "," + rgbObj.b + ")";
    }
    //brushsize slider
    const sizeSlider = new _klSlider.KlSlider({
        label: _language.LANG('brush-size'),
        width: sizeObj.width,
        height: sizeObj.sliderHeight,
        min: 0,
        max: 500,
        initValue: 50,
        resolution: 225,
        eventResMs: 1000 / 30,
        onChange: function(v) {
            p.brushSettingService.setSize(v);
        },
        formatFunc: function(v) {
            if (v * 2 < 10) return Math.round(v * 20) / 10;
            return Math.round(v * 2);
        }
    });
    _bb.BB.css(sizeSlider.getElement(), {
        marginTop: '2px'
    });
    div.appendChild(sizeSlider.getElement());
    const opacitySlider = new _klSlider.KlSlider({
        label: _language.LANG('opacity'),
        width: sizeObj.width,
        height: sizeObj.sliderHeight,
        min: 0,
        max: 1,
        initValue: 1,
        resolution: 225,
        eventResMs: 1000 / 30,
        onChange: function(v) {
            p.brushSettingService.setOpacity(v);
        },
        formatFunc: function(v) {
            return Math.round(v * 100);
        }
    });
    _bb.BB.css(opacitySlider.getElement(), {
        margin: '2px 0'
    });
    div.appendChild(opacitySlider.getElement());
    // --- general setup ---
    const subscriptionFunc = function(event) {
        if (event.type === 'color') {
            if (!isVisible) queuedObj.color = event.value;
            else updateColor(event.value);
        }
        if (event.type === 'size') {
            if (!isVisible) queuedObj.size = event.value;
            else sizeSlider.setValue(event.value);
        }
        if (event.type === 'opacity') {
            if (!isVisible) queuedObj.opacity = event.value;
            else opacitySlider.setValue(event.value);
        }
        if (event.type === 'sliderConfig') {
            sizeSlider.update(event.value.sizeSlider);
            opacitySlider.update(event.value.opacitySlider);
        }
    };
    p.brushSettingService.subscribe(subscriptionFunc);
    {
        const sliderConfig = p.brushSettingService.getSliderConfig();
        sizeSlider.update(sliderConfig.sizeSlider);
        opacitySlider.update(sliderConfig.opacitySlider);
        sizeSlider.setValue(p.brushSettingService.getSize());
        opacitySlider.setValue(p.brushSettingService.getOpacity());
    }
    function updateUI() {
        div.style.display = isVisible ? 'block' : 'none';
        if (isVisible && mousePos) {
            div.style.left = mousePos.x - Math.round(sizeObj.width / 2) + 'px';
            div.style.top = mousePos.y - Math.round(sizeObj.svHeight + sizeObj.hHeight * 3 / 2) + 'px';
        }
    }
    let mousePos = null;
    _bb.BB.addEventListener(document, 'pointermove', function(event) {
        mousePos = {
            x: event.pageX,
            y: event.pageY
        };
    });
    let button = document.getElementById('vaiz');
    button?.addEventListener('touchstart', function handleClick(event) {
        event.preventDefault();
        isVisible = true;
        if (queuedObj.color !== null) {
            updateColor(queuedObj.color);
            queuedObj.color = null;
        }
        if (queuedObj.size !== null) {
            sizeSlider.setValue(queuedObj.size);
            queuedObj.size = null;
        }
        if (queuedObj.opacity !== null) {
            opacitySlider.setValue(queuedObj.opacity);
            queuedObj.opacity = null;
        }
        updateUI();
    });
    button?.addEventListener('touchend', function handleClick(event) {
        isVisible = false;
        colorSlider.end();
        updateUI();
    });
    const keyListener = new _bb.BB.KeyListener({
        onDown: function(keyStr, event, comboStr, isRepeat) {
            if (isRepeat) return;
            if (isVisible) {
                isVisible = false;
                updateUI();
                return;
            }
            if (!p.enabledTest() || !mousePos) return;
            if ([
                'ctrl+alt',
                'cmd+alt',
                'alt+ctrl',
                'alt+cmd'
            ].includes(comboStr)) {
                event.preventDefault();
                isVisible = true;
                if (queuedObj.color !== null) {
                    updateColor(queuedObj.color);
                    queuedObj.color = null;
                }
                if (queuedObj.size !== null) {
                    sizeSlider.setValue(queuedObj.size);
                    queuedObj.size = null;
                }
                if (queuedObj.opacity !== null) {
                    opacitySlider.setValue(queuedObj.opacity);
                    queuedObj.opacity = null;
                }
                updateUI();
            }
        },
        onUp: function(keyStr, event, oldComboStr) {
            if ([
                'ctrl+alt',
                'cmd+alt',
                'alt+ctrl',
                'alt+cmd'
            ].includes(oldComboStr) && isVisible) {
                isVisible = false;
                colorSlider.end();
                updateUI();
            }
        },
        onBlur: function() {
            if (isVisible) {
                isVisible = false;
                colorSlider.end();
                updateUI();
            }
        }
    });
    // --- interface ---
    this.getElement = function() {
        return div;
    };
}

},{"../../../bb/bb":"e3nbn","../base-components/kl-color-slider-small":"5etHO","../base-components/kl-slider":"1Vedp","../../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5LPAW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Topmost row of buttons in toolspace (with the app logo)
 *
 * p = { // button click callbacks
 *      logoImg: img,
 *     onLogo: function(),
 *     onNew: function(),
 *     onImport: function(),
 *     onSave: function(),
 *     onShare: function(),
 *     onHelp: function()
 * }
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "ToolspaceTopRow", ()=>ToolspaceTopRow
);
var _bb = require("../../../bb/bb");
// @ts-ignore
var _klecksLogoPng = require("url:~/src/app/img/klecks-logo.png");
var _klecksLogoPngDefault = parcelHelpers.interopDefault(_klecksLogoPng);
// @ts-ignore
var _newImageSvg = require("url:~/src/app/img/ui/new-image.svg");
var _newImageSvgDefault = parcelHelpers.interopDefault(_newImageSvg);
// @ts-ignore
var _importSvg = require("url:~/src/app/img/ui/import.svg");
var _importSvgDefault = parcelHelpers.interopDefault(_importSvg);
// @ts-ignore
var _exportSvg = require("url:~/src/app/img/ui/export.svg");
var _exportSvgDefault = parcelHelpers.interopDefault(_exportSvg);
// @ts-ignore
var _shareSvg = require("url:~/src/app/img/ui/share.svg");
var _shareSvgDefault = parcelHelpers.interopDefault(_shareSvg);
// @ts-ignore
var _helpSvg = require("url:~/src/app/img/ui/help.svg");
var _helpSvgDefault = parcelHelpers.interopDefault(_helpSvg);
var _language = require("../../../language/language");
function ToolspaceTopRow(p1) {
    let div = document.createElement('div');
    _bb.BB.css(div, {
        height: '36px',
        //background: '#f00',
        display: 'flex',
        backgroundImage: 'linear-gradient(to top, rgba(255, 255, 255, 0) 20%, rgba(255, 255, 255, 0.6) 100%)'
    });
    function createButton(p) {
        let padding = 6 + (p.extraPadding ? p.extraPadding : 0);
        let result = _bb.BB.el({
            className: 'toolspace-row-button nohighlight',
            title: p.title,
            onClick: p.onClick,
            css: {
                padding: p.contain ? padding + 'px 0' : ''
            }
        });
        let im = _bb.BB.el({
            css: {
                backgroundImage: 'url(\'' + p.image + '\')',
                backgroundRepeat: 'no-repeat',
                backgroundPosition: 'center',
                backgroundSize: p.contain ? 'contain' : '',
                //filter: 'grayscale(1)',
                height: '100%'
            }
        });
        im.style.pointerEvents = 'none';
        result.appendChild(im);
        result.pointerListener = new _bb.BB.PointerListener({
            target: result,
            onEnterLeave: function(isOver) {
                if (isOver) _bb.BB.addClassName(result, 'toolspace-row-button-hover');
                else _bb.BB.removeClassName(result, 'toolspace-row-button-hover');
            }
        });
        return result;
    }
    let logoButton = createButton({
        title: _language.LANG('home'),
        image: p1.logoImg ? p1.logoImg : _klecksLogoPngDefault.default,
        contain: true
    });
    logoButton.style.width = '45px';
    logoButton.style.borderRight = '1px solid rgb(212, 212, 212)';
    let newButton = createButton({
        onClick: p1.onNew,
        title: _language.LANG('file-new'),
        image: _newImageSvgDefault.default,
        extraPadding: 1,
        contain: true
    });
    let importButton = createButton({
        onClick: p1.onImport,
        title: _language.LANG('file-import'),
        image: _importSvgDefault.default,
        extraPadding: 1,
        contain: true
    });
    let saveButton = createButton({
        onClick: p1.onSave,
        title: _language.LANG('file-save'),
        image: _exportSvgDefault.default,
        extraPadding: 1,
        contain: true
    });
    let shareButton = null;
    if (_bb.BB.canShareFiles()) shareButton = createButton({
        onClick: p1.onShare,
        title: _language.LANG('file-share'),
        image: _shareSvgDefault.default,
        contain: true
    });
    let helpButton = createButton({
        onClick: p1.onHelp,
        title: _language.LANG('help'),
        image: _helpSvgDefault.default,
        contain: true
    });
    div.appendChild(logoButton);
    div.appendChild(newButton);
    div.appendChild(importButton);
    div.appendChild(saveButton);
    // --- interface ---
    this.getElement = function() {
        return div;
    };
}

},{"../../../bb/bb":"e3nbn","url:~/src/app/img/klecks-logo.png":"bYyZn","url:~/src/app/img/ui/new-image.svg":"ln28s","url:~/src/app/img/ui/import.svg":"kYp42","url:~/src/app/img/ui/export.svg":"hM2b0","url:~/src/app/img/ui/share.svg":"2Zkby","url:~/src/app/img/ui/help.svg":"qgQhh","../../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bYyZn":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "klecks-logo.1fdac8f7.png" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"ln28s":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "new-image.55ed6e46.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"kYp42":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "import.3a21d601.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"hM2b0":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "export.7dc0f6a7.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"2Zkby":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "share.f4cc91c4.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"qgQhh":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "help.1f84b67b.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"3p7MV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Toolrow Dropdown. The button where you select: brush, fill, select, transform, etc.
 *
 * p = {
 *     onChange: func(activeStr)
 * }
 *
 * activeStr = 'draw' | 'fill' | 'text'
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "ToolDropdown", ()=>ToolDropdown
);
var _bb = require("../../../bb/bb");
var _modalCount = require("../modals/modal-count");
// @ts-ignore
var _toolPaintSvg = require("url:~/src/app/img/ui/tool-paint.svg");
var _toolPaintSvgDefault = parcelHelpers.interopDefault(_toolPaintSvg);
// @ts-ignore
var _toolFillSvg = require("url:~/src/app/img/ui/tool-fill.svg");
var _toolFillSvgDefault = parcelHelpers.interopDefault(_toolFillSvg);
// @ts-ignore
var _toolTextSvg = require("url:~/src/app/img/ui/tool-text.svg");
var _toolTextSvgDefault = parcelHelpers.interopDefault(_toolTextSvg);
// @ts-ignore
var _toolShapeSvg = require("url:~/src/app/img/ui/tool-shape.svg");
var _toolShapeSvgDefault = parcelHelpers.interopDefault(_toolShapeSvg);
// @ts-ignore
var _caretDownSvg = require("url:~/src/app/img/ui/caret-down.svg");
var _caretDownSvgDefault = parcelHelpers.interopDefault(_caretDownSvg);
var _language = require("../../../language/language");
function ToolDropdown(p1) {
    let optionArr = [
        'draw',
        'fill',
        'text',
        'shape'
    ];
    let imArr = [
        _toolPaintSvgDefault.default,
        _toolFillSvgDefault.default,
        _toolTextSvgDefault.default,
        _toolShapeSvgDefault.default
    ];
    let titleArr = [
        `${_language.LANG('tool-brush')} [B]`,
        `${_language.LANG('tool-paint-bucket')} [G]`,
        `${_language.LANG('tool-text')} [T]`,
        `${_language.LANG('tool-shape')} [U]`, 
    ];
    let currentActiveIndex = 0;
    let isActive = true;
    let isOpen = false;
    //preload images
    setTimeout(function() {
        for(let i = 1; i < imArr.length; i++){
            let im = new Image();
            im.src = imArr[i];
        }
    }, 100);
    let smallMargin = '6px 0';
    let div = _bb.BB.el({
        css: {
            position: 'relative',
            flexGrow: '1'
        }
    });
    let openTimeout;
    let isDragging = false;
    let startX, startY;
    let pointerListener;
    if (_bb.BB.hasPointerEvents) pointerListener = new _bb.BB.PointerListener({
        target: div,
        maxPointers: 1,
        onPointer: function(event) {
            if (event.type === 'pointerdown') {
                if (isOpen) return;
                openTimeout = setTimeout(function() {
                    showDropdown();
                }, 400);
                isDragging = true;
                startX = event.pageX;
                startY = event.pageY;
            } else if (event.type === 'pointermove') {
                if (isDragging && !isOpen && _bb.BB.dist(startX, startY, event.pageX, event.pageY) > 5) {
                    clearTimeout(openTimeout);
                    showDropdown();
                }
            } else if (event.type === 'pointerup') {
                clearTimeout(openTimeout);
                if (isOpen && isDragging) {
                    let target = document.elementFromPoint(event.pageX, event.pageY);
                    for(let i = 0; i < dropdownBtnArr.length; i++)if (target === dropdownBtnArr[i].wrapper) {
                        closeDropdown();
                        isActive = true;
                        currentActiveIndex = i;
                        updateButton();
                        p1.onChange(optionArr[currentActiveIndex]);
                        break;
                    }
                }
                isDragging = false;
            }
        }
    });
    let activeButton = _bb.BB.el({
        parent: div,
        className: 'toolspace-row-button nohighlight toolspace-row-button-activated',
        title: titleArr[currentActiveIndex],
        onClick: function(e) {
            if (isActive && !isOpen) {
                e.preventDefault();
                e.stopPropagation();
                showDropdown();
                return;
            }
            isActive = true;
            p1.onChange(optionArr[currentActiveIndex]);
            if (isOpen) closeDropdown();
        },
        css: {
            padding: '10px 0',
            pointerEvents: 'auto',
            height: '100%',
            boxSizing: 'border-box'
        }
    });
    let activeButtonIm = _bb.BB.el({
        parent: activeButton,
        css: {
            backgroundRepeat: 'no-repeat',
            backgroundPosition: 'center',
            backgroundSize: 'contain',
            width: 'calc(100% - 7px)',
            height: '100%',
            pointerEvents: 'none',
            opacity: '0.75'
        }
    });
    let arrowButton = _bb.BB.el({
        parent: activeButton,
        css: {
            position: 'absolute',
            right: '1px',
            bottom: '1px',
            width: '18px',
            height: '18px',
            //background: '#aaa',
            //borderRadius: '2px',
            cursor: 'pointer',
            backgroundImage: 'url(\'' + _caretDownSvgDefault.default + '\')',
            backgroundRepeat: 'no-repeat',
            backgroundPosition: 'center',
            backgroundSize: '60%'
        },
        title: 'More Tools',
        onClick: function(e) {
            e.preventDefault();
            e.stopPropagation();
            showDropdown();
        }
    });
    let overlay = _bb.BB.el({
        css: {
            position: 'absolute',
            //background: 'rgba(255,0,0,0.5)',
            left: '0',
            top: '0',
            right: '0',
            bottom: '0'
        }
    });
    let overlayPointerListener = new _bb.BB.PointerListener({
        target: overlay,
        pointers: 1,
        onPointer: function(e) {
            if (e.type === 'pointerdown') {
                e.eventPreventDefault();
                closeDropdown();
            }
        }
    });
    let dropdownWrapper = _bb.BB.el({
        className: 'tool-dropdown-wrapper',
        css: {
            position: 'absolute',
            width: '100%',
            height: 100 * (optionArr.length - 1) + '%',
            top: '100%',
            left: '0',
            zIndex: '1',
            boxSizing: 'border-box',
            cursor: 'pointer',
            transition: 'height 0.1s ease-in-out, opacity 0.1s ease-in-out',
            borderBottomLeftRadius: '5px',
            borderBottomRightRadius: '5px',
            overflow: 'hidden'
        }
    });
    let dropdownBtnArr = [];
    function createDropdownButton(p) {
        let result = {
        };
        let wrapper = _bb.BB.el({
            parent: dropdownWrapper,
            className: 'tool-dropdown-button',
            title: p.title,
            css: {
                padding: '10px 0',
                height: 100 / (optionArr.length - 1) + '%',
                boxSizing: 'border-box'
            },
            onClick: function(e) {
                e.preventDefault();
                e.stopPropagation();
                p.onClick(p.index, p.id);
            }
        });
        result.wrapper = wrapper;
        let im = _bb.BB.el({
            parent: wrapper,
            css: {
                backgroundImage: 'url(\'' + p.image + '\')',
                backgroundRepeat: 'no-repeat',
                backgroundPosition: 'center',
                backgroundSize: 'contain',
                height: '100%',
                pointerEvents: 'none',
                opacity: '0.75'
            }
        });
        // --- interface ---
        result.show = function(b) {
            wrapper.style.display = b ? 'block' : 'none';
        };
        result.setIsSmall = function(b) {
            wrapper.style.padding = b ? smallMargin : '10px 0';
        };
        return result;
    }
    function onClickDropdownBtn(index, id) {
        closeDropdown();
        isActive = true;
        currentActiveIndex = index;
        updateButton();
        p1.onChange(optionArr[currentActiveIndex]);
    }
    for(let i1 = 0; i1 < optionArr.length; i1++)dropdownBtnArr.push(createDropdownButton({
        index: i1,
        id: optionArr[i1],
        image: imArr[i1],
        title: titleArr[i1],
        onClick: onClickDropdownBtn
    }));
    function showDropdown() {
        _modalCount.dialogCounter.increase(0.5);
        isOpen = true;
        for(let i = 0; i < optionArr.length; i++)dropdownBtnArr[i].show(currentActiveIndex !== i);
        arrowButton.style.display = 'none';
        div.style.zIndex = '1';
        document.body.appendChild(overlay);
        div.appendChild(dropdownWrapper);
    }
    function closeDropdown() {
        _modalCount.dialogCounter.decrease(0.5);
        isOpen = false;
        arrowButton.style.removeProperty('display');
        div.style.removeProperty('z-index');
        document.body.removeChild(overlay);
        div.removeChild(dropdownWrapper);
    }
    function updateButton() {
        activeButton.title = titleArr[currentActiveIndex];
        activeButtonIm.style.backgroundImage = 'url(\'' + imArr[currentActiveIndex] + '\')';
    }
    updateButton();
    // --- interface ---
    this.setIsSmall = function(b) {
        activeButton.style.padding = b ? smallMargin : '10px 0';
        for(let i = 0; i < optionArr.length; i++)dropdownBtnArr[i].setIsSmall(b);
        if (b) {
            arrowButton.style.width = '14px';
            arrowButton.style.height = '14px';
        } else {
            arrowButton.style.width = '18px';
            arrowButton.style.height = '18px';
        }
    };
    this.setActive = function(activeStr) {
        if (optionArr.includes(activeStr)) {
            isActive = true;
            for(let i = 0; i < optionArr.length; i++)if (optionArr[i] === activeStr) {
                currentActiveIndex = i;
                break;
            }
            _bb.BB.addClassName(activeButton, 'toolspace-row-button-activated');
            updateButton();
        } else {
            isActive = false;
            _bb.BB.removeClassName(activeButton, 'toolspace-row-button-activated');
        }
    };
    this.getActive = function() {
        return optionArr[currentActiveIndex];
    };
    this.getElement = function() {
        return div;
    };
}

},{"../../../bb/bb":"e3nbn","../modals/modal-count":"5hzLs","url:~/src/app/img/ui/tool-paint.svg":"l9lMS","url:~/src/app/img/ui/tool-fill.svg":"54jCT","url:~/src/app/img/ui/tool-text.svg":"jRPtM","url:~/src/app/img/ui/tool-shape.svg":"4jh19","url:~/src/app/img/ui/caret-down.svg":"iTPRK","../../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"l9lMS":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "tool-paint.c0b7dc8d.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"54jCT":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "tool-fill.ae52b8fa.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"jRPtM":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "tool-text.f14c14aa.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"4jh19":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "tool-shape.d3d5fc04.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"iTPRK":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "caret-down.44e9d022.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"7wDA7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Row of buttons in toolspace. image-operations (draw, hand), zoom, undo/redo
 * Need to do syncing. So tool is correct, and zoom/undo/redo buttons are properly enabled/disabled
 * heights: 54px tall, 36px small -> via setIsSmall
 *
 * p = {
 *     onActivate: function(activeStr), // clicking on tool button - activating it
 *     onZoomIn: function(),
 *     onZoomOut: function(),
 *     onUndo: function(),
 *     onRedo: function(),
 * }
 *
 * activeStr = 'draw' | 'hand' | 'fill' | 'text'
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "ToolspaceToolRow", ()=>ToolspaceToolRow
);
var _bb = require("../../../bb/bb");
var _toolDropdown = require("./tool-dropdown");
// @ts-ignore
var _toolHandSvg = require("url:~/src/app/img/ui/tool-hand.svg");
var _toolHandSvgDefault = parcelHelpers.interopDefault(_toolHandSvg);
// @ts-ignore
var _toolZoomInSvg = require("url:~/src/app/img/ui/tool-zoom-in.svg");
var _toolZoomInSvgDefault = parcelHelpers.interopDefault(_toolZoomInSvg);
// @ts-ignore
var _toolZoomOutSvg = require("url:~/src/app/img/ui/tool-zoom-out.svg");
var _toolZoomOutSvgDefault = parcelHelpers.interopDefault(_toolZoomOutSvg);
// @ts-ignore
var _toolUndoSvg = require("url:~/src/app/img/ui/tool-undo.svg");
var _toolUndoSvgDefault = parcelHelpers.interopDefault(_toolUndoSvg);
var _language = require("../../../language/language");
function ToolspaceToolRow(p1) {
    let div = document.createElement('div');
    _bb.BB.css(div, {
        height: '54px',
        //height: '36px',
        display: 'flex',
        backgroundImage: 'linear-gradient(to top, rgba(255, 255, 255, 0) 20%, rgba(255, 255, 255, 0.6) 100%)'
    });
    let currentActiveStr = 'draw'; // 'draw' | 'hand' | 'fill'
    function setActive(activeStr, doEmit) {
        if (currentActiveStr === activeStr) return;
        currentActiveStr = activeStr;
        toolDropdown.setActive(currentActiveStr);
        if (currentActiveStr === 'hand') _bb.BB.addClassName(handButton, 'toolspace-row-button-activated');
        else _bb.BB.removeClassName(handButton, 'toolspace-row-button-activated');
        if (doEmit) p1.onActivate(currentActiveStr);
    }
    function createButton(p) {
        let smallMargin = p.doLighten ? '6px 0' : '8px 0';
        let result = _bb.BB.el({
            className: 'toolspace-row-button nohighlight',
            //title: p.title,
            onClick: p.onClick,
            css: {
                padding: p.contain ? '10px 0' : ''
            }
        });
        let im = _bb.BB.el({
            css: {
                backgroundImage: 'url(\'' + p.image + '\')',
                backgroundRepeat: 'no-repeat',
                backgroundPosition: 'center',
                backgroundSize: p.contain ? 'contain' : '',
                //filter: 'grayscale(1)',
                height: '100%',
                transform: p.doMirror ? 'scale(-1, 1)' : '',
                pointerEvents: 'none',
                opacity: p.doLighten ? '0.75' : '1'
            }
        });
        result.appendChild(im);
        result.pointerListener = new _bb.BB.PointerListener({
            target: result,
            onEnterLeave: function(isOver) {
                if (isOver) _bb.BB.addClassName(result, 'toolspace-row-button-hover');
                else _bb.BB.removeClassName(result, 'toolspace-row-button-hover');
            }
        });
        result.setIsSmall = function(b) {
            result.style.padding = p.contain ? b ? smallMargin : '10px 0' : '';
        };
        return result;
    }
    function createTriangleButton(p) {
        let result = document.createElement('div');
        _bb.BB.css(result, {
            flexGrow: '1',
            position: 'relative'
        });
        let svg = _bb.BB.createSvg({
            elementType: 'svg',
            width: '67px',
            height: '54px',
            viewBox: '0 0 100 100',
            preserveAspectRatio: 'none'
        });
        _bb.BB.css(svg, {
            position: 'absolute',
            left: '0',
            top: '0'
        });
        let blurRadius = 10;
        let blurOffsetX = 2;
        let blurOffsetY = 2;
        let defs = _bb.BB.createSvg({
            elementType: 'defs',
            childrenArr: [
                {
                    elementType: 'filter',
                    id: 'innershadow',
                    x0: '-50%',
                    y0: '-50%',
                    width: '200%',
                    height: '200%',
                    childrenArr: [
                        {
                            elementType: 'feGaussianBlur',
                            in: 'SourceAlpha',
                            stdDeviation: '' + blurRadius,
                            result: 'blur'
                        },
                        {
                            elementType: 'feOffset',
                            dx: '' + blurOffsetX,
                            dy: '' + blurOffsetY
                        },
                        {
                            elementType: 'feComposite',
                            in2: 'SourceAlpha',
                            operator: 'arithmetic',
                            k2: '-1',
                            k3: '1',
                            result: 'shadowDiff'
                        },
                        {
                            elementType: 'feFlood',
                            'flood-color': '#000',
                            'flood-opacity': '0.2'
                        },
                        {
                            elementType: 'feComposite',
                            in2: 'shadowDiff',
                            operator: 'in'
                        },
                        {
                            elementType: 'feComposite',
                            in2: 'SourceGraphic',
                            operator: 'over',
                            result: 'firstfilter'
                        },
                        {
                            elementType: 'feGaussianBlur',
                            in: 'firstfilter',
                            stdDeviation: '' + blurRadius,
                            result: 'blur2'
                        },
                        {
                            elementType: 'feOffset',
                            dx: '' + blurOffsetX,
                            dy: '' + blurOffsetY
                        },
                        {
                            elementType: 'feComposite',
                            in2: 'firstfilter',
                            operator: 'arithmetic',
                            k2: '-1',
                            k3: '1',
                            result: 'shadowDiff'
                        },
                        {
                            elementType: 'feFlood',
                            'flood-color': '#000',
                            'flood-opacity': '0.2'
                        },
                        {
                            elementType: 'feComposite',
                            in2: 'shadowDiff',
                            operator: 'in'
                        },
                        {
                            elementType: 'feComposite',
                            in2: 'firstfilter',
                            operator: 'over'
                        }
                    ]
                }
            ]
        });
        let svgTriangleLeft = _bb.BB.createSvg({
            elementType: 'path',
            'vector-effect': 'non-scaling-stroke',
            d: 'M0,0 L 100,0 0,100 z',
            fill: 'rgba(0,0,0,0)',
            class: 'toolspace-svg-triangle-button'
        });
        svgTriangleLeft.onclick = function() {
            p.onLeft();
            _bb.BB.removeClassName(svgTriangleLeft, 'toolspace-svg-triangle-button-hover');
        };
        let svgTriangleRight = _bb.BB.createSvg({
            elementType: 'path',
            'vector-effect': 'non-scaling-stroke',
            d: 'M100,100 L 100,0 0,100 z',
            fill: 'rgba(0,0,0,0)',
            class: 'toolspace-svg-triangle-button'
        });
        svgTriangleRight.onclick = function() {
            p.onRight();
            _bb.BB.removeClassName(svgTriangleRight, 'toolspace-svg-triangle-button-hover');
        };
        // because :hover causes problems w touch
        result.leftPointerListener = new _bb.BB.PointerListener({
            target: svgTriangleLeft,
            onEnterLeave: function(isOver) {
                if (isOver) _bb.BB.addClassName(svgTriangleLeft, 'toolspace-svg-triangle-button-hover');
                else _bb.BB.removeClassName(svgTriangleLeft, 'toolspace-svg-triangle-button-hover');
            }
        });
        result.rightPointerListener = new _bb.BB.PointerListener({
            target: svgTriangleRight,
            onEnterLeave: function(isOver) {
                if (isOver) _bb.BB.addClassName(svgTriangleRight, 'toolspace-svg-triangle-button-hover');
                else _bb.BB.removeClassName(svgTriangleRight, 'toolspace-svg-triangle-button-hover');
            }
        });
        svg.appendChild(defs);
        svg.appendChild(svgTriangleLeft);
        svg.appendChild(svgTriangleRight);
        result.appendChild(svg);
        let leftIm = _bb.BB.el({
            css: {
                backgroundImage: 'url(\'' + p.leftImage + '\')',
                backgroundRepeat: 'no-repeat',
                backgroundSize: 'contain',
                width: '20px',
                height: '20px',
                position: 'absolute',
                left: '10px',
                top: '8px',
                //transform: p.doMirror ? 'scale(-1, 1)' : '',
                pointerEvents: 'none'
            }
        });
        result.appendChild(leftIm);
        let rightIm = _bb.BB.el({
            css: {
                backgroundImage: 'url(\'' + (p.rightImage ? p.rightImage : p.leftImage) + '\')',
                backgroundRepeat: 'no-repeat',
                backgroundSize: 'contain',
                width: '20px',
                height: '20px',
                position: 'absolute',
                right: '10px',
                bottom: '8px',
                transform: p.rightImage ? '' : 'scale(-1, 1)',
                pointerEvents: 'none'
            }
        });
        result.appendChild(rightIm);
        result.setIsEnabledLeft = function(b) {
            if (b) {
                _bb.BB.removeClassName(svgTriangleLeft, 'toolspace-row-button-disabled');
                _bb.BB.removeClassName(leftIm, 'toolspace-row-button-disabled');
            } else {
                _bb.BB.addClassName(svgTriangleLeft, 'toolspace-row-button-disabled');
                _bb.BB.addClassName(leftIm, 'toolspace-row-button-disabled');
            }
        };
        result.setIsEnabledRight = function(b) {
            if (b) {
                _bb.BB.removeClassName(svgTriangleRight, 'toolspace-row-button-disabled');
                _bb.BB.removeClassName(rightIm, 'toolspace-row-button-disabled');
            } else {
                _bb.BB.addClassName(svgTriangleRight, 'toolspace-row-button-disabled');
                _bb.BB.addClassName(rightIm, 'toolspace-row-button-disabled');
            }
        };
        return result;
    }
    function createTriangleButtonViaClipPath(p) {
        let result = document.createElement('div');
        _bb.BB.css(result, {
            flexGrow: '1',
            position: 'relative'
        });
        let leftButton = _bb.BB.el({
            className: 'toolspace-triangle-button',
            onClick: p.onLeft,
            css: {
                clipPath: 'polygon(0% 0%, 100% 0%, 100% 0%, 0% 100%)'
            }
        });
        let leftIm = _bb.BB.el({
            css: {
                backgroundImage: 'url(\'' + p.leftImage + '\')',
                backgroundRepeat: 'no-repeat',
                backgroundSize: 'contain',
                width: '20px',
                height: '20px',
                position: 'absolute',
                left: '10px',
                top: '8px',
                //transform: p.doMirror ? 'scale(-1, 1)' : '',
                pointerEvents: 'none'
            }
        });
        leftButton.appendChild(leftIm);
        let rightButton = _bb.BB.el({
            className: 'toolspace-triangle-button',
            onClick: p.onRight,
            css: {
                clipPath: 'polygon(0% 100%, 100% 0%, 100% 100%, 0% 100%)'
            }
        });
        let rightIm = _bb.BB.el({
            css: {
                backgroundImage: 'url(\'' + (p.rightImage ? p.rightImage : p.leftImage) + '\')',
                backgroundRepeat: 'no-repeat',
                backgroundSize: 'contain',
                width: '20px',
                height: '20px',
                position: 'absolute',
                right: '10px',
                bottom: '8px',
                transform: p.rightImage ? '' : 'scale(-1, 1)',
                pointerEvents: 'none'
            }
        });
        rightButton.appendChild(rightIm);
        result.appendChild(leftButton);
        result.appendChild(rightButton);
        // because :hover causes problems w touch
        result.leftPointerListener = new _bb.BB.PointerListener({
            target: leftButton,
            onEnterLeave: function(isOver) {
                if (isOver) _bb.BB.addClassName(leftButton, 'toolspace-row-button-hover');
                else _bb.BB.removeClassName(leftButton, 'toolspace-row-button-hover');
            }
        });
        result.rightPointerListener = new _bb.BB.PointerListener({
            target: rightButton,
            onEnterLeave: function(isOver) {
                if (isOver) _bb.BB.addClassName(rightButton, 'toolspace-row-button-hover');
                else _bb.BB.removeClassName(rightButton, 'toolspace-row-button-hover');
            }
        });
        result.setIsEnabledLeft = function(b) {
            if (b) _bb.BB.removeClassName(leftButton, 'toolspace-row-button-disabled');
            else _bb.BB.addClassName(leftButton, 'toolspace-row-button-disabled');
        };
        result.setIsEnabledRight = function(b) {
            if (b) _bb.BB.removeClassName(rightButton, 'toolspace-row-button-disabled');
            else _bb.BB.addClassName(rightButton, 'toolspace-row-button-disabled');
        };
        return result;
    }
    /*let brushButton = createButton({
        onClick: function() {
            setActive('draw', true);
        },
        image: 'app/img/ui/paint.png',
        contain: true,
        doLighten: true
    });
    BB.addClassName(brushButton, 'toolspace-row-button-activated');
    div.appendChild(brushButton);*/ let toolDropdown = new _toolDropdown.ToolDropdown({
        onChange: function(activeStr) {
            setActive(activeStr, true);
        }
    });
    div.appendChild(toolDropdown.getElement());
    let handButton = createButton({
        onClick: function() {
            setActive('hand', true);
        },
        image: _toolHandSvgDefault.default,
        contain: true,
        doLighten: true
    });
    handButton.style.borderRight = '1px solid rgb(212, 212, 212)';
    handButton.title = _language.LANG('tool-hand');
    div.appendChild(handButton);
    let zoomInNOutButton = createTriangleButton({
        onLeft: p1.onZoomIn,
        onRight: p1.onZoomOut,
        leftImage: _toolZoomInSvgDefault.default,
        rightImage: _toolZoomOutSvgDefault.default
    });
    zoomInNOutButton.title = _language.LANG('tool-zoom');
    div.appendChild(zoomInNOutButton);
    let zoomInButton = createButton({
        onClick: p1.onZoomIn,
        image: _toolZoomInSvgDefault.default,
        contain: true
    });
    zoomInButton.title = _language.LANG('zoom-in');
    div.appendChild(zoomInButton);
    let zoomOutButton = createButton({
        onClick: p1.onZoomOut,
        image: _toolZoomOutSvgDefault.default,
        contain: true
    });
    zoomOutButton.title = _language.LANG('zoom-out');
    div.appendChild(zoomOutButton);
    let undoNRedoButton = createTriangleButton({
        onLeft: p1.onUndo,
        onRight: p1.onRedo,
        leftImage: _toolUndoSvgDefault.default,
        rightImage: null
    });
    undoNRedoButton.title = _language.LANG('tool-undo-redo');
    undoNRedoButton.setIsEnabledLeft(false);
    undoNRedoButton.setIsEnabledRight(false);
    div.appendChild(undoNRedoButton);
    let undoButton = createButton({
        onClick: p1.onUndo,
        image: _toolUndoSvgDefault.default,
        contain: true
    });
    undoButton.title = _language.LANG('undo');
    _bb.BB.addClassName(undoButton, 'toolspace-row-button-disabled');
    div.appendChild(undoButton);
    let redoButton = createButton({
        onClick: p1.onRedo,
        image: _toolUndoSvgDefault.default,
        contain: true,
        doMirror: true
    });
    redoButton.title = _language.LANG('redo');
    _bb.BB.addClassName(redoButton, 'toolspace-row-button-disabled');
    div.appendChild(redoButton);
    zoomInButton.style.display = 'none';
    zoomOutButton.style.display = 'none';
    undoButton.style.display = 'none';
    redoButton.style.display = 'none';
    // --- interface ---
    this.getElement = function() {
        return div;
    };
    this.setIsSmall = function(b) {
        _bb.BB.css(div, {
            height: b ? '36px' : '54px'
        });
        toolDropdown.setIsSmall(b);
        handButton.setIsSmall(b);
        zoomInButton.setIsSmall(b);
        zoomOutButton.setIsSmall(b);
        undoButton.setIsSmall(b);
        redoButton.setIsSmall(b);
        if (b) {
            zoomInNOutButton.style.display = 'none';
            undoNRedoButton.style.display = 'none';
            zoomInButton.style.display = 'block';
            zoomOutButton.style.display = 'block';
            undoButton.style.display = 'block';
            redoButton.style.display = 'block';
        } else {
            zoomInNOutButton.style.display = 'block';
            undoNRedoButton.style.display = 'block';
            zoomInButton.style.display = 'none';
            zoomOutButton.style.display = 'none';
            undoButton.style.display = 'none';
            redoButton.style.display = 'none';
        }
    };
    this.setEnableZoomIn = function(b) {
        if (b) _bb.BB.removeClassName(zoomInButton, 'toolspace-row-button-disabled');
        else _bb.BB.addClassName(zoomInButton, 'toolspace-row-button-disabled');
        zoomInNOutButton.setIsEnabledLeft(b);
    };
    this.setEnableZoomOut = function(b) {
        if (b) _bb.BB.removeClassName(zoomOutButton, 'toolspace-row-button-disabled');
        else _bb.BB.addClassName(zoomOutButton, 'toolspace-row-button-disabled');
        zoomInNOutButton.setIsEnabledRight(b);
    };
    this.setEnableUndo = function(b) {
        if (b) _bb.BB.removeClassName(undoButton, 'toolspace-row-button-disabled');
        else _bb.BB.addClassName(undoButton, 'toolspace-row-button-disabled');
        undoNRedoButton.setIsEnabledLeft(b);
    };
    this.setEnableRedo = function(b) {
        if (b) _bb.BB.removeClassName(redoButton, 'toolspace-row-button-disabled');
        else _bb.BB.addClassName(redoButton, 'toolspace-row-button-disabled');
        undoNRedoButton.setIsEnabledRight(b);
    };
    this.setActive = function(activeStr) {
        setActive(activeStr);
    };
    this.getActive = function() {
        return currentActiveStr;
    };
}

},{"../../../bb/bb":"e3nbn","./tool-dropdown":"3p7MV","url:~/src/app/img/ui/tool-hand.svg":"dRUNs","url:~/src/app/img/ui/tool-zoom-in.svg":"eIVnd","url:~/src/app/img/ui/tool-zoom-out.svg":"6KJcL","url:~/src/app/img/ui/tool-undo.svg":"kIyDN","../../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"dRUNs":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "tool-hand.e7acb885.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"eIVnd":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "tool-zoom-in.bf369d8c.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"6KJcL":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "tool-zoom-out.11d47b7d.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"kIyDN":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "tool-undo.b8b1b558.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"lUTMl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Ui to select stabilizer level. 4 options. returned as 0-3
 *
 * p = {
 *     smoothing: number, // initial level 0-3
 *     onSelect: function(level number) // 0-3, when level changes
 * }
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "ToolspaceStabilizerRow", ()=>ToolspaceStabilizerRow
);
var _bb = require("../../../bb/bb");
var _select = require("../base-components/select");
var _language = require("../../../language/language");
function ToolspaceStabilizerRow(p) {
    let div = _bb.BB.el({
        tagName: 'label',
        content: _language.LANG('stabilizer') + '&nbsp;',
        title: _language.LANG('stabilizer-title'),
        css: {
            display: 'flex',
            alignItems: 'center',
            fontSize: '13px',
            color: 'rgba(0,0,0,0.6)'
        }
    });
    let strengthSelect = new _select.Select({
        optionArr: [
            [
                '0',
                '0'
            ],
            [
                '1',
                '1'
            ],
            [
                '2',
                '2'
            ],
            [
                '3',
                '3'
            ],
            [
                '4',
                '4'
            ],
            [
                '5',
                '5'
            ]
        ],
        initValue: p.smoothing,
        onChange: function(val) {
            p.onSelect(parseInt(val));
        }
    });
    div.appendChild(strengthSelect.getElement());
    let pointerListener = new _bb.BB.PointerListener({
        target: div,
        onWheel: function(e) {
            strengthSelect.setDeltaValue(e.deltaY);
        }
    });
    // --- interface ---
    this.getElement = function() {
        return div;
    };
}

},{"../../../bb/bb":"e3nbn","../base-components/select":"gIUAj","../../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kxZMh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * row of tabs. uses css class .tabrow-tab
 *
 * p = {
 *     initialId: string, // e.g. 'draw'
 *     useAccent: boolean,
 *     tabArr: [
 *         {
 *             id: string, // e.g. 'draw',
 *             label: string, // optional
 *             image: string, // optional background image
 *             title: string, // optional
 *             isVisible: boolean, // optional - default is true
 *             onOpen: function(),
 *             onClose: function(),
 *             css: {...},
 *         }
 *     ]
 * }
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "TabRow", ()=>TabRow
);
var _bb = require("../../../bb/bb");
// @ts-ignore
var _invertedBorderSvg = require("url:~/src/app/img/ui/inverted-border.svg");
var _invertedBorderSvgDefault = parcelHelpers.interopDefault(_invertedBorderSvg);
function TabRow(p) {
    let _this = this;
    let height = 35;
    let div = _bb.BB.el({
        className: 'tabrow',
        css: {
            height: height + 'px'
        }
    });
    let tabArr = []; //creates its own internal arr
    let openedTabObj1 = null;
    const roundSize = 10;
    const roundRight = _bb.BB.el({
        css: {
            width: roundSize + 'px',
            height: roundSize + 'px',
            backgroundImage: `url('${_invertedBorderSvgDefault.default}')`,
            backgroundSize: 'cover',
            position: 'absolute',
            right: -roundSize + 'px',
            bottom: '0',
            pointerEvents: 'none'
        }
    });
    const roundLeft = _bb.BB.el({
        css: {
            width: roundSize + 'px',
            height: roundSize + 'px',
            backgroundImage: `url('${_invertedBorderSvgDefault.default}')`,
            backgroundSize: 'cover',
            position: 'absolute',
            left: -roundSize + 'px',
            bottom: '0',
            transform: 'scale(-1,1)',
            pointerEvents: 'none'
        }
    });
    function createTab(pTabObj, initialId, useAccent) {
        let result = {
            id: pTabObj.id,
            isVisible: 'isVisible' in pTabObj ? pTabObj.isVisible : true,
            onOpen: pTabObj.onOpen,
            onClose: pTabObj.onClose,
            update: function(openedTabObj) {
                tabDiv.className = openedTabObj === result ? useAccent ? 'tabrow-tab tabrow-tab-opened-accented' : 'tabrow-tab tabrow-tab-opened' : 'tabrow-tab';
                tabDiv.style.display = result.isVisible ? 'block' : 'none';
            }
        };
        let tabDiv = _bb.BB.el({
            content: 'label' in pTabObj ? pTabObj.label : '',
            title: 'title' in pTabObj ? pTabObj.title : undefined,
            className: initialId === result.id ? useAccent ? 'tabrow-tab tabrow-tab-opened-accented' : 'tabrow-tab tabrow-tab-opened' : 'tabrow-tab',
            css: {
                lineHeight: height + 'px',
                display: result.isVisible ? 'block' : 'none',
                zIndex: '0'
            },
            onClick: function() {
                if (openedTabObj1 === result) return;
                _this.open(result.id);
            }
        });
        result.div = tabDiv;
        if ('image' in pTabObj) _bb.BB.css(tabDiv, {
            backgroundImage: 'url(\'' + pTabObj.image + '\')',
            backgroundSize: height - 7 + 'px'
        });
        if ('css' in pTabObj) _bb.BB.css(tabDiv, pTabObj.css);
        div.appendChild(tabDiv);
        let pointerListener = new _bb.BB.PointerListener({
            target: tabDiv,
            onEnterLeave: function(isOver) {
                if (isOver) _bb.BB.addClassName(tabDiv, 'tabrow-tab-hover');
                else _bb.BB.removeClassName(tabDiv, 'tabrow-tab-hover');
            }
        });
        if (initialId === result.id) {
            result.onOpen();
            result.div.appendChild(roundRight);
            result.div.appendChild(roundLeft);
        } else result.onClose();
        return result;
    }
    for(let i2 = 0; i2 < p.tabArr.length; i2++)tabArr.push(createTab(p.tabArr[i2], p.initialId, p.useAccent));
    for(let i1 = 0; i1 < tabArr.length; i1++)if (tabArr[i1].id === p.initialId) openedTabObj1 = tabArr[i1];
    if (openedTabObj1 === null) throw 'invalid initialId';
    function update() {
        for(let i = 0; i < tabArr.length; i++)tabArr[i].update(openedTabObj1);
    }
    // --- interface ---
    this.getElement = function() {
        return div;
    };
    this.open = function(tabId) {
        for(let i = 0; i < tabArr.length; i++)if (tabArr[i].id === tabId) {
            if (openedTabObj1 === tabArr[i]) return;
            openedTabObj1.onClose();
            openedTabObj1 = tabArr[i];
            openedTabObj1.onOpen();
            openedTabObj1.div.appendChild(roundRight);
            openedTabObj1.div.appendChild(roundLeft);
            update();
            return;
        }
        throw 'TabRow.open - invalid tabId';
    };
    this.getOpenedTabId = function() {
        return '' + openedTabObj1.id;
    };
    this.setIsVisible = function(tabId, isVisible) {
        for(let i = 0; i < tabArr.length; i++)if (tabArr[i].id === tabId) {
            tabArr[i].isVisible = !!isVisible;
            update();
            return;
        }
        throw 'TabRow.setIsVisible - invalid tabId';
    };
}

},{"../../../bb/bb":"e3nbn","url:~/src/app/img/ui/inverted-border.svg":"6Igk8","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6Igk8":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "inverted-border.758c9eb1.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"am8Pr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Ui, when hand tool tab is open.
 *
 * p = {
 *     scale: number, // initial value
 *     angleDeg: number, // initial value
 *     onReset: function(),
 *     onFit: function(),
 *     onAngleChange: function(angleDeg number, isRelative number)
 * }
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "HandUi", ()=>HandUi
);
var _bb = require("../../../bb/bb");
// @ts-ignore
var _angleSvg = require("url:~/src/app/img/ui/angle.svg");
var _angleSvgDefault = parcelHelpers.interopDefault(_angleSvg);
// @ts-ignore
var _editRotateSvg = require("url:~/src/app/img/ui/edit-rotate.svg");
var _editRotateSvgDefault = parcelHelpers.interopDefault(_editRotateSvg);
var _language = require("../../../language/language");
function HandUi(p) {
    let div = _bb.BB.el({
        css: {
            margin: '10px'
        }
    });
    let isVisible = true;
    let scale = p.scale;
    let angleDeg = p.angleDeg;
    let row1 = _bb.BB.el({
        css: {
            marginBottom: '10px',
            display: 'flex'
        }
    });
    let row2 = _bb.BB.el({
        css: {
            display: 'flex',
            marginBottom: '10px'
        }
    });
    let row3 = _bb.BB.el({
        css: {
            display: 'flex'
        }
    });
    div.append(row1, row2, row3);
    let scaleEl = _bb.BB.el({
        css: {
            width: '55px',
            userSelect: 'none'
        }
    });
    row1.appendChild(scaleEl);
    let angleIm = new Image();
    angleIm.src = _angleSvgDefault.default;
    _bb.BB.css(angleIm, {
        verticalAlign: 'bottom',
        width: '20px',
        height: '20px',
        marginRight: '5px',
        borderRadius: '10px',
        background: 'rgba(0,0,0,0.2)',
        userSelect: 'none'
    });
    row1.appendChild(angleIm);
    let angleEl = _bb.BB.el({
        css: {
            userSelect: 'none'
        }
    });
    row1.appendChild(angleEl);
    function update() {
        scaleEl.innerHTML = Math.round(scale * 100) + '%';
        angleEl.innerHTML = Math.round(angleDeg) + '°';
        angleIm.style.transform = 'rotate(' + angleDeg + 'deg)';
        if (angleDeg % 90 === 0) angleIm.style.boxShadow = 'inset 0 0 0 1px rgba(255,255,255, 1), 0 0 0 1px rgba(0, 0, 0, 0.3)';
        else angleIm.style.boxShadow = '';
    }
    update();
    let resetButton = _bb.BB.el({
        tagName: 'button',
        content: _language.LANG('hand-reset'),
        onClick: p.onReset
    });
    _bb.BB.makeUnfocusable(resetButton);
    let fitButton = _bb.BB.el({
        tagName: 'button',
        content: _language.LANG('hand-fit'),
        css: {
            marginLeft: '10px'
        },
        onClick: p.onFit
    });
    _bb.BB.makeUnfocusable(fitButton);
    row2.append(resetButton, fitButton);
    let leftRotateButton = _bb.BB.el({
        tagName: 'button',
        content: '<img height="20" src="' + _editRotateSvgDefault.default + '" alt="Rotate" style="transform: scale(-1, 1)"/>',
        onClick: function() {
            p.onAngleChange(-15, true);
        }
    });
    _bb.BB.makeUnfocusable(leftRotateButton);
    let resetAngleButton = _bb.BB.el({
        tagName: 'button',
        content: '0°',
        css: {
            marginLeft: '10px'
        },
        onClick: function() {
            p.onAngleChange(0);
        }
    });
    _bb.BB.makeUnfocusable(resetAngleButton);
    let rightRotateButton = _bb.BB.el({
        tagName: 'button',
        content: '<img height="20" src="' + _editRotateSvgDefault.default + '" alt="Rotate"/>',
        css: {
            marginLeft: '10px'
        },
        onClick: function() {
            p.onAngleChange(15, true);
        }
    });
    _bb.BB.makeUnfocusable(rightRotateButton);
    row3.append(leftRotateButton, resetAngleButton, rightRotateButton);
    // --- interface ---
    this.getElement = function() {
        return div;
    };
    this.setIsVisible = function(pIsVisible) {
        isVisible = !!pIsVisible;
        div.style.display = isVisible ? 'block' : 'none';
        if (isVisible) update();
    };
    this.update = function(pScale, pAngleDeg) {
        scale = pScale;
        angleDeg = pAngleDeg;
        if (isVisible) update();
    };
}

},{"../../../bb/bb":"e3nbn","url:~/src/app/img/ui/angle.svg":"5sOrq","url:~/src/app/img/ui/edit-rotate.svg":"44zjq","../../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"44zjq":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "edit-rotate.444bbb67.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"axy3K":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Paint Bucket tab contents (color slider, opacity slider, etc)
 *
 * p = {
 *     colorSlider: KlColorSlider// when opening tab, inserts it (snatches it from where else it was)
 * }
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "FillUi", ()=>FillUi
);
var _bb = require("../../../bb/bb");
var _klSlider = require("../base-components/kl-slider");
var _select = require("../base-components/select");
var _checkbox = require("../base-components/checkbox");
var _language = require("../../../language/language");
function FillUi(p) {
    let div = _bb.BB.el({
        css: {
            margin: '10px'
        }
    });
    let isVisible = true;
    let colorDiv = _bb.BB.el({
        parent: div,
        css: {
            marginBottom: '10px'
        }
    });
    let opacitySlider = new _klSlider.KlSlider({
        label: _language.LANG('opacity'),
        width: 250,
        height: 30,
        min: 0,
        max: 1,
        initValue: 1,
        onChange: function(val) {
        },
        formatFunc: function(v) {
            return Math.round(v * 100);
        }
    });
    div.appendChild(opacitySlider.getElement());
    let toleranceSlider = new _klSlider.KlSlider({
        label: _language.LANG('bucket-tolerance'),
        width: 250,
        height: 30,
        min: 0,
        max: 255,
        initValue: 51,
        onChange: function(val) {
        },
        formatFunc: function(v) {
            return Math.round(v / 255 * 100);
        }
    });
    _bb.BB.css(toleranceSlider.getElement(), {
        marginTop: '10px'
    });
    div.appendChild(toleranceSlider.getElement());
    let selectRow = _bb.BB.el({
        parent: div,
        css: {
            display: 'flex',
            marginTop: '10px'
        }
    });
    let modeWrapper;
    let modeSelect;
    modeWrapper = _bb.BB.el({
        content: _language.LANG('bucket-sample') + '&nbsp;',
        title: _language.LANG('bucket-sample-title'),
        css: {
            fontSize: '15px'
        }
    });
    modeSelect = new _select.Select({
        optionArr: [
            [
                'all',
                _language.LANG('bucket-sample-all')
            ],
            [
                'current',
                _language.LANG('bucket-sample-active')
            ],
            [
                'above',
                _language.LANG('bucket-sample-above')
            ]
        ],
        initValue: 'all',
        onChange: function(val) {
        }
    });
    let modePointerListener = new _bb.BB.PointerListener({
        target: modeSelect.getElement(),
        onWheel: function(e) {
            modeSelect.setDeltaValue(e.deltaY);
        }
    });
    modeWrapper.appendChild(modeSelect.getElement());
    selectRow.appendChild(modeWrapper);
    let growWrapper;
    let growSelect;
    growWrapper = _bb.BB.el({
        content: _language.LANG('bucket-grow') + '&nbsp;',
        title: _language.LANG('bucket-grow-title'),
        css: {
            fontSize: '15px',
            marginLeft: '10px'
        }
    });
    growSelect = new _select.Select({
        optionArr: [
            [
                '0',
                '0'
            ],
            [
                '1',
                '1'
            ],
            [
                '2',
                '2'
            ],
            [
                '3',
                '3'
            ],
            [
                '4',
                '4'
            ],
            [
                '5',
                '5'
            ],
            [
                '6',
                '6'
            ],
            [
                '7',
                '7'
            ], 
        ],
        initValue: '0',
        onChange: function(val) {
        }
    });
    let growPointerListener = new _bb.BB.PointerListener({
        target: growSelect.getElement(),
        onWheel: function(e) {
            growSelect.setDeltaValue(e.deltaY);
        }
    });
    growWrapper.appendChild(growSelect.getElement());
    selectRow.appendChild(growWrapper);
    let isContiguous = true;
    let contiguousToggle = new _checkbox.Checkbox({
        init: true,
        label: _language.LANG('bucket-contiguous'),
        title: _language.LANG('bucket-contiguous-title'),
        callback: function(b) {
            isContiguous = b;
        },
        css: {
            marginTop: '10px',
            paddingRight: '5px',
            display: 'inline-block'
        }
    });
    div.appendChild(contiguousToggle.getElement());
    // --- interface ---
    this.getElement = function() {
        return div;
    };
    this.setIsVisible = function(pIsVisible) {
        isVisible = !!pIsVisible;
        div.style.display = isVisible ? 'block' : 'none';
        if (isVisible) {
            colorDiv.appendChild(p.colorSlider.getElement());
            colorDiv.appendChild(p.colorSlider.getOutputElement());
        }
    };
    this.getTolerance = function() {
        return toleranceSlider.getValue();
    };
    this.getOpacity = function() {
        return opacitySlider.getValue();
    };
    /**
     * returns string 'current' | 'all' | 'above'
     */ this.getSample = function() {
        return modeSelect.getValue();
    };
    this.getGrow = function() {
        return parseInt(growSelect.getValue(), 10);
    };
    this.getContiguous = function() {
        return isContiguous;
    };
}

},{"../../../bb/bb":"e3nbn","../base-components/kl-slider":"1Vedp","../base-components/select":"gIUAj","../base-components/checkbox":"clzcQ","../../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"LoWaK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Text Tool tab contents (color slider)
 *
 * p = {
 *     colorSlider: KlColorSlider// when opening tab, inserts it (snatches it from where else it was)
 * }
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "TextUi", ()=>TextUi
);
var _bb = require("../../../bb/bb");
var _language = require("../../../language/language");
function TextUi(p) {
    let div = _bb.BB.el({
        css: {
            margin: '10px'
        }
    });
    let isVisible = true;
    let colorDiv = _bb.BB.el({
        parent: div,
        css: {
            marginBottom: '10px'
        }
    });
    let hint = _bb.BB.el({
        parent: div,
        content: _language.LANG('text-instruction')
    });
    // --- interface ---
    this.getElement = function() {
        return div;
    };
    this.setIsVisible = function(pIsVisible) {
        isVisible = !!pIsVisible;
        div.style.display = isVisible ? 'block' : 'none';
        if (isVisible) {
            colorDiv.appendChild(p.colorSlider.getElement());
            colorDiv.appendChild(p.colorSlider.getOutputElement());
        //update();
        }
    };
}

},{"../../../bb/bb":"e3nbn","../../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cX1I2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Shape Tool tab contents
 *
 * p = {
 *     colorSlider: KlColorSlider// when opening tab, inserts it (snatches it from where else it was)
 * }
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "ShapeUi", ()=>ShapeUi
);
var _bb = require("../../../bb/bb");
var _options = require("../base-components/options");
var _checkbox = require("../base-components/checkbox");
var _klSlider = require("../base-components/kl-slider");
var _language = require("../../../language/language");
function ShapeUi(p) {
    let div = _bb.BB.el({
        css: {
            margin: '10px'
        }
    });
    let isVisible = true;
    let colorDiv = _bb.BB.el({
        parent: div,
        css: {
            marginBottom: '10px'
        }
    });
    let previewSize = 35;
    let previewPadding = 8;
    let shape; // 'rect'|'ellipse'|'line'
    let mode; // 'stroke'|'fill'
    let rectStrokeSvgRect = _bb.BB.createSvg({
        elementType: 'rect',
        x: '' + previewPadding,
        width: '' + (previewSize - previewPadding * 2)
    });
    let rectStrokeSvg = _bb.BB.createSvg({
        elementType: 'svg',
        width: '' + previewSize,
        height: '' + previewSize
    });
    rectStrokeSvg.appendChild(rectStrokeSvgRect);
    _bb.BB.css(rectStrokeSvg, {
        display: 'block'
    });
    let rectFilledSvgRect = _bb.BB.createSvg({
        elementType: 'rect',
        x: '' + previewPadding,
        width: '' + (previewSize - previewPadding * 2)
    });
    let rectFilledSvg = _bb.BB.createSvg({
        elementType: 'svg',
        width: '' + previewSize,
        height: '' + previewSize
    });
    rectFilledSvg.appendChild(rectFilledSvgRect);
    _bb.BB.css(rectFilledSvg, {
        display: 'block'
    });
    let ellipseStrokeSvgEllipse = _bb.BB.createSvg({
        elementType: 'ellipse',
        cx: '' + previewSize / 2,
        cy: '' + previewSize / 2,
        rx: '' + (previewSize / 2 - previewPadding)
    });
    let ellipseStrokeSvg = _bb.BB.createSvg({
        elementType: 'svg',
        width: '' + previewSize,
        height: '' + previewSize
    });
    ellipseStrokeSvg.appendChild(ellipseStrokeSvgEllipse);
    _bb.BB.css(ellipseStrokeSvg, {
        display: 'block'
    });
    let ellipseFilledSvgEllipse = _bb.BB.createSvg({
        elementType: 'ellipse',
        cx: '' + previewSize / 2,
        cy: '' + previewSize / 2,
        rx: '' + (previewSize / 2 - previewPadding)
    });
    let ellipseFilledSvg = _bb.BB.createSvg({
        elementType: 'svg',
        width: '' + previewSize,
        height: '' + previewSize
    });
    ellipseFilledSvg.appendChild(ellipseFilledSvgEllipse);
    _bb.BB.css(ellipseFilledSvg, {
        display: 'block'
    });
    let lineSvgLine = _bb.BB.createSvg({
        elementType: 'line',
        x1: '' + previewPadding,
        x2: '' + (previewSize - previewPadding)
    });
    let lineSvg = _bb.BB.createSvg({
        elementType: 'svg',
        width: '' + previewSize,
        height: '' + previewSize
    });
    lineSvg.appendChild(lineSvgLine);
    _bb.BB.css(lineSvg, {
        display: 'block'
    });
    function updatePreviews() {
        let strokeWidth = _bb.BB.clamp(Math.round(lineWidthSlider.getValue() / 10), 1, 10) + 'px';
        let squish = 1.35;
        _bb.BB.css(rectStrokeSvgRect, {
            fill: 'none',
            stroke: 'black',
            strokeWidth: strokeWidth
        });
        _bb.BB.css(rectFilledSvgRect, {
            fill: 'black',
            stroke: 'none'
        });
        _bb.BB.css(ellipseStrokeSvgEllipse, {
            fill: 'none',
            stroke: 'black',
            strokeWidth: strokeWidth
        });
        _bb.BB.css(ellipseFilledSvgEllipse, {
            fill: 'black',
            stroke: 'none'
        });
        _bb.BB.css(lineSvgLine, {
            fill: 'none',
            stroke: 'black',
            strokeWidth: strokeWidth
        });
        if (fixedToggle.getValue()) {
            rectStrokeSvgRect.setAttribute('y', '' + previewPadding);
            rectStrokeSvgRect.setAttribute('height', '' + (previewSize - previewPadding * 2));
            rectFilledSvgRect.setAttribute('y', '' + previewPadding);
            rectFilledSvgRect.setAttribute('height', '' + (previewSize - previewPadding * 2));
            ellipseStrokeSvgEllipse.setAttribute('ry', '' + (previewSize / 2 - previewPadding));
            ellipseFilledSvgEllipse.setAttribute('ry', '' + (previewSize / 2 - previewPadding));
        } else {
            rectStrokeSvgRect.setAttribute('y', '' + previewPadding * squish);
            rectStrokeSvgRect.setAttribute('height', '' + (previewSize - previewPadding * squish * 2));
            rectFilledSvgRect.setAttribute('y', '' + previewPadding * squish);
            rectFilledSvgRect.setAttribute('height', '' + (previewSize - previewPadding * squish * 2));
            ellipseStrokeSvgEllipse.setAttribute('ry', '' + (previewSize / 2 - previewPadding * squish));
            ellipseFilledSvgEllipse.setAttribute('ry', '' + (previewSize / 2 - previewPadding * squish));
        }
        if (snapToggle.getValue()) {
            lineSvgLine.setAttribute('y1', '' + (previewSize - previewPadding));
            lineSvgLine.setAttribute('y2', '' + previewPadding);
        } else {
            lineSvgLine.setAttribute('y1', '' + (previewSize - previewPadding * squish));
            lineSvgLine.setAttribute('y2', '' + previewPadding * squish);
        }
    }
    let row1 = _bb.BB.el({
        parent: div,
        css: {
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'start'
        }
    });
    let shapeOptions = new _options.Options({
        optionArr: [
            {
                id: 'rect-stroke',
                label: rectStrokeSvg,
                title: _language.LANG('shape-rect') + ' ' + _language.LANG('shape-stroke')
            },
            {
                id: 'ellipse-stroke',
                label: ellipseStrokeSvg,
                title: _language.LANG('shape-ellipse') + ' ' + _language.LANG('shape-stroke')
            },
            {
                id: 'line',
                label: lineSvg,
                title: _language.LANG('shape-line')
            },
            {
                id: 'rect-fill',
                label: rectFilledSvg,
                title: _language.LANG('shape-rect') + ' ' + _language.LANG('shape-fill')
            },
            {
                id: 'ellipse-fill',
                label: ellipseFilledSvg,
                title: _language.LANG('shape-ellipse') + ' ' + _language.LANG('shape-fill')
            }, 
        ],
        initId: 'rect',
        onChange: function(id) {
            let split = id.split('-');
            shape = split[0];
            mode = split[1];
            _bb.BB.css(fixedToggle.getElement(), {
                display: shape === 'line' ? 'none' : null
            });
            _bb.BB.css(snapToggle.getElement(), {
                display: shape === 'line' ? null : 'none'
            });
            _bb.BB.css(lineWidthSlider.getElement(), {
                display: shape !== 'line' && mode === 'fill' ? 'none' : null
            });
        },
        changeOnInit: true
    });
    shapeOptions.getElement().style.width = '120px';
    row1.appendChild(shapeOptions.getElement());
    let eraserToggle = new _checkbox.Checkbox({
        init: false,
        label: _language.LANG('eraser'),
        callback: function(b) {
            updatePreviews();
        }
    });
    row1.appendChild(eraserToggle.getElement());
    let lineWidthSlider = new _klSlider.KlSlider({
        label: _language.LANG('shape-line-width'),
        width: 250,
        height: 30,
        min: 1,
        max: 200,
        initValue: 4,
        curve: 'quadratic',
        onChange: function(val) {
            updatePreviews();
        },
        formatFunc: function(v) {
            return Math.round(v);
        }
    });
    _bb.BB.css(lineWidthSlider.getElement(), {
        marginTop: '10px'
    });
    div.appendChild(lineWidthSlider.getElement());
    let opacitySlider = new _klSlider.KlSlider({
        label: _language.LANG('opacity'),
        width: 250,
        height: 30,
        min: 0,
        max: 1,
        initValue: 1,
        onChange: function(val) {
        },
        formatFunc: function(v) {
            return Math.round(v * 100);
        }
    });
    _bb.BB.css(opacitySlider.getElement(), {
        marginTop: '10px'
    });
    div.appendChild(opacitySlider.getElement());
    let row2 = _bb.BB.el({
        parent: div,
        css: {
            display: 'flex',
            alignItems: 'center',
            marginTop: '10px'
        }
    });
    let outwardsToggle = new _checkbox.Checkbox({
        init: false,
        label: _language.LANG('shape-outwards'),
        callback: function(b) {
        },
        css: {
            width: '50%',
            marginRight: '10px'
        }
    });
    row2.appendChild(outwardsToggle.getElement());
    let fixedToggle = new _checkbox.Checkbox({
        init: false,
        label: _language.LANG('shape-fixed'),
        callback: function(b) {
            updatePreviews();
        },
        css: {
            flexGrow: '1'
        }
    });
    row2.appendChild(fixedToggle.getElement());
    let snapToggle = new _checkbox.Checkbox({
        init: false,
        label: _language.LANG('shape-snap'),
        title: _language.LANG('shape-snap-title'),
        callback: function(b) {
            updatePreviews();
        },
        css: {
            flexGrow: '1'
        }
    });
    row2.appendChild(snapToggle.getElement());
    updatePreviews();
    // --- interface ---
    this.getElement = function() {
        return div;
    };
    this.setIsVisible = function(pIsVisible) {
        isVisible = !!pIsVisible;
        div.style.display = isVisible ? 'block' : 'none';
        if (isVisible) {
            colorDiv.appendChild(p.colorSlider.getElement());
            colorDiv.appendChild(p.colorSlider.getOutputElement());
        //update();
        }
    };
    this.getShape = function() {
        return shape;
    };
    this.getMode = function() {
        return mode;
    };
    this.getIsEraser = function() {
        return eraserToggle.getValue();
    };
    this.getOpacity = function() {
        return opacitySlider.getValue();
    };
    this.getLineWidth = function() {
        return lineWidthSlider.getValue();
    };
    this.getIsOutwards = function() {
        return outwardsToggle.getValue();
    };
    this.getIsFixed = function() {
        return fixedToggle.getValue();
    };
    this.getIsSnap = function() {
        return snapToggle.getValue();
    };
}

},{"../../../bb/bb":"e3nbn","../base-components/options":"b8ZKE","../base-components/checkbox":"clzcQ","../base-components/kl-slider":"1Vedp","../../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fQl05":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * P = {
 *     currentColor: RGB, // current color
 *     secondaryColor: RGB,
 *     maxCanvasSize: number,
 *     canvasWidth: number, // current canvas size
 *     canvasHeight: number, // current canvas size
 *     workspaceWidth: number,
 *     workspaceHeight: number,
 *     onConfirm: function(width number, height number, color RGBA),
 *     onCancel: function()
 * }
 *
 * @param p
 */ parcelHelpers.export(exports, "newImageDialog", ()=>newImageDialog
);
var _bb = require("../../../bb/bb");
var _select = require("../base-components/select");
var _colorOptions = require("../base-components/color-options");
var _popup = require("./popup");
var _language = require("../../../language/language");
function newImageDialog(p) {
    let currentColor = p.currentColor;
    let secondaryColor = p.secondaryColor;
    let maxCanvasSize = p.maxCanvasSize;
    let canvasWidth = p.canvasWidth;
    let canvasHeight = p.canvasHeight;
    let workspaceWidth = p.workspaceWidth;
    let workspaceHeight = p.workspaceHeight;
    let onConfirm = p.onConfirm;
    let onCancel = p.onCancel;
    function createRatioSize(ratioX, ratioY, width, height, padding) {
        return _bb.BB.fitInto(ratioX, ratioY, Math.min(maxCanvasSize, width - padding), Math.min(maxCanvasSize, height - padding), 1);
    }
    let newImDiv = document.createElement("div");
    let widthWrapper = document.createElement("div");
    let heightWrapper = document.createElement("div");
    let widthInput = document.createElement("input");
    let widthUnit = document.createElement("div");
    let heightInput = document.createElement("input");
    let heightUnit = document.createElement("div");
    widthWrapper.style.position = "relative";
    widthWrapper.style.width = "145px";
    widthWrapper.style.height = "35px";
    widthWrapper.style.lineHeight = "30px";
    heightWrapper.style.width = "145px";
    heightWrapper.style.height = "35px";
    heightWrapper.style.lineHeight = "30px";
    widthUnit.innerText = _language.LANG('new-px');
    widthUnit.style.color = '#888';
    widthUnit.style.fontSize = "12px";
    widthUnit.style.marginLeft = "5px";
    widthUnit.style.cssFloat = "right";
    heightUnit.innerText = _language.LANG('new-px');
    heightUnit.style.color = '#888';
    heightUnit.style.fontSize = "12px";
    heightUnit.style.marginLeft = "5px";
    heightUnit.style.cssFloat = "right";
    widthInput.setAttribute('data-ignore-focus', 'true');
    heightInput.setAttribute('data-ignore-focus', 'true');
    widthInput.type = 'number';
    widthInput.min = '1';
    widthInput.max = maxCanvasSize;
    widthInput.style.cssFloat = "right";
    widthInput.style.width = "70px";
    heightInput.type = 'number';
    heightInput.min = '1';
    heightInput.max = maxCanvasSize;
    heightInput.style.cssFloat = "right";
    heightInput.style.width = "70px";
    widthInput.value = canvasWidth;
    heightInput.value = canvasHeight;
    widthInput.onclick = function() {
        this.focus();
        updateRatio();
    };
    heightInput.onclick = function() {
        this.focus();
        updateRatio();
    };
    widthWrapper.appendChild(widthUnit);
    widthWrapper.appendChild(widthInput);
    _bb.BB.appendTextDiv(widthWrapper, _language.LANG('width') + ": ");
    heightWrapper.appendChild(heightUnit);
    heightWrapper.appendChild(heightInput);
    _bb.BB.appendTextDiv(heightWrapper, _language.LANG('height') + ": ");
    let ratioWrapper = document.createElement("div");
    ratioWrapper.style.marginTop = '5px';
    ratioWrapper.style.color = '#888';
    let templateWrapper = document.createElement("div");
    //BB.appendTextDiv(templateWrapper, "Preset Resolutions: <br />");
    let presetFitBtn = document.createElement("button");
    templateWrapper.style.marginBottom = "10px";
    let presetCurrentBtn = document.createElement("button");
    let presetSquareBtn = document.createElement("button");
    let presetLandscapeBtn = document.createElement("button");
    let presetPortraitBtn = document.createElement("button");
    let presetOversizeBtn = document.createElement("button");
    presetCurrentBtn.textContent = _language.LANG('new-current');
    presetFitBtn.textContent = _language.LANG('new-fit');
    presetOversizeBtn.textContent = _language.LANG('new-oversize');
    presetLandscapeBtn.textContent = _language.LANG('new-landscape');
    presetPortraitBtn.textContent = _language.LANG('new-portrait');
    presetSquareBtn.textContent = _language.LANG('new-square');
    presetCurrentBtn.style.marginRight = "5px";
    presetFitBtn.style.marginRight = "5px";
    presetOversizeBtn.style.marginRight = "5px";
    presetLandscapeBtn.style.marginTop = "5px";
    presetLandscapeBtn.style.marginRight = "5px";
    presetPortraitBtn.style.marginTop = "5px";
    presetPortraitBtn.style.marginRight = "5px";
    templateWrapper.appendChild(presetCurrentBtn);
    templateWrapper.appendChild(presetFitBtn);
    templateWrapper.appendChild(presetOversizeBtn);
    templateWrapper.appendChild(presetSquareBtn);
    templateWrapper.appendChild(presetLandscapeBtn);
    templateWrapper.appendChild(presetPortraitBtn);
    let templatePadding = 50;
    presetCurrentBtn.onclick = function() {
        widthInput.value = canvasWidth;
        heightInput.value = canvasHeight;
        updateRatio();
    };
    presetFitBtn.onclick = function() {
        widthInput.value = workspaceWidth;
        heightInput.value = workspaceHeight;
        updateRatio();
    };
    presetOversizeBtn.onclick = function() {
        widthInput.value = workspaceWidth + 500;
        heightInput.value = workspaceHeight + 500;
        updateRatio();
    };
    presetSquareBtn.onclick = function() {
        let sizeObj = createRatioSize(1, 1, workspaceWidth, workspaceHeight, templatePadding);
        widthInput.value = '' + Math.round(sizeObj.width);
        heightInput.value = '' + Math.round(sizeObj.height);
        updateRatio();
    };
    presetLandscapeBtn.onclick = function() {
        let sizeObj = createRatioSize(4, 3, workspaceWidth, workspaceHeight, templatePadding);
        widthInput.value = '' + Math.round(sizeObj.width);
        heightInput.value = '' + Math.round(sizeObj.height);
        updateRatio();
    };
    presetPortraitBtn.onclick = function() {
        let sizeObj = createRatioSize(3, 4, workspaceWidth, workspaceHeight, templatePadding);
        widthInput.value = '' + Math.round(sizeObj.width);
        heightInput.value = '' + Math.round(sizeObj.height);
        updateRatio();
    };
    let select = new _select.Select({
        isFocusable: true,
        optionArr: [
            [
                'screen',
                _language.LANG('new-screen')
            ],
            [
                '16 9',
                _language.LANG('new-video') + ' 16:9'
            ],
            [
                '3 2',
                '3:2'
            ],
            [
                '5 3',
                '5:3'
            ],
            [
                '2 1',
                '2:1'
            ],
            [
                'paper',
                _language.LANG('new-din-paper') + ' √2:1'
            ],
            [
                '9 16',
                '9:16'
            ],
            [
                '2 3',
                '2:3'
            ],
            [
                '3 5',
                '3:5'
            ],
            [
                '1 2',
                '1:2'
            ],
            [
                '1 1.4142135623730951',
                '1:√2'
            ]
        ],
        onChange: function(val) {
            if (val === 'screen') {
                widthInput.value = '' + window.screen.width;
                heightInput.value = '' + window.screen.height;
            } else if (val === 'paper') {
                let sizeObj = createRatioSize(Math.sqrt(2), 1, workspaceWidth, workspaceHeight, templatePadding);
                widthInput.value = '' + Math.round(sizeObj.width);
                heightInput.value = '' + Math.round(sizeObj.height);
            } else {
                let split = val.split(' ');
                let sizeObj = createRatioSize(parseFloat(split[0]), parseFloat(split[1]), workspaceWidth, workspaceHeight, templatePadding);
                widthInput.value = '' + Math.round(sizeObj.width);
                heightInput.value = '' + Math.round(sizeObj.height);
            }
            updateRatio();
            select.setValue(null);
        }
    });
    setTimeout(()=>{
        // safari: not empty without also setting it to null via timeout
        select.setValue(null);
    }, 0);
    _bb.BB.css(select.getElement(), {
        width: '80px'
    });
    templateWrapper.appendChild(select.getElement());
    let backgroundRGBA = {
        r: 255,
        g: 255,
        b: 255,
        a: 1
    };
    let colorOptionsArr = [
        {
            r: 255,
            g: 255,
            b: 255,
            a: 1
        },
        {
            r: 0,
            g: 0,
            b: 0,
            a: 1
        },
        {
            r: 0,
            g: 0,
            b: 0,
            a: 0
        }
    ];
    colorOptionsArr.push({
        r: currentColor.r,
        g: currentColor.g,
        b: currentColor.b,
        a: 1
    });
    colorOptionsArr.push({
        r: secondaryColor.r,
        g: secondaryColor.g,
        b: secondaryColor.b,
        a: 1
    });
    let colorOptions = new _colorOptions.ColorOptions({
        colorArr: colorOptionsArr,
        onChange: function(rgbaObj) {
            backgroundRGBA = rgbaObj;
            preview.style.backgroundColor = "rgba(" + rgbaObj.r + "," + rgbaObj.g + "," + rgbaObj.b + ", " + rgbaObj.a + ")";
        }
    });
    let previewWrapper = document.createElement("div");
    _bb.BB.css(previewWrapper, {
        boxSizing: 'border-box',
        width: '340px',
        height: '140px',
        display: 'table',
        backgroundColor: '#9e9e9e',
        padding: '10px',
        marginTop: '10px',
        boxShadow: 'rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset',
        marginLeft: '-20px',
        colorScheme: 'only light'
    });
    let preview = document.createElement("div");
    _bb.BB.css(preview, {
        width: "200px",
        height: "100px",
        backgroundColor: "#fff",
        marginLeft: "auto",
        marginRight: "auto",
        color: "#aaa",
        fontSize: "16px",
        fontWeight: "bold",
        textAlign: "center",
        verticalAlign: "center",
        display: "table",
        overflow: "hidden",
        boxShadow: "0px 0px 3px rgba(0,0,0,0.5)"
    });
    let previewcell = document.createElement("div");
    previewcell.style.display = "table-cell";
    previewcell.style.verticalAlign = "middle";
    previewcell.appendChild(preview);
    previewWrapper.appendChild(previewcell);
    let cell = _bb.BB.appendTextDiv(preview, "");
    //let ratio = BB.appendTextDiv(cell, "1:2");
    cell.style.display = "table-cell";
    cell.style.verticalAlign = "middle";
    let prevW = parseInt(widthInput.value);
    let prevH = parseInt(heightInput.value);
    function updateRatio() {
        widthInput.value = '' + Math.min(maxCanvasSize, parseInt(widthInput.value));
        heightInput.value = '' + Math.min(maxCanvasSize, parseInt(heightInput.value));
        function HCF(u, v) {
            let U = u, V = v;
            while(true){
                if (!(U %= V)) return V;
                if (!(V %= U)) return U;
            }
        }
        let w = parseInt(widthInput.value);
        let h = parseInt(heightInput.value);
        if (w < 1 || w > maxCanvasSize || h < 1 || h > maxCanvasSize) {
            if (w > maxCanvasSize) w = maxCanvasSize;
            else if (h > maxCanvasSize) h = maxCanvasSize;
            widthInput.value = '' + w;
            heightInput.value = '' + h;
        }
        //generated canvas size doesn't always match ratio. so check if a common ratio is very close
        let commonRatios = [
            [
                1,
                2
            ],
            [
                2,
                1
            ],
            [
                2,
                3
            ],
            [
                3,
                2
            ],
            [
                3,
                4
            ],
            [
                4,
                3
            ],
            [
                4,
                5
            ],
            [
                5,
                4
            ],
            [
                16,
                9
            ],
            [
                9,
                16
            ],
            [
                3,
                2
            ],
            [
                2,
                3
            ],
            [
                5,
                3
            ],
            [
                3,
                5
            ],
            [
                2,
                1
            ],
            [
                1,
                2
            ],
            [
                1.414,
                1
            ],
            [
                1,
                1.414
            ], 
        ];
        let reducedArr = _bb.BB.reduce(w, h);
        let closestRatio = null;
        let closestDistance = null;
        for(let i = 0; i < commonRatios.length; i++)if (i === 0 || Math.abs(commonRatios[i][0] / commonRatios[i][1] - reducedArr[0] / reducedArr[1]) < closestDistance) {
            closestRatio = commonRatios[i];
            closestDistance = Math.abs(commonRatios[i][0] / commonRatios[i][1] - reducedArr[0] / reducedArr[1]);
        }
        //display ratio
        if (closestDistance > 0 && closestDistance < 0.005) ratioWrapper.innerText = _language.LANG('new-ratio') + ': ~' + closestRatio[0] + ':' + closestRatio[1];
        else ratioWrapper.innerText = _language.LANG('new-ratio') + ': ' + reducedArr[0] + ':' + reducedArr[1];
        prevW = w;
        prevH = h;
        let realw = w;
        let T = HCF(w, h);
        w /= T;
        h /= T;
        w *= 260;
        h *= 260;
        if (w > 260) {
            h = 260 / w * h;
            w = 260;
        }
        if (h > 100) {
            w = 100 / h * w;
            h = 100;
        }
        preview.style.width = w + "px";
        preview.style.height = h + "px";
        _bb.BB.createCheckerDataUrl(parseInt('' + 30 * (w / realw)), function(url) {
            previewWrapper.style.background = "url(" + url + ")";
        });
    }
    widthInput.onchange = function() {
        if (widthInput.value === '' || parseInt(widthInput.value) < 0) widthInput.value = '1';
        updateRatio();
    };
    widthInput.onkeyup = function() {
        updateRatio();
    };
    heightInput.onchange = function() {
        if (heightInput.value === '' || parseFloat(heightInput.value) < 0) heightInput.value = '1';
        updateRatio();
    };
    heightInput.onkeyup = function() {
        updateRatio();
    };
    updateRatio();
    newImDiv.appendChild(templateWrapper);
    let secondRow = _bb.BB.el({
        parent: newImDiv,
        css: {
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'flex-end'
        }
    });
    let secondRowLeft = _bb.BB.el({
        parent: secondRow
    });
    secondRowLeft.appendChild(widthWrapper);
    secondRowLeft.appendChild(heightWrapper);
    secondRowLeft.appendChild(ratioWrapper);
    secondRow.appendChild(colorOptions.getElement());
    newImDiv.appendChild(previewWrapper);
    _popup.popup({
        target: document.body,
        message: `<b>${_language.LANG('new-title')}</b>`,
        div: newImDiv,
        buttons: [
            'Ok',
            'Cancel'
        ],
        callback: function(result) {
            widthInput.onclick = null;
            heightInput.onclick = null;
            presetCurrentBtn.onclick = null;
            presetFitBtn.onclick = null;
            presetOversizeBtn.onclick = null;
            presetSquareBtn.onclick = null;
            presetLandscapeBtn.onclick = null;
            presetPortraitBtn.onclick = null;
            widthInput.onchange = null;
            widthInput.onkeyup = null;
            heightInput.onchange = null;
            heightInput.onkeyup = null;
            select.destroy();
            colorOptions.destroy();
            if (result === "Cancel" || parseInt(widthInput.value) <= 0 || parseInt(heightInput.value) <= 0 || isNaN(parseInt(widthInput.value)) || isNaN(parseInt(heightInput.value))) {
                onCancel();
                return;
            }
            onConfirm(parseInt(widthInput.value), parseInt(heightInput.value), backgroundRGBA);
        },
        clickOnEnter: 'Ok'
    });
}

},{"../../../bb/bb":"e3nbn","../base-components/select":"gIUAj","../base-components/color-options":"6ALHb","./popup":"7D028","../../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hgEFd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * button that allows to collapse toolspace (for mobile)
 *
 * p = {
 *     onChange: function()
 * }
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "ToolspaceCollapser", ()=>ToolspaceCollapser
);
var _bb = require("../../../bb/bb");
// @ts-ignore
var _uiCollapseSvg = require("url:~/src/app/img/ui/ui-collapse.svg");
var _uiCollapseSvgDefault = parcelHelpers.interopDefault(_uiCollapseSvg);
var _language = require("../../../language/language");
function ToolspaceCollapser(p) {
    let isOpen = true;
    let directionStr = 'right'; // 'left' | 'right'
    function update() {
        if (directionStr === 'left') icon.style.transform = isOpen ? 'rotate(180deg)' : '';
        else icon.style.transform = isOpen ? '' : 'rotate(180deg)';
    }
    let div = _bb.BB.el({
        css: {
            width: '36px',
            height: '36px',
            background: 'rgba(100, 100, 100, 0.9)',
            color: '#fff',
            position: 'absolute',
            top: '0',
            textAlign: 'center',
            lineHeight: '36px',
            cursor: 'pointer',
            userSelect: 'none',
            padding: '6px',
            boxSizing: 'border-box'
        },
        title: _language.LANG('toggle-show-tools'),
        onClick: function(e) {
            e.preventDefault();
            isOpen = !isOpen;
            update();
            p.onChange();
        },
        id: "ngungu"
    });
    let icon = _bb.BB.el({
        parent: div,
        css: {
            backgroundImage: `url(${_uiCollapseSvgDefault.default})`,
            width: '100%',
            height: '100%',
            backgroundSize: 'contain',
            backgroundRepeat: 'no-repeat',
            backgroundPosition: 'center',
            userSelect: 'none'
        }
    });
    div.oncontextmenu = function() {
        return false;
    };
    // --- interface ---
    this.isOpen = function() {
        return isOpen;
    };
    /**
     *
     * @param dirStr
     */ this.setDirection = function(dirStr) {
        directionStr = dirStr;
        update();
    };
    this.getElement = function() {
        return div;
    };
}

},{"../../../bb/bb":"e3nbn","url:~/src/app/img/ui/ui-collapse.svg":"2na8o","../../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"2na8o":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "ui-collapse.2d379721.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"5Cjgq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Text Tool dialog
 *
 * confirmP = {
 *     x: number,
 *     y: number,
 *     textStr: string,
 *     align: 'left' | 'center' | 'right',
 *     isItalic: boolean,
 *     isBold: boolean,
 *     color: rgb,
 *     size: number, // px
 *     font: 'serif' | 'monospace' | 'sans-serif' | 'cursive' | 'fantasy',
 *     opacity: number, // 0 - 1
 * }
 *
 * @param p
 */ parcelHelpers.export(exports, "textToolDialog", ()=>textToolDialog
);
var _bb = require("../../../bb/bb");
var _renderText = require("../../image-operations/render-text");
var _colorOptions = require("../base-components/color-options");
var _select = require("../base-components/select");
var _imageRadioList = require("../base-components/image-radio-list");
var _imageToggle = require("../base-components/image-toggle");
var _klSlider = require("../base-components/kl-slider");
var _popup = require("./popup");
// @ts-ignore
var _alignLeftSvg = require("url:~/src/app/img/ui/align-left.svg");
var _alignLeftSvgDefault = parcelHelpers.interopDefault(_alignLeftSvg);
// @ts-ignore
var _alignCenterSvg = require("url:~/src/app/img/ui/align-center.svg");
var _alignCenterSvgDefault = parcelHelpers.interopDefault(_alignCenterSvg);
// @ts-ignore
var _alignRightSvg = require("url:~/src/app/img/ui/align-right.svg");
var _alignRightSvgDefault = parcelHelpers.interopDefault(_alignRightSvg);
// @ts-ignore
var _typoItalicSvg = require("url:~/src/app/img/ui/typo-italic.svg");
var _typoItalicSvgDefault = parcelHelpers.interopDefault(_typoItalicSvg);
// @ts-ignore
var _typoBoldSvg = require("url:~/src/app/img/ui/typo-bold.svg");
var _typoBoldSvgDefault = parcelHelpers.interopDefault(_typoBoldSvg);
// @ts-ignore
var _toolZoomInSvg = require("url:~/src/app/img/ui/tool-zoom-in.svg");
var _toolZoomInSvgDefault = parcelHelpers.interopDefault(_toolZoomInSvg);
// @ts-ignore
var _toolZoomOutSvg = require("url:~/src/app/img/ui/tool-zoom-out.svg");
var _toolZoomOutSvgDefault = parcelHelpers.interopDefault(_toolZoomOutSvg);
var _language = require("../../../language/language");
function textToolDialog(p) {
    let div = _bb.BB.el({
    });
    let isSmallWidth = window.innerWidth < 550;
    let isSmallHeight = window.innerHeight < 630;
    // --- preview ---
    // Text drawn on klCanvas-sized canvas: textCanvas
    // LayerArr[target].canvas & textCanvas then drawn on targetCanvas
    //      they are transformed. canvas size of final preview
    // All layers and targetCanvas drawn on layersCanvas. transformed and size of final preview
    // Checkerboard, layersCanvas, and outline then drawn on previewCanvas
    let width = isSmallWidth ? 340 : 540;
    let height = isSmallWidth ? isSmallHeight ? 210 : 260 : isSmallHeight ? 230 : 350;
    let scale = 1;
    let layerArr = p.klCanvas.getLayersFast();
    let textCanvas = _bb.BB.canvas(p.klCanvas.getWidth(), p.klCanvas.getHeight());
    let textCtx = textCanvas.getContext('2d');
    let targetCanvas = _bb.BB.canvas(width, height);
    let targetCtx = targetCanvas.getContext('2d');
    let layersCanvas = _bb.BB.canvas(width, height);
    let layersCtx = layersCanvas.getContext('2d');
    let previewCanvas = _bb.BB.canvas(width, height); // the one that is visible
    let previewCtx = previewCanvas.getContext('2d');
    _bb.BB.css(previewCanvas, {
        display: 'block'
    });
    let previewWrapper = _bb.BB.el({
        parent: div,
        css: {
            position: 'relative',
            width: width + 'px',
            marginLeft: '-20px',
            cursor: 'move',
            colorScheme: 'only light',
            touchAction: 'none'
        },
        onClick: function() {
            textInput.focus();
        }
    });
    _bb.BB.el({
        parent: previewWrapper,
        css: {
            position: 'absolute',
            left: '0',
            top: '0',
            right: '0',
            bottom: '0',
            boxShadow: 'rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset',
            pointerEvents: 'none'
        }
    });
    previewWrapper.appendChild(previewCanvas);
    let checkerPattern = previewCtx.createPattern(_bb.BB.createCheckerCanvas(8), 'repeat');
    let emptyCanvas = _bb.BB.canvas(1, 1);
    {
        let ctx = emptyCanvas.getContext('2d');
        ctx.fillRect(0, 0, 1, 1);
    }
    function updatePreview() {
        // try to draw very much like klCanvasWorkspace
        // --- draw text ---
        textCtx.clearRect(0, 0, textCanvas.width, textCanvas.height);
        let colorRGBA = {
            ...p.color,
            a: opacitySlider.getValue()
        };
        let bounds = _renderText.renderText(textCanvas, {
            x: p.x,
            y: p.y,
            textStr: textInput.value,
            align: alignRadioList.getValue(),
            isItalic: italicToggle.getValue(),
            isBold: boldToggle.getValue(),
            size: parseFloat(sizeInput.value),
            font: fontSelect.getValue(),
            color: _bb.BB.ColorConverter.toRgbaStr(colorRGBA),
            angleRad: p.angleRad
        });
        // --- determine transformation of viewport ---
        // text should always be visible
        bounds.width = Math.max(bounds.width, 1);
        bounds.height = Math.max(bounds.height, 1);
        let rotatedXY = _bb.BB.rotate(bounds.x, bounds.y, -p.angleRad / Math.PI * 180);
        let rotatedWH = _bb.BB.rotate(bounds.width, bounds.height, -p.angleRad / Math.PI * 180);
        let centerX = p.x + rotatedXY.x + rotatedWH.x / 2;
        let centerY = p.y + rotatedXY.y + rotatedWH.y / 2;
        let padding = 100;
        let fitBounds = _bb.BB.fitInto(bounds.width, bounds.height, width - padding, height - padding);
        scale = Math.min(1, fitBounds.width / bounds.width);
        scale = Math.min(4, scale * Math.pow(2, zoomFac));
        // --- compose text and target layer ---
        targetCtx.save();
        if (scale >= 4) targetCtx.imageSmoothingEnabled = false;
        else {
            targetCtx.imageSmoothingEnabled = true;
            targetCtx.imageSmoothingQuality = scale >= 1 ? 'low' : 'medium';
        }
        targetCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
        targetCtx.translate(width / 2, height / 2);
        targetCtx.scale(scale, scale);
        targetCtx.rotate(p.angleRad);
        targetCtx.drawImage(layerArr[p.layerIndex].canvas, -centerX, -centerY);
        targetCtx.drawImage(textCanvas, -centerX, -centerY);
        targetCtx.restore();
        // --- layers ---
        layersCtx.save();
        layersCtx.fillStyle = 'rgb(158,158,158)';
        layersCtx.fillRect(0, 0, width, height);
        {
            layersCtx.save();
            layersCtx.translate(width / 2, height / 2);
            layersCtx.scale(scale, scale);
            layersCtx.rotate(p.angleRad);
            layersCtx.imageSmoothingEnabled = false;
            //outline
            let borderSize = 1 / scale;
            layersCtx.globalAlpha = 0.2;
            layersCtx.drawImage(emptyCanvas, -centerX - borderSize, -centerY - borderSize, textCanvas.width + borderSize * 2, textCanvas.height + borderSize * 2);
            layersCtx.globalAlpha = 1;
            //erase
            layersCtx.globalCompositeOperation = 'destination-out';
            layersCtx.drawImage(emptyCanvas, -centerX, -centerY, textCanvas.width, textCanvas.height);
            layersCtx.restore();
        }
        if (scale >= 4) layersCtx.imageSmoothingEnabled = false;
        else {
            layersCtx.imageSmoothingEnabled = true;
            layersCtx.imageSmoothingQuality = scale >= 1 ? 'low' : 'medium';
        }
        // layers below
        layersCtx.save();
        layersCtx.translate(width / 2, height / 2);
        layersCtx.scale(scale, scale);
        layersCtx.rotate(p.angleRad);
        for(var i = 0; i < p.layerIndex; i++)if (layerArr[i].opacity > 0) {
            layersCtx.globalAlpha = layerArr[i].opacity;
            layersCtx.globalCompositeOperation = layerArr[i].mixModeStr;
            layersCtx.drawImage(layerArr[i].canvas, -centerX, -centerY);
        }
        layersCtx.restore();
        // target layer
        layersCtx.globalAlpha = layerArr[p.layerIndex].opacity;
        layersCtx.globalCompositeOperation = layerArr[p.layerIndex].mixModeStr;
        layersCtx.drawImage(targetCanvas, 0, 0);
        // layers above
        layersCtx.save();
        layersCtx.translate(width / 2, height / 2);
        layersCtx.scale(scale, scale);
        layersCtx.rotate(p.angleRad);
        for(let i1 = p.layerIndex + 1; i1 < layerArr.length; i1++)if (layerArr[i1].opacity > 0) {
            layersCtx.globalAlpha = layerArr[i1].opacity;
            layersCtx.globalCompositeOperation = layerArr[i1].mixModeStr;
            layersCtx.drawImage(layerArr[i1].canvas, -centerX, -centerY);
        }
        layersCtx.restore();
        layersCtx.restore();
        // --- final composite ---
        previewCtx.save();
        previewCtx.fillStyle = checkerPattern;
        previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
        previewCtx.drawImage(layersCanvas, 0, 0);
        previewCtx.restore();
        // bounds
        previewCtx.save();
        previewCtx.globalCompositeOperation = 'difference';
        previewCtx.strokeStyle = '#fff';
        previewCtx.lineWidth = 1;
        // centerX = p.x + bounds.x + bounds.width / 2;
        // centerY = p.y + bounds.y + bounds.height / 2;
        previewCtx.strokeRect(Math.round(width / 2 - bounds.width / 2 * scale), Math.round(height / 2 - bounds.height / 2 * scale), Math.round(bounds.width * scale), Math.round(bounds.height * scale));
        previewCtx.restore();
    }
    function move(x, y) {
        let rotated = _bb.BB.rotate(x, y, -p.angleRad / Math.PI * 180);
        p.x += rotated.x / scale;
        p.y += rotated.y / scale;
        updatePreview();
    }
    let previewPointerListener = new _bb.BB.PointerListener({
        target: previewCanvas,
        pointers: 1,
        onPointer: function(e) {
            if (e.type === 'pointermove' && e.button) {
                e.eventPreventDefault();
                move(-e.dX, -e.dY);
            }
        },
        onWheel: function(e) {
            changeZoomFac(-e.deltaY);
        }
    });
    const wheelPrevent = (event)=>{
        event.preventDefault();
    };
    _bb.BB.addEventListener(previewCanvas, 'wheel', wheelPrevent);
    let row1 = _bb.BB.el({
        parent: div,
        css: {
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            marginTop: '10px'
        }
    });
    let row2n3Wrapper = _bb.BB.el({
        parent: div,
        css: isSmallWidth ? {
        } : {
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between'
        }
    });
    let row2 = _bb.BB.el({
        parent: row2n3Wrapper,
        css: {
            display: 'flex',
            alignItems: 'center',
            marginTop: '5px'
        }
    });
    let row3 = _bb.BB.el({
        parent: row2n3Wrapper,
        css: {
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
            marginTop: '5px',
            width: isSmallWidth ? '' : '300px'
        }
    });
    // --- row 1 ---
    // color
    let selectedRgbaObj = {
        r: 0,
        g: 0,
        b: 0,
        a: 1
    };
    let colorOptionsArr = [
        {
            r: 0,
            g: 0,
            b: 0,
            a: 1
        },
        {
            r: 255,
            g: 255,
            b: 255,
            a: 1
        }
    ];
    colorOptionsArr.unshift({
        r: p.secondaryColor.r,
        g: p.secondaryColor.g,
        b: p.secondaryColor.b,
        a: 1
    });
    colorOptionsArr.unshift({
        r: p.color.r,
        g: p.color.g,
        b: p.color.b,
        a: 1
    });
    let colorOptions = new _colorOptions.ColorOptions({
        colorArr: colorOptionsArr,
        initialIndex: 0,
        onChange: function(rgbaObj) {
            p.color = rgbaObj;
            updatePreview();
        }
    });
    colorOptions.getElement().title = _language.LANG('text-color');
    colorOptions.getElement().style.marginLeft = '-5px';
    row1.appendChild(colorOptions.getElement());
    let zoomFac = 0;
    function changeZoomFac(d) {
        zoomFac = Math.min(2, Math.max(-2, zoomFac + d));
        updatePreview();
        zoomInBtn.disabled = !canZoom(1);
        zoomOutBtn.disabled = !canZoom(-1);
    }
    function canZoom(d) {
        return zoomFac !== Math.min(2, Math.max(-2, zoomFac + d));
    }
    let zoomWrapper = _bb.BB.el({
        parent: row1,
        css: {
        }
    });
    let zoomInBtn = _bb.BB.el({
        parent: zoomWrapper,
        content: `<img height="20" src="${_toolZoomInSvgDefault.default}">`,
        title: _language.LANG('zoom-in'),
        tagName: 'button',
        onClick: function() {
            changeZoomFac(1);
        },
        css: {
            fontWeight: 'bold'
        }
    });
    let zoomOutBtn = _bb.BB.el({
        parent: zoomWrapper,
        content: `<img height="20" src="${_toolZoomOutSvgDefault.default}">`,
        title: _language.LANG('zoom-out'),
        tagName: 'button',
        onClick: function() {
            changeZoomFac(-1);
        },
        css: {
            fontWeight: 'bold',
            marginLeft: '5px'
        }
    });
    // --- row 2 ---
    let sizeInput = _bb.BB.el({
        parent: row2,
        tagName: 'input',
        title: _language.LANG('text-size'),
        custom: {
            type: 'number',
            min: 1,
            max: 10000,
            value: p.size
        },
        css: {
            width: '60px'
        },
        onChange: function() {
            sizeInput.value = '' + Math.max(1, Math.min(10000, parseInt(sizeInput.value)));
            updatePreview();
        }
    });
    let sizePointerListener = new _bb.BB.PointerListener({
        target: sizeInput,
        onWheel: function(e) {
            sizeInput.value = '' + Math.max(1, Math.min(1000, parseInt(sizeInput.value) - e.deltaY));
            updatePreview();
        }
    });
    let modeWrapper;
    let fontSelect;
    let fontPointerListener;
    modeWrapper = _bb.BB.el({
        css: {
            fontSize: '15px',
            marginLeft: '10px'
        }
    });
    fontSelect = new _select.Select({
        isFocusable: true,
        optionArr: [
            [
                'sans-serif',
                'Sans-serif'
            ],
            [
                'serif',
                'Serif'
            ],
            [
                'monospace',
                'Monospace'
            ],
            [
                'cursive',
                'Cursive'
            ],
            [
                'fantasy',
                'Fantasy'
            ], 
        ],
        initValue: p.font,
        onChange: function(val) {
            updatePreview();
        }
    });
    modeWrapper.appendChild(fontSelect.getElement());
    row2.appendChild(modeWrapper);
    fontPointerListener = new _bb.BB.PointerListener({
        target: fontSelect.getElement(),
        onWheel: function(e) {
            fontSelect.setDeltaValue(e.deltaY);
        }
    });
    // --- row 3 ---
    let alignRadioList = new _imageRadioList.ImageRadioList({
        optionArr: [
            {
                id: 'left',
                title: _language.LANG('text-left'),
                image: _alignLeftSvgDefault.default
            },
            {
                id: 'center',
                title: _language.LANG('text-center'),
                image: _alignCenterSvgDefault.default
            },
            {
                id: 'right',
                title: _language.LANG('text-right'),
                image: _alignRightSvgDefault.default
            }
        ],
        initId: p.align,
        onChange: function(id) {
            updatePreview();
        }
    });
    row3.appendChild(alignRadioList.getElement());
    let italicToggle = new _imageToggle.ImageToggle({
        image: _typoItalicSvgDefault.default,
        title: _language.LANG('text-italic'),
        initValue: p.isItalic,
        onChange: function(b) {
            updatePreview();
        }
    });
    row3.appendChild(italicToggle.getElement());
    let boldToggle = new _imageToggle.ImageToggle({
        image: _typoBoldSvgDefault.default,
        title: _language.LANG('text-bold'),
        initValue: p.isBold,
        onChange: function(b) {
            updatePreview();
        }
    });
    row3.appendChild(boldToggle.getElement());
    let opacitySlider = new _klSlider.KlSlider({
        label: _language.LANG('opacity'),
        width: 150,
        height: 30,
        min: 0,
        max: 1,
        initValue: p.opacity,
        resolution: 225,
        eventResMs: 1000 / 30,
        onChange: function(v) {
            updatePreview();
        },
        formatFunc: function(v) {
            return Math.round(v * 100);
        }
    });
    row3.appendChild(opacitySlider.getElement());
    let textInput = _bb.BB.el({
        parent: div,
        tagName: 'textarea',
        custom: {
            placeholder: _language.LANG('text-placeholder'),
            'data-ignore-focus': 'true'
        },
        css: {
            whiteSpace: 'nowrap',
            overflow: 'auto',
            width: '100%',
            height: '70px',
            resize: 'vertical',
            marginTop: '10px'
        },
        onChange: function() {
            updatePreview();
        }
    });
    textInput.addEventListener('input', updatePreview);
    setTimeout(function() {
        textInput.focus();
        textInput.select();
    });
    let closefunc;
    let keyListener = new _bb.BB.KeyListener({
        onDown: function(keyStr, e, comboStr) {
            if (_bb.BB.isInputFocused(true)) return;
            if (keyStr === 'left') move(-1, 0);
            if (keyStr === 'right') move(1, 0);
            if (keyStr === 'up') move(0, -1);
            if (keyStr === 'down') move(0, 1);
        }
    });
    // prevent mobile keyboards scrolling page
    function onScroll() {
        window.scrollTo(0, 0);
    }
    window.addEventListener('scroll', onScroll);
    _popup.popup({
        target: document.body,
        message: `<b>${_language.LANG('text-title')}</b>`,
        div: div,
        buttons: [
            "Ok",
            "Cancel"
        ],
        style: isSmallWidth ? {
        } : {
            width: '500px'
        },
        callback: function(val) {
            window.removeEventListener('scroll', onScroll);
            previewPointerListener.destroy();
            sizePointerListener.destroy();
            fontPointerListener.destroy();
            _bb.BB.removeEventListener(previewCanvas, 'wheel', wheelPrevent);
            keyListener.destroy();
            if (val === 'Ok') p.onConfirm({
                x: p.x,
                y: p.y,
                textStr: textInput.value,
                align: alignRadioList.getValue(),
                isItalic: italicToggle.getValue(),
                isBold: boldToggle.getValue(),
                color: p.color,
                size: sizeInput.value,
                font: fontSelect.getValue(),
                opacity: opacitySlider.getValue()
            });
        },
        autoFocus: false,
        clickOnEnter: 'Ok',
        ignoreBackground: true,
        closefunc: function(func) {
            closefunc = func;
        }
    });
    updatePreview();
}

},{"../../../bb/bb":"e3nbn","../../image-operations/render-text":"amc9m","../base-components/color-options":"6ALHb","../base-components/select":"gIUAj","../base-components/image-radio-list":"jngG4","../base-components/image-toggle":"85Ix1","../base-components/kl-slider":"1Vedp","./popup":"7D028","url:~/src/app/img/ui/align-left.svg":"iR1C2","url:~/src/app/img/ui/align-center.svg":"8RAKW","url:~/src/app/img/ui/align-right.svg":"cy1a0","url:~/src/app/img/ui/typo-italic.svg":"WPJDg","url:~/src/app/img/ui/typo-bold.svg":"6xf3b","url:~/src/app/img/ui/tool-zoom-in.svg":"eIVnd","url:~/src/app/img/ui/tool-zoom-out.svg":"6KJcL","../../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"iR1C2":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "align-left.c65ead74.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"8RAKW":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "align-center.1457bc63.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"cy1a0":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "align-right.c6d9fa49.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"WPJDg":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "typo-italic.1add9568.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"6xf3b":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "typo-bold.cae38600.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"dtyfo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 *
 * p = {
 *     image: convertedPsd | {type: 'image', width: number, height: number, canvas: image | canvas},
 *     maxSize: number,
 *     target: htmlElement,
 *     callback: func(
 *         {
 *             type: 'as-image',
 *             image: image | canvas,
 *         } | {
 *             type: 'as-image-psd',
 *             image: convertedPsd,
 *             cropObj: {x: number, y: number, width: number, height: number}
 *         } | {
 *             type: 'as-layer',
 *             image: image | canvas,
 *         } | {
 *             type: 'cancel',
 *         }
 *     )
 * }
 *
 * @param p {}
 */ parcelHelpers.export(exports, "showImportImageDialog", ()=>showImportImageDialog
);
var _bb = require("../../../bb/bb");
var _cropCopy = require("../components/crop-copy");
var _checkbox = require("../base-components/checkbox");
var _popup = require("./popup");
var _language = require("../../../language/language");
function showImportImageDialog(p) {
    const div = _bb.BB.el({
    });
    const isSmall = window.innerWidth < 550 || window.innerHeight < 550;
    const style = isSmall ? {
    } : {
        width: '500px'
    };
    let resolutionEl;
    const cropCopy = new _cropCopy.CropCopy({
        width: isSmall ? 340 : 540,
        height: isSmall ? 300 : 400,
        canvas: p.image.canvas,
        isNotCopy: true,
        onChange: function(width, height) {
            if (!resolutionEl) return;
            updateResolution(width, height);
        }
    });
    _bb.BB.css(cropCopy.getEl(), {
        marginLeft: '-20px',
        borderTop: '1px solid #bbb',
        borderBottom: '1px solid #bbb'
    });
    cropCopy.getEl().title = _language.LANG('crop-drag-to-crop');
    div.appendChild(cropCopy.getEl());
    resolutionEl = _bb.BB.el({
        parent: div,
        css: {
            marginTop: '10px',
            textAlign: 'center',
            color: '#888',
            lineHeight: '20px'
        }
    });
    function updateResolution(w, h) {
        const fit = _bb.BB.fitInto(w, h, p.maxSize, p.maxSize);
        if (fit.width < w) {
            resolutionEl.innerHTML = `<span style="color:#f00">${w} X ${h}</span> ⟶ ${Math.round(fit.width)} X ${Math.round(fit.height)}`;
            resolutionEl.title = _language.LANG('import-too-large');
        } else {
            resolutionEl.innerHTML = `${w} X ${h}`;
            resolutionEl.title = '';
        }
    }
    updateResolution(p.image.width, p.image.height);
    let doFlatten = false;
    function showWarnings(psdWarningArr) {
        let contentArr = [];
        let warningMap = {
            'mask': 'Masks not supported. Mask was applied.',
            'clipping': 'Clipping not supported. Clipping layers were merged.',
            'group': 'Groups not supported. Layers were ungrouped.',
            'adjustment': 'Adjustment layers not supported.',
            'layer-effect': 'Layer effects not supported.',
            'smart-object': 'Smart objects not supported.',
            'blend-mode': 'Unsupported layer blend mode.',
            'bits-per-channel': 'Unsupported color depth. Only 8bit per channel supported.'
        };
        for(let i = 0; i < psdWarningArr.length; i++)contentArr.push('- ' + warningMap[psdWarningArr[i]]);
        alert(contentArr.join("\n"));
    }
    let flattenCheckbox;
    if (p.image.type === 'psd') {
        const noteStyle = {
            background: 'rgba(255,255,0,0.5)',
            padding: '10px',
            marginTop: '5px',
            marginBottom: '5px',
            border: '1px solid #e7d321',
            borderRadius: '5px'
        };
        if (p.image.layers) {
            flattenCheckbox = new _checkbox.Checkbox({
                init: doFlatten,
                label: _language.LANG('import-flatten'),
                callback: function(b) {
                    doFlatten = b;
                }
            });
            div.appendChild(flattenCheckbox.getElement());
            if (p.image.warningArr) {
                const noteEl = _bb.BB.el({
                    content: _language.LANG('import-psd-limited-support'),
                    css: noteStyle
                });
                noteEl.appendChild(_bb.BB.el({
                    tagName: 'a',
                    content: 'Details',
                    onClick: function() {
                        showWarnings(p.image.warningArr);
                    }
                }));
                div.appendChild(noteEl);
            }
        } else {
            const noteEl = _bb.BB.el({
                content: _language.LANG('import-psd-unsupported'),
                css: noteStyle
            });
            div.appendChild(noteEl);
        }
    }
    function callback(result) {
        const croppedImage = cropCopy.getCroppedImage();
        const cropRect = cropCopy.getRect();
        cropCopy.destroy();
        if (flattenCheckbox) flattenCheckbox.destroy();
        if (result === _language.LANG('import-btn-as-layer')) p.callback({
            type: 'as-layer',
            image: croppedImage
        });
        else if (result === _language.LANG('import-btn-as-image')) {
            if (p.image.type === 'psd') {
                if (doFlatten) p.image.layers = null;
                p.callback({
                    type: 'as-image-psd',
                    image: p.image,
                    cropObj: cropRect
                });
            } else if (p.image.type === 'image') p.callback({
                type: 'as-image',
                image: croppedImage
            });
        } else p.callback({
            type: 'cancel'
        });
    }
    _popup.popup({
        target: p.target,
        message: `<b>${_language.LANG('import-title')}</b>`,
        div: div,
        style,
        buttons: [
            _language.LANG('import-btn-as-layer'),
            _language.LANG('import-btn-as-image'),
            "Cancel"
        ],
        callback: callback,
        autoFocus: 'As Image'
    });
}

},{"../../../bb/bb":"e3nbn","../components/crop-copy":"fSFui","../base-components/checkbox":"clzcQ","./popup":"7D028","../../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4VGUb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "blendPsdToKl", ()=>blendPsdToKl
);
parcelHelpers.export(exports, "blendKlToPsd", ()=>blendKlToPsd
);
/**
 * Converts ag-psd object into something that KlCanvas can represent
 * @param psdObj
 */ parcelHelpers.export(exports, "readPsd", ()=>readPsd
);
parcelHelpers.export(exports, "klPsdToKlProject", ()=>klPsdToKlProject
);
var _createCanvas = require("../../bb/base/create-canvas");
var _language = require("../../language/language");
var _klCanvas = require("../canvas/kl-canvas");
let kl2PsdMap;
let psd2KlMap;
function init() {
    if (kl2PsdMap) return;
    kl2PsdMap = {
        'source-over': 'normal',
        'darken': 'darken',
        'multiply': 'multiply',
        'color-burn': 'color burn',
        'lighten': 'lighten',
        'screen': 'screen',
        'color-dodge': 'color dodge',
        'overlay': 'overlay',
        'soft-light': 'soft light',
        'hard-light': 'hard light',
        'difference': 'difference',
        'exclusion': 'exclusion',
        'hue': 'hue',
        'saturation': 'saturation',
        'color': 'color',
        'luminosity': 'luminosity'
    };
    psd2KlMap = {
    };
    let keys = Object.keys(kl2PsdMap);
    for(let i = 0; i < keys.length; i++)psd2KlMap[kl2PsdMap[keys[i]]] = keys[i];
}
function blendPsdToKl(str) {
    init();
    return psd2KlMap[str];
}
function blendKlToPsd(str) {
    init();
    return kl2PsdMap[str];
}
function readPsd(psdObj) {
    let result1 = {
        type: 'psd',
        canvas: psdObj.canvas,
        width: psdObj.width,
        height: psdObj.height
    };
    function addWarning(warningStr) {
        if (!result1.warningArr) result1.warningArr = [];
        if (result1.warningArr.includes(warningStr)) return;
        result1.warningArr.push(warningStr);
    }
    function getMixModeStr(blendMode) {
        let mixModeStr = blendPsdToKl(blendMode);
        if (!mixModeStr) {
            addWarning('blend-mode');
            mixModeStr = 'source-over';
        }
        return mixModeStr;
    }
    if (psdObj.bitsPerChannel !== 8) addWarning('bits-per-channel');
    if (!psdObj.children) {
        result1.error = true;
        return result1;
    }
    // count resulting layers
    let maxLayers = _klCanvas.MAX_LAYERS;
    let layerCount = 0;
    function countWithinGroup(groupObj) {
        let result = 0;
        if (groupObj.blendMode) {
            let mixModeStr = blendPsdToKl(groupObj.blendMode);
            if (mixModeStr && mixModeStr !== 'source-over') return 1;
        }
        for(let i = 0; i < groupObj.children.length; i++){
            let item = groupObj.children[i];
            if (item.clipping || item.adjustment) continue;
            if (item.children) {
                addWarning('group');
                result += countWithinGroup(item);
            } else result++;
        }
        return result;
    }
    layerCount += countWithinGroup(psdObj);
    if (layerCount > maxLayers) {
        result1.error = true;
        return result1;
    }
    result1.layers = [];
    function prepareMask(maskCanvas, defaultColor) {
        const groupMaskCtx = maskCanvas.getContext('2d');
        let imData = groupMaskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
        if (defaultColor === 0) for(let i = 0; i < imData.data.length; i += 4)imData.data[i + 3] = imData.data[i];
        else for(let i1 = 0; i1 < imData.data.length; i1 += 4)imData.data[i1 + 3] = 255 - imData.data[i1];
        groupMaskCtx.putImageData(imData, 0, 0);
    }
    function convertGroup(psdGroupObj) {
        let resultArr = [];
        let groupOpacity = psdGroupObj.hidden ? 0 : psdGroupObj.opacity;
        let groupMixModeStr = getMixModeStr(psdGroupObj.blendMode);
        let groupCanvas;
        let groupCtx;
        if (groupMixModeStr !== 'source-over') {
            groupCanvas = _createCanvas.createCanvas(result1.width, result1.height);
            groupCtx = groupCanvas.getContext('2d');
        }
        // prepare group mask
        if (psdGroupObj.mask) {
            addWarning('mask');
            prepareMask(psdGroupObj.mask.canvas, psdGroupObj.mask.defaultColor);
        }
        for(let i = 0; i < psdGroupObj.children.length; i++){
            let item = psdGroupObj.children[i];
            if (item.clipping) continue;
            if (item.adjustment) {
                addWarning('adjustment');
                continue;
            }
            let hasClipping = (item.children || item.canvas) && psdGroupObj.children[i + 1] && psdGroupObj.children[i + 1].clipping;
            if (hasClipping) addWarning('clipping');
            if (item.children) {
                let innerArr = convertGroup(item);
                for(let e = 0; e < innerArr.length; e++){
                    let innerItem = innerArr[e];
                    let innerCtx = innerItem.image.getContext('2d');
                    // clipping
                    if (hasClipping) {
                        let clippingCanvas = _createCanvas.createCanvas(result1.width, result1.height);
                        let clippingCtx = clippingCanvas.getContext('2d');
                        clippingCtx.drawImage(innerItem.image, 0, 0);
                        for(let f = i + 1; f < psdGroupObj.children.length && psdGroupObj.children[f].clipping; f++){
                            let clippingItem = psdGroupObj.children[f];
                            if (clippingItem.opacity === 0 || clippingItem.hidden) continue;
                            clippingCtx.globalCompositeOperation = getMixModeStr(clippingItem.blendMode);
                            clippingCtx.globalAlpha = clippingItem.opacity;
                            clippingCtx.drawImage(clippingItem.canvas, clippingItem.left, clippingItem.top);
                        }
                        innerCtx.globalCompositeOperation = 'source-atop';
                        innerCtx.drawImage(clippingCanvas, 0, 0);
                    }
                    // group mask
                    if (psdGroupObj.mask) {
                        innerCtx.globalCompositeOperation = psdGroupObj.mask.defaultColor === 0 ? 'destination-in' : 'destination-out';
                        innerCtx.drawImage(psdGroupObj.mask.canvas, psdGroupObj.mask.left, psdGroupObj.mask.top);
                    }
                    if (groupCanvas) {
                        groupCtx.globalCompositeOperation = innerItem.mixModeStr;
                        groupCtx.globalAlpha = innerItem.opacity;
                        groupCtx.drawImage(innerItem.image, 0, 0);
                    } else {
                        innerItem.opacity = innerItem.opacity * groupOpacity;
                        resultArr.push(innerItem);
                    }
                }
                continue;
            }
            let canvas = _createCanvas.createCanvas(result1.width, result1.height);
            let ctx = canvas.getContext('2d');
            if (item.canvas) ctx.drawImage(item.canvas, item.left, item.top);
            // effects
            if (item.effects) addWarning('layer-effect');
            // mask
            if (item.mask) {
                addWarning('mask');
                prepareMask(item.mask.canvas, item.mask.defaultColor);
                ctx.globalCompositeOperation = item.mask.defaultColor === 0 ? 'destination-in' : 'destination-out';
                ctx.drawImage(item.mask.canvas, item.mask.left, item.mask.top);
            }
            // clipping
            if (hasClipping) {
                let clippingCanvas = _createCanvas.createCanvas(item.right - item.left, item.bottom - item.top);
                let clippingCtx = clippingCanvas.getContext('2d');
                clippingCtx.drawImage(item.canvas, 0, 0);
                for(let e = i + 1; e < psdGroupObj.children.length && psdGroupObj.children[e].clipping; e++){
                    let clippingItem = psdGroupObj.children[e];
                    if (clippingItem.opacity === 0 || clippingItem.hidden) continue;
                    clippingCtx.globalCompositeOperation = getMixModeStr(clippingItem.blendMode);
                    clippingCtx.globalAlpha = clippingItem.opacity;
                    clippingCtx.drawImage(clippingItem.canvas, clippingItem.left - item.left, clippingItem.top - item.top);
                }
                ctx.globalCompositeOperation = 'source-atop';
                ctx.drawImage(clippingCanvas, item.left, item.top);
            }
            // group mask
            if (psdGroupObj.mask) {
                ctx.globalCompositeOperation = psdGroupObj.mask.defaultColor === 0 ? 'destination-in' : 'destination-out';
                ctx.drawImage(psdGroupObj.mask.canvas, psdGroupObj.mask.left, psdGroupObj.mask.top);
            }
            if (groupCanvas) {
                if (groupOpacity > 0) {
                    groupCtx.globalCompositeOperation = getMixModeStr(item.blendMode);
                    groupCtx.globalAlpha = item.hidden ? 0 : item.opacity;
                    groupCtx.drawImage(canvas, 0, 0);
                }
            } else resultArr.push({
                name: item.name,
                opacity: (item.hidden ? 0 : item.opacity) * groupOpacity,
                mixModeStr: getMixModeStr(item.blendMode),
                image: canvas
            });
        }
        if (groupCanvas) resultArr = [
            {
                name: psdGroupObj.name,
                opacity: groupOpacity,
                mixModeStr: groupMixModeStr,
                image: groupCanvas
            }
        ];
        return resultArr;
    }
    result1.layers = convertGroup({
        name: 'root',
        opacity: 1,
        blendMode: 'normal',
        children: psdObj.children
    });
    return result1;
}
function klPsdToKlProject(klPsd) {
    // only share references to Canvas elements
    const result = {
        width: klPsd.width,
        height: klPsd.height,
        layers: []
    };
    if (klPsd.layers) result.layers = result.layers.concat(klPsd.layers.map((item)=>{
        return {
            name: item.name,
            opacity: item.opacity,
            mixModeStr: item.mixModeStr,
            image: item.image
        };
    }));
    else // flattened
    result.layers.push({
        name: _language.LANG('background'),
        opacity: 1,
        mixModeStr: 'source-over',
        image: klPsd.canvas
    });
    return result;
}

},{"../../bb/base/create-canvas":"lUl5x","../../language/language":"lvNW4","../canvas/kl-canvas":"7NlZB","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"7mvlr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setDbName", ()=>setDbName
);
/**
 * getKlProjectObj {
 *     width: int,
 *     height: int,
 *     layers: {
 *        name: string,
 *        opacity: float (0 - 1),
 *        mixModeStr: string,
 *        image: image object                <--------- image already loaded!
 *     }[]
 * }
 *
 * @param successCallback function - called when succesfully queried. passes KlProjectObj
 * @param errorCallback - function(errorStr) - called when error during query
 */ parcelHelpers.export(exports, "getKlProjectObj", ()=>getKlProjectObj
);
/**
 * stores a klProjectObj into id = 1 in database:dbNameStr > storage: storageNameStr
 *
 * KlProjectObj {
 *     width: int,
 *     height: int,
 *     layers: {
 *        name: string,
 *        opacity: float (0 - 1),
 *        mixModeStr: string,
 *        blob: blob object                 <--------- blob!
 *     }[]
 * }
 *
 * @param storageProject IKlStorageProject - project to be stored
 * @param successCallback function() - on successful transaction
 * @param errorCallback function(errorStr) - on error
 */ parcelHelpers.export(exports, "storeKlProjectObj", ()=>storeKlProjectObj
);
/**
 * removes id = 1 from database:dbNameStr > storage: storageNameStr
 *
 * @param successCallback function() - on successful transaction
 * @param errorCallback function(error) - on error
 */ parcelHelpers.export(exports, "clear", ()=>clear
);
const indexedDbIsSupported = !!window.indexedDB;
let dbNameStr = 'Klecks';
const storageNameStr = 'ProjectStore';
function setDbName(name) {
    dbNameStr = '' + name;
}
/**
 * connects to db dbNameStr, then executes transaction on storageNameStr storage
 * with index 'id'
 *
 * @param actionFunction function(storeObj) - what you want to execute during transaction
 * @param successCallback function() - on succesful transaction
 * @param errorCallback function(errorStr) - on error
 */ function execIndexedDBTransaction(actionFunction, successCallback, errorCallback) {
    let hasFinished = false;
    function onSuccess() {
        if (hasFinished) return;
        hasFinished = true;
        successCallback();
    }
    function onError(errorStr) {
        if (hasFinished) return;
        hasFinished = true;
        errorCallback(errorStr);
    }
    if (!indexedDbIsSupported) {
        setTimeout(function() {
            onError('no indexed db available');
        }, 0);
        return;
    }
    let requestObj;
    try {
        requestObj = window.indexedDB.open(dbNameStr, 1);
    } catch (e) {
        onError(e.message);
        return;
    }
    requestObj.onupgradeneeded = function(e) {
        try {
            let db = requestObj.result;
            let store = db.createObjectStore(storageNameStr, {
                keyPath: 'id'
            });
            store.createIndex('id', 'id', {
                unique: true
            });
        } catch (e1) {
            onError(e1.message);
        }
    };
    requestObj.onerror = function(e) {
        onError('indexedDB.open failed, ' + requestObj.error);
    };
    requestObj.onsuccess = function(e) {
        let databaseObj;
        let transactionObj;
        let storeObj;
        try {
            databaseObj = requestObj.result;
            if (!databaseObj.objectStoreNames.contains(storageNameStr)) {
                //someone maybe messed with the db, or creation failed earlier
                //it's broken -> destroy
                window.indexedDB.deleteDatabase(dbNameStr);
                onError('object store ' + storageNameStr + ' missing. destroying db');
                return;
            }
            transactionObj = databaseObj.transaction(storageNameStr, 'readwrite');
            storeObj = transactionObj.objectStore(storageNameStr);
            storeObj.index('id');
        } catch (e2) {
            onError(e2.message);
            return;
        }
        databaseObj.onerror = function(e) {
            onError('database error, ' + databaseObj.error);
        };
        try {
            actionFunction(storeObj);
        } catch (e3) {
            onError(e3.message);
            return;
        }
        transactionObj.oncomplete = function() {
            onSuccess();
            databaseObj.close();
        };
        transactionObj.onerror = function() {
            onError('transaction error, ' + transactionObj.error);
        };
    };
}
function getKlProjectObj(successCallback, errorCallback) {
    if (indexedDbIsSupported) {
        let query;
        execIndexedDBTransaction(function(storeObj) {
            query = storeObj.get(1);
        }, function() {
            successCallback(query.result);
        }, function(errorStr) {
            errorCallback('execIndexedDBTransaction error, ' + errorStr);
        });
    } else successCallback(null);
}
function storeKlProjectObj(storageProject, successCallback, errorCallback) {
    execIndexedDBTransaction(function(storeObj) {
        storeObj.put(storageProject);
    }, function() {
        successCallback();
    }, function(errorStr) {
        errorCallback(errorStr);
    });
}
function clear(successCallback, errorCallback) {
    execIndexedDBTransaction(function(storeObj) {
        storeObj.delete(1);
    }, function() {
        successCallback();
    }, function(error) {
        errorCallback(error);
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"d4Ymd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterLibStatus", ()=>filterLibStatus
);
parcelHelpers.export(exports, "filterLib", ()=>filterLib
);
// @ts-ignore
var _editBrightnessContrastSvg = require("url:~/src/app/img/ui/edit-brightness-contrast.svg");
var _editBrightnessContrastSvgDefault = parcelHelpers.interopDefault(_editBrightnessContrastSvg);
// @ts-ignore
var _editCropSvg = require("url:~/src/app/img/ui/edit-crop.svg");
var _editCropSvgDefault = parcelHelpers.interopDefault(_editCropSvg);
// @ts-ignore
var _editCurvesSvg = require("url:~/src/app/img/ui/edit-curves.svg");
var _editCurvesSvgDefault = parcelHelpers.interopDefault(_editCurvesSvg);
// @ts-ignore
var _editFlipSvg = require("url:~/src/app/img/ui/edit-flip.svg");
var _editFlipSvgDefault = parcelHelpers.interopDefault(_editFlipSvg);
// @ts-ignore
var _editHueSaturationSvg = require("url:~/src/app/img/ui/edit-hue-saturation.svg");
var _editHueSaturationSvgDefault = parcelHelpers.interopDefault(_editHueSaturationSvg);
// @ts-ignore
var _editInvertPng = require("url:~/src/app/img/ui/edit-invert.png");
var _editInvertPngDefault = parcelHelpers.interopDefault(_editInvertPng);
// @ts-ignore
var _editPerspectiveSvg = require("url:~/src/app/img/ui/edit-perspective.svg");
var _editPerspectiveSvgDefault = parcelHelpers.interopDefault(_editPerspectiveSvg);
// @ts-ignore
var _editResizeSvg = require("url:~/src/app/img/ui/edit-resize.svg");
var _editResizeSvgDefault = parcelHelpers.interopDefault(_editResizeSvg);
// @ts-ignore
var _editRotateSvg = require("url:~/src/app/img/ui/edit-rotate.svg");
var _editRotateSvgDefault = parcelHelpers.interopDefault(_editRotateSvg);
// @ts-ignore
var _editTiltShiftPng = require("url:~/src/app/img/ui/edit-tilt-shift.png");
var _editTiltShiftPngDefault = parcelHelpers.interopDefault(_editTiltShiftPng);
// @ts-ignore
var _editToAlphaSvg = require("url:~/src/app/img/ui/edit-to-alpha.svg");
var _editToAlphaSvgDefault = parcelHelpers.interopDefault(_editToAlphaSvg);
// @ts-ignore
var _editTransformSvg = require("url:~/src/app/img/ui/edit-transform.svg");
var _editTransformSvgDefault = parcelHelpers.interopDefault(_editTransformSvg);
// @ts-ignore
var _editTriangleBlurPng = require("url:~/src/app/img/ui/edit-triangle-blur.png");
var _editTriangleBlurPngDefault = parcelHelpers.interopDefault(_editTriangleBlurPng);
// @ts-ignore
var _editUnsharpMaskPng = require("url:~/src/app/img/ui/edit-unsharp-mask.png");
var _editUnsharpMaskPngDefault = parcelHelpers.interopDefault(_editUnsharpMaskPng);
var _language = require("../../language/language");
const filterLibStatus = {
    isLoaded: false
};
const filterLib = {
    glBrightnessContrast: {
        lang: {
            name: 'filter-bright-contrast-title',
            button: 'filter-bright-contrast'
        },
        name: '',
        buttonLabel: '',
        webgl: true,
        updateContext: true,
        icon: _editBrightnessContrastSvgDefault.default,
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    cropExtend: {
        lang: {
            name: 'filter-crop-title',
            button: 'filter-crop-extend'
        },
        name: '',
        buttonLabel: '',
        icon: _editCropSvgDefault.default,
        webgl: false,
        neededWithWebGL: true,
        updateContext: true,
        updatePos: true,
        getDialog: null,
        apply: null,
        inEmbed: false
    },
    glCurves: {
        lang: {
            name: 'filter-curves-title',
            button: 'filter-curves'
        },
        name: '',
        buttonLabel: '',
        icon: _editCurvesSvgDefault.default,
        webgl: true,
        updateContext: true,
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    flip: {
        lang: {
            name: 'filter-flip-title',
            button: 'filter-flip'
        },
        name: '',
        buttonLabel: '',
        icon: _editFlipSvgDefault.default,
        webgl: false,
        neededWithWebGL: true,
        updateContext: true,
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    glHueSaturation: {
        lang: {
            name: 'filter-hue-sat-title',
            button: 'filter-hue-sat'
        },
        name: '',
        buttonLabel: '',
        icon: _editHueSaturationSvgDefault.default,
        webgl: true,
        updateContext: true,
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    invert: {
        lang: {
            name: 'filter-invert',
            button: 'filter-invert'
        },
        name: '',
        icon: _editInvertPngDefault.default,
        webgl: true,
        updateContext: true,
        updatePos: false,
        isInstant: true,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    glPerspective: {
        lang: {
            name: 'filter-perspective-title',
            button: 'filter-perspective'
        },
        name: '',
        buttonLabel: '',
        icon: _editPerspectiveSvgDefault.default,
        webgl: true,
        updateContext: true,
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    resize: {
        lang: {
            name: 'filter-resize-title',
            button: 'filter-resize'
        },
        name: '',
        buttonLabel: '',
        icon: _editResizeSvgDefault.default,
        webgl: false,
        neededWithWebGL: true,
        updateContext: true,
        updatePos: true,
        getDialog: null,
        apply: null,
        inEmbed: false
    },
    rotate: {
        lang: {
            name: 'filter-rotate-title',
            button: 'filter-rotate'
        },
        name: '',
        buttonLabel: '',
        icon: _editRotateSvgDefault.default,
        webgl: false,
        neededWithWebGL: true,
        updateContext: true,
        updatePos: true,
        getDialog: null,
        apply: null,
        inEmbed: false
    },
    glTiltShift: {
        lang: {
            name: 'filter-tilt-shift-title',
            button: 'filter-tilt-shift'
        },
        name: '',
        buttonLabel: '',
        icon: _editTiltShiftPngDefault.default,
        webgl: true,
        updateContext: true,
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    toAlpha: {
        lang: {
            name: 'filter-to-alpha-title',
            button: 'filter-to-alpha'
        },
        name: '',
        buttonLabel: '',
        icon: _editToAlphaSvgDefault.default,
        webgl: true,
        updateContext: false,
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    transform: {
        lang: {
            name: 'filter-transform-title',
            button: 'filter-transform'
        },
        name: '',
        buttonLabel: '',
        icon: _editTransformSvgDefault.default,
        webgl: false,
        neededWithWebGL: true,
        updateContext: true,
        updatePos: false,
        ieFails: true,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    glBlur: {
        lang: {
            name: 'filter-triangle-blur-title',
            button: 'filter-triangle-blur'
        },
        name: '',
        buttonLabel: '',
        icon: _editTriangleBlurPngDefault.default,
        webgl: true,
        updateContext: true,
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    glUnsharpMask: {
        lang: {
            name: 'filter-unsharp-mask-title',
            button: 'filter-unsharp-mask'
        },
        name: '',
        buttonLabel: '',
        icon: _editUnsharpMaskPngDefault.default,
        webgl: true,
        updateContext: true,
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    }
};
function updateNames() {
    const keys = Object.keys(filterLib);
    keys.forEach((item)=>{
        filterLib[item].name = _language.LANG(filterLib[item].lang.name);
        filterLib[item].buttonLabel = _language.LANG(filterLib[item].lang.button);
    });
}
updateNames();
_language.languageStrings.subscribe(()=>{
    updateNames();
});

},{"url:~/src/app/img/ui/edit-brightness-contrast.svg":"iA22z","url:~/src/app/img/ui/edit-crop.svg":"fjeFI","url:~/src/app/img/ui/edit-curves.svg":"73O5C","url:~/src/app/img/ui/edit-flip.svg":"6b73q","url:~/src/app/img/ui/edit-hue-saturation.svg":"50p8Y","url:~/src/app/img/ui/edit-invert.png":"jiK9b","url:~/src/app/img/ui/edit-perspective.svg":"hH22s","url:~/src/app/img/ui/edit-resize.svg":"1W5D2","url:~/src/app/img/ui/edit-rotate.svg":"44zjq","url:~/src/app/img/ui/edit-tilt-shift.png":"6QAOr","url:~/src/app/img/ui/edit-to-alpha.svg":"cNJkf","url:~/src/app/img/ui/edit-transform.svg":"8dCh5","url:~/src/app/img/ui/edit-triangle-blur.png":"I3lUJ","url:~/src/app/img/ui/edit-unsharp-mask.png":"dV9fU","../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"iA22z":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "edit-brightness-contrast.a134fcd7.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"fjeFI":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "edit-crop.c774b1f4.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"73O5C":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "edit-curves.41c4828e.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"6b73q":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "edit-flip.6d44da10.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"50p8Y":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "edit-hue-saturation.63c2f02c.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"jiK9b":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "edit-invert.83f4be05.png" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"hH22s":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "edit-perspective.13cbf84c.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"1W5D2":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "edit-resize.05d38aeb.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"6QAOr":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "edit-tilt-shift.d42e52fb.png" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"cNJkf":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "edit-to-alpha.81889522.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"8dCh5":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "edit-transform.caf1cfb0.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"I3lUJ":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "edit-triangle-blur.37a6a13a.png" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"dV9fU":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "edit-unsharp-mask.0cbaeb97.png" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"34S30":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "brushes", ()=>brushes
);
var _penBrush = require("./pen-brush");
var _blendBrush = require("./blend-brush");
var _sketchyBrush = require("./sketchy-brush");
var _pixelBrush = require("./pixel-brush");
var _eraserBrush = require("./eraser-brush");
var _smudgeBrush = require("./smudge-brush");
var _chemyBrush = require("./chemy-brush");
const brushes = {
    PenBrush: _penBrush.PenBrush,
    BlendBrush: _blendBrush.BlendBrush,
    SketchyBrush: _sketchyBrush.SketchyBrush,
    PixelBrush: _pixelBrush.PixelBrush,
    ChemyBrush: _chemyBrush.ChemyBrush,
    SmudgeBrush: _smudgeBrush.SmudgeBrush,
    EraserBrush: _eraserBrush.EraserBrush
};

},{"./pen-brush":"beAHH","./blend-brush":"93ael","./sketchy-brush":"hNLuS","./pixel-brush":"66DDx","./eraser-brush":"lmqon","./smudge-brush":"6WD75","./chemy-brush":"ei7AK","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"beAHH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PenBrush", ()=>PenBrush
);
var _bb = require("../../bb/bb");
var _brushesCommon = require("./brushes-common");
var _kl = require("../kl");
function PenBrush() {
    let context;
    let history = new _kl.KL.DecoyKlHistory();
    let historyEntry1;
    let settingColor, settingSize = 2, settingSpacing = 0.8489, settingOpacity = 1;
    let settingColorStr;
    let settingHasSizePressure = true, settingHasOpacityPressure = false;
    let settingLockLayerAlpha = false;
    let ALPHA_CIRCLE = 0, ALPHA_CHALK = 1, ALPHA_CAL = 2, ALPHA_SQUARE = 3;
    let settingAlphaId = ALPHA_CIRCLE;
    let lineToolLastDot;
    let lastInput = {
        x: 0,
        y: 0,
        pressure: 0
    };
    let lastInput2 = {
        x: 0,
        y: 0,
        pressure: 0
    };
    let isDrawing = false;
    let alphaOpacityArr = [
        1,
        0.9,
        1,
        1
    ];
    //mipmapping
    let alphaCanvas128 = document.createElement("canvas");
    alphaCanvas128.width = 128;
    alphaCanvas128.height = 128;
    let alphaCanvas64 = document.createElement("canvas");
    alphaCanvas64.width = 64;
    alphaCanvas64.height = 64;
    let alphaCanvas32 = document.createElement("canvas");
    alphaCanvas32.width = 32;
    alphaCanvas32.height = 32;
    let bezierLine = null;
    let twoPI = Math.PI * 2;
    function updateAlphaCanvas() {
        if (settingAlphaId === ALPHA_CIRCLE || settingAlphaId === ALPHA_SQUARE) return;
        let instructionArr = [
            [
                alphaCanvas128,
                128
            ],
            [
                alphaCanvas64,
                64
            ],
            [
                alphaCanvas32,
                32
            ]
        ];
        let ctx;
        for(let i = 0; i < instructionArr.length; i++){
            ctx = instructionArr[i][0].getContext("2d");
            ctx.save();
            ctx.clearRect(0, 0, instructionArr[i][1], instructionArr[i][1]);
            ctx.fillStyle = "rgba(" + settingColor.r + ", " + settingColor.g + ", " + settingColor.b + ", " + alphaOpacityArr[settingAlphaId] + ")";
            ctx.fillRect(0, 0, instructionArr[i][1], instructionArr[i][1]);
            ctx.globalCompositeOperation = "destination-in";
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(_brushesCommon.alphaImArr[settingAlphaId], 0, 0, instructionArr[i][1], instructionArr[i][1]);
            ctx.restore();
        }
    }
    /**
     *
     *
     * @param x
     * @param y
     * @param size
     * @param opacity
     * @param angle
     * @param before - [x, y, size, opacity, angle] the drawDot call before
     */ function drawDot(x, y, size, opacity, angle, before) {
        if (size <= 0) return;
        if (settingLockLayerAlpha) context.globalCompositeOperation = "source-atop";
        if (!before || before[3] !== opacity) context.globalAlpha = opacity;
        if (!before && (settingAlphaId === ALPHA_CIRCLE || settingAlphaId === ALPHA_SQUARE)) context.fillStyle = settingColorStr;
        if (settingAlphaId === ALPHA_CIRCLE) {
            context.beginPath();
            context.arc(x, y, size, 0, twoPI);
            context.closePath();
            context.fill();
        } else if (settingAlphaId === ALPHA_SQUARE) {
            if (angle !== undefined) {
                context.save();
                context.translate(x, y);
                context.rotate(angle / 180 * Math.PI);
                context.fillRect(-size, -size, size * 2, size * 2);
                context.restore();
            }
        } else {
            context.save();
            context.translate(x, y);
            let targetMipmap = alphaCanvas128;
            if (size <= 32 && size > 16) targetMipmap = alphaCanvas64;
            else if (size <= 16) targetMipmap = alphaCanvas32;
            context.scale(size, size);
            if (settingAlphaId === ALPHA_CHALK) context.rotate((x + y) * 53123 % twoPI); // without mod it sometimes looks different
            context.drawImage(targetMipmap, -1, -1, 2, 2);
            context.restore();
        }
    }
    function continueLine(x, y, size, pressure) {
        if (bezierLine === null) {
            bezierLine = new _bb.BB.BezierLine();
            bezierLine.add(lastInput.x, lastInput.y, 0, function() {
            });
        }
        let drawArr = []; //draw instructions. will be all drawn at once
        function dotCallback(val) {
            let localPressure = _bb.BB.mix(lastInput2.pressure, pressure, val.t);
            let localOpacity = settingOpacity * (settingHasOpacityPressure ? localPressure * localPressure : 1);
            let localSize = Math.max(0.1, settingSize * (settingHasSizePressure ? localPressure : 1));
            drawArr.push([
                val.x,
                val.y,
                localSize,
                localOpacity,
                val.angle
            ]);
        }
        let localSpacing = size * settingSpacing;
        if (x === null) bezierLine.addFinal(localSpacing, dotCallback);
        else bezierLine.add(x, y, localSpacing, dotCallback);
        // execute draw instructions
        context.save();
        let before;
        for(let i = 0; i < drawArr.length; i++){
            let item = drawArr[i];
            drawDot(item[0], item[1], item[2], item[3], item[4], before);
            before = item;
        }
        context.restore();
    }
    //------------------ interface ---------------------------------------------------
    this.startLine = function(x, y, p) {
        historyEntry1 = {
            tool: [
                "brush",
                "PenBrush"
            ],
            actions: []
        };
        historyEntry1.actions.push({
            action: "opacityPressure",
            params: [
                settingHasOpacityPressure
            ]
        });
        historyEntry1.actions.push({
            action: "sizePressure",
            params: [
                settingHasSizePressure
            ]
        });
        historyEntry1.actions.push({
            action: "setSize",
            params: [
                settingSize
            ]
        });
        historyEntry1.actions.push({
            action: "setSpacing",
            params: [
                settingSpacing
            ]
        });
        historyEntry1.actions.push({
            action: "setOpacity",
            params: [
                settingOpacity
            ]
        });
        historyEntry1.actions.push({
            action: "setColor",
            params: [
                settingColor
            ]
        });
        historyEntry1.actions.push({
            action: "setAlpha",
            params: [
                settingAlphaId
            ]
        });
        historyEntry1.actions.push({
            action: "setLockAlpha",
            params: [
                settingLockLayerAlpha
            ]
        });
        p = _bb.BB.clamp(p, 0, 1);
        let localOpacity = settingHasOpacityPressure ? settingOpacity * p * p : settingOpacity;
        let localSize = settingHasSizePressure ? Math.max(0.1, p * settingSize) : Math.max(0.1, settingSize);
        isDrawing = true;
        context.save();
        drawDot(x, y, localSize, localOpacity);
        context.restore();
        lineToolLastDot = localSize * settingSpacing;
        lastInput.x = x;
        lastInput.y = y;
        lastInput.pressure = p;
        lastInput2.pressure = p;
        historyEntry1.actions.push({
            action: "startLine",
            params: [
                x,
                y,
                p
            ]
        });
    };
    this.goLine = function(x, y, p) {
        if (!isDrawing) return;
        historyEntry1.actions.push({
            action: "goLine",
            params: [
                x,
                y,
                p
            ]
        });
        let pressure = _bb.BB.clamp(p, 0, 1);
        let localSize = settingHasSizePressure ? Math.max(0.1, lastInput.pressure * settingSize) : Math.max(0.1, settingSize);
        context.save();
        continueLine(x, y, localSize, lastInput.pressure);
        /*context.fillStyle = 'red';
        context.fillRect(Math.floor(x), Math.floor(y - 10), 1, 20);
        context.fillRect(Math.floor(x - 10), Math.floor(y), 20, 1);*/ context.restore();
        lastInput.x = x;
        lastInput.y = y;
        lastInput2.pressure = lastInput.pressure;
        lastInput.pressure = pressure;
    };
    this.endLine = function(x, y) {
        let localSize = settingHasSizePressure ? Math.max(0.1, lastInput.pressure * settingSize) : Math.max(0.1, settingSize);
        context.save();
        continueLine(null, null, localSize, lastInput.pressure);
        context.restore();
        isDrawing = false;
        bezierLine = null;
        if (historyEntry1) {
            historyEntry1.actions.push({
                action: "endLine",
                params: [
                    x,
                    y
                ]
            });
            history.push(historyEntry1);
            historyEntry1 = undefined;
        }
    };
    //cheap n' ugly
    this.drawLineSegment = function(x1, y1, x2, y2) {
        lastInput.x = x2;
        lastInput.y = y2;
        lastInput.pressure = 1;
        if (isDrawing || x1 === undefined) return;
        let angle = _bb.BB.pointsToAngleDeg({
            x: x1,
            y: y1
        }, {
            x: x2,
            y: y2
        });
        let mouseDist = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        let eX = (x2 - x1) / mouseDist;
        let eY = (y2 - y1) / mouseDist;
        let loopDist;
        let bdist = settingSize * settingSpacing;
        lineToolLastDot = settingSize * settingSpacing;
        for(loopDist = lineToolLastDot; loopDist <= mouseDist; loopDist += bdist)drawDot(x1 + eX * loopDist, y1 + eY * loopDist, settingSize, settingOpacity, angle);
        let historyEntry = {
            tool: [
                "brush",
                "PenBrush"
            ],
            actions: []
        };
        historyEntry.actions.push({
            action: "opacityPressure",
            params: [
                settingHasOpacityPressure
            ]
        });
        historyEntry.actions.push({
            action: "sizePressure",
            params: [
                settingHasSizePressure
            ]
        });
        historyEntry.actions.push({
            action: "setSize",
            params: [
                settingSize
            ]
        });
        historyEntry.actions.push({
            action: "setSpacing",
            params: [
                settingSpacing
            ]
        });
        historyEntry.actions.push({
            action: "setOpacity",
            params: [
                settingOpacity
            ]
        });
        historyEntry.actions.push({
            action: "setColor",
            params: [
                settingColor
            ]
        });
        historyEntry.actions.push({
            action: "setAlpha",
            params: [
                settingAlphaId
            ]
        });
        historyEntry.actions.push({
            action: "setLockAlpha",
            params: [
                settingLockLayerAlpha
            ]
        });
        historyEntry.actions.push({
            action: "drawLineSegment",
            params: [
                x1,
                y1,
                x2,
                y2
            ]
        });
        history.push(historyEntry);
    };
    //IS
    this.isDrawing = function() {
        return isDrawing;
    };
    //SET
    this.setAlpha = function(a) {
        if (settingAlphaId === a) return;
        settingAlphaId = a;
        updateAlphaCanvas();
    };
    this.setColor = function(c) {
        if (settingColor === c) return;
        settingColor = {
            r: c.r,
            g: c.g,
            b: c.b
        };
        settingColorStr = "rgb(" + settingColor.r + "," + settingColor.g + "," + settingColor.b + ")";
        updateAlphaCanvas();
    };
    this.setContext = function(c) {
        context = c;
    };
    this.setHistory = function(l) {
        history = l;
    };
    this.setSize = function(s) {
        settingSize = s;
    };
    this.setOpacity = function(o) {
        settingOpacity = o;
    };
    this.setSpacing = function(s) {
        settingSpacing = s;
    };
    this.sizePressure = function(b) {
        settingHasSizePressure = b;
    };
    this.opacityPressure = function(b) {
        settingHasOpacityPressure = b;
    };
    this.setLockAlpha = function(b) {
        settingLockLayerAlpha = b;
    };
    //GET
    this.getSpacing = function() {
        return settingSpacing;
    };
    this.getSize = function() {
        return settingSize;
    };
    this.getOpacity = function() {
        return settingOpacity;
    };
    this.getLockAlpha = function(b) {
        return settingLockLayerAlpha;
    };
}

},{"../../bb/bb":"e3nbn","./brushes-common":"7euQK","../kl":"3bnx1","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"7euQK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "alphaImArr", ()=>alphaImArr
);
var _brushAlphas = require("./alphas/brush-alphas");
const alphaImArr = []; //used by default brush
alphaImArr[1] = _brushAlphas.genBrushAlpha01(128);
alphaImArr[2] = _brushAlphas.genBrushAlpha02(128);

},{"./alphas/brush-alphas":"fPGfk","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fPGfk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// chalk
parcelHelpers.export(exports, "genBrushAlpha01", ()=>genBrushAlpha01
);
// calligraphy
parcelHelpers.export(exports, "genBrushAlpha02", ()=>genBrushAlpha02
);
var _bb = require("../../../bb/bb");
var _perlin = require("../../../bb/math/perlin");
function genBrushAlpha01(w) {
    const scaleFac = w / 500;
    const h = w;
    const canvas = _bb.BB.canvas(w, h);
    const ctx = canvas.getContext('2d');
    const imData = ctx.createImageData(w, h);
    for(let x = 0; x < w; x++)for(let y = 0; y < h; y++){
        let i = (y * w + x) * 4;
        // base noise
        const sFac2 = scaleFac + _perlin.noise.simplex2(x / 50 / scaleFac, y / 50 / scaleFac) * 0.04;
        let noisePattern = 100 + (_perlin.noise.simplex2(x / 50 / sFac2, y / 50 / sFac2) + 1) / 2 * 100;
        noisePattern -= (_perlin.noise.simplex2(x / 10 / scaleFac, y / 10 / scaleFac) + 1) / 2 * 100;
        // fade out in circular shape
        const centerDist = _bb.BB.dist(w / 2, h / 2, x, y);
        let falloff = _bb.BB.clamp(1 - ((centerDist - w / 2.5) / (w / 14) + _perlin.noise.simplex2(x / 22 / sFac2, y / 22 / sFac2)), 0, 1);
        noisePattern = noisePattern * falloff;
        // make the middle darker
        const falloff2 = _bb.BB.clamp(1 - centerDist / w, 0, 1) * 2;
        noisePattern = noisePattern * falloff2;
        imData.data[i] = 0;
        imData.data[i + 1] = 0;
        imData.data[i + 2] = 0;
        imData.data[i + 3] = _bb.BB.clamp(noisePattern, 0, 255);
    }
    ctx.putImageData(imData, 0, 0);
    return canvas;
}
// https://www.shadertoy.com/view/3tdSDj
function udSegment(p, a, b) {
    let ba = _bb.BB.Vec2.sub(b, a);
    let pa = _bb.BB.Vec2.sub(p, a);
    let h = _bb.BB.clamp(_bb.BB.Vec2.dot(pa, ba) / _bb.BB.Vec2.dot(ba, ba), 0, 1);
    return _bb.BB.Vec2.len(_bb.BB.Vec2.sub(pa, _bb.BB.Vec2.mul(ba, h)));
}
function genBrushAlpha02(w) {
    const pDist = 0.25;
    let centerSize = 2 / 3;
    let transitionSize = 1 / 3;
    centerSize *= pDist;
    transitionSize *= pDist;
    const p1 = {
        x: pDist * w,
        y: w - w * pDist
    };
    const p2 = {
        x: w - w * pDist,
        y: pDist * w
    };
    const h = w;
    const canvas = _bb.BB.canvas(w, h);
    let ctx = canvas.getContext('2d');
    const imData = ctx.createImageData(w, h);
    for(let x = 0; x < w; x++)for(let y = 0; y < h; y++){
        const i = (y * w + x) * 4;
        let col = udSegment({
            x: x,
            y: y
        }, p1, p2);
        col = _bb.BB.clamp(255 - (col - w * centerSize) / (w * transitionSize) * 255, 0, 255);
        imData.data[i] = 0;
        imData.data[i + 1] = 0;
        imData.data[i + 2] = 0;
        imData.data[i + 3] = col;
    }
    ctx.putImageData(imData, 0, 0);
    return canvas;
}

},{"../../../bb/bb":"e3nbn","../../../bb/math/perlin":"fsHdc","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fsHdc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "noise", ()=>noise
);
/*
 * A speed-improved perlin and simplex noise algorithms for 2D.
 *
 * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
 * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
 * Better rank ordering method by Stefan Gustavson in 2012.
 * Converted to Javascript by Joseph Gentle.
 *
 * Version 2012-03-09
 *
 * This code was placed in the public domain by its original author,
 * Stefan Gustavson. You may use it as you see fit, but
 * attribution is appreciated.
 *
 */ const myModule = {
};
function Grad(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
}
Grad.prototype.dot2 = function(x, y) {
    return this.x * x + this.y * y;
};
/*
Grad.prototype.dot3 = function(x, y, z) {
    return this.x*x + this.y*y + this.z*z;
};*/ let grad3 = [
    new Grad(1, 1, 0),
    new Grad(-1, 1, 0),
    new Grad(1, -1, 0),
    new Grad(-1, -1, 0),
    new Grad(1, 0, 1),
    new Grad(-1, 0, 1),
    new Grad(1, 0, -1),
    new Grad(-1, 0, -1),
    new Grad(0, 1, 1),
    new Grad(0, -1, 1),
    new Grad(0, 1, -1),
    new Grad(0, -1, -1)
];
let p = [
    151,
    160,
    137,
    91,
    90,
    15,
    131,
    13,
    201,
    95,
    96,
    53,
    194,
    233,
    7,
    225,
    140,
    36,
    103,
    30,
    69,
    142,
    8,
    99,
    37,
    240,
    21,
    10,
    23,
    190,
    6,
    148,
    247,
    120,
    234,
    75,
    0,
    26,
    197,
    62,
    94,
    252,
    219,
    203,
    117,
    35,
    11,
    32,
    57,
    177,
    33,
    88,
    237,
    149,
    56,
    87,
    174,
    20,
    125,
    136,
    171,
    168,
    68,
    175,
    74,
    165,
    71,
    134,
    139,
    48,
    27,
    166,
    77,
    146,
    158,
    231,
    83,
    111,
    229,
    122,
    60,
    211,
    133,
    230,
    220,
    105,
    92,
    41,
    55,
    46,
    245,
    40,
    244,
    102,
    143,
    54,
    65,
    25,
    63,
    161,
    1,
    216,
    80,
    73,
    209,
    76,
    132,
    187,
    208,
    89,
    18,
    169,
    200,
    196,
    135,
    130,
    116,
    188,
    159,
    86,
    164,
    100,
    109,
    198,
    173,
    186,
    3,
    64,
    52,
    217,
    226,
    250,
    124,
    123,
    5,
    202,
    38,
    147,
    118,
    126,
    255,
    82,
    85,
    212,
    207,
    206,
    59,
    227,
    47,
    16,
    58,
    17,
    182,
    189,
    28,
    42,
    223,
    183,
    170,
    213,
    119,
    248,
    152,
    2,
    44,
    154,
    163,
    70,
    221,
    153,
    101,
    155,
    167,
    43,
    172,
    9,
    129,
    22,
    39,
    253,
    19,
    98,
    108,
    110,
    79,
    113,
    224,
    232,
    178,
    185,
    112,
    104,
    218,
    246,
    97,
    228,
    251,
    34,
    242,
    193,
    238,
    210,
    144,
    12,
    191,
    179,
    162,
    241,
    81,
    51,
    145,
    235,
    249,
    14,
    239,
    107,
    49,
    192,
    214,
    31,
    181,
    199,
    106,
    157,
    184,
    84,
    204,
    176,
    115,
    121,
    50,
    45,
    127,
    4,
    150,
    254,
    138,
    236,
    205,
    93,
    222,
    114,
    67,
    29,
    24,
    72,
    243,
    141,
    128,
    195,
    78,
    66,
    215,
    61,
    156,
    180
];
// To remove the need for index wrapping, double the permutation table length
let perm = new Array(512);
let gradP = new Array(512);
// This isn't a very good seeding function, but it works ok. It supports 2^16
// different seed values. Write something better if you need more seeds.
myModule.seed = function(seed) {
    if (seed > 0 && seed < 1) // Scale the seed out
    seed *= 65536;
    seed = Math.floor(seed);
    if (seed < 256) seed |= seed << 8;
    for(let i = 0; i < 256; i++){
        let v;
        if (i & 1) v = p[i] ^ seed & 255;
        else v = p[i] ^ seed >> 8 & 255;
        perm[i] = perm[i + 256] = v;
        gradP[i] = gradP[i + 256] = grad3[v % 12];
    }
};
myModule.seed(0);
/*
for (let i=0; i<256; i++) {
  perm[i] = perm[i + 256] = p[i];
  gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];
}*/ // Skewing and unskewing factors for 2, 3, and 4 dimensions
let F2 = 0.5 * (Math.sqrt(3) - 1);
let G2 = (3 - Math.sqrt(3)) / 6;
/*let F3 = 1/3;
let G3 = 1/6;*/ // 2D simplex noise
myModule.simplex2 = function(xin, yin) {
    let n0, n1, n2; // Noise contributions from the three corners
    // Skew the input space to determine which simplex cell we're in
    let s = (xin + yin) * F2; // Hairy factor for 2D
    let i = Math.floor(xin + s);
    let j = Math.floor(yin + s);
    let t = (i + j) * G2;
    let x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.
    let y0 = yin - j + t;
    // For the 2D case, the simplex shape is an equilateral triangle.
    // Determine which simplex we are in.
    let i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
    if (x0 > y0) {
        i1 = 1;
        j1 = 0;
    } else {
        i1 = 0;
        j1 = 1;
    }
    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
    // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
    // c = (3-sqrt(3))/6
    let x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
    let y1 = y0 - j1 + G2;
    let x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords
    let y2 = y0 - 1 + 2 * G2;
    // Work out the hashed gradient indices of the three simplex corners
    i &= 255;
    j &= 255;
    let gi0 = gradP[i + perm[j]];
    let gi1 = gradP[i + i1 + perm[j + j1]];
    let gi2 = gradP[i + 1 + perm[j + 1]];
    // Calculate the contribution from the three corners
    let t0 = 0.5 - x0 * x0 - y0 * y0;
    if (t0 < 0) n0 = 0;
    else {
        t0 *= t0;
        n0 = t0 * t0 * gi0.dot2(x0, y0); // (x,y) of grad3 used for 2D gradient
    }
    let t1 = 0.5 - x1 * x1 - y1 * y1;
    if (t1 < 0) n1 = 0;
    else {
        t1 *= t1;
        n1 = t1 * t1 * gi1.dot2(x1, y1);
    }
    let t2 = 0.5 - x2 * x2 - y2 * y2;
    if (t2 < 0) n2 = 0;
    else {
        t2 *= t2;
        n2 = t2 * t2 * gi2.dot2(x2, y2);
    }
    // Add contributions from each corner to get the final noise value.
    // The result is scaled to return values in the interval [-1,1].
    return 70 * (n0 + n1 + n2);
};
const noise = myModule;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"93ael":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BlendBrush", ()=>BlendBrush
);
var _bb = require("../../bb/bb");
const cellSize = 256;
// faster than using BB.clamp somehow (in chrome)
function clamp(num, min, max) {
    return num <= min ? min : num >= max ? max : num;
}
class BlendBrush {
    updateRedrawBounds(bounds) {
        this.redrawBounds = _bb.BB.updateBounds(this.redrawBounds, bounds);
    }
    getCellsWidth() {
        return Math.ceil(this.context.canvas.width / cellSize);
    }
    /**
     * draw changed cells (changed by brushstroke) onto context
     * @private
     */ drawChangedCells() {
        const cells = this.cells.map((item)=>null
        );
        const touchedCells = this.getTouchedCells(this.redrawBounds);
        touchedCells.forEach((isTouched, index)=>{
            if (isTouched) cells[index] = this.cells[index];
        });
        this.drawCells(cells);
        this.redrawBounds = null;
    }
    getTouchedCells(bounds) {
        const touchedCells = this.cells.map((item)=>false
        );
        const cellsW = this.getCellsWidth();
        bounds = {
            x1: Math.floor(bounds.x1 / cellSize),
            y1: Math.floor(bounds.y1 / cellSize),
            x2: Math.floor(bounds.x2 / cellSize),
            y2: Math.floor(bounds.y2 / cellSize)
        };
        for(let i = bounds.x1; i <= bounds.x2; i++)for(let e = bounds.y1; e <= bounds.y2; e++)touchedCells[e * cellsW + i] = true;
        return touchedCells;
    }
    /**
     * Slice up bounds accordings to cells
     * @param bounds
     * @private
     */ sliceBounds(bounds) {
        const cellsW = this.getCellsWidth();
        const result = [];
        const touchedCells = this.getTouchedCells(bounds);
        touchedCells.forEach((cell, i)=>{
            if (!cell) return;
            const cellOffsetX = i % cellsW * cellSize;
            const cellOffsetY = Math.floor(i / cellsW) * cellSize;
            const cellWidth = this.cells[i].width;
            const cellHeight = this.cells[i].height;
            const inCellBounds = {
                x1: Math.max(0, bounds.x1 - cellOffsetX),
                y1: Math.max(0, bounds.y1 - cellOffsetY),
                x2: Math.min(cellWidth - 1, bounds.x2 - cellOffsetX),
                y2: Math.min(cellHeight - 1, bounds.y2 - cellOffsetY)
            };
            if (inCellBounds.x1 > inCellBounds.x2 || inCellBounds.y1 > inCellBounds.y2) return;
            result.push({
                index: i,
                bounds: inCellBounds
            });
        });
        return result;
    }
    /**
     * update copyImageData. copy over new regions if needed
     */ copyFromCanvas(bounds) {
        if (!bounds) return;
        const touchedCells = this.getTouchedCells(bounds);
        const cellsW = this.getCellsWidth();
        touchedCells.forEach((item, i)=>{
            if (!item || this.cells[i]) // not touched, or already copied
            return;
            const x = i % cellsW;
            const y = Math.floor(i / cellsW);
            const w = (Math.min(x * cellSize + cellSize, this.context.canvas.width) - 1) % cellSize + 1;
            const h = (Math.min(y * cellSize + cellSize, this.context.canvas.height) - 1) % cellSize + 1;
            // temp canvas to prevent main canvas from getting slowed down in chrome
            const tmpCanvas = _bb.BB.canvas(w, h);
            const tmpCtx = tmpCanvas.getContext('2d');
            tmpCtx.drawImage(this.context.canvas, -x * cellSize, -y * cellSize);
            this.cells[i] = tmpCtx.getImageData(0, 0, w, h);
        });
    }
    getAverage(x, y, size) {
        size = Math.max(0.5, size * 0.75);
        const x1 = Math.max(0, Math.floor(x - size));
        const y1 = Math.max(0, Math.floor(y - size));
        const x2 = Math.min(this.context.canvas.width - 1, Math.ceil(x + size));
        const y2 = Math.min(this.context.canvas.height - 1, Math.ceil(y + size));
        if (x1 > x2 || y1 > y2) return {
            r: 0,
            g: 0,
            b: 0,
            a: 0
        };
        let ar = 0, ag = 0, ab = 0, aa = 0, alpha;
        const slicedBounds = this.sliceBounds({
            x1,
            y1,
            x2,
            y2
        });
        slicedBounds.forEach((slice)=>{
            const width = this.cells[slice.index].width;
            const data = this.cells[slice.index].data;
            const bounds = slice.bounds;
            for(let i = bounds.y1; i <= bounds.y2; i += 4)for(let e = bounds.x1, e2 = i * width * 4 + bounds.x1 * 4; e <= bounds.x2; e += 4, e2 += 16){
                alpha = data[e2 + 3];
                ar += data[e2] * alpha;
                ag += data[e2 + 1] * alpha;
                ab += data[e2 + 2] * alpha;
                aa += alpha;
            }
        });
        if (aa !== 0) {
            ar /= aa;
            ag /= aa;
            ab /= aa;
            aa = Math.min(1, aa);
        }
        return {
            r: ar,
            g: ag,
            b: ab,
            a: aa
        };
    }
    prepDot(x, y, size) {
        size = Math.max(0.5, size);
        let x1 = Math.max(0, Math.floor(x - size));
        let y1 = Math.max(0, Math.floor(y - size));
        let x2 = Math.min(this.context.canvas.width - 1, Math.ceil(x + size));
        let y2 = Math.min(this.context.canvas.height - 1, Math.ceil(y + size));
        if (x1 > x2 || y1 > y2) return null;
        return {
            x1,
            y1,
            x2,
            y2
        };
    }
    drawDot(params) {
        // array with random numbers. faster than Math.random()
        let randI = 0;
        const randLen = params.size > 30 ? 1024 : 512; // lower lengths lead to noticeable patterns
        const randArr = [];
        for(let i1 = 0; i1 < randLen; i1++)randArr[i1] = (Math.random() - 0.5) / 1.001 + 0.5;
        // thin lines take more than just 1 sample
        const sampleArr = [
            8,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2
        ]; // <0.5, 0.5, 1, 1.5, etc.
        const samples = sampleArr[Math.floor(params.size * 2)];
        const samplesSquared = samples ? samples * samples : 0;
        const sampleOffsets = [];
        if (samples) {
            let i = 0;
            for(let n = 0; n < samples; n++)for(let m = 0; m < samples; m++, i += 2){
                sampleOffsets[i] = (n + 1) / samples; // x offset
                sampleOffsets[i + 1] = (m + 1) / samples; // y offset
            }
        }
        const sharpness = Math.pow(params.opacity, 2) * 0.8;
        // to optimize calculations
        const invSharpness = 1 - sharpness;
        const sharpnessSubtrahend = sharpness / invSharpness;
        const sizeSquared = params.size * params.size;
        const distDivisor = sizeSquared * invSharpness / params.opacity;
        const alphaMinuend = (1 + sharpnessSubtrahend) * params.opacity;
        const slicedBounds = this.sliceBounds({
            x1: params.x1,
            y1: params.y1,
            x2: params.x2,
            y2: params.y2
        });
        const cellsW = this.getCellsWidth();
        slicedBounds.forEach((slice)=>{
            const cellOffsetX = slice.index % cellsW * cellSize;
            const cellOffsetY = Math.floor(slice.index / cellsW) * cellSize;
            const cellWidth = this.cells[slice.index].width;
            const data = this.cells[slice.index].data;
            // i - y index within cell
            // e - x index within cell
            // e2 - index in image data
            // ri - y index within image relative to dot-center
            // re - x index within image relative to dot-center
            for(let i = slice.bounds.y1, ri = i + cellOffsetY - params.y; i <= slice.bounds.y2; i++, ri++)for(let e = slice.bounds.x1, e2 = i * cellWidth * 4 + slice.bounds.x1 * 4, re = e + cellOffsetX - params.x; e <= slice.bounds.x2; e++, e2 += 4, re++){
                // O = over -> brush-dot
                // U = under -> image
                let alphaO = 0;
                if (samplesSquared) {
                    for(let f = 0; f < sampleOffsets.length; f += 2){
                        const dist = _bb.BB.lenSquared(re + sampleOffsets[f], ri + sampleOffsets[f + 1]);
                        if (dist >= sizeSquared) continue;
                        alphaO += clamp(alphaMinuend - dist / distDivisor, 0, params.opacity);
                    }
                    if (!alphaO) continue;
                    alphaO /= samplesSquared;
                } else {
                    // technically needs + 0.5 offset, but not noticeable with large brush
                    const dist = Math.pow(re, 2) + Math.pow(ri, 2);
                    if (dist >= sizeSquared) continue;
                    alphaO = clamp(alphaMinuend - dist / distDivisor, 0, params.opacity);
                }
                const invAlphaO = 1 - alphaO;
                const alphaU = data[e2 + 3] / 255;
                if (this.settingLockLayerAlpha) {
                    const underR = params.r * alphaO + data[e2] * invAlphaO;
                    const underG = params.g * alphaO + data[e2 + 1] * invAlphaO;
                    const underB = params.b * alphaO + data[e2 + 2] * invAlphaO;
                    if (alphaU) {
                        data[e2] = Math.floor(underR + randArr[randI]);
                        data[e2 + 1] = Math.floor(underG + randArr[randI]);
                        data[e2 + 2] = Math.floor(underB + randArr[randI]);
                    }
                } else {
                    const underR = params.r * alphaO + data[e2] * alphaU * invAlphaO;
                    const underG = params.g * alphaO + data[e2 + 1] * alphaU * invAlphaO;
                    const underB = params.b * alphaO + data[e2 + 2] * alphaU * invAlphaO;
                    let newAlpha = 1 - invAlphaO * (1 - alphaU);
                    data[e2 + 3] = Math.floor(Math.min(255, newAlpha * 255) + 0.5);
                    if (newAlpha) {
                        data[e2] = Math.floor(underR / newAlpha + randArr[randI]);
                        data[e2 + 1] = Math.floor(underG / newAlpha + randArr[randI]);
                        data[e2 + 2] = Math.floor(underB / newAlpha + randArr[randI]);
                    }
                }
                randI = (randI + 1) % randLen;
            }
        });
    }
    calcSpacing(size) {
        return _bb.BB.mix(size * 2 / 2, size * 2 / 9, _bb.BB.clamp((size - 2.7) / 9.3, 0, 1));
    }
    continueLine(x, y, p, isCoalesced) {
        this.drawBuffer = [];
        let localPressure;
        let localOpacity;
        let localSize = this.settingSizePressure ? Math.max(1, p * this.size) : Math.max(1, this.size);
        let bdist = this.calcSpacing(localSize);
        let avgX = x;
        let avgY = y;
        if (x === null) {
            avgX = this.lastInput.x;
            avgY = this.lastInput.y;
        }
        let localColNew;
        if (this.blending === 0) {
            this.mixr = this.color.r;
            this.mixg = this.color.g;
            this.mixb = this.color.b;
        } else {
            let average;
            if (isCoalesced) average = {
                r: this.localColOld.r,
                g: this.localColOld.g,
                b: this.localColOld.b,
                a: 0
            };
            else {
                const avgParams = [
                    avgX,
                    avgY,
                    this.settingSizePressure ? Math.max(0.5, p * this.size) : Math.max(0.5, this.size)
                ];
                const bounds = this.prepDot(avgParams[0], avgParams[1], avgParams[2]);
                this.copyFromCanvas(bounds);
                average = this.getAverage(avgParams[0], avgParams[1], avgParams[2]);
            }
            localColNew = {
                r: 0,
                g: 0,
                b: 0,
                a: 0
            };
            if (average.a > 0 && this.blendCol.a === 0) {
                this.blendCol.r = average.r;
                this.blendCol.g = average.g;
                this.blendCol.b = average.b;
                this.blendCol.a = average.a;
                localColNew.r = this.blendCol.r;
                localColNew.g = this.blendCol.g;
                localColNew.b = this.blendCol.b;
                localColNew.a = this.blendCol.a;
            } else {
                if (average.a === 0) {
                    average.r = this.color.r;
                    average.g = this.color.g;
                    average.b = this.color.b;
                    average.a = 1 - this.blending;
                }
                this.blendCol.r = _bb.BB.mix(this.blendCol.r, _bb.BB.mix(this.blendCol.r, average.r, this.blendMix), average.a);
                this.blendCol.g = _bb.BB.mix(this.blendCol.g, _bb.BB.mix(this.blendCol.g, average.g, this.blendMix), average.a);
                this.blendCol.b = _bb.BB.mix(this.blendCol.b, _bb.BB.mix(this.blendCol.b, average.b, this.blendMix), average.a);
                this.blendCol.a = Math.min(1, this.blendCol.a + average.a);
                localColNew.r = this.blendCol.r;
                localColNew.g = this.blendCol.g;
                localColNew.b = this.blendCol.b;
                localColNew.a = this.blendCol.a;
            }
        }
        const bezierCallback = (val)=>{
            if (this.blending >= 1 && this.blendCol.a <= 0) return;
            let factor = val.t;
            localPressure = this.lastInput2.pressure * (1 - factor) + p * factor;
            localOpacity = this.settingOpacityPressure ? this.opacity * localPressure * localPressure : this.opacity;
            localSize = this.settingSizePressure ? Math.max(0.1, localPressure * this.size) : Math.max(0.1, this.size);
            if (this.blending != 0) {
                this.mixr = _bb.BB.mix(this.localColOld.r, localColNew.r, factor);
                this.mixg = _bb.BB.mix(this.localColOld.g, localColNew.g, factor);
                this.mixb = _bb.BB.mix(this.localColOld.b, localColNew.b, factor);
            }
            if (this.blending === 1 && this.localColOld.a === 0) {
                this.mixr = localColNew.r;
                this.mixg = localColNew.g;
                this.mixb = localColNew.b;
            }
            const bounds = this.prepDot(val.x, val.y, localSize);
            if (bounds) {
                this.updateRedrawBounds(bounds);
                this.drawBuffer.push({
                    x: val.x,
                    y: val.y,
                    size: localSize,
                    opacity: localOpacity,
                    x1: bounds.x1,
                    y1: bounds.y1,
                    x2: bounds.x2,
                    y2: bounds.y2,
                    r: _bb.BB.mix(this.color.r, this.mixr, this.blending),
                    g: _bb.BB.mix(this.color.g, this.mixg, this.blending),
                    b: _bb.BB.mix(this.color.b, this.mixb, this.blending)
                });
            }
        };
        if (x === null) this.bezierLine.addFinal(bdist, bezierCallback);
        else this.bezierLine.add(x, y, bdist, bezierCallback);
        this.copyFromCanvas(this.redrawBounds);
        this.drawBuffer.forEach((item)=>{
            this.drawDot(item);
        });
        this.drawBuffer = [];
        this.localColOld = localColNew;
    }
    // --- public ----
    constructor(){
        this.isTesting // testing mode - context only gets updated when line is finished
         = false;
        this.size // radius - 0.5 - 99999
         = 29;
        this.opacity // 0-1
         = 0.6;
        this.blending // 0-1
         = 0.65;
        this.settingLockLayerAlpha = false;
        this.settingSizePressure = true;
        this.settingOpacityPressure = false;
        this.blendCol // todo docs
         = {
            r: 0,
            g: 0,
            b: 0,
            a: 1
        };
        this.blendMix // todo docs
         = 0.45;
        this.isDrawing = false;
        this.lastInput // todo docs
         = {
            x: 0,
            y: 0,
            pressure: 0
        };
        this.lastInput2 // todo docs
         = {
            x: 0,
            y: 0,
            pressure: 0
        };
    }
    setHistory(h) {
        this.history = h;
    }
    getSize() {
        return this.size;
    }
    setSize(s) {
        this.size = s;
    }
    getOpacity() {
        return this.opacity;
    }
    setOpacity(o) {
        this.opacity = o;
    }
    getBlending() {
        return this.blending;
    }
    setBlending(b) {
        this.blending = b;
    }
    setColor(c) {
        this.color = _bb.BB.copyObj(c);
    }
    setContext(c) {
        this.context = c;
    }
    setSizePressure(b) {
        this.settingSizePressure = !!b;
    }
    setOpacityPressure(b) {
        this.settingOpacityPressure = !!b;
    }
    getLockAlpha() {
        return this.settingLockLayerAlpha;
    }
    setLockAlpha(b) {
        this.settingLockLayerAlpha = !!b;
    }
    getIsDrawing() {
        return this.isDrawing;
    }
    setIsTesting(b) {
        this.isTesting = !!b;
    }
    startLine(x, y, p) {
        this.historyEntry = {
            tool: [
                "brush",
                "BlendBrush"
            ],
            actions: []
        };
        const totalCells = Math.ceil(this.context.canvas.width / cellSize) * Math.ceil(this.context.canvas.height / cellSize);
        this.cells = '0'.repeat(totalCells).split('').map((item)=>null
        );
        this.isDrawing = true;
        p = Math.max(0, Math.min(1, p));
        let localOpacity = this.settingOpacityPressure ? this.opacity * p * p : this.opacity;
        let localSize = this.settingSizePressure ? Math.max(0.1, p * this.size) : Math.max(0.1, this.size);
        if (this.blending === 0) {
            this.mixr = this.color.r;
            this.mixg = this.color.g;
            this.mixb = this.color.b;
        } else {
            this.copyFromCanvas(this.prepDot(x, y, localSize));
            let average = this.getAverage(x, y, this.settingSizePressure ? Math.max(0.1, p * this.size) : Math.max(0.1, this.size));
            if (average.a === 0) this.blendCol = {
                r: this.color.r,
                g: this.color.g,
                b: this.color.b,
                a: 1 - this.blending
            };
            else this.blendCol = {
                r: average.r,
                g: average.g,
                b: average.b,
                a: average.a
            };
            this.mixr = this.blendCol.r;
            this.mixg = this.blendCol.g;
            this.mixb = this.blendCol.b;
        }
        this.localColOld = {
            r: this.mixr,
            g: this.mixg,
            b: this.mixb,
            a: this.blendCol.a
        };
        this.redrawBounds = null;
        this.drawBuffer = [];
        if (this.blending < 1 || this.blendCol.a > 0) {
            const bounds = this.prepDot(x, y, localSize);
            if (bounds) {
                this.updateRedrawBounds(bounds);
                this.drawBuffer.push({
                    x: x,
                    y: y,
                    size: localSize,
                    opacity: localOpacity,
                    x1: bounds.x1,
                    y1: bounds.y1,
                    x2: bounds.x2,
                    y2: bounds.y2,
                    r: _bb.BB.mix(this.color.r, this.mixr, this.blending),
                    g: _bb.BB.mix(this.color.g, this.mixg, this.blending),
                    b: _bb.BB.mix(this.color.b, this.mixb, this.blending)
                });
            }
        }
        this.copyFromCanvas(this.redrawBounds);
        this.drawBuffer.forEach((item)=>{
            this.drawDot(item);
        });
        this.drawBuffer = [];
        this.bezierLine = new _bb.BB.BezierLine();
        this.bezierLine.add(x, y, 0, function() {
        });
        this.lastInput.x = x;
        this.lastInput.y = y;
        this.lastInput.pressure = p;
        this.lastInput2 = _bb.BB.copyObj(this.lastInput);
        if (this.redrawBounds && !this.isTesting) this.drawChangedCells();
    }
    goLine(x, y, p, isCoalesced) {
        if (!this.isDrawing) return;
        this.continueLine(x, y, this.lastInput.pressure, isCoalesced);
        this.lastInput2 = _bb.BB.copyObj(this.lastInput);
        this.lastInput.x = x;
        this.lastInput.y = y;
        this.lastInput.pressure = p;
        if (this.redrawBounds && !this.isTesting) this.drawChangedCells();
    }
    endLine() {
        if (this.bezierLine) this.continueLine(null, null, this.lastInput.pressure, false);
        this.isDrawing = false;
        this.bezierLine = null;
        if (this.redrawBounds) this.drawChangedCells();
        if (this.historyEntry && this.history && this.cells.find((item)=>!!item
        )) {
            this.historyEntry.actions.push({
                action: "drawCells",
                params: [
                    this.cells
                ]
            });
            this.history.push(this.historyEntry);
            this.historyEntry = null;
        }
        this.cells = null;
    }
    /**
     * draw cells onto context
     * @param cells
     */ drawCells(cells) {
        const cellsW = this.getCellsWidth();
        cells.forEach((imageData, index)=>{
            if (!imageData) return;
            const cellOffsetX = index % cellsW * cellSize;
            const cellOffsetY = Math.floor(index / cellsW) * cellSize;
            this.context.putImageData(imageData, cellOffsetX, cellOffsetY);
        });
    }
    drawLineSegment(x1, y1, x2, y2) {
        this.lastInput.x = x2;
        this.lastInput.y = y2;
        if (this.isDrawing || x1 === undefined) return;
        const totalCells = Math.ceil(this.context.canvas.width / cellSize) * Math.ceil(this.context.canvas.height / cellSize);
        this.cells = '0'.repeat(totalCells).split('').map((item)=>null
        );
        this.redrawBounds = null;
        this.drawBuffer = [];
        this.copyFromCanvas(this.prepDot(x1, y1, Math.max(0.1, this.size)));
        let average = this.getAverage(x1, y1, Math.max(0.1, this.size));
        if (average.a === 0) this.blendCol = {
            r: this.color.r,
            g: this.color.g,
            b: this.color.b,
            a: 1 - this.blending
        };
        else this.blendCol = {
            r: average.r,
            g: average.g,
            b: average.b,
            a: average.a
        };
        this.mixr = this.color.r * (1 - this.blendCol.a) + (this.blending * this.blendCol.r + this.color.r * (1 - this.blending)) * this.blendCol.a;
        this.mixg = this.color.g * (1 - this.blendCol.a) + (this.blending * this.blendCol.g + this.color.g * (1 - this.blending)) * this.blendCol.a;
        this.mixb = this.color.b * (1 - this.blendCol.a) + (this.blending * this.blendCol.b + this.color.b * (1 - this.blending)) * this.blendCol.a;
        const p = 1;
        const localOpacity = this.settingOpacityPressure ? this.opacity * p * p : this.opacity;
        const localSize = this.settingSizePressure ? Math.max(0.1, p * this.size) : Math.max(0.1, this.size);
        const mouseDist = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        const eX = (x2 - x1) / mouseDist;
        const eY = (y2 - y1) / mouseDist;
        const bdist = this.calcSpacing(localSize);
        for(let loopDist = 0; loopDist <= mouseDist; loopDist += bdist){
            const bounds = this.prepDot(x1 + eX * loopDist, y1 + eY * loopDist, localSize);
            if (bounds) {
                this.copyFromCanvas(bounds);
                this.drawBuffer.push({
                    x: x1 + eX * loopDist,
                    y: y1 + eY * loopDist,
                    size: localSize,
                    opacity: localOpacity,
                    x1: bounds.x1,
                    y1: bounds.y1,
                    x2: bounds.x2,
                    y2: bounds.y2,
                    r: _bb.BB.mix(this.color.r, this.mixr, this.blending),
                    g: _bb.BB.mix(this.color.g, this.mixg, this.blending),
                    b: _bb.BB.mix(this.color.b, this.mixb, this.blending)
                });
            }
        }
        this.drawBuffer.forEach((item)=>{
            this.drawDot(item);
        });
        this.drawBuffer = [];
        if (this.history && this.cells.find((item)=>!!item
        )) {
            this.drawCells(this.cells);
            this.historyEntry = {
                tool: [
                    "brush",
                    "BlendBrush"
                ],
                actions: [
                    {
                        action: "drawCells",
                        params: [
                            this.cells
                        ]
                    }
                ]
            };
            this.history.push(this.historyEntry);
            this.historyEntry = null;
        }
        this.cells = null;
    }
}

},{"../../bb/bb":"e3nbn","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hNLuS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SketchyBrush", ()=>SketchyBrush
);
var _bb = require("../../bb/bb");
var _kl = require("../kl");
const sampleCanvas = _bb.BB.canvas(32, 32);
const sampleCtx = sampleCanvas.getContext('2d');
function SketchyBrush() {
    let context;
    let settingColor;
    let settingSize = 1, settingOpacity = 0.2;
    let settingBlending = 0.5;
    let settingScale = 1;
    let lastX, lastY;
    let isDrawing = false;
    let lastInput = {
        x: 0,
        y: 0,
        pressure: 0
    };
    let history = new _kl.KL.DecoyKlHistory();
    let historyEntry1;
    let sketchySeed = 0;
    this.setHistory = function(l) {
        history = l;
    };
    this.setSeed = function(s) {
        sketchySeed = parseInt(s);
    };
    this.getSeed = function() {
        return parseInt('' + sketchySeed);
    };
    function rand() {
        sketchySeed++;
        return Math.sin(6324634.2345 * Math.cos(sketchySeed * 5342.3423)) * 0.5 + 0.5;
    }
    let points = [];
    let count = 0;
    let mixmode = [
        function(c1, c2) {
            return c1;
        },
        function(c1, c2) {
            let result = new _bb.BB.RGB(c1.r, c1.g, c1.b);
            result.r *= c2.r / 255;
            result.g *= c2.g / 255;
            result.b *= c2.b / 255;
            return result;
        },
        function(c1, c2) {
            let result = new _bb.BB.RGB(c1.r, c1.g, c1.b);
            result.r *= c2.r / 255;
            result.g *= c2.g / 255;
            result.b *= c2.b / 255;
            return result;
        }
    ];
    this.getSize = function() {
        return settingSize / 2;
    };
    this.setColor = function(c) {
        settingColor = c;
    };
    this.getOpacity = function() {
        return settingOpacity;
    };
    this.setOpacity = function(o) {
        settingOpacity = o;
    };
    this.getBlending = function() {
        return settingBlending;
    };
    this.setBlending = function(b) {
        settingBlending = b;
    };
    this.setSize = function(s) {
        settingSize = s * 2;
    };
    this.getScale = function() {
        return settingScale;
    };
    this.setScale = function(s) {
        settingScale = s;
    };
    this.setContext = function(c) {
        context = c;
    };
    this.startLine = function(x, y, pressure, shift) {
        if (shift && lastInput.x) {
            let lx = lastInput.x, ly = lastInput.y;
            isDrawing = true;
            //this.goLine(x,y,pressure);
            this.endLine();
        } else {
            isDrawing = true;
            lastX = x;
            lastY = y;
            lastInput.x = x;
            lastInput.y = y;
            historyEntry1 = {
                tool: [
                    "brush",
                    "SketchyBrush"
                ],
                actions: []
            };
            historyEntry1.actions.push({
                action: "setScale",
                params: [
                    settingScale
                ]
            });
            historyEntry1.actions.push({
                action: "setSize",
                params: [
                    settingSize / 2
                ]
            });
            historyEntry1.actions.push({
                action: "setOpacity",
                params: [
                    settingOpacity
                ]
            });
            historyEntry1.actions.push({
                action: "setColor",
                params: [
                    settingColor
                ]
            });
            historyEntry1.actions.push({
                action: "setBlending",
                params: [
                    settingBlending
                ]
            });
            historyEntry1.actions.push({
                action: "startLine",
                params: [
                    x,
                    y,
                    pressure
                ]
            });
        }
    };
    this.goLine = function(p_x, p_y, pressure, preMixedColor) {
        if (!isDrawing || p_x === lastInput.x && p_y === lastInput.y) return;
        let e, b, a, g;
        let x = parseInt(p_x);
        let y = parseInt(p_y);
        points.push([
            x,
            y
        ]);
        let mixr = settingColor.r;
        let mixg = settingColor.g;
        let mixb = settingColor.b;
        if (preMixedColor !== null) {
            mixr = preMixedColor.r;
            mixg = preMixedColor.g;
            mixb = preMixedColor.b;
        } else {
            if (settingBlending !== 0) {
                if (x + 5 >= 0 && y + 5 >= 0 && x - 5 < context.canvas.width - 1 && y - 5 < context.canvas.height - 1) {
                    mixr = 0;
                    mixg = 0;
                    mixb = 0;
                    let mixx = Math.min(context.canvas.width - 1, Math.max(0, x - 5));
                    let mixy = Math.min(context.canvas.height - 1, Math.max(0, y - 5));
                    let mixw = Math.min(context.canvas.width - 1, Math.max(0, x + 5));
                    let mixh = Math.min(context.canvas.height - 1, Math.max(0, y + 5));
                    mixw -= mixx;
                    mixh -= mixy;
                    if (mixw > 0 && mixh > 0) {
                        let imdat = context.getImageData(mixx, mixy, mixw, mixh);
                        let countmix = 0;
                        for(let i = 0; i < imdat.data.length; i += 4){
                            mixr += imdat.data[i + 0];
                            mixg += imdat.data[i + 1];
                            mixb += imdat.data[i + 2];
                            countmix++;
                        }
                        mixr /= countmix;
                        mixg /= countmix;
                        mixb /= countmix;
                    }
                    let mixed = mixmode[0](new _bb.BB.RGB(mixr, mixg, mixb), settingColor);
                    mixr = parseInt('' + _bb.BB.mix(settingColor.r, mixed.r, settingBlending));
                    mixg = parseInt('' + _bb.BB.mix(settingColor.g, mixed.g, settingBlending));
                    mixb = parseInt('' + _bb.BB.mix(settingColor.b, mixed.b, settingBlending));
                }
            }
        }
        context.save();
        context.strokeStyle = "rgba(" + mixr + ", " + mixg + ", " + mixb + ", " + settingOpacity + ")";
        context.lineWidth = settingSize;
        context.beginPath();
        context.moveTo(lastX, lastY);
        context.lineTo(x, y);
        for(e = 0; e < points.length; e++){
            b = points[e][0] - points[count][0];
            a = points[e][1] - points[count][1];
            g = b * b + a * a;
            if (g < 4000 * settingScale * settingScale && rand() > g / 2000 / settingScale / settingScale) {
                context.moveTo(points[count][0] + b * 0.3, points[count][1] + a * 0.3);
                context.lineTo(points[e][0] - b * 0.3, points[e][1] - a * 0.3);
            }
        }
        context.stroke();
        context.restore();
        count++;
        lastX = x;
        lastY = y;
        lastInput.x = x;
        lastInput.y = y;
        historyEntry1.actions.push({
            action: "goLine",
            params: [
                p_x,
                p_y,
                pressure,
                {
                    r: mixr,
                    g: mixg,
                    b: mixb
                }
            ]
        });
    };
    this.endLine = function() {
        isDrawing = false;
        count = 0;
        points = [];
        if (historyEntry1) {
            historyEntry1.actions.push({
                action: "endLine",
                params: []
            });
            history.push(historyEntry1);
            historyEntry1 = undefined;
        }
    };
    //cheap n' ugly
    this.drawLineSegment = function(x1, y1, x2, y2) {
        lastInput.x = x2;
        lastInput.y = y2;
        if (isDrawing || x1 === undefined) return;
        context.save();
        context.lineWidth = settingSize;
        let mixr = settingColor.r, mixg = settingColor.g, mixb = settingColor.b;
        if (x1 + 5 >= 0 && y1 + 5 >= 0 && x1 - 5 < context.canvas.width - 1 && y1 - 5 < context.canvas.height - 1) {
            mixr = 0;
            mixg = 0;
            mixb = 0;
            let mixx = Math.min(context.canvas.width - 1, Math.max(0, x1 - 5));
            let mixy = Math.min(context.canvas.height - 1, Math.max(0, y1 - 5));
            let mixw = Math.min(context.canvas.width - 1, Math.max(0, x1 + 5));
            let mixh = Math.min(context.canvas.height - 1, Math.max(0, y1 + 5));
            mixw -= mixx;
            mixh -= mixy;
            if (mixw > 0 && mixh > 0) {
                let w = Math.min(sampleCanvas.width, mixw);
                let h = Math.min(sampleCanvas.height, mixh);
                sampleCtx.save();
                sampleCtx.globalCompositeOperation = 'copy';
                sampleCtx.drawImage(context.canvas, mixx, mixy, mixw, mixh, 0, 0, w, h);
                sampleCtx.restore();
                let imdat = sampleCtx.getImageData(mixx, mixy, mixw, mixh);
                let countmix = 0;
                for(let i = 0; i < imdat.data.length; i += 4){
                    mixr += imdat.data[i + 0];
                    mixg += imdat.data[i + 1];
                    mixb += imdat.data[i + 2];
                    countmix++;
                }
                mixr /= countmix;
                mixg /= countmix;
                mixb /= countmix;
            }
        }
        let mixed = mixmode[0](new _bb.BB.RGB(mixr, mixg, mixb), settingColor);
        mixr = parseInt('' + (settingBlending * mixed.r + settingColor.r * (1 - settingBlending)));
        mixg = parseInt('' + (settingBlending * mixed.g + settingColor.g * (1 - settingBlending)));
        mixb = parseInt('' + (settingBlending * mixed.b + settingColor.b * (1 - settingBlending)));
        context.strokeStyle = "rgba(" + mixr + ", " + mixg + ", " + mixb + ", " + settingOpacity + ")";
        context.beginPath();
        context.moveTo(x1, y1);
        context.lineTo(x2, y2);
        context.stroke();
        context.strokeStyle = "rgba(" + mixr + ", " + mixg + ", " + mixb + ", " + settingOpacity + ")";
        context.restore();
        let historyEntry = {
            tool: [
                "brush",
                "SketchyBrush"
            ],
            actions: []
        };
        historyEntry.actions.push({
            action: "setScale",
            params: [
                settingScale
            ]
        });
        historyEntry.actions.push({
            action: "setSize",
            params: [
                settingSize / 2
            ]
        });
        historyEntry.actions.push({
            action: "setOpacity",
            params: [
                settingOpacity
            ]
        });
        historyEntry.actions.push({
            action: "setColor",
            params: [
                settingColor
            ]
        });
        historyEntry.actions.push({
            action: "setBlending",
            params: [
                settingBlending
            ]
        });
        historyEntry.actions.push({
            action: "drawLineSegment",
            params: [
                x1,
                y1,
                x2,
                y2
            ]
        });
        history.push(historyEntry);
    };
    this.isDrawing = function() {
        return isDrawing;
    };
}

},{"../../bb/bb":"e3nbn","../kl":"3bnx1","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"66DDx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PixelBrush", ()=>PixelBrush
);
var _bb = require("../../bb/bb");
var _kl = require("../kl");
function PixelBrush() {
    let context;
    let history = new _kl.KL.DecoyKlHistory();
    let historyEntry1;
    let settingColor, settingSize = 0.5, settingSpacing = 0.9, settingOpacity = 1;
    let settingColorStr;
    let settingHasSizePressure = true, settingHasOpacityPressure = false;
    let settingLockLayerAlpha = false;
    let settingIsEraser = false;
    let settingUseDither = true;
    let lineToolLastDot;
    let lastInput = {
        x: 0,
        y: 0,
        pressure: 0
    };
    let lastInput2 = {
        x: 0,
        y: 0,
        pressure: 0
    };
    let isDrawing = false;
    let bezierLine = null;
    let twoPI = Math.PI * 2;
    let ditherCanvas = _bb.BB.canvas(4, 4);
    let ditherCtx = ditherCanvas.getContext('2d');
    let ditherPattern;
    let ditherArr = [
        [
            3,
            2
        ],
        [
            1,
            0
        ],
        [
            3,
            0
        ],
        [
            1,
            2
        ],
        [
            2,
            1
        ],
        [
            0,
            3
        ],
        [
            0,
            1
        ],
        [
            2,
            3
        ],
        [
            2,
            0
        ],
        [
            0,
            2
        ],
        [
            0,
            0
        ],
        [
            2,
            2
        ],
        [
            1,
            1
        ],
        [
            3,
            3
        ],
        [
            3,
            1
        ],
        [
            1,
            3
        ]
    ];
    function updateDither() {
        ditherCtx.clearRect(0, 0, 4, 4);
        ditherCtx.fillStyle = settingIsEraser ? '#fff' : settingColorStr;
        for(let i = 0; i < Math.max(1, Math.round(settingOpacity * ditherArr.length)); i++)ditherCtx.fillRect(ditherArr[i][0], ditherArr[i][1], 1, 1);
        ditherPattern = context.createPattern(ditherCanvas, 'repeat');
    }
    /**
     * Tests p1->p2 or p3->p4 deviate in their direction more than max, compared to p1->p4
     * @param p1
     * @param p2
     * @param p3
     * @param p4
     * @param maxAngleRad
     */ function cubicCurveOverThreshold(p1, p2, p3, p4, max) {
        let d = _bb.BB.Vec2.nor({
            x: p4.x - p1.x,
            y: p4.y - p1.y
        });
        let d2 = _bb.BB.Vec2.nor({
            x: p2.x - p1.x,
            y: p2.y - p1.y
        });
        let d3 = _bb.BB.Vec2.nor({
            x: p4.x - p3.x,
            y: p4.y - p3.y
        });
        let a2 = Math.abs(_bb.BB.Vec2.angle(d, d2) % Math.PI) / Math.PI * 180;
        let a3 = Math.abs(_bb.BB.Vec2.angle(d, d3) % Math.PI) / Math.PI * 180;
        return Math.max(_bb.BB.Vec2.dist(d, d2), _bb.BB.Vec2.dist(d, d3)) > max;
    }
    //bresenheim line drawing
    function plotLine(x0, y0, x1, y1, skipFirst) {
        context.save();
        if (settingIsEraser) {
            context.fillStyle = settingUseDither ? ditherPattern : '#fff';
            if (settingLockLayerAlpha) context.globalCompositeOperation = "source-atop";
            else context.globalCompositeOperation = "destination-out";
        } else {
            context.fillStyle = settingUseDither ? ditherPattern : settingColorStr;
            if (settingLockLayerAlpha) context.globalCompositeOperation = "source-atop";
        }
        context.globalAlpha = settingUseDither ? 1 : settingOpacity;
        x0 = Math.floor(x0);
        y0 = Math.floor(y0);
        x1 = Math.floor(x1);
        y1 = Math.floor(y1);
        let dX = Math.abs(x1 - x0);
        let sX = x0 < x1 ? 1 : -1;
        let dY = -Math.abs(y1 - y0);
        let sY = y0 < y1 ? 1 : -1;
        let err = dX + dY;
        while(true){
            if (skipFirst) skipFirst = false;
            else context.fillRect(x0, y0, 1, 1);
            if (x0 === x1 && y0 === y1) break;
            let e2 = 2 * err;
            if (e2 >= dY) {
                err += dY;
                x0 += sX;
            }
            if (e2 <= dX) {
                err += dX;
                y0 += sY;
            }
        }
        context.restore();
    }
    function plotCubicBezierLine(p1, p2, p3, p4) {
        let isOverThreshold = cubicCurveOverThreshold(p1, p2, p3, p4, 0.1);
        p1.x = Math.floor(p1.x);
        p1.y = Math.floor(p1.y);
        p4.x = Math.floor(p4.x);
        p4.y = Math.floor(p4.y);
        let dist = _bb.BB.dist(p1.x, p1.y, p4.x, p4.y);
        if (!isOverThreshold || dist < 7) {
            plotLine(p1.x, p1.y, p4.x, p4.y, true);
            return;
        }
        let n = Math.max(2, Math.round(dist / 4));
        let pointArr = [];
        for(let i = 0; i <= n; i++){
            let t = i / n;
            let a = Math.pow(1 - t, 3);
            let b = 3 * t * Math.pow(1 - t, 2);
            let c = 3 * Math.pow(t, 2) * (1 - t);
            let d = Math.pow(t, 3);
            pointArr.push({
                x: a * p1.x + b * p2.x + c * p3.x + d * p4.x,
                y: a * p1.y + b * p2.y + c * p3.y + d * p4.y
            });
        }
        for(let i1 = 0; i1 < n; i1++)plotLine(Math.round(pointArr[i1].x), Math.round(pointArr[i1].y), Math.round(pointArr[i1 + 1].x), Math.round(pointArr[i1 + 1].y), true);
    }
    function drawDot(x, y, size, opacity, angle) {
        context.save();
        if (settingIsEraser) {
            context.fillStyle = settingUseDither ? ditherPattern : '#fff';
            if (settingLockLayerAlpha) context.globalCompositeOperation = "source-atop";
            else context.globalCompositeOperation = "destination-out";
        } else {
            context.fillStyle = settingUseDither ? ditherPattern : settingColorStr;
            if (settingLockLayerAlpha) context.globalCompositeOperation = "source-atop";
        }
        context.globalAlpha = settingUseDither ? 1 : opacity;
        context.fillRect(Math.round(x + -size), Math.round(y + -size), Math.round(size * 2), Math.round(size * 2));
        context.restore();
    }
    function continueLine(x, y, size, pressure) {
        if (bezierLine === null) {
            bezierLine = new _bb.BB.BezierLine();
            bezierLine.add(lastInput.x, lastInput.y, 0, function() {
            });
        }
        context.save();
        function dotCallback(val) {
            let localPressure = _bb.BB.mix(lastInput2.pressure, pressure, val.t);
            let localOpacity = settingOpacity * (settingHasOpacityPressure ? localPressure * localPressure : 1);
            let localSize = Math.max(0.5, settingSize * (settingHasSizePressure ? localPressure : 1));
            drawDot(val.x, val.y, localSize, localOpacity, val.angle);
        }
        function controlCallback(controlObj) {
            plotCubicBezierLine(controlObj.p1, controlObj.p2, controlObj.p3, controlObj.p4);
        }
        if (Math.round(settingSize * 2) === 1) {
            if (x === null) bezierLine.addFinal(4, null, controlCallback);
            else bezierLine.add(x, y, 4, null, controlCallback);
        } else {
            let localSpacing = size * settingSpacing;
            if (x === null) bezierLine.addFinal(localSpacing, dotCallback);
            else bezierLine.add(x, y, localSpacing, dotCallback);
        }
        context.restore();
    }
    //------------------ interface ---------------------------------------------------
    this.startLine = function(x, y, p) {
        historyEntry1 = {
            tool: [
                "brush",
                "PixelBrush"
            ],
            actions: []
        };
        historyEntry1.actions.push({
            action: "sizePressure",
            params: [
                settingHasSizePressure
            ]
        });
        historyEntry1.actions.push({
            action: "setSize",
            params: [
                settingSize
            ]
        });
        historyEntry1.actions.push({
            action: "setSpacing",
            params: [
                settingSpacing
            ]
        });
        historyEntry1.actions.push({
            action: "setOpacity",
            params: [
                settingOpacity
            ]
        });
        historyEntry1.actions.push({
            action: "setColor",
            params: [
                settingColor
            ]
        });
        historyEntry1.actions.push({
            action: "setLockAlpha",
            params: [
                settingLockLayerAlpha
            ]
        });
        historyEntry1.actions.push({
            action: "setIsEraser",
            params: [
                settingIsEraser
            ]
        });
        historyEntry1.actions.push({
            action: "setUseDither",
            params: [
                settingUseDither
            ]
        });
        if (settingUseDither) updateDither();
        p = Math.max(0, Math.min(1, p));
        let localOpacity = settingHasOpacityPressure ? settingOpacity * p * p : settingOpacity;
        let localSize = settingHasSizePressure ? Math.max(0.5, p * settingSize) : Math.max(0.5, settingSize);
        isDrawing = true;
        drawDot(x, y, localSize, localOpacity);
        lineToolLastDot = localSize * settingSpacing;
        lastInput.x = x;
        lastInput.y = y;
        lastInput.pressure = p;
        lastInput2 = _bb.BB.copyObj(lastInput);
        historyEntry1.actions.push({
            action: "startLine",
            params: [
                x,
                y,
                p
            ]
        });
    };
    this.goLine = function(x, y, p) {
        if (!isDrawing) return;
        historyEntry1.actions.push({
            action: "goLine",
            params: [
                x,
                y,
                p
            ]
        });
        //debug
        //drawDot(x, y, 1, 0.5);
        let pressure = _bb.BB.clamp(p, 0, 1);
        let localSize = settingHasSizePressure ? Math.max(0.1, lastInput.pressure * settingSize) : Math.max(0.1, settingSize);
        continueLine(x, y, localSize, lastInput.pressure);
        lastInput2 = _bb.BB.copyObj(lastInput);
        lastInput.x = x;
        lastInput.y = y;
        lastInput.pressure = pressure;
    };
    this.endLine = function(x, y) {
        let localSize = settingHasSizePressure ? Math.max(0.1, lastInput.pressure * settingSize) : Math.max(0.1, settingSize);
        continueLine(null, null, localSize, lastInput.pressure);
        //debug
        //drawDot(lastInput.x, lastInput.y, 3, 1);
        //drawDot(x, y, 10, 0.1);
        isDrawing = false;
        bezierLine = null;
        if (historyEntry1) {
            historyEntry1.actions.push({
                action: "endLine",
                params: [
                    x,
                    y
                ]
            });
            history.push(historyEntry1);
            historyEntry1 = undefined;
        }
    };
    //cheap n' ugly
    this.drawLineSegment = function(x1, y1, x2, y2) {
        lastInput.x = x2;
        lastInput.y = y2;
        lastInput.pressure = 1;
        if (isDrawing || x1 === undefined) return;
        if (settingUseDither) updateDither();
        if (Math.round(settingSize * 2) === 1) plotLine(x1, y1, x2, y2, true);
        else {
            let angle = _bb.BB.pointsToAngleDeg({
                x: x1,
                y: y1
            }, {
                x: x2,
                y: y2
            });
            let mouseDist = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            let eX = (x2 - x1) / mouseDist;
            let eY = (y2 - y1) / mouseDist;
            let loopDist;
            let bdist = settingSize * settingSpacing;
            lineToolLastDot = settingSize * settingSpacing;
            for(loopDist = lineToolLastDot; loopDist <= mouseDist; loopDist += bdist)drawDot(x1 + eX * loopDist, y1 + eY * loopDist, settingSize, settingOpacity, angle);
        }
        let historyEntry = {
            tool: [
                "brush",
                "PixelBrush"
            ],
            actions: []
        };
        historyEntry.actions.push({
            action: "sizePressure",
            params: [
                settingHasSizePressure
            ]
        });
        historyEntry.actions.push({
            action: "setSize",
            params: [
                settingSize
            ]
        });
        historyEntry.actions.push({
            action: "setSpacing",
            params: [
                settingSpacing
            ]
        });
        historyEntry.actions.push({
            action: "setOpacity",
            params: [
                settingOpacity
            ]
        });
        historyEntry.actions.push({
            action: "setColor",
            params: [
                settingColor
            ]
        });
        historyEntry.actions.push({
            action: "setLockAlpha",
            params: [
                settingLockLayerAlpha
            ]
        });
        historyEntry.actions.push({
            action: "setIsEraser",
            params: [
                settingIsEraser
            ]
        });
        historyEntry.actions.push({
            action: "setUseDither",
            params: [
                settingUseDither
            ]
        });
        historyEntry.actions.push({
            action: "drawLineSegment",
            params: [
                x1,
                y1,
                x2,
                y2
            ]
        });
        history.push(historyEntry);
    };
    //IS
    this.isDrawing = function() {
        return isDrawing;
    };
    //SET
    this.setColor = function(c) {
        if (settingColor === c) return;
        settingColor = c;
        settingColorStr = "rgb(" + settingColor.r + "," + settingColor.g + "," + settingColor.b + ")";
    };
    this.setContext = function(c) {
        context = c;
    };
    this.setHistory = function(l) {
        history = l;
    };
    this.setSize = function(s) {
        settingSize = s;
    };
    this.setOpacity = function(o) {
        settingOpacity = o;
    };
    this.setSpacing = function(s) {
        settingSpacing = s;
    };
    this.sizePressure = function(b) {
        settingHasSizePressure = b;
    };
    this.opacityPressure = function(b) {
        settingHasOpacityPressure = b;
    };
    this.setLockAlpha = function(b) {
        settingLockLayerAlpha = b;
    };
    this.setIsEraser = function(b) {
        settingIsEraser = !!b;
    };
    this.setUseDither = function(b) {
        settingUseDither = !!b;
    };
    //GET
    this.getSpacing = function() {
        return settingSpacing;
    };
    this.getSize = function() {
        return settingSize;
    };
    this.getOpacity = function() {
        return settingOpacity;
    };
    this.getLockAlpha = function() {
        return settingLockLayerAlpha;
    };
    this.getIsEraser = function() {
        return settingIsEraser;
    };
    this.getUseDither = function() {
        return settingUseDither;
    };
}

},{"../../bb/bb":"e3nbn","../kl":"3bnx1","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"lmqon":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EraserBrush", ()=>EraserBrush
);
var _bb = require("../../bb/bb");
var _kl = require("../kl");
function EraserBrush() {
    let context;
    let history = new _kl.KL.DecoyKlHistory();
    let historyEntry1;
    let size1 = 30, spacing = 0.4, opacity1 = 1;
    let sizePressure = true, opacityPressure = false;
    let lastDot, lastInput = {
        x: 0,
        y: 0,
        pressure: 0
    };
    let lastInput2 = {
        x: 0,
        y: 0,
        pressure: 0
    };
    let started = false;
    let bezierLine;
    let isBaseLayer = false;
    let isTransparentBG = false;
    function drawDot(x, y, size, opacity) {
        context.save();
        if (isBaseLayer) {
            if (isTransparentBG) context.globalCompositeOperation = "destination-out";
            else context.globalCompositeOperation = "source-atop";
        } else context.globalCompositeOperation = "destination-out";
        let radgrad = context.createRadialGradient(size, size, 0, size, size, size);
        let sharpness = Math.pow(opacity, 2);
        sharpness = Math.max(0, Math.min((size - 1) / size, sharpness));
        let oFac = Math.max(0, Math.min(1, opacity));
        let localOpacity = 2 * oFac - oFac * oFac;
        radgrad.addColorStop(sharpness, "rgba(255, 255, 255, " + localOpacity + ")");
        radgrad.addColorStop(1, "rgba(255, 255, 255, 0)");
        context.fillStyle = radgrad;
        context.translate(x - size, y - size);
        context.fillRect(0, 0, size * 2, size * 2);
        context.restore();
    }
    function continueLine(x, y, p) {
        p = Math.max(0, Math.min(1, p));
        let localPressure;
        let localOpacity;
        let localSize = sizePressure ? Math.max(0.1, p * size1) : Math.max(0.1, size1);
        let bdist = Math.max(1, Math.max(0.5, 1 - opacity1) * localSize * spacing);
        function bezierCallback(val) {
            let factor = val.t;
            localPressure = lastInput2.pressure * (1 - factor) + p * factor;
            localOpacity = opacityPressure ? opacity1 * localPressure * localPressure : opacity1;
            localSize = sizePressure ? Math.max(0.1, localPressure * size1) : Math.max(0.1, size1);
            drawDot(val.x, val.y, localSize, localOpacity);
        }
        if (x === null) bezierLine.addFinal(bdist, bezierCallback);
        else bezierLine.add(x, y, bdist, bezierCallback);
    }
    this.startLine = function(x, y, p) {
        historyEntry1 = {
            tool: [
                "brush",
                "EraserBrush"
            ],
            actions: []
        };
        historyEntry1.actions.push({
            action: "opacityPressure",
            params: [
                opacityPressure
            ]
        });
        historyEntry1.actions.push({
            action: "sizePressure",
            params: [
                sizePressure
            ]
        });
        historyEntry1.actions.push({
            action: "setSize",
            params: [
                size1
            ]
        });
        historyEntry1.actions.push({
            action: "setOpacity",
            params: [
                opacity1
            ]
        });
        historyEntry1.actions.push({
            action: "setTransparentBG",
            params: [
                isTransparentBG
            ]
        });
        isBaseLayer = 0 === context.canvas.index;
        p = Math.max(0, Math.min(1, p));
        let localOpacity = opacityPressure ? opacity1 * p * p : opacity1;
        let localSize = sizePressure ? Math.max(0.1, p * size1) : Math.max(0.1, size1);
        started = true;
        if (localSize > 1) drawDot(x, y, localSize, localOpacity);
        lastDot = localSize * spacing;
        lastInput.x = x;
        lastInput.y = y;
        lastInput.pressure = p;
        lastInput2 = _bb.BB.copyObj(lastInput);
        bezierLine = new _bb.BB.BezierLine();
        bezierLine.add(x, y, 0, function() {
        });
        historyEntry1.actions.push({
            action: "startLine",
            params: [
                x,
                y,
                p
            ]
        });
    };
    this.goLine = function(x, y, p) {
        if (!started) return;
        historyEntry1.actions.push({
            action: "goLine",
            params: [
                x,
                y,
                p
            ]
        });
        continueLine(x, y, lastInput.pressure);
        lastInput2 = _bb.BB.copyObj(lastInput);
        lastInput.x = x;
        lastInput.y = y;
        lastInput.pressure = p;
    };
    this.endLine = function() {
        if (bezierLine) continueLine(null, null, lastInput.pressure);
        started = false;
        bezierLine = undefined;
        if (historyEntry1) {
            historyEntry1.actions.push({
                action: "endLine",
                params: []
            });
            history.push(historyEntry1);
            historyEntry1 = undefined;
        }
    };
    //cheap n' ugly
    this.drawLineSegment = function(x1, y1, x2, y2) {
        isBaseLayer = 0 === context.canvas.index;
        lastInput.x = x2;
        lastInput.y = y2;
        if (started || x1 === undefined) return;
        let mouseDist = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        let eX = (x2 - x1) / mouseDist;
        let eY = (y2 - y1) / mouseDist;
        let loopDist;
        let bdist = Math.max(1, Math.max(0.5, 1 - opacity1) * size1 * spacing);
        lastDot = 0;
        for(loopDist = lastDot; loopDist <= mouseDist; loopDist += bdist)drawDot(x1 + eX * loopDist, y1 + eY * loopDist, size1, opacity1);
        let historyEntry = {
            tool: [
                "brush",
                "EraserBrush"
            ],
            actions: []
        };
        historyEntry.actions.push({
            action: "opacityPressure",
            params: [
                opacityPressure
            ]
        });
        historyEntry.actions.push({
            action: "sizePressure",
            params: [
                sizePressure
            ]
        });
        historyEntry.actions.push({
            action: "setSize",
            params: [
                size1
            ]
        });
        historyEntry.actions.push({
            action: "setOpacity",
            params: [
                opacity1
            ]
        });
        historyEntry.actions.push({
            action: "setTransparentBG",
            params: [
                isTransparentBG
            ]
        });
        historyEntry.actions.push({
            action: "drawLineSegment",
            params: [
                x1,
                y1,
                x2,
                y2
            ]
        });
        history.push(historyEntry);
    };
    //IS
    this.isDrawing = function() {
        return started;
    };
    //SET
    /*this.setAlpha = function(a) {
        lastInput = {};
        alpha = a;
        updateAlphaCanvas();
    };*/ this.setContext = function(c) {
        context = c;
    };
    this.setHistory = function(l) {
        history = l;
    };
    this.setSize = function(s) {
        size1 = s;
    };
    this.setOpacity = function(o) {
        opacity1 = o;
    };
    this.sizePressure = function(b) {
        sizePressure = b;
    };
    this.opacityPressure = function(b) {
        opacityPressure = b;
    };
    this.setTransparentBG = function(b) {
        isTransparentBG = b == true;
    };
    //GET
    this.getSize = function() {
        return size1;
    };
    this.getOpacity = function() {
        return opacity1;
    };
}

},{"../../bb/bb":"e3nbn","../kl":"3bnx1","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6WD75":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SmudgeBrush", ()=>SmudgeBrush
);
var _bb = require("../../bb/bb");
var _kl = require("../kl");
// let statCount = 1;
// let statAcc = 0;
// stats on win10, chrome, size 100, opacity 80, smudge()
// unoptimized: 1 ms
// minimal: 0.09 ms
// minimal + circle: 0.5ms
// minimal + circle + ix, iy: 0.23ms
// unoptimized + ix, iy: 0.64 ms
// unoptimized + ix, iy + sans rounding: 0.61 ms
// ix, iy + sans rounding + sans random: 0.32ms
// ix, iy + sans rounding + fast random: 0.46 ms
// ix, iy + sans rounding + fast random + offset const: 0.48 ms
const CELL_SIZE = 256;
/**
 * determine bounds of smudge
 * @param imWidth
 * @param imHeight
 * @param aP
 * @param bP
 * @param size
 */ function prepSmudge(imWidth, imHeight, aP, bP, size) {
    if (aP.x === bP.x && aP.y === bP.y) return null;
    aP = _bb.BB.copyObj(aP);
    bP = _bb.BB.copyObj(bP);
    size = _bb.BB.copyObj(size);
    // corner behavior
    // cut down rectangles, if a or b go outside
    // i.e. if user drags partially or fully outside the canvas
    {
        let top = 0;
        let right = 0;
        let bottom = 0;
        let left = 0;
        if (aP.x < 0) left = -aP.x;
        if (aP.y < 0) top = -aP.y;
        if (bP.x < 0) left = Math.max(left, -bP.x);
        if (bP.y < 0) top = Math.max(top, -bP.y);
        if (aP.x + size.w > imWidth) right = aP.x + size.w - imWidth;
        if (aP.y + size.h > imHeight) bottom = aP.y + size.h - imHeight;
        if (bP.x + size.w > imWidth) right = Math.max(right, bP.x + size.w - imWidth);
        if (bP.y + size.h > imHeight) bottom = Math.max(bottom, bP.y + size.h - imHeight);
        aP.x += left;
        bP.x += left;
        aP.y += top;
        bP.y += top;
        size.w = size.w - left - right;
        size.h = size.h - top - bottom;
        if (size.w <= 0 || size.h <= 0) return null;
    }
    return {
        aP: {
            x: aP.x,
            y: aP.y
        },
        bP: {
            x: bP.x,
            y: bP.y
        },
        size: {
            w: size.w,
            h: size.h
        }
    };
}
// faster than using BB.clamp somehow (in chrome)
function clamp(num, min, max) {
    return num <= min ? min : num >= max ? max : num;
}
/**
 * Pixel operations that do the smudging via ImageData
 * @param imageData
 * @param p
 */ function smudge(imageData, p) {
    p = _bb.BB.copyObj(p);
    const cSize = p.brush.size;
    const cX = p.brush.center.x;
    const cY = p.brush.center.y;
    /*if (statCount % 1000 === 0) {
        console.log(statAcc / 1000);
        statAcc = 0;
    }
    let start = performance.now();*/ // determine offset
    let aIndex = p.aP.y * imageData.width + p.aP.x;
    let bIndex = p.bP.y * imageData.width + p.bP.x;
    const offset = (bIndex - aIndex) * 4;
    // array with random numbers. faster than Math.random()
    let randI = 0;
    const randLen = cSize > 30 ? 1024 : 512; // lower lengths lead to noticeable patterns
    const randArr = [];
    for(let i = 0; i < randLen; i++)randArr[i] = (Math.random() - 0.5) / 1.001 + 0.5;
    const softnessPx = Math.max(3, Math.min(8, p.brush.size - 8));
    const pixel = (ai, bi, ix, iy)=>{
        const dist = _bb.BB.dist(cX, cY, ix, iy);
        const fac = 1 - p.brush.opacity * (1 - clamp((dist - (cSize - softnessPx)) / softnessPx, 0, 1));
        if (fac === 1) return;
        if (!imageData.data[ai + 3]) ;
        else if (!imageData.data[bi + 3]) {
            imageData.data[bi] = imageData.data[ai + 0];
            imageData.data[bi + 1] = imageData.data[ai + 1];
            imageData.data[bi + 2] = imageData.data[ai + 2];
        } else {
            // consider alpha ratio. If a has lower alpha than b, then b should be stronger, and vice versa
            // not totally accurate. TODO same compositing as blend brush
            let fac2;
            if (imageData.data[ai + 3] < imageData.data[bi + 3]) fac2 = 1 - imageData.data[ai + 3] / imageData.data[bi + 3] * (1 - fac);
            else fac2 = imageData.data[bi + 3] / imageData.data[ai + 3] * fac;
            // ImageData's Uint8ClampedArray rounds -> 0.5 becomes 1. But not in Safari, so needs to be done manually
            // Offset mixed color by random number noise (-0.5, 0.5), so it doesn't get stuck while mixing.
            // No +0.5, because it cancels out with rand.
            imageData.data[bi] = Math.floor(_bb.BB.mix(imageData.data[ai], imageData.data[bi + 0], fac2) + randArr[randI]);
            imageData.data[bi + 1] = Math.floor(_bb.BB.mix(imageData.data[ai + 1], imageData.data[bi + 1], fac2) + randArr[randI]);
            imageData.data[bi + 2] = Math.floor(_bb.BB.mix(imageData.data[ai + 2], imageData.data[bi + 2], fac2) + randArr[randI]);
            randI = (randI + 1) % randLen;
        }
        // Always mix alpha. unless alpha lock
        if (!p.brush.alphaLock) imageData.data[bi + 3] = Math.floor(_bb.BB.mix(imageData.data[ai + 3], imageData.data[bi + 3], fac) + 0.5);
    };
    const bx1 = p.bP.x * 4;
    const bx2 = bx1 + (p.size.w - 1) * 4;
    // transfer of pixels depends on direction of smudging if there is overlap
    if (p.aP.y < p.bP.y) for(let y = p.size.h - 1, iy2 = p.bP.y + p.size.h - 1; y >= 0; y--, iy2--){
        const yStart = (y + p.bP.y) * imageData.width * 4;
        for(let x = bx2 + yStart, x2 = bx2 + yStart - offset, ix = p.bP.x + p.size.w - 1; x >= bx1 + yStart; x -= 4, x2 -= 4, ix--)pixel(x2, x, ix, iy2);
    }
    else if (p.aP.y > p.bP.y) for(let y1 = 0, iy1 = p.bP.y; y1 < p.size.h; y1++, iy1++){
        const yStart = (y1 + p.bP.y) * imageData.width * 4;
        for(let x = bx2 + yStart, x2 = bx2 + yStart - offset, ix = p.bP.x + p.size.w - 1; x >= bx1 + yStart; x -= 4, x2 -= 4, ix--)pixel(x2, x, ix, iy1);
    }
    else {
        if (p.aP.x < p.bP.x) for(let y = p.size.h - 1, iy = p.bP.y + p.size.h - 1; y >= 0; y--, iy--){
            const yStart = (y + p.bP.y) * imageData.width * 4;
            for(let x = bx2 + yStart, x2 = bx2 + yStart - offset, ix = p.bP.x + p.size.w - 1; x >= bx1 + yStart; x -= 4, x2 -= 4, ix--)pixel(x2, x, ix, iy);
        }
        else for(let y2 = 0, iy3 = p.bP.y; y2 < p.size.h; y2++, iy3++){
            const yStart = (y2 + p.bP.y) * imageData.width * 4;
            for(let x = bx1 + yStart, x2 = bx1 + yStart - offset, ix = p.bP.x; x < bx2 + yStart; x += 4, x2 += 4, ix++)pixel(x2, x, ix, iy3);
        }
    }
//statCount++;
//statAcc += performance.now() - start;
}
class SmudgeBrush {
    updateRedrawBounds(bounds) {
        this.redrawBounds = _bb.BB.updateBounds(this.redrawBounds, bounds);
    }
    updateCompleteRedrawBounds(x1, y1, x2, y2) {
        this.completeRedrawBounds = _bb.BB.updateBounds(this.completeRedrawBounds, {
            x1,
            y1,
            x2,
            y2
        });
    }
    /**
     * update copyImageData. copy over new regions if needed
     */ copyFromCanvas() {
        const touchedCells = this.copiedCells.map((item)=>false
        );
        const bounds = [];
        const cellsW = Math.ceil(this.copyImageData.width / CELL_SIZE);
        if (!this.redrawBounds) return;
        bounds.push({
            x1: Math.floor(this.redrawBounds.x1 / CELL_SIZE),
            y1: Math.floor(this.redrawBounds.y1 / CELL_SIZE),
            x2: Math.floor(this.redrawBounds.x2 / CELL_SIZE),
            y2: Math.floor(this.redrawBounds.y2 / CELL_SIZE)
        });
        bounds.forEach((item)=>{
            for(let i = item.x1; i <= item.x2; i++)for(let e = item.y1; e <= item.y2; e++)touchedCells[e * cellsW + i] = true;
        });
        touchedCells.forEach((item, i)=>{
            if (!item || this.copiedCells[i]) // not touched, or already copied
            return;
            this.copiedCells[i] = true;
            const x = i % cellsW;
            const y = Math.floor(i / cellsW);
            const w = (Math.min(x * CELL_SIZE + CELL_SIZE, this.copyImageData.width) - 1) % CELL_SIZE + 1;
            const h = (Math.min(y * CELL_SIZE + CELL_SIZE, this.copyImageData.height) - 1) % CELL_SIZE + 1;
            // temp canvas to prevent main canvas from getting slowed down in chrome
            const tmpCanvas = _bb.BB.canvas(w, h);
            const tmpCtx = tmpCanvas.getContext('2d');
            tmpCtx.drawImage(this.context.canvas, -x * CELL_SIZE, -y * CELL_SIZE);
            const data = tmpCtx.getImageData(0, 0, w, h);
            for(let i1 = 0; i1 < h; i1++)for(let e = 0, e2 = i1 * w * 4, e3 = ((y * CELL_SIZE + i1) * this.copyImageData.width + x * CELL_SIZE) * 4; e < w; e++, e2 += 4, e3 += 4){
                this.copyImageData.data[e3] = data.data[e2];
                this.copyImageData.data[e3 + 1] = data.data[e2 + 1];
                this.copyImageData.data[e3 + 2] = data.data[e2 + 2];
                this.copyImageData.data[e3 + 3] = data.data[e2 + 3];
            }
        });
    }
    /**
     * fill drawBuffer with params about to be drawn
     * @param x
     * @param y
     * @param size
     * @param opacity
     */ prepDot(x, y, size, opacity) {
        if (!this.lastDot) {
            this.lastDot = {
                x: x,
                y: y
            };
            return;
        }
        size = Math.round(size);
        const w = Math.round(size * 2);
        const h = Math.round(size * 2);
        const bounds = prepSmudge(this.copyImageData.width, this.copyImageData.height, {
            x: Math.round(this.lastDot.x - size),
            y: Math.round(this.lastDot.y - size)
        }, {
            x: Math.round(x - size),
            y: Math.round(y - size)
        }, {
            w,
            h
        });
        if (bounds) {
            const params = {
                aP: bounds.aP,
                bP: bounds.bP,
                size: bounds.size,
                brush: {
                    center: {
                        x,
                        y
                    },
                    size,
                    opacity,
                    alphaLock: this.settingLockLayerAlpha
                }
            };
            this.updateRedrawBounds({
                x1: params.bP.x,
                y1: params.bP.y,
                x2: params.bP.x + params.brush.size * 2,
                y2: params.bP.y + params.brush.size * 2
            });
            this.drawBuffer.push(params);
        }
        this.lastDot = {
            x: x,
            y: y
        };
    }
    continueLine(x, y, size, pressure) {
        this.drawBuffer = [];
        if (this.bezierLine === null) {
            this.bezierLine = new _bb.BB.BezierLine();
            this.bezierLine.add(this.lastInput.x, this.lastInput.y, 0, function() {
            });
        }
        const drawArr = []; //draw instructions. will be all drawn at once
        const dotCallback = (val)=>{
            const localPressure = _bb.BB.mix(this.lastInput2.pressure, pressure, val.t);
            const localOpacity = this.settingOpacity * (this.settingHasOpacityPressure ? localPressure * localPressure : 1);
            const localSize = Math.max(0.1, this.settingSize * (this.settingHasSizePressure ? localPressure : 1));
            drawArr.push([
                val.x,
                val.y,
                localSize,
                localOpacity,
                val.angle
            ]);
        };
        const localSpacing = size * this.settingSpacing / 3;
        if (x === null) this.bezierLine.addFinal(localSpacing, dotCallback);
        else this.bezierLine.add(x, y, localSpacing, dotCallback);
        // execute draw instructions
        let before;
        for(let i = 0; i < drawArr.length; i++){
            const item = drawArr[i];
            this.prepDot(item[0], item[1], item[2], item[3]);
            before = item;
        }
        this.copyFromCanvas();
        for(let i2 = 0; i2 < this.drawBuffer.length; i2++)smudge(this.copyImageData, this.drawBuffer[i2]);
    }
    // ---- public ----
    constructor(){
        this.history = new _kl.KL.DecoyKlHistory();
        this.settingColor = {
            r: 0,
            g: 0,
            b: 0
        };
        this.settingSize = 35;
        this.settingSpacing = 0.20446882736951905;
        this.settingOpacity = 0.8;
        this.settingHasSizePressure = false;
        this.settingHasOpacityPressure = false;
        this.settingLockLayerAlpha = false;
        this.lastInput = {
            x: 0,
            y: 0,
            pressure: 0
        };
        this.lastInput2 = {
            x: 0,
            y: 0,
            pressure: 0
        };
        this.isDrawing = false;
        this.bezierLine // todo type BezierLine
         = null;
        this.drawBuffer = [];
    }
    startLine(x, y, p) {
        this.historyEntry = {
            tool: [
                "brush",
                "SmudgeBrush"
            ],
            actions: []
        };
        p = _bb.BB.clamp(p, 0, 1);
        const localOpacity = this.settingHasOpacityPressure ? this.settingOpacity * p * p : this.settingOpacity;
        const localSize = this.settingHasSizePressure ? Math.max(0.1, p * this.settingSize) : Math.max(0.1, this.settingSize);
        this.lastDot = null;
        this.isDrawing = true;
        this.copyImageData = new ImageData(this.context.canvas.width, this.context.canvas.height);
        const totalCells = Math.ceil(this.context.canvas.width / CELL_SIZE) * Math.ceil(this.context.canvas.height / CELL_SIZE);
        this.copiedCells = '0'.repeat(totalCells).split('').map((item)=>false
        );
        this.prepDot(x, y, localSize, localOpacity);
        this.lineToolLastDot = localSize * this.settingSpacing;
        this.lastInput.x = x;
        this.lastInput.y = y;
        this.lastInput.pressure = p;
        this.lastInput2.pressure = p;
        this.completeRedrawBounds = null;
    }
    goLine(x, y, p) {
        if (!this.isDrawing) return;
        this.redrawBounds = null;
        const pressure = _bb.BB.clamp(p, 0, 1);
        const localSize = this.settingHasSizePressure ? Math.max(0.1, this.lastInput.pressure * this.settingSize) : Math.max(0.1, this.settingSize);
        this.continueLine(x, y, localSize, this.lastInput.pressure);
        if (this.redrawBounds) {
            this.context.putImageData(this.copyImageData, 0, 0, this.redrawBounds.x1, this.redrawBounds.y1, this.redrawBounds.x2 - this.redrawBounds.x1 - 1, this.redrawBounds.y2 - this.redrawBounds.y1 - 1);
            this.updateCompleteRedrawBounds(this.redrawBounds.x1, this.redrawBounds.y1, this.redrawBounds.x2, this.redrawBounds.y2);
        }
        this.lastInput.x = x;
        this.lastInput.y = y;
        this.lastInput2.pressure = this.lastInput.pressure;
        this.lastInput.pressure = pressure;
    }
    endLine() {
        this.redrawBounds = null;
        const localSize = this.settingHasSizePressure ? Math.max(0.1, this.lastInput.pressure * this.settingSize) : Math.max(0.1, this.settingSize);
        this.context.save();
        this.continueLine(null, null, localSize, this.lastInput.pressure);
        this.context.restore();
        this.isDrawing = false;
        this.bezierLine = null;
        if (this.redrawBounds) {
            this.context.putImageData(this.copyImageData, 0, 0, this.redrawBounds.x1, this.redrawBounds.y1, this.redrawBounds.x2 - this.redrawBounds.x1 - 1, this.redrawBounds.y2 - this.redrawBounds.y1 - 1);
            this.updateCompleteRedrawBounds(this.redrawBounds.x1, this.redrawBounds.y1, this.redrawBounds.x2, this.redrawBounds.y2);
        }
        if (this.historyEntry && this.completeRedrawBounds) {
            let historyIm = this.copyImageData;
            if (!(this.completeRedrawBounds.x1 === 0 && this.completeRedrawBounds.y1 === 0 && this.completeRedrawBounds.x2 >= this.context.canvas.width - 1 && this.completeRedrawBounds.y2 >= this.context.canvas.height - 1)) {
                // temp canvas to prevent main canvas from getting slowed down in chrome
                const tmpCanvas = _bb.BB.canvas(this.completeRedrawBounds.x2 - this.completeRedrawBounds.x1 + 1, this.completeRedrawBounds.y2 - this.completeRedrawBounds.y1 + 1);
                const tmpCtx = tmpCanvas.getContext('2d');
                tmpCtx.drawImage(this.context.canvas, -this.completeRedrawBounds.x1, -this.completeRedrawBounds.y1);
                historyIm = tmpCanvas; // faster than getting image data (measured on 2018 lenovo chromebook)
            }
            this.historyEntry.actions.push({
                action: "drawImage",
                params: [
                    historyIm,
                    this.completeRedrawBounds.x1,
                    this.completeRedrawBounds.y1, 
                ]
            });
            this.history.push(this.historyEntry);
            this.historyEntry = undefined;
        }
        this.copyImageData = null;
    }
    drawImage(im, x, y) {
        if (im instanceof ImageData) this.context.putImageData(im, x, y);
        else {
            this.context.clearRect(x, y, im.width, im.height);
            this.context.drawImage(im, x, y);
        }
    }
    drawLineSegment(x1, y1, x2, y2) {
        return;
    /*
        // todo
        lastInput.x = x2;
        lastInput.y = y2;
        lastInput.pressure = 1;

        if (isDrawing || x1 === undefined) {
            return;
        }

        let angle = BB.pointsToAngleDeg({x:x1, y:y1}, {x:x2, y:y2});
        let mouseDist = Math.sqrt(Math.pow(x2 - x1, 2.0) + Math.pow(y2 - y1, 2.0));
        let eX = (x2 - x1) / mouseDist;
        let eY = (y2 - y1) / mouseDist;
        let loopDist;
        let bdist = settingSize * settingSpacing;
        lineToolLastDot = settingSize * settingSpacing;
        for (loopDist = lineToolLastDot; loopDist <= mouseDist; loopDist += bdist) {
            drawDot(x1 + eX * loopDist, y1 + eY * loopDist, settingSize, settingOpacity);
        }


        let historyEntry = {
            tool: ["brush", "SmudgeBrush"],
            actions: []
        };
        // todo
        history.add(historyEntry);*/ }
    getIsDrawing() {
        return this.isDrawing;
    }
    setColor(c) {
        if (this.settingColor.r === c.r && this.settingColor.g === c.g && this.settingColor.b === c.b) return;
        this.settingColor = {
            r: c.r,
            g: c.g,
            b: c.b
        };
        this.settingColorStr = _bb.BB.ColorConverter.toRgbStr(this.settingColor);
    }
    setContext(c) {
        this.context = c;
    }
    setHistory(h) {
        this.history = h;
    }
    setSize(s) {
        this.settingSize = s;
    }
    setOpacity(o) {
        this.settingOpacity = o;
    }
    setSpacing(s) {
        this.settingSpacing = s;
    }
    sizePressure(b) {
        this.settingHasSizePressure = !!b;
    }
    opacityPressure(b) {
        this.settingHasOpacityPressure = !!b;
    }
    setLockAlpha(b) {
        this.settingLockLayerAlpha = !!b;
    }
    getSpacing() {
        return this.settingSpacing;
    }
    getSize() {
        return this.settingSize;
    }
    getOpacity() {
        return this.settingOpacity;
    }
    getLockAlpha() {
        return this.settingLockLayerAlpha;
    }
}

},{"../../bb/bb":"e3nbn","../kl":"3bnx1","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ei7AK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ChemyBrush", ()=>ChemyBrush
);
var _bb = require("../../bb/bb");
class ChemyBrush {
    updateCompleteRedrawBounds(x, y) {
        let bounds = {
            x1: x,
            y1: y,
            x2: x,
            y2: y
        };
        if (this.settingXSymmetry) bounds = _bb.BB.updateBounds(bounds, {
            x1: -x + this.copyCanvas.width,
            y1: y,
            x2: -x + this.copyCanvas.width,
            y2: y
        });
        if (this.settingYSymmetry) bounds = _bb.BB.updateBounds(bounds, {
            x1: x,
            y1: -y + this.copyCanvas.height,
            x2: x,
            y2: -y + this.copyCanvas.height
        });
        const buffer = this.settingMode === 'stroke' ? this.settingSize + 1 : 1;
        bounds.x1 = Math.floor(bounds.x1 - buffer);
        bounds.y1 = Math.floor(bounds.y1 - buffer);
        bounds.x2 = Math.ceil(bounds.x2 + buffer);
        bounds.y2 = Math.ceil(bounds.y2 + buffer);
        this.completeRedrawBounds = _bb.BB.updateBounds(this.completeRedrawBounds, bounds);
    }
    drawShape() {
        this.context.save();
        this.context.clearRect(0, 0, this.context.canvas.width, this.context.canvas.height);
        this.context.drawImage(this.copyCanvas, 0, 0);
        let color = {
            ...this.settingColor
        };
        if (this.settingIsEraser) {
            color.r = 255;
            color.g = 255;
            color.b = 255;
            if (this.settingLockLayerAlpha) this.context.globalCompositeOperation = "source-atop";
            else this.context.globalCompositeOperation = "destination-out";
        } else if (this.settingLockLayerAlpha) this.context.globalCompositeOperation = "source-atop";
        if (this.path) {
            // path
            const path = new Path2D();
            this.path.forEach((item, index)=>{
                if (index === 0) path.moveTo(item.x, item.y);
                else path.lineTo(item.x, item.y);
            });
            let style = _bb.BB.ColorConverter.toRgbaStr({
                r: color.r,
                g: color.g,
                b: color.b,
                a: this.settingOpacity
            });
            if (this.settingGradient) {
                const startAtTop = this.path[0].x > this.path[this.path.length - 1].x;
                const gradient = this.context.createLinearGradient(0, startAtTop ? this.minY : this.maxY, 0, startAtTop ? this.maxY : this.minY);
                gradient.addColorStop(0, _bb.BB.ColorConverter.toRgbaStr({
                    r: color.r,
                    g: color.g,
                    b: color.b,
                    a: this.settingOpacity
                }));
                gradient.addColorStop(1, _bb.BB.ColorConverter.toRgbaStr({
                    r: color.r,
                    g: color.g,
                    b: color.b,
                    a: 0
                }));
                style = gradient;
            }
            // setup params
            if (this.settingMode === 'fill') this.context.fillStyle = style;
            else {
                this.context.lineWidth = this.settingSize * 2;
                this.context.lineJoin = 'bevel';
                this.context.strokeStyle = style;
            }
            // draw
            const draw = ()=>{
                if (this.settingMode === 'fill') this.context.fill(path);
                else this.context.stroke(path);
            };
            draw();
            if (this.settingXSymmetry) {
                this.context.save();
                this.context.translate(this.context.canvas.width / 2, 0);
                this.context.scale(-1, 1);
                this.context.translate(-this.context.canvas.width / 2, 0);
                draw();
                this.context.restore();
            }
            if (this.settingYSymmetry) {
                this.context.save();
                this.context.translate(0, this.context.canvas.height / 2);
                this.context.scale(1, -1);
                this.context.translate(0, -this.context.canvas.height / 2);
                draw();
                this.context.restore();
                if (this.settingXSymmetry) {
                    this.context.save();
                    this.context.translate(this.context.canvas.width / 2, this.context.canvas.height / 2);
                    this.context.scale(-1, -1);
                    this.context.translate(-this.context.canvas.width / 2, -this.context.canvas.height / 2);
                    draw();
                    this.context.restore();
                }
            }
        }
        this.context.restore();
    }
    // --- public ----
    constructor(){
        this.settingSize // radius - 0.5 - 99999
         = 0.25;
        this.settingOpacity // 0-1
         = 1;
        this.settingLockLayerAlpha = false;
        this.settingIsEraser = false;
        this.settingMode = 'fill';
        this.settingDistort // 0 - 1
         = 0;
        this.settingXSymmetry = false;
        this.settingYSymmetry = false;
        this.settingGradient = false;
        this.isDrawing = false;
    }
    setHistory(h) {
        this.history = h;
    }
    getSize() {
        return this.settingMode === 'stroke' ? this.settingSize : 0;
    }
    setSize(s) {
        this.settingSize = s;
    }
    getOpacity() {
        return this.settingOpacity;
    }
    setOpacity(o) {
        this.settingOpacity = o;
    }
    setColor(c) {
        this.settingColor = _bb.BB.copyObj(c);
    }
    setContext(c) {
        this.context = c;
    }
    setMode(mode) {
        this.settingMode = mode;
    }
    getMode() {
        return this.settingMode;
    }
    setDistort(distort) {
        this.settingDistort = _bb.BB.clamp(distort, 0, 1);
    }
    getDistort() {
        return this.settingDistort;
    }
    setXSymmetry(b) {
        this.settingXSymmetry = !!b;
    }
    getXSymmetry() {
        return this.settingXSymmetry;
    }
    setYSymmetry(b) {
        this.settingYSymmetry = !!b;
    }
    getYSymmetry() {
        return this.settingYSymmetry;
    }
    setGradient(b) {
        this.settingGradient = !!b;
    }
    getGradient() {
        return this.settingGradient;
    }
    getLockAlpha() {
        return this.settingLockLayerAlpha;
    }
    setLockAlpha(b) {
        this.settingLockLayerAlpha = !!b;
    }
    getIsEraser() {
        return this.settingIsEraser;
    }
    setIsEraser(b) {
        this.settingIsEraser = !!b;
    }
    getIsDrawing() {
        return this.isDrawing;
    }
    startLine(x, y) {
        this.isDrawing = true;
        this.path = [
            {
                x,
                y
            }
        ];
        this.minY = y;
        this.maxY = y;
        this.copyCanvas = _bb.BB.canvas(this.context.canvas.width, this.context.canvas.height);
        this.copyCanvas.getContext('2d').drawImage(this.context.canvas, 0, 0);
        this.completeRedrawBounds = null;
        this.updateCompleteRedrawBounds(x, y);
    }
    goLine(x, y) {
        if (!this.isDrawing) return;
        let pos = {
            x,
            y
        };
        if (this.settingDistort > 0) {
            pos.x += (Math.random() - 0.5) * this.settingDistort * 80;
            pos.y += (Math.random() - 0.5) * this.settingDistort * 80;
        }
        this.minY = Math.min(this.minY, pos.y);
        this.maxY = Math.max(this.maxY, pos.y);
        this.path.push(pos);
        this.updateCompleteRedrawBounds(x, y);
        this.drawShape();
    }
    endLine() {
        this.isDrawing = false;
        this.completeRedrawBounds = _bb.BB.boundsInArea(this.completeRedrawBounds, this.copyCanvas.width, this.copyCanvas.height);
        if (this.path.length > 1 && this.completeRedrawBounds) {
            const historyCanvas = _bb.BB.canvas(this.completeRedrawBounds.x2 - this.completeRedrawBounds.x1 + 1, this.completeRedrawBounds.y2 - this.completeRedrawBounds.y1 + 1);
            const historyCtx = historyCanvas.getContext('2d');
            historyCtx.drawImage(this.context.canvas, -this.completeRedrawBounds.x1, -this.completeRedrawBounds.y1);
            this.history.push({
                tool: [
                    "brush",
                    "ChemyBrush"
                ],
                actions: [
                    {
                        action: "drawImage",
                        params: [
                            historyCanvas,
                            this.completeRedrawBounds.x1,
                            this.completeRedrawBounds.y1, 
                        ]
                    }
                ]
            });
        }
        this.path = null;
        this.copyCanvas = null;
    }
    drawImage(im, x, y) {
        this.context.save();
        this.context.clearRect(x, y, im.width, im.height);
        this.context.drawImage(im, x, y);
        this.context.restore();
    }
    drawLineSegment(x1, y1, x2, y2) {
    // might make sense for stroke
    }
}

},{"../../bb/bb":"e3nbn","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"icb0x":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "brushesUI", ()=>brushesUI
);
var _penBrushUi = require("./pen-brush-ui");
var _blendBrushUi = require("./blend-brush-ui");
var _sketchyBrushUi = require("./sketchy-brush-ui");
var _pixelBrushUi = require("./pixel-brush-ui");
var _eraserBrushUi = require("./eraser-brush-ui");
var _smudgeBrushUi = require("./smudge-brush-ui");
var _chemyBrushUi = require("./chemy-brush-ui");
const brushesUI = {
    penBrush: _penBrushUi.penBrushUi,
    blendBrush: _blendBrushUi.blendBrushUi,
    sketchyBrush: _sketchyBrushUi.sketchyBrushUi,
    pixelBrush: _pixelBrushUi.pixelBrushUi,
    chemyBrush: _chemyBrushUi.chemyBrushUi,
    smudgeBrush: _smudgeBrushUi.smudgeBrushUi,
    eraserBrush: _eraserBrushUi.eraserBrushUi
};

},{"./pen-brush-ui":"edsNm","./blend-brush-ui":"98sjw","./sketchy-brush-ui":"awz09","./pixel-brush-ui":"6Rcg3","./eraser-brush-ui":"38Rvj","./smudge-brush-ui":"6s06V","./chemy-brush-ui":"8UQlM","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"edsNm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "penBrushUi", ()=>penBrushUi
);
var _bb = require("../../bb/bb");
var _brushes = require("../brushes/brushes");
var _brushesConsts = require("./brushes-consts");
var _klHistory = require("../history/kl-history");
var _checkbox = require("../ui/base-components/checkbox");
var _klSlider = require("../ui/base-components/kl-slider");
var _penPressureToggle = require("../ui/base-components/pen-pressure-toggle");
// @ts-ignore
var _brushPenSvg = require("url:~/src/app/img/ui/brush-pen.svg");
var _brushPenSvgDefault = parcelHelpers.interopDefault(_brushPenSvg);
var _brushAlphas = require("../brushes/alphas/brush-alphas");
var _language = require("../../language/language");
const penBrushUi = function() {
    let brushInterface = {
        image: _brushPenSvgDefault.default,
        tooltip: _language.LANG('brush-pen'),
        sizeSlider: {
            min: 0.5,
            max: 100,
            curve: _bb.BB.quadraticSplineInput(0.5, 100, 0.1)
        },
        opacitySlider: {
            min: 0,
            max: 1,
            curve: [
                [
                    0,
                    0.01
                ],
                [
                    0.5,
                    0.3
                ],
                [
                    1,
                    1
                ]
            ]
        },
        Ui: null
    };
    let alphaNames = [
        _language.LANG('brush-pen-circle'),
        _language.LANG('brush-pen-chalk'),
        _language.LANG('brush-pen-calligraphy'),
        _language.LANG('brush-pen-square'), 
    ];
    _language.languageStrings.subscribe(()=>{
        brushInterface.tooltip = _language.LANG('brush-pen');
        alphaNames = [
            _language.LANG('brush-pen-circle'),
            _language.LANG('brush-pen-chalk'),
            _language.LANG('brush-pen-calligraphy'),
            _language.LANG('brush-pen-square'), 
        ];
    });
    brushInterface.Ui = function(p1) {
        let div = document.createElement("div"); // the gui
        let brush = new _brushes.brushes.PenBrush();
        brush.setHistory(_klHistory.klHistory);
        p1.onSizeChange(brush.getSize());
        let sizeSlider;
        let opacitySlider;
        let alphas = [];
        let currentAlpha = 0;
        for(let i1 = 0; i1 < 4; i1++)(function(i) {
            let alpha = _bb.BB.el({
                title: alphaNames[i],
                onClick: ()=>{
                    alphaClick(i);
                }
            });
            let canvas = _bb.BB.canvas(70, 70);
            let ctx = canvas.getContext('2d');
            if (i === 0 || i === 3) {
                if (i === 0) {
                    ctx.beginPath();
                    ctx.arc(35, 35, 30, 0, 2 * Math.PI);
                    ctx.closePath();
                    ctx.fill();
                } else ctx.fillRect(5, 5, 60, 60);
            } else if (i === 1) ctx.drawImage(_brushAlphas.genBrushAlpha01(60), 5, 5);
            else if (i === 2) ctx.drawImage(_brushAlphas.genBrushAlpha02(60), 5, 5);
            alpha.style.backgroundImage = 'url(' + canvas.toDataURL('image/png') + ')';
            alphas.push(alpha);
        })(i1);
        function updateAlphas() {
            for(let i = 0; i < alphas.length; i++)if (i === currentAlpha) alphas[i].className = 'brush-alpha-selected';
            else alphas[i].className = 'brush-alpha';
        }
        updateAlphas();
        function alphaClick(id) {
            currentAlpha = id;
            brush.setAlpha(id);
            updateAlphas();
        }
        let lockAlphaToggle = new _checkbox.Checkbox({
            init: brush.getLockAlpha(),
            label: _language.LANG('brush-lock-alpha'),
            callback: function(b) {
                brush.setLockAlpha(b);
            },
            doHighlight: true,
            title: _language.LANG('brush-lock-alpha-title'),
            css: {
                cssFloat: 'right',
                textAlign: 'right'
            }
        });
        let spacingSpline = new _bb.BB.SplineInterpolator([
            [
                0,
                15
            ],
            [
                8,
                7
            ],
            [
                14,
                4
            ],
            [
                30,
                3
            ],
            [
                50,
                2.7
            ],
            [
                100,
                2
            ]
        ]);
        function setSize(size) {
            brush.setSize(size);
            brush.setSpacing(Math.max(2, spacingSpline.interpolate(size)) / 15);
        }
        function init() {
            sizeSlider = new _klSlider.KlSlider({
                label: _language.LANG('brush-size'),
                width: 225,
                height: 30,
                min: brushInterface.sizeSlider.min,
                max: brushInterface.sizeSlider.max,
                initValue: brush.getSize(),
                eventResMs: _brushesConsts.eventResMs,
                onChange: function(val) {
                    setSize(val);
                    p1.onSizeChange(val);
                },
                curve: brushInterface.sizeSlider.curve,
                formatFunc: function(v) {
                    v *= 2;
                    if (v < 10) return Math.round(v * 10) / 10;
                    else return Math.round(v);
                }
            });
            opacitySlider = new _klSlider.KlSlider({
                label: _language.LANG('opacity'),
                width: 225,
                height: 30,
                min: brushInterface.opacitySlider.min,
                max: brushInterface.opacitySlider.max,
                initValue: brushInterface.opacitySlider.max,
                eventResMs: _brushesConsts.eventResMs,
                onChange: function(val) {
                    brush.setOpacity(val);
                    p1.onOpacityChange(val);
                },
                curve: brushInterface.opacitySlider.curve,
                formatFunc: function(v) {
                    return Math.round(v * 100);
                }
            });
            let pressureSizeToggle = _penPressureToggle.penPressureToggle(false, function(b) {
                brush.sizePressure(b);
            });
            let pressureOpacityToggle = _penPressureToggle.penPressureToggle(false, function(b) {
                brush.opacityPressure(b);
            });
            div.append(_bb.BB.el({
                content: [
                    sizeSlider.getElement(),
                    pressureSizeToggle
                ],
                css: {
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    marginBottom: '10px'
                }
            }), _bb.BB.el({
                content: [
                    opacitySlider.getElement(),
                    pressureOpacityToggle
                ],
                css: {
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center'
                }
            }));
            let alphaWrapper = document.createElement("div");
            for(let i = 0; i < alphas.length; i++)alphaWrapper.appendChild(alphas[i]);
            alphaWrapper.style.marginTop = "10px";
            div.appendChild(alphaWrapper);
            alphaWrapper.appendChild(lockAlphaToggle.getElement());
        }
        init();
        this.increaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.increaseValue(f);
        };
        this.decreaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.decreaseValue(f);
        };
        this.getSize = function() {
            return brush.getSize();
        };
        this.setSize = function(size) {
            setSize(size);
            sizeSlider.setValue(size);
        };
        this.getOpacity = function() {
            return brush.getOpacity();
        };
        this.setOpacity = function(opacity) {
            brush.setOpacity(opacity);
            opacitySlider.setValue(opacity);
        };
        this.setColor = function(c) {
            brush.setColor(c);
        };
        this.setContext = function(c) {
            brush.setContext(c);
        };
        this.startLine = function(x, y, p) {
            brush.startLine(x, y, p);
        };
        this.goLine = function(x, y, p) {
            brush.goLine(x, y, p);
        };
        this.endLine = function(x, y) {
            brush.endLine(x, y);
        };
        this.getBrush = function() {
            return brush;
        };
        this.isDrawing = function() {
            return brush.isDrawing();
        };
        this.getElement = function() {
            return div;
        };
    };
    return brushInterface;
}();

},{"../../bb/bb":"e3nbn","../brushes/brushes":"34S30","./brushes-consts":"3AD2T","../history/kl-history":"ai9zE","../ui/base-components/checkbox":"clzcQ","../ui/base-components/kl-slider":"1Vedp","../ui/base-components/pen-pressure-toggle":"1AVub","url:~/src/app/img/ui/brush-pen.svg":"cxi7O","../brushes/alphas/brush-alphas":"fPGfk","../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3AD2T":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "eventResMs", ()=>eventResMs
);
const eventResMs = 20;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cxi7O":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "brush-pen.85cb4f0a.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"98sjw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "blendBrushUi", ()=>blendBrushUi
);
var _bb = require("../../bb/bb");
var _penPressureToggle = require("../ui/base-components/pen-pressure-toggle");
var _brushesConsts = require("./brushes-consts");
var _checkbox = require("../ui/base-components/checkbox");
var _brushes = require("../brushes/brushes");
var _klHistory = require("../history/kl-history");
var _klSlider = require("../ui/base-components/kl-slider");
// @ts-ignore
var _brushBlendSvg = require("url:~/src/app/img/ui/brush-blend.svg");
var _brushBlendSvgDefault = parcelHelpers.interopDefault(_brushBlendSvg);
var _language = require("../../language/language");
const blendBrushUi = function() {
    let brushInterface = {
        image: _brushBlendSvgDefault.default,
        tooltip: _language.LANG('brush-blend'),
        sizeSlider: {
            min: 0.5,
            max: 100,
            curve: _bb.BB.quadraticSplineInput(0.5, 100, 0.1)
        },
        opacitySlider: {
            min: 0.01,
            max: 1
        },
        Ui: null
    };
    _language.languageStrings.subscribe(()=>{
        brushInterface.tooltip = _language.LANG('brush-blend');
    });
    brushInterface.Ui = function(p1) {
        let div = document.createElement("div"); // the gui
        let brush = new _brushes.brushes.BlendBrush();
        brush.setHistory(_klHistory.klHistory);
        p1.onSizeChange(brush.getSize());
        let sizeSlider;
        let opacitySlider;
        function setSize(size) {
            brush.setSize(size);
        }
        function init() {
            sizeSlider = new _klSlider.KlSlider({
                label: _language.LANG('brush-size'),
                width: 225,
                height: 30,
                min: brushInterface.sizeSlider.min,
                max: brushInterface.sizeSlider.max,
                initValue: 29,
                eventResMs: _brushesConsts.eventResMs,
                onChange: function(val) {
                    setSize(val);
                    p1.onSizeChange(val);
                },
                curve: brushInterface.sizeSlider.curve,
                formatFunc: function(v) {
                    v *= 2;
                    return Math.round(v);
                }
            });
            opacitySlider = new _klSlider.KlSlider({
                label: _language.LANG('opacity'),
                width: 225,
                height: 30,
                min: brushInterface.opacitySlider.min,
                max: brushInterface.opacitySlider.max,
                initValue: brush.getOpacity(),
                eventResMs: _brushesConsts.eventResMs,
                onChange: function(val) {
                    brush.setOpacity(val);
                    p1.onOpacityChange(val);
                },
                formatFunc: function(v) {
                    return Math.round(v * 100);
                }
            });
            let blendingSlider = new _klSlider.KlSlider({
                label: _language.LANG('brush-blending'),
                width: 225,
                height: 30,
                min: 0,
                max: 100,
                initValue: brush.getBlending() * 100,
                eventResMs: _brushesConsts.eventResMs,
                onChange: function(val) {
                    brush.setBlending(val / 100);
                }
            });
            blendingSlider.getElement().style.marginTop = "10px";
            let pressureSizeToggle = _penPressureToggle.penPressureToggle(true, function(b) {
                brush.setSizePressure(b);
            });
            let pressureOpacityToggle = _penPressureToggle.penPressureToggle(false, function(b) {
                brush.setOpacityPressure(b);
            });
            let lockAlphaToggle = new _checkbox.Checkbox({
                init: brush.getLockAlpha(),
                label: _language.LANG('brush-lock-alpha'),
                callback: function(b) {
                    brush.setLockAlpha(b);
                },
                doHighlight: true,
                title: _language.LANG('brush-lock-alpha-title'),
                css: {
                    marginTop: '10px',
                    display: 'inline-block'
                }
            });
            div.append(_bb.BB.el({
                content: [
                    sizeSlider.getElement(),
                    pressureSizeToggle
                ],
                css: {
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    marginBottom: '10px'
                }
            }), _bb.BB.el({
                content: [
                    opacitySlider.getElement(),
                    pressureOpacityToggle
                ],
                css: {
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center'
                }
            }), blendingSlider.getElement(), lockAlphaToggle.getElement());
        }
        init();
        this.increaseSize = function(f) {
            if (!brush.getIsDrawing()) sizeSlider.increaseValue(f);
        };
        this.decreaseSize = function(f) {
            if (!brush.getIsDrawing()) sizeSlider.decreaseValue(f);
        };
        this.getSize = function() {
            return brush.getSize();
        };
        this.setSize = function(size) {
            setSize(size);
            sizeSlider.setValue(size);
        };
        this.getOpacity = function() {
            return brush.getOpacity();
        };
        this.setOpacity = function(opacity) {
            brush.setOpacity(opacity);
            opacitySlider.setValue(opacity);
        };
        this.setColor = function(c) {
            brush.setColor(c);
        };
        this.setContext = function(c) {
            brush.setContext(c);
        };
        this.startLine = function(x, y, p) {
            brush.startLine(x, y, p);
        };
        this.goLine = function(x, y, p, isCoalesced) {
            brush.goLine(x, y, p, isCoalesced);
        };
        this.endLine = function() {
            brush.endLine();
        };
        this.getBrush = function() {
            return brush;
        };
        this.isDrawing = function() {
            return brush.getIsDrawing();
        };
        this.getElement = function() {
            return div;
        };
    };
    return brushInterface;
}();

},{"../../bb/bb":"e3nbn","../ui/base-components/pen-pressure-toggle":"1AVub","./brushes-consts":"3AD2T","../ui/base-components/checkbox":"clzcQ","../brushes/brushes":"34S30","../history/kl-history":"ai9zE","../ui/base-components/kl-slider":"1Vedp","url:~/src/app/img/ui/brush-blend.svg":"gGTHb","../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gGTHb":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "brush-blend.6e8a8669.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"awz09":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sketchyBrushUi", ()=>sketchyBrushUi
);
var _brushes = require("../brushes/brushes");
var _brushesConsts = require("./brushes-consts");
var _klHistory = require("../history/kl-history");
var _klSlider = require("../ui/base-components/kl-slider");
// @ts-ignore
var _brushSketchyPng = require("url:~/src/app/img/ui/brush-sketchy.png");
var _brushSketchyPngDefault = parcelHelpers.interopDefault(_brushSketchyPng);
var _language = require("../../language/language");
const sketchyBrushUi = function() {
    let brushInterface = {
        image: _brushSketchyPngDefault.default,
        tooltip: _language.LANG('brush-sketchy'),
        sizeSlider: {
            min: 0.5,
            max: 10
        },
        opacitySlider: {
            min: 0.01,
            max: 1
        },
        Ui: null
    };
    _language.languageStrings.subscribe(()=>{
        brushInterface.tooltip = _language.LANG('brush-sketchy');
    });
    brushInterface.Ui = function(p) {
        let div = document.createElement("div"); // the gui
        let brush = new _brushes.brushes.SketchyBrush();
        brush.setHistory(_klHistory.klHistory);
        p.onSizeChange(brush.getSize());
        let sizeSlider;
        let opacitySlider;
        function setSize(size) {
            brush.setSize(size);
        }
        function init() {
            sizeSlider = new _klSlider.KlSlider({
                label: _language.LANG('brush-size'),
                width: 250,
                height: 30,
                min: brushInterface.sizeSlider.min,
                max: brushInterface.sizeSlider.max,
                initValue: brush.getSize(),
                eventResMs: _brushesConsts.eventResMs,
                onChange: function(val) {
                    brush.setSize(val);
                    p.onSizeChange(brush.getSize());
                },
                formatFunc: function(v) {
                    v *= 2;
                    if (v < 10) return Math.round(v * 10) / 10;
                    else return Math.round(v);
                }
            });
            opacitySlider = new _klSlider.KlSlider({
                label: _language.LANG('opacity'),
                width: 250,
                height: 30,
                min: brushInterface.opacitySlider.min,
                max: brushInterface.opacitySlider.max,
                initValue: brush.getOpacity(),
                eventResMs: _brushesConsts.eventResMs,
                onChange: function(val) {
                    brush.setOpacity(val);
                    p.onOpacityChange(val);
                },
                formatFunc: function(v) {
                    return Math.round(v * 100);
                }
            });
            let blendSlider = new _klSlider.KlSlider({
                label: _language.LANG('brush-blending'),
                width: 250,
                height: 30,
                min: 0,
                max: 100,
                initValue: brush.getBlending() * 100,
                eventResMs: _brushesConsts.eventResMs,
                onChange: function(val) {
                    brush.setBlending(val / 100);
                }
            });
            let scaleSlider = new _klSlider.KlSlider({
                label: _language.LANG('brush-sketchy-scale'),
                width: 250,
                height: 30,
                min: 1,
                max: 20,
                initValue: brush.getScale(),
                eventResMs: _brushesConsts.eventResMs,
                onChange: function(val) {
                    brush.setScale(val);
                }
            });
            opacitySlider.getElement().style.marginTop = "10px";
            blendSlider.getElement().style.marginTop = "10px";
            scaleSlider.getElement().style.marginTop = "10px";
            div.appendChild(sizeSlider.getElement());
            div.appendChild(opacitySlider.getElement());
            div.appendChild(blendSlider.getElement());
            div.appendChild(scaleSlider.getElement());
        }
        init();
        this.increaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.increaseValue(f);
        };
        this.decreaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.decreaseValue(f);
        };
        this.getSize = function() {
            return brush.getSize();
        };
        this.setSize = function(size) {
            setSize(size);
            sizeSlider.setValue(size);
        };
        this.getOpacity = function() {
            return brush.getOpacity();
        };
        this.setOpacity = function(opacity) {
            brush.setOpacity(opacity);
            opacitySlider.setValue(opacity);
        };
        this.setColor = function(c) {
            brush.setColor(c);
        };
        this.setContext = function(c) {
            brush.setContext(c);
        };
        this.startLine = function(x, y, pressure) {
            brush.startLine(x, y, pressure);
        };
        this.goLine = function(x, y, pressure) {
            brush.goLine(x, y, pressure, null);
        };
        this.endLine = function() {
            brush.endLine();
        };
        this.getSeed = function() {
            return parseInt(brush.getSeed());
        };
        this.setSeed = function(s) {
            brush.setSeed(parseInt(s));
        };
        this.getBrush = function() {
            return brush;
        };
        this.isDrawing = function() {
            return brush.isDrawing();
        };
        this.getElement = function() {
            return div;
        };
    };
    return brushInterface;
}();

},{"../brushes/brushes":"34S30","./brushes-consts":"3AD2T","../history/kl-history":"ai9zE","../ui/base-components/kl-slider":"1Vedp","url:~/src/app/img/ui/brush-sketchy.png":"bV5Qi","../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bV5Qi":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "brush-sketchy.005ebd2a.png" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"6Rcg3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pixelBrushUi", ()=>pixelBrushUi
);
var _bb = require("../../bb/bb");
var _brushes = require("../brushes/brushes");
var _brushesConsts = require("./brushes-consts");
var _klHistory = require("../history/kl-history");
var _checkbox = require("../ui/base-components/checkbox");
var _klSlider = require("../ui/base-components/kl-slider");
var _penPressureToggle = require("../ui/base-components/pen-pressure-toggle");
// @ts-ignore
var _brushPixelSvg = require("url:~/src/app/img/ui/brush-pixel.svg");
var _brushPixelSvgDefault = parcelHelpers.interopDefault(_brushPixelSvg);
var _language = require("../../language/language");
const pixelBrushUi = function() {
    let brushInterface = {
        image: _brushPixelSvgDefault.default,
        tooltip: _language.LANG('brush-pixel'),
        sizeSlider: {
            min: 0.5,
            max: 100,
            curve: _bb.BB.quadraticSplineInput(0.5, 100, 0.1)
        },
        opacitySlider: {
            min: 0,
            max: 1,
            curve: [
                [
                    0,
                    0.01
                ],
                [
                    0.5,
                    0.3
                ],
                [
                    1,
                    1
                ]
            ]
        },
        Ui: null
    };
    _language.languageStrings.subscribe(()=>{
        brushInterface.tooltip = _language.LANG('brush-pixel');
    });
    brushInterface.Ui = function(p1) {
        let div = document.createElement("div"); // the gui
        let brush = new _brushes.brushes.PixelBrush();
        brush.setHistory(_klHistory.klHistory);
        p1.onSizeChange(brush.getSize());
        let sizeSlider;
        let opacitySlider;
        let lockAlphaToggle = new _checkbox.Checkbox({
            init: brush.getLockAlpha(),
            label: _language.LANG('brush-lock-alpha'),
            callback: function(b) {
                brush.setLockAlpha(b);
            },
            doHighlight: true,
            title: _language.LANG('brush-lock-alpha-title'),
            css: {
                marginRight: '10px'
            }
        });
        let eraserToggle = new _checkbox.Checkbox({
            init: brush.getIsEraser(),
            label: _language.LANG('eraser'),
            callback: function(b) {
                brush.setIsEraser(b);
            },
            css: {
                marginRight: '10px'
            }
        });
        let ditherToggle = new _checkbox.Checkbox({
            init: brush.getUseDither(),
            label: _language.LANG('brush-pixel-dither'),
            callback: function(b) {
                brush.setUseDither(b);
            }
        });
        let spacingSpline = new _bb.BB.SplineInterpolator([
            [
                0.5,
                0.45
            ],
            [
                100,
                4
            ]
        ]);
        function setSize(size) {
            brush.setSize(size);
            brush.setSpacing(spacingSpline.interpolate(size) / size);
        }
        function init() {
            sizeSlider = new _klSlider.KlSlider({
                label: _language.LANG('brush-size'),
                width: 225,
                height: 30,
                min: brushInterface.sizeSlider.min,
                max: brushInterface.sizeSlider.max,
                initValue: brush.getSize(),
                eventResMs: _brushesConsts.eventResMs,
                onChange: function(val) {
                    val = Math.round(val * 2) / 2;
                    setSize(val);
                    p1.onSizeChange(val);
                },
                curve: brushInterface.sizeSlider.curve,
                formatFunc: function(v) {
                    v *= 2;
                    return Math.round(v);
                }
            });
            opacitySlider = new _klSlider.KlSlider({
                label: _language.LANG('opacity'),
                width: 225,
                height: 30,
                min: brushInterface.opacitySlider.min,
                max: brushInterface.opacitySlider.max,
                initValue: brushInterface.opacitySlider.max,
                eventResMs: _brushesConsts.eventResMs,
                onChange: function(val) {
                    brush.setOpacity(val);
                    p1.onOpacityChange(val);
                },
                curve: brushInterface.opacitySlider.curve,
                formatFunc: function(v) {
                    return Math.round(v * 100);
                }
            });
            let pressureSizeToggle = _penPressureToggle.penPressureToggle(false, function(b) {
                brush.sizePressure(b);
            });
            div.append(_bb.BB.el({
                content: [
                    sizeSlider.getElement(),
                    pressureSizeToggle
                ],
                css: {
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    marginBottom: '10px'
                }
            }), opacitySlider.getElement());
            let toggleRow = _bb.BB.el({
                parent: div,
                css: {
                    display: 'flex',
                    marginTop: '10px'
                }
            });
            toggleRow.appendChild(lockAlphaToggle.getElement());
            toggleRow.appendChild(eraserToggle.getElement());
            toggleRow.appendChild(ditherToggle.getElement());
        }
        init();
        this.increaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.increaseValue(f);
        };
        this.decreaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.decreaseValue(f);
        };
        this.getSize = function() {
            return brush.getSize();
        };
        this.setSize = function(size) {
            setSize(size);
            sizeSlider.setValue(size);
        };
        this.getOpacity = function() {
            return brush.getOpacity();
        };
        this.setOpacity = function(opacity) {
            brush.setOpacity(opacity);
            opacitySlider.setValue(opacity);
        };
        this.setColor = function(c) {
            brush.setColor(c);
        };
        this.setContext = function(c) {
            brush.setContext(c);
        };
        this.startLine = function(x, y, p) {
            brush.startLine(x, y, p);
        };
        this.goLine = function(x, y, p) {
            brush.goLine(x, y, p);
        };
        this.endLine = function(x, y) {
            brush.endLine(x, y);
        };
        this.getBrush = function() {
            return brush;
        };
        this.isDrawing = function() {
            return brush.isDrawing();
        };
        this.getElement = function() {
            return div;
        };
    };
    return brushInterface;
}();

},{"../../bb/bb":"e3nbn","../brushes/brushes":"34S30","./brushes-consts":"3AD2T","../history/kl-history":"ai9zE","../ui/base-components/checkbox":"clzcQ","../ui/base-components/kl-slider":"1Vedp","../ui/base-components/pen-pressure-toggle":"1AVub","url:~/src/app/img/ui/brush-pixel.svg":"lMnep","../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"lMnep":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "brush-pixel.ec0a6671.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"38Rvj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "eraserBrushUi", ()=>eraserBrushUi
);
var _bb = require("../../bb/bb");
var _brushes = require("../brushes/brushes");
var _brushesConsts = require("./brushes-consts");
var _klHistory = require("../history/kl-history");
var _klSlider = require("../ui/base-components/kl-slider");
var _penPressureToggle = require("../ui/base-components/pen-pressure-toggle");
var _checkbox = require("../ui/base-components/checkbox");
// @ts-ignore
var _brushEraserSvg = require("url:~/src/app/img/ui/brush-eraser.svg");
var _brushEraserSvgDefault = parcelHelpers.interopDefault(_brushEraserSvg);
var _language = require("../../language/language");
const eraserBrushUi = function() {
    let brushInterface = {
        image: _brushEraserSvgDefault.default,
        tooltip: _language.LANG('eraser') + ' [E]',
        sizeSlider: {
            min: 0.5,
            max: 200,
            curve: _bb.BB.quadraticSplineInput(0.5, 200, 0.1)
        },
        opacitySlider: {
            min: 0.01,
            max: 1
        },
        Ui: null
    };
    _language.languageStrings.subscribe(()=>{
        brushInterface.tooltip = _language.LANG('eraser') + ' [E]';
    });
    brushInterface.Ui = function(p1) {
        let div = document.createElement("div"); // the gui
        let brush = new _brushes.brushes.EraserBrush();
        brush.setHistory(_klHistory.klHistory);
        p1.onSizeChange(brush.getSize());
        let sizeSlider;
        let opacitySlider;
        let isTransparentBg = false;
        function setSize(size) {
            brush.setSize(size);
        }
        function init() {
            sizeSlider = new _klSlider.KlSlider({
                label: _language.LANG('brush-size'),
                width: 225,
                height: 30,
                min: brushInterface.sizeSlider.min,
                max: brushInterface.sizeSlider.max,
                initValue: 30,
                eventResMs: _brushesConsts.eventResMs,
                onChange: function(val) {
                    setSize(val);
                    p1.onSizeChange(val);
                },
                curve: brushInterface.sizeSlider.curve,
                formatFunc: function(v) {
                    v *= 2;
                    if (v < 10) return Math.round(v * 10) / 10;
                    else return Math.round(v);
                }
            });
            opacitySlider = new _klSlider.KlSlider({
                label: _language.LANG('opacity'),
                width: 225,
                height: 30,
                min: brushInterface.opacitySlider.min,
                max: brushInterface.opacitySlider.max,
                initValue: 1,
                eventResMs: _brushesConsts.eventResMs,
                onChange: function(val) {
                    brush.setOpacity(val);
                    p1.onOpacityChange(val);
                },
                formatFunc: function(v) {
                    return Math.round(v * 100);
                }
            });
            let pressureSizeToggle = _penPressureToggle.penPressureToggle(false, function(b) {
                brush.sizePressure(b);
            });
            let pressureOpacityToggle = _penPressureToggle.penPressureToggle(false, function(b) {
                brush.opacityPressure(b);
            });
            div.append(_bb.BB.el({
                content: [
                    sizeSlider.getElement(),
                    pressureSizeToggle
                ],
                css: {
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    marginBottom: '10px'
                }
            }), _bb.BB.el({
                content: [
                    opacitySlider.getElement(),
                    pressureOpacityToggle
                ],
                css: {
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center'
                }
            }));
            let transparencyToggle = new _checkbox.Checkbox({
                init: false,
                label: _language.LANG('brush-eraser-transparent-bg'),
                callback: function(b) {
                    isTransparentBg = b;
                    brush.setTransparentBG(b);
                },
                css: {
                    marginTop: "10px"
                }
            });
            div.appendChild(transparencyToggle.getElement());
        }
        init();
        function drawDot(x, y) {
            brush.drawDot(x, y);
        }
        this.increaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.increaseValue(f);
        };
        this.decreaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.decreaseValue(f);
        };
        this.getSize = function() {
            return brush.getSize();
        };
        this.setSize = function(size) {
            setSize(size);
            sizeSlider.setValue(size);
        };
        this.getOpacity = function() {
            return brush.getOpacity();
        };
        this.setOpacity = function(opacity) {
            brush.setOpacity(opacity);
            opacitySlider.setValue(opacity);
        };
        this.setColor = function(c) {
        //brush.setColor(c);
        };
        this.setContext = function(c) {
            brush.setContext(c);
        };
        this.startLine = function(x, y, p) {
            brush.startLine(x, y, p);
        };
        this.goLine = function(x, y, p) {
            brush.goLine(x, y, p);
        };
        this.endLine = function() {
            brush.endLine();
        };
        this.getBrush = function() {
            return brush;
        };
        this.getIsTransparentBg = function() {
            return isTransparentBg;
        };
        this.isDrawing = function() {
            return brush.isDrawing();
        };
        this.getElement = function() {
            return div;
        };
    };
    return brushInterface;
}();

},{"../../bb/bb":"e3nbn","../brushes/brushes":"34S30","./brushes-consts":"3AD2T","../history/kl-history":"ai9zE","../ui/base-components/kl-slider":"1Vedp","../ui/base-components/pen-pressure-toggle":"1AVub","../ui/base-components/checkbox":"clzcQ","url:~/src/app/img/ui/brush-eraser.svg":"i4Zz0","../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"i4Zz0":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "brush-eraser.ffb3764e.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"6s06V":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "smudgeBrushUi", ()=>smudgeBrushUi
);
var _bb = require("../../bb/bb");
var _brushes = require("../brushes/brushes");
var _brushesConsts = require("./brushes-consts");
var _klHistory = require("../history/kl-history");
var _checkbox = require("../ui/base-components/checkbox");
var _klSlider = require("../ui/base-components/kl-slider");
var _penPressureToggle = require("../ui/base-components/pen-pressure-toggle");
// @ts-ignore
var _brushSmudgeSvg = require("url:~/src/app/img/ui/brush-smudge.svg");
var _brushSmudgeSvgDefault = parcelHelpers.interopDefault(_brushSmudgeSvg);
var _language = require("../../language/language");
const smudgeBrushUi = function() {
    let brushInterface = {
        image: _brushSmudgeSvgDefault.default,
        tooltip: _language.LANG('brush-smudge'),
        sizeSlider: {
            min: 0.5,
            max: 100,
            curve: _bb.BB.quadraticSplineInput(0.5, 100, 0.1)
        },
        opacitySlider: {
            min: 0,
            max: 1,
            curve: [
                [
                    0,
                    0.01
                ],
                [
                    0.5,
                    0.3
                ],
                [
                    1,
                    1
                ]
            ]
        },
        Ui: null
    };
    _language.languageStrings.subscribe(()=>{
        brushInterface.tooltip = _language.LANG('brush-smudge');
    });
    brushInterface.Ui = function(p1) {
        let div = document.createElement("div"); // the gui
        let brush = new _brushes.brushes.SmudgeBrush();
        brush.setHistory(_klHistory.klHistory);
        p1.onSizeChange(brush.getSize());
        let sizeSlider;
        let opacitySlider;
        let lockAlphaToggle = new _checkbox.Checkbox({
            init: brush.getLockAlpha(),
            label: _language.LANG('brush-lock-alpha'),
            callback: function(b) {
                brush.setLockAlpha(b);
            },
            doHighlight: true,
            title: _language.LANG('brush-lock-alpha-title')
        });
        let spacingSpline = new _bb.BB.SplineInterpolator([
            [
                0,
                15
            ],
            [
                8,
                7
            ],
            [
                14,
                4
            ],
            [
                30,
                3
            ],
            [
                50,
                2.7
            ],
            [
                100,
                2
            ]
        ]);
        function setSize(size) {
            brush.setSize(size);
            brush.setSpacing(Math.max(2, spacingSpline.interpolate(size)) / 15);
        }
        function init() {
            sizeSlider = new _klSlider.KlSlider({
                label: _language.LANG('brush-size'),
                width: 225,
                height: 30,
                min: brushInterface.sizeSlider.min,
                max: brushInterface.sizeSlider.max,
                initValue: brush.getSize(),
                eventResMs: _brushesConsts.eventResMs,
                onChange: function(val) {
                    setSize(val);
                    p1.onSizeChange(val);
                },
                curve: brushInterface.sizeSlider.curve,
                formatFunc: function(v) {
                    v *= 2;
                    if (v < 10) return Math.round(v * 10) / 10;
                    else return Math.round(v);
                }
            });
            opacitySlider = new _klSlider.KlSlider({
                label: _language.LANG('opacity'),
                width: 225,
                height: 30,
                min: brushInterface.opacitySlider.min,
                max: brushInterface.opacitySlider.max,
                initValue: brush.getOpacity(),
                eventResMs: _brushesConsts.eventResMs,
                onChange: function(val) {
                    brush.setOpacity(val);
                    p1.onOpacityChange(val);
                },
                curve: brushInterface.opacitySlider.curve,
                formatFunc: function(v) {
                    return Math.round(v * 100);
                }
            });
            let pressureSizeToggle = _penPressureToggle.penPressureToggle(false, function(b) {
                brush.sizePressure(b);
            });
            let pressureOpacityToggle = _penPressureToggle.penPressureToggle(false, function(b) {
                brush.opacityPressure(b);
            });
            div.append(_bb.BB.el({
                content: [
                    sizeSlider.getElement(),
                    pressureSizeToggle
                ],
                css: {
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    marginBottom: '10px'
                }
            }), _bb.BB.el({
                content: [
                    opacitySlider.getElement(),
                    pressureOpacityToggle
                ],
                css: {
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center'
                }
            }));
            let bottomRow = _bb.BB.el({
                parent: div,
                css: {
                    marginTop: '10px'
                }
            });
            bottomRow.append(lockAlphaToggle.getElement());
        }
        init();
        this.increaseSize = function(f) {
            if (!brush.getIsDrawing()) sizeSlider.increaseValue(f);
        };
        this.decreaseSize = function(f) {
            if (!brush.getIsDrawing()) sizeSlider.decreaseValue(f);
        };
        this.getSize = function() {
            return brush.getSize();
        };
        this.setSize = function(size) {
            setSize(size);
            sizeSlider.setValue(size);
        };
        this.getOpacity = function() {
            return brush.getOpacity();
        };
        this.setOpacity = function(opacity) {
            brush.setOpacity(opacity);
            opacitySlider.setValue(opacity);
        };
        this.setColor = function(c) {
            brush.setColor(c);
        };
        this.setContext = function(c) {
            brush.setContext(c);
        };
        this.startLine = function(x, y, p) {
            brush.startLine(x, y, p);
        };
        this.goLine = function(x, y, p) {
            brush.goLine(x, y, p);
        };
        this.endLine = function(x, y) {
            brush.endLine();
        };
        this.getBrush = function() {
            return brush;
        };
        this.isDrawing = function() {
            return brush.getIsDrawing();
        };
        this.getElement = function() {
            return div;
        };
    };
    return brushInterface;
}();

},{"../../bb/bb":"e3nbn","../brushes/brushes":"34S30","./brushes-consts":"3AD2T","../history/kl-history":"ai9zE","../ui/base-components/checkbox":"clzcQ","../ui/base-components/kl-slider":"1Vedp","../ui/base-components/pen-pressure-toggle":"1AVub","url:~/src/app/img/ui/brush-smudge.svg":"fcvQ8","../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fcvQ8":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "brush-smudge.21507cbc.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"8UQlM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "chemyBrushUi", ()=>chemyBrushUi
);
var _bb = require("../../bb/bb");
var _brushesConsts = require("./brushes-consts");
var _checkbox = require("../ui/base-components/checkbox");
var _brushes = require("../brushes/brushes");
var _klHistory = require("../history/kl-history");
var _klSlider = require("../ui/base-components/kl-slider");
// @ts-ignore
var _brushChemySvg = require("url:~/src/app/img/ui/brush-chemy.svg");
var _brushChemySvgDefault = parcelHelpers.interopDefault(_brushChemySvg);
var _options = require("../ui/base-components/options");
var _boxToggle = require("../ui/base-components/box-toggle");
var _language = require("../../language/language");
const chemyBrushUi = function() {
    const brushInterface = {
        image: _brushChemySvgDefault.default,
        tooltip: _language.LANG('brush-chemy'),
        sizeSlider: {
            min: 0.25,
            max: 25,
            curve: _bb.BB.quadraticSplineInput(0.25, 25, 0.1),
            isDisabled: true
        },
        opacitySlider: {
            min: 0.01,
            max: 1
        },
        Ui: null
    };
    _language.languageStrings.subscribe(()=>{
        brushInterface.tooltip = _language.LANG('brush-chemy');
    });
    brushInterface.Ui = function(p) {
        const div = document.createElement("div"); // the gui
        const brush = new _brushes.brushes.ChemyBrush();
        brush.setHistory(_klHistory.klHistory);
        p.onSizeChange(brush.getSize());
        let sizeSlider;
        let opacitySlider;
        function setSize(size) {
            brush.setSize(size);
        }
        function init() {
            sizeSlider = new _klSlider.KlSlider({
                label: _language.LANG('brush-size'),
                width: 250,
                height: 30,
                min: brushInterface.sizeSlider.min,
                max: brushInterface.sizeSlider.max,
                initValue: brush.getSize(),
                eventResMs: _brushesConsts.eventResMs,
                isEnabled: brush.getMode() === 'stroke',
                onChange: function(val) {
                    setSize(val);
                    p.onSizeChange(brush.getSize());
                },
                curve: brushInterface.sizeSlider.curve,
                formatFunc: function(v) {
                    v *= 2;
                    return v < 5 ? Math.round(v * 10) / 10 : Math.round(v);
                }
            });
            opacitySlider = new _klSlider.KlSlider({
                label: _language.LANG('opacity'),
                width: 250,
                height: 30,
                min: brushInterface.opacitySlider.min,
                max: brushInterface.opacitySlider.max,
                initValue: brush.getOpacity(),
                eventResMs: _brushesConsts.eventResMs,
                onChange: function(val) {
                    brush.setOpacity(val);
                    p.onOpacityChange(val);
                },
                formatFunc: function(v) {
                    return Math.round(v * 100);
                }
            });
            _bb.BB.css(opacitySlider.getElement(), {
                marginTop: '10px'
            });
            let eraserToggle = new _checkbox.Checkbox({
                init: brush.getIsEraser(),
                label: _language.LANG('eraser'),
                callback: function(b) {
                    brush.setIsEraser(b);
                },
                css: {
                    marginTop: '10px',
                    marginLeft: '10px'
                }
            });
            const lockAlphaToggle = new _checkbox.Checkbox({
                init: brush.getLockAlpha(),
                label: _language.LANG('brush-lock-alpha'),
                callback: function(b) {
                    brush.setLockAlpha(b);
                },
                doHighlight: true,
                title: _language.LANG('brush-lock-alpha-title'),
                css: {
                    marginTop: '10px'
                }
            });
            const toggleRow = _bb.BB.el({
                css: {
                    display: 'flex',
                    marginTop: '10px'
                }
            });
            const iconSize = 35;
            const padding = 8;
            const actualIconSize = iconSize - padding * 2;
            const halfSize = actualIconSize / 2;
            const modeOptions = new _options.Options({
                optionArr: [
                    {
                        id: 'fill',
                        label: _bb.BB.createSvg({
                            elementType: 'svg',
                            width: iconSize + '',
                            height: iconSize + '',
                            childrenArr: [
                                {
                                    elementType: 'path',
                                    fill: '#000',
                                    style: `transform-origin: 0 0; transform: translate(-0.5px, -0.5px) scale(${actualIconSize}, ${actualIconSize}) translate(0.5px, 0.5px)`,
                                    d: 'M 0,0 C 1.5,0 -0.5,1 1,1'
                                }, 
                            ]
                        }),
                        title: _language.LANG('brush-chemy-fill')
                    },
                    {
                        id: 'stroke',
                        label: _bb.BB.createSvg({
                            elementType: 'svg',
                            width: iconSize + '',
                            height: iconSize + '',
                            childrenArr: [
                                {
                                    elementType: 'path',
                                    fill: 'none',
                                    stroke: '#000',
                                    style: `stroke-width: 0.12px; transform-origin: 0 0; transform: translate(-0.5px, -0.5px) scale(${actualIconSize}, ${actualIconSize}) translate(0.5px, 0.5px)`,
                                    d: 'M 0,0 C 1.5,0 -0.5,1 1,1'
                                }, 
                            ]
                        }),
                        title: _language.LANG('brush-chemy-stroke')
                    }
                ],
                initId: brush.getMode(),
                onChange: (id)=>{
                    brush.setMode(id);
                    brushInterface.sizeSlider.isDisabled = brush.getMode() === 'fill';
                    sizeSlider.setIsEnabled(!brushInterface.sizeSlider.isDisabled);
                    sizeSlider.setValue(brush.getSize());
                    p.onSizeChange(brush.getSize());
                    p.onConfigChange();
                }
            });
            const mirrorXToggle = new _boxToggle.BoxToggle({
                label: _bb.BB.createSvg({
                    elementType: 'svg',
                    width: iconSize + '',
                    height: iconSize + '',
                    childrenArr: [
                        {
                            elementType: 'path',
                            fill: 'none',
                            stroke: '#000',
                            style: 'stroke-width: 1px',
                            d: `M ${halfSize + padding},${padding} ${halfSize + padding},${actualIconSize + padding}`
                        }, 
                    ]
                }),
                title: _language.LANG('brush-chemy-mirror-x'),
                init: brush.getXSymmetry(),
                onChange: (b)=>{
                    brush.setXSymmetry(b);
                }
            });
            const mirrorYToggle = new _boxToggle.BoxToggle({
                label: _bb.BB.createSvg({
                    elementType: 'svg',
                    width: iconSize + '',
                    height: iconSize + '',
                    childrenArr: [
                        {
                            elementType: 'path',
                            fill: 'none',
                            stroke: '#000',
                            style: 'stroke-width: 1px',
                            d: `M ${padding},${halfSize + padding} ${actualIconSize + padding},${halfSize + padding}`
                        }, 
                    ]
                }),
                title: _language.LANG('brush-chemy-mirror-y'),
                init: brush.getYSymmetry(),
                onChange: (b)=>{
                    brush.setYSymmetry(b);
                }
            });
            const gradientToggle = new _boxToggle.BoxToggle({
                label: _bb.BB.createSvg({
                    elementType: 'svg',
                    width: iconSize + '',
                    height: iconSize + '',
                    childrenArr: [
                        {
                            elementType: 'defs',
                            childrenArr: [
                                {
                                    elementType: 'linearGradient',
                                    id: 'gradient',
                                    x1: '0',
                                    y1: '0',
                                    x2: '0',
                                    y2: '1',
                                    childrenArr: [
                                        {
                                            elementType: 'stop',
                                            offset: '0%',
                                            'stop-color': 'rgba(0,0,0,0)'
                                        },
                                        {
                                            elementType: 'stop',
                                            offset: '100%',
                                            'stop-color': 'rgba(0,0,0,1)'
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            elementType: 'rect',
                            fill: "url('#gradient')",
                            x: '' + padding,
                            y: '' + padding,
                            width: '' + actualIconSize,
                            height: '' + actualIconSize
                        }, 
                    ]
                }),
                title: _language.LANG('brush-chemy-gradient'),
                init: brush.getGradient(),
                onChange: (b)=>{
                    brush.setGradient(b);
                }
            });
            _bb.BB.css(mirrorXToggle.getElement(), {
                marginLeft: '10px'
            });
            {
                const margin = {
                    marginLeft: '4px'
                };
                _bb.BB.css(mirrorYToggle.getElement(), margin);
                _bb.BB.css(gradientToggle.getElement(), margin);
            }
            toggleRow.append(modeOptions.getElement(), mirrorXToggle.getElement(), mirrorYToggle.getElement(), gradientToggle.getElement());
            div.append(sizeSlider.getElement(), opacitySlider.getElement(), toggleRow, _bb.BB.el({
                content: [
                    lockAlphaToggle.getElement(),
                    eraserToggle.getElement(), 
                ],
                css: {
                    display: 'flex'
                }
            }));
        }
        init();
        this.increaseSize = function(f) {
            if (!brush.getIsDrawing() && brush.getMode() === 'stroke') sizeSlider.increaseValue(f);
        };
        this.decreaseSize = function(f) {
            if (!brush.getIsDrawing() && brush.getMode() === 'stroke') sizeSlider.decreaseValue(f);
        };
        this.getSize = function() {
            return brush.getSize();
        };
        this.setSize = function(size) {
            setSize(size);
            sizeSlider.setValue(size);
        };
        this.getOpacity = function() {
            return brush.getOpacity();
        };
        this.setOpacity = function(opacity) {
            brush.setOpacity(opacity);
            opacitySlider.setValue(opacity);
        };
        this.setColor = function(c) {
            brush.setColor(c);
        };
        this.setContext = function(c) {
            brush.setContext(c);
        };
        this.startLine = function(x, y, p) {
            brush.startLine(x, y);
        };
        this.goLine = function(x, y, p, isCoalesced) {
            brush.goLine(x, y);
        };
        this.endLine = function() {
            brush.endLine();
        };
        this.getBrush = function() {
            return brush;
        };
        this.isDrawing = function() {
            return brush.getIsDrawing();
        };
        this.getElement = function() {
            return div;
        };
    };
    return brushInterface;
}();

},{"../../bb/bb":"e3nbn","./brushes-consts":"3AD2T","../ui/base-components/checkbox":"clzcQ","../brushes/brushes":"34S30","../history/kl-history":"ai9zE","../ui/base-components/kl-slider":"1Vedp","url:~/src/app/img/ui/brush-chemy.svg":"hSqRW","../ui/base-components/options":"b8ZKE","../ui/base-components/box-toggle":"RbMtc","../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hSqRW":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "brush-chemy.dea0c95d.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"RbMtc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BoxToggle", ()=>BoxToggle
);
var _bb = require("../../../bb/bb");
class BoxToggle {
    update() {
        if (this.value) _bb.BB.addClassName(this.el, 'kl-box-toggle--active');
        else _bb.BB.removeClassName(this.el, 'kl-box-toggle--active');
    }
    // --- public ---
    constructor(p){
        this.value = !!p.init;
        this.el = _bb.BB.el({
            content: p.label,
            title: p.title,
            className: typeof p.label === 'string' ? 'kl-box-toggle' : 'kl-box-toggle kl-box-toggle--custom-el',
            onClick: ()=>{
                this.value = !this.value;
                this.update();
                p.onChange(this.value);
            },
            css: {
                cursor: 'pointer'
            }
        });
        if (typeof p.label !== 'string') _bb.BB.css(p.label, {
            display: 'block',
            pointerEvents: 'none'
        });
        this.update();
    }
    getValue() {
        return this.value;
    }
    setValue(b) {
        this.value = !!b;
        this.update();
    }
    getElement() {
        return this.el;
    }
    destroy() {
        _bb.BB.destroyEl(this.el);
    }
}

},{"../../../bb/bb":"e3nbn","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gIAOL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "showIframePopup", ()=>showIframePopup
);
var _bb = require("../../../bb/bb");
var _popup = require("./popup");
var _language = require("../../../language/language");
function showIframePopup(url, isEmbed) {
    if (!isEmbed && (window.innerHeight < 500 || window.innerWidth < 700)) {
        window.open(url);
        return;
    }
    let iframe = _bb.BB.el({
        tagName: 'iframe',
        custom: {
            src: url
        },
        css: {
            width: '100%',
            height: '100%'
        }
    });
    let titleEl = _bb.BB.el({
    });
    let linkEl;
    if (!isEmbed) {
        linkEl = _bb.BB.el({
            tagName: 'a',
            parent: titleEl,
            content: _language.LANG('modal-new-tab'),
            custom: {
                href: 'help',
                target: '_blank'
            },
            onClick: function() {
                popup.close();
            }
        });
        iframe.onload = function() {
            _bb.BB.setAttributes(linkEl, {
                href: '' + iframe.contentWindow.location
            });
        };
    }
    let popup = new _popup.Popup({
        title: titleEl,
        content: iframe,
        width: 880,
        isMaxHeight: true,
        onClose: ()=>{
            if (linkEl) _bb.BB.destroyEl(linkEl);
        }
    });
}

},{"../../../bb/bb":"e3nbn","./popup":"7D028","../../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"67Kg4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RadioList", ()=>RadioList
);
var _bb = require("../../../bb/bb");
class RadioList {
    constructor(p){
        this.inputs = [];
        this.el = _bb.BB.el({
            className: 'kl-radio'
        });
        p.items.forEach((item)=>{
            let label = _bb.BB.el({
                tagName: 'label'
            });
            let input = _bb.BB.el({
                tagName: 'input',
                parent: label,
                custom: {
                    name: p.name,
                    value: item.value,
                    type: 'radio'
                }
            });
            if (p.ignoreFocus) input.setAttribute('data-ignore-focus', 'true');
            if (p.init === item.value) input.checked = true;
            label.append(item.label);
            this.el.append(label);
            this.inputs.push(input);
        });
    }
    getValue() {
        for(let i = 0; i < this.inputs.length; i++){
            if (this.inputs[i].checked) return this.inputs[i].value;
        }
        return null;
    }
    getElement() {
        return this.el;
    }
}

},{"../../../bb/bb":"e3nbn","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4iUpn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BrowserStorageUi", ()=>BrowserStorageUi
);
var _bb = require("../../../bb/bb");
// @ts-ignore
var _removeLayerSvg = require("url:~/src/app/img/ui/remove-layer.svg");
var _removeLayerSvgDefault = parcelHelpers.interopDefault(_removeLayerSvg);
var _showIframePopup = require("../modals/show-iframe-popup");
var _kl = require("../../kl");
var _language = require("../../../language/language");
class BrowserStorageUi {
    updateAge() {
        if (!this.timestamp) return;
        let age = new Date().getTime() - this.timestamp;
        let ageStr;
        age = Math.floor(age / 1000 / 60);
        ageStr = _language.LANG('file-storage-min-ago').replace('{x}', '' + age);
        if (age > 60) {
            age = Math.floor(age / 60);
            ageStr = _language.LANG('file-storage-hours-ago').replace('{x}', '' + age);
            if (age > 24) {
                age = Math.floor(age / 24);
                ageStr = _language.LANG('file-storage-days-ago').replace('{x}', '' + age);
                if (age > 31) ageStr = _language.LANG('file-storage-month-ago');
            }
        }
        this.ageEl.textContent = ageStr;
    }
    resetButtons() {
        if (this.timestamp) {
            this.storeEl.textContent = _language.LANG('file-storage-overwrite');
            this.storeEl.disabled = false;
            this.clearEl.disabled = false;
        } else {
            this.storeEl.textContent = _language.LANG('file-storage-store');
            this.storeEl.disabled = false;
            this.clearEl.disabled = true;
        }
    }
    updateThumb(timestamp, thumbnail) {
        this.timestamp = timestamp;
        if (this.timestamp) {
            _bb.BB.css(thumbnail, {
                display: 'block',
                maxWidth: 'calc(100% - 2px)',
                maxHeight: 'calc(100% - 2px)',
                margin: '0 auto',
                background: "url('" + _bb.BB.createCheckerCanvas(4).toDataURL('image/png') + "')",
                boxShadow: '0 0 0 1px #aaa',
                pointerEvents: 'none'
            });
            this.previewEl.innerHTML = '';
            this.updateAge();
            this.previewEl.append(thumbnail, this.ageEl);
        } else this.previewEl.innerHTML = _language.LANG('file-storage-empty');
        this.resetButtons();
    }
    async store() {
        this.storeEl.textContent = _language.LANG('file-storage-storing');
        this.storeEl.disabled = true;
        this.clearEl.disabled = true;
        await new Promise((resolve)=>{
            setTimeout(()=>resolve(null)
            , 20);
        });
        try {
            await this.projectStore.store(this.getProject());
            this.saveReminder.reset();
        } catch (e) {
            this.resetButtons();
            _kl.KL.popup({
                target: this.klRootEl,
                type: 'error',
                message: [
                    `${_language.LANG('file-storage-failed-1')}<ul>`,
                    `<li>${_language.LANG('file-storage-failed-2')}</li>`,
                    `<li>${_language.LANG('file-storage-failed-3')}</li>`,
                    `<li>${_language.LANG('file-storage-failed-4')}</li>`,
                    `</ul>`, 
                ].join(''),
                buttons: [
                    'Ok'
                ]
            });
            setTimeout(()=>{
                throw new Error('storage-ui: failed to store browser storage, ' + e);
            }, 0);
        }
    }
    async clear() {
        this.storeEl.disabled = true;
        this.clearEl.disabled = true;
        try {
            await this.projectStore.clear();
        } catch (e) {
            this.resetButtons();
            _kl.KL.popup({
                target: this.klRootEl,
                type: 'error',
                message: _language.LANG('file-storage-failed-clear'),
                buttons: [
                    'Ok'
                ]
            });
            setTimeout(()=>{
                throw new Error('storage-ui: failed to clear browser storage, ' + e);
            }, 0);
        }
    }
    constructor(projectStore, getProject, saveReminder, klRootEl){
        this.projectStore = projectStore;
        this.getProject = getProject;
        this.saveReminder = saveReminder;
        this.klRootEl = klRootEl;
        this.element = _bb.BB.el({
            css: {
                display: 'grid',
                gridTemplateColumns: '1fr 0fr',
                gridTemplateRows: '0fr 0fr 0fr',
                gap: '0 0',
                gridTemplateAreas: '"title title" "preview store" "preview clear"'
            }
        });
        const title = _bb.BB.el({
            parent: this.element,
            content: _language.LANG('file-storage'),
            css: {
                gridArea: 'title',
                display: 'flex',
                margin: '-5px 0'
            }
        });
        const infoEl = _bb.BB.el({
            parent: title,
            content: '?',
            title: _language.LANG('file-storage-about'),
            css: {
                cursor: 'pointer',
                marginLeft: '5px',
                width: '19px',
                height: '19px',
                borderRadius: '100%',
                textAlign: 'center',
                lineHeight: '19px',
                fontWeight: 'bold',
                boxShadow: 'inset 0 0 0 1px #000'
            },
            onClick: ()=>{
                _showIframePopup.showIframePopup('./help/#help-browser-storage', false);
            }
        });
        if (this.projectStore.isBroken()) {
            _bb.BB.el({
                parent: this.element,
                content: "🔴 " + _language.LANG('file-storage-cant-access'),
                css: {
                    marginTop: '10px'
                }
            });
            return;
        }
        this.previewEl = _bb.BB.el({
            parent: this.element,
            title: _language.LANG('file-storage-thumb-title'),
            css: {
                gridArea: 'preview',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                marginTop: '10px',
                position: 'relative',
                boxShadow: 'inset 0 0 0 1px #aaa',
                background: '#cdcdcd',
                color: '#545454',
                colorScheme: 'only light'
            }
        });
        this.ageEl = _bb.BB.el({
            css: {
                position: 'absolute',
                right: '0',
                bottom: '0',
                width: '100%',
                textAlign: 'center',
                background: 'rgba(0,0,0,0.7)',
                color: '#fff',
                textSize: '13px'
            }
        });
        this.storeEl = _bb.BB.el({
            parent: this.element,
            tagName: 'button',
            className: 'gridButton',
            content: _language.LANG('file-storage-store'),
            css: {
                gridArea: 'store'
            },
            custom: {
                tabIndex: -1
            },
            onClick: ()=>this.store()
        });
        this.storeEl.tabIndex = -1;
        this.clearEl = _bb.BB.el({
            parent: this.element,
            tagName: 'button',
            className: 'gridButton',
            content: '<img src="' + _removeLayerSvgDefault.default + '" height="20"/> ' + _language.LANG('file-storage-clear'),
            css: {
                gridArea: 'clear'
            },
            custom: {
                tabIndex: -1
            },
            onClick: ()=>this.clear()
        });
        this.projectStore.subscribe({
            onUpdate: (timestamp, thumbnail)=>{
                this.updateThumb(timestamp, thumbnail);
            }
        });
        setInterval(()=>this.updateAge()
        , 60000);
        (async ()=>{
            try {
                const readResult = await this.projectStore.read();
                if (readResult) this.updateThumb(readResult.timestamp, readResult.thumbnail);
                else this.updateThumb();
            } catch (e) {
                setTimeout(()=>{
                    throw new Error('storage-ui: failed initial read browser storage, ' + e);
                }, 0);
            }
        })();
    }
    getElement() {
        return this.element;
    }
    show() {
    // todo
    }
    hide() {
    // todo
    }
}

},{"../../../bb/bb":"e3nbn","url:~/src/app/img/ui/remove-layer.svg":"96CFw","../modals/show-iframe-popup":"gIAOL","../../kl":"3bnx1","../../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3f0UC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * simplified interface for storing projects into browser storage
 */ parcelHelpers.export(exports, "ProjectStore", ()=>ProjectStore
);
var _projectConverter = require("./project-converter");
var _indexedDb = require("./indexed-db");
var _localStorage = require("../../bb/base/local-storage");
function makeAsync(func) {
    return new Promise((resolve, reject)=>{
        func(resolve, reject);
    });
}
class ProjectStore {
    async lowLevelStore(project) {
        await new Promise((resolve, reject)=>{
            _indexedDb.storeKlProjectObj(project, resolve, reject);
        });
    }
    async lowLevelRead() {
        return await makeAsync(_indexedDb.getKlProjectObj);
    }
    async lowLevelClear() {
        await makeAsync(_indexedDb.clear);
    }
    emit(timestamp, thumbnail) {
        this.listeners.forEach((item)=>{
            item.onUpdate(timestamp, thumbnail);
        });
    }
    updateTimestamp() {
        _localStorage.LocalStorage.setItem('indexedDbUpdatedAt', '' + new Date().getTime());
    }
    // --- public ---
    constructor(){
        this.listeners = [];
        this.accessHasFailed = false;
        window.addEventListener('storage', (e)=>{
            if (e.key !== 'indexedDbUpdatedAt' || this.listeners.length === 0) return;
            try {
                (async ()=>{
                    const readResult = await this.read();
                    if (readResult) this.emit(readResult.timestamp, readResult.thumbnail);
                    else this.emit();
                })();
            } catch (e1) {
                if (e1.message === 'db-error') this.accessHasFailed = true;
            }
        });
    }
    async read() {
        let storageProject;
        try {
            storageProject = await this.lowLevelRead();
        } catch (e) {
            this.accessHasFailed = true;
            throw new Error('db-error');
        }
        if (!storageProject) return null;
        let result;
        try {
            result = await _projectConverter.ProjectConverter.readStorageProject(storageProject);
        } catch (e2) {
            throw new Error('format-error');
        }
        return result;
    }
    async store(project) {
        try {
            const storageProject = _projectConverter.ProjectConverter.createStorageProject(project);
            await this.lowLevelStore(storageProject);
        } catch (e) {
            this.accessHasFailed = true;
            throw new Error('db-error');
        }
        {
            // immediately test if it can be read
            const storageProject = await this.lowLevelRead();
            let readResult = null;
            try {
                readResult = await _projectConverter.ProjectConverter.readStorageProject(storageProject);
            } catch (e) {
                await this.lowLevelClear();
                this.updateTimestamp();
                setTimeout(()=>this.emit()
                , 0);
                throw new Error('format-error');
            }
            this.updateTimestamp();
            setTimeout(()=>this.emit(readResult.timestamp, readResult.thumbnail)
            , 0);
        }
    }
    async clear() {
        await this.lowLevelClear();
        this.updateTimestamp();
        setTimeout(()=>this.emit()
        , 0);
    }
    subscribe(listener) {
        if (this.listeners.includes(listener)) return;
        this.listeners.push(listener);
    }
    unsubscribe(listener) {
        for(let i = 0; i < this.listeners.length; i++)if (listener === this.listeners[i]) {
            this.listeners.splice(i, 1);
            return;
        }
    }
    isBroken() {
        return this.accessHasFailed;
    }
}

},{"./project-converter":"ijDIu","./indexed-db":"7mvlr","../../bb/base/local-storage":"iOEIY","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ijDIu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * for:
 * - preparing project to be stored in ProjectStore
 * - reading a project that came out of the ProjectStore
 */ parcelHelpers.export(exports, "ProjectConverter", ()=>ProjectConverter
);
var _bb = require("../../bb/bb");
var _drawProject = require("../canvas/draw-project");
var _base64ToBlob = require("./base-64-to-blob");
const thumbSize = 240;
function loadImage(blob) {
    return new Promise((resolve, reject)=>{
        const im = new Image();
        try {
            im.src = _bb.BB.imageBlobToUrl(blob);
        } catch (e) {
            reject('imageBlobToUrl, ' + e.message);
            return;
        }
        im.onload = ()=>{
            resolve(im);
        };
        im.onabort = function() {
            reject('layer image failed loading');
        };
        im.onerror = function() {
            reject('layer image failed loading');
        };
    });
}
class ProjectConverter {
    static createThumbnail(project) {
        const size = _bb.BB.fitInto(project.width, project.height, thumbSize, thumbSize);
        const factor = size.width / project.width;
        return _drawProject.drawProject(project, factor);
    }
    static createStorageProject(project) {
        return {
            id: 1,
            timestamp: new Date().getTime(),
            thumbnail: _base64ToBlob.base64ToBlob(ProjectConverter.createThumbnail(project).toDataURL('image/png')),
            width: project.width,
            height: project.height,
            layers: project.layers.map((item)=>{
                let blob;
                if (item.image instanceof HTMLCanvasElement) blob = _base64ToBlob.base64ToBlob(item.image.toDataURL('image/png'));
                else // todo image
                throw new Error('Not implemented');
                return {
                    name: item.name,
                    opacity: item.opacity,
                    mixModeStr: item.mixModeStr,
                    blob
                };
            })
        };
    }
    static async readStorageProject(storageProject) {
        const project = {
            width: storageProject.width,
            height: storageProject.height,
            layers: (await Promise.all(storageProject.layers.map((layer)=>loadImage(layer.blob)
            ))).map((image, i)=>{
                return {
                    name: storageProject.layers[i].name,
                    opacity: storageProject.layers[i].opacity,
                    mixModeStr: storageProject.layers[i].mixModeStr,
                    image
                };
            })
        };
        let thumbnail;
        if (storageProject.thumbnail) thumbnail = await loadImage(storageProject.thumbnail);
        else thumbnail = ProjectConverter.createThumbnail(project);
        return {
            project: project,
            timestamp: storageProject.timestamp,
            thumbnail: thumbnail
        };
    }
}

},{"../../bb/bb":"e3nbn","../canvas/draw-project":"4pmbZ","./base-64-to-blob":"5MgNM","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5MgNM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "base64ToBlob", ()=>base64ToBlob
);
function base64ToBlob(base64Str) {
    let parts = base64Str.match(/data:([^;]*)(;base64)?,([0-9A-Za-z+/]+)/);
    let binStr = atob(parts[3]);
    let buf = new ArrayBuffer(binStr.length);
    let view = new Uint8Array(buf);
    for(let i = 0; i < view.length; i++)view[i] = binStr.charCodeAt(i);
    return new Blob([
        view
    ], {
        'type': parts[1]
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gDKzx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FileTab", ()=>FileTab
);
var _bb = require("../../../bb/bb");
var _kl = require("../../kl");
// @ts-ignore
var _newImageSvg = require("url:~/src/app/img/ui/new-image.svg");
var _newImageSvgDefault = parcelHelpers.interopDefault(_newImageSvg);
// @ts-ignore
var _exportSvg = require("url:~/src/app/img/ui/export.svg");
var _exportSvgDefault = parcelHelpers.interopDefault(_exportSvg);
// @ts-ignore
var _importSvg = require("url:~/src/app/img/ui/import.svg");
var _importSvgDefault = parcelHelpers.interopDefault(_importSvg);
var _browserStorageUi = require("../components/browser-storage-ui");
var _language = require("../../../language/language");
class FileTab {
    constructor(klRootEl, projectStore, getProject, exportType, onExportTypeChange, onFileSelect, onSaveImageToComputer, onNewImage, onShareImage, onUpload, onCopyToClipboard, saveReminder){
        this.exportType = exportType;
        const _this = this;
        this.div = document.createElement("div");
        const asyncCreation = ()=>{
            let filemenu = document.createElement("div");
            let newButton = document.createElement("button");
            let saveButton = document.createElement("button");
            newButton.style.cssFloat = 'left';
            _bb.BB.css(saveButton, {
                cssFloat: 'left',
                clear: 'both'
            });
            newButton.tabIndex = -1;
            saveButton.tabIndex = -1;
            newButton.innerHTML = `<img src='${_newImageSvgDefault.default}' alt='icon' height='20'/>${_language.LANG('file-new')}`;
            saveButton.innerHTML = `<img src='${_exportSvgDefault.default}' alt='icon' height='20'/>${_language.LANG('file-save')}`;
            newButton.className = "gridButton";
            saveButton.className = "gridButton";
            this.importButton = document.createElement("input");
            this.importButton.tabIndex = -1;
            this.importButton.type = "file";
            this.importButton.multiple = true;
            this.importButton.accept = "image";
            this.importButton.size = "71";
            this.importButton.textContent = "Import";
            let importWrapper = this.importButton;
            function createImportButton() {
                importWrapper = document.createElement("div");
                importWrapper.className = "gridButton";
                importWrapper.style.position = "relative";
                importWrapper.style.cursor = "pointer";
                importWrapper.style.cssFloat = "left";
                let innerMask = document.createElement("div");
                innerMask.style.width = "120px";
                innerMask.style.height = "28px";
                innerMask.style.overflow = "hidden";
                innerMask.style.cursor = "pointer";
                innerMask.style.position = "relative";
                importWrapper.appendChild(innerMask);
                innerMask.appendChild(_this.importButton);
                let importFakeButton = document.createElement("button");
                importFakeButton.innerHTML = "<img style='float:left' height='20' src='" + _importSvgDefault.default + "' alt='icon'/>" + _language.LANG('file-import');
                importFakeButton.tabIndex = -1;
                _bb.BB.css(importFakeButton, {
                    width: "120px",
                    display: "box",
                    position: "absolute",
                    left: '0',
                    top: '0',
                    cursor: "pointer"
                });
                _bb.BB.css(_this.importButton, {
                    display: 'none'
                });
                importWrapper.appendChild(importFakeButton);
                importFakeButton.onclick = function() {
                    _this.importButton.click();
                };
            }
            createImportButton();
            this.importButton.onchange = function(e) {
                onFileSelect(_this.importButton.files, 'default');
                _this.importButton.value = "";
            };
            // --- export filetype dropdown ---
            let exportTypeWrapper;
            let exportTypeSelect;
            exportTypeWrapper = _bb.BB.el({
                css: {
                    display: 'none',
                    fontSize: '15px',
                    marginLeft: '10px',
                    marginTop: '10px',
                    cssFloat: 'left',
                    width: 'calc(50% - 15px)',
                    height: '30px'
                }
            });
            exportTypeSelect = new _kl.KL.Select({
                optionArr: [
                    [
                        'png',
                        _language.LANG('file-save-png')
                    ],
                    [
                        'psd',
                        _language.LANG('file-save-psd')
                    ],
                    [
                        'layers',
                        _language.LANG('file-save-layers')
                    ], 
                ],
                initValue: exportType,
                onChange: function(val) {
                    exportType = val;
                    onExportTypeChange(exportType);
                    onSaveImageToComputer();
                }
            });
            _bb.BB.css(exportTypeSelect.getElement(), {
                width: '120px',
                height: '30px'
            });
            exportTypeWrapper.appendChild(exportTypeSelect.getElement());
            newButton.onclick = onNewImage;
            saveButton.onclick = function() {
                onSaveImageToComputer();
            };
            let saveNote = document.createElement("div");
            saveNote.textContent = "⚠️ " + _language.LANG('file-no-autosave');
            _bb.BB.css(saveNote, {
                textAlign: "center",
                marginTop: "10px",
                background: "rgb(243, 243, 161)",
                padding: "5px 0px",
                color: 'rgba(0,0,0,0.65)',
                fontSize: '15px'
            });
            function createSpacer() {
                let el = document.createElement("div");
                let clearer = document.createElement("div");
                let line = document.createElement("div");
                el.appendChild(clearer);
                el.appendChild(line);
                _bb.BB.css(clearer, {
                    clear: 'both'
                });
                _bb.BB.css(line, {
                    display: 'none',
                    marginLeft: "10px",
                    marginRight: "10px",
                    marginTop: "10px",
                    borderBottom: "1px solid rgba(0,0,0,0.2)",
                    clear: 'both'
                });
                return el;
            }
            _this.fileBrowserStorage = new _browserStorageUi.BrowserStorageUi(projectStore, getProject, saveReminder, klRootEl);
            _bb.BB.css(_this.fileBrowserStorage.getElement(), {
                //background: 'red',
                display: 'none',
                margin: '10px'
            });
            //actual structure
            _bb.BB.append(filemenu, [
                saveNote,
                newButton,
                importWrapper,
                _bb.BB.el({
                    css: {
                        clear: 'both'
                    }
                }),
                saveButton,
                exportTypeWrapper,
                _bb.BB.el({
                    css: {
                        clear: 'both'
                    }
                }),
                _bb.BB.el({
                    css: {
                        clear: 'both'
                    }
                }),
                createSpacer(),
                _this.fileBrowserStorage.getElement(),
                createSpacer(), 
            ]);
            this.div.appendChild(filemenu);
        };
        setTimeout(asyncCreation, 1);
    }
    refresh() {
    }
    getElement() {
        return this.div;
    }
    setIsVisible(isVisible) {
        if (isVisible) this.refresh();
    }
    triggerImport() {
        this.importButton.click();
    }
}

},{"../../../bb/bb":"e3nbn","../../kl":"3bnx1","url:~/src/app/img/ui/new-image.svg":"ln28s","url:~/src/app/img/ui/export.svg":"hM2b0","url:~/src/app/img/ui/import.svg":"kYp42","../components/browser-storage-ui":"4iUpn","../../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8j5rC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FilterTab", ()=>FilterTab
);
var _bb = require("../../../bb/bb");
var _kl = require("../../kl");
var _klHistory = require("../../history/kl-history");
var _language = require("../../../language/language");
class FilterTab {
    constructor(klRootEl, klColorSlider, layerManager, setCurrentLayer, klCanvasWorkspace, handUi, getCurrentColor, getKlMaxCanvasSize, getKlCanvas, getCurrentLayerCtx, isEmbed, statusOverlay){
        this.klRootEl = klRootEl;
        this.klColorSlider = klColorSlider;
        this.layerManager = layerManager;
        this.setCurrentLayer = setCurrentLayer;
        this.klCanvasWorkspace = klCanvasWorkspace;
        this.handUi = handUi;
        this.getCurrentColor = getCurrentColor;
        this.getKlMaxCanvasSize = getKlMaxCanvasSize;
        this.getKlCanvas = getKlCanvas;
        this.getCurrentLayerCtx = getCurrentLayerCtx;
        this.isEmbed = isEmbed;
        this.statusOverlay = statusOverlay;
        this.isInit = false;
        this.div = document.createElement("div");
    }
    init() {
        const _this = this;
        let hasWebGl = _bb.BB.hasWebGl();
        let filters = _kl.KL.filterLib;
        let buttons = [];
        _bb.BB.BbLog.emit({
            type: 'init-filters'
        });
        if (!_kl.KL.filterLibStatus.isLoaded) throw new Error('filters not loaded');
        function createButton(filterKey, filterArr) {
            let button = document.createElement("button");
            let buttonLabel = filterArr[filterKey].buttonLabel ? filterArr[filterKey].buttonLabel : filterArr[filterKey].name;
            let im = '<img height="20" width="18" src="' + filterArr[filterKey].icon + '" alt="icon" />';
            button.innerHTML = im + buttonLabel;
            button.className = "gridButton";
            _bb.BB.css(button, {
                lineHeight: '20px',
                fontSize: '12px'
            });
            button.tabIndex = -1;
            button.onclick = function() {
                function finishedDialog(result, filterDialog) {
                    if (result == "Cancel") {
                        if (filterDialog.destroy) filterDialog.destroy();
                        return;
                    }
                    let input;
                    try {
                        input = filterDialog.getInput(); // also destroys
                    } catch (e) {
                        if (e.message.indexOf('.getInput is not a function') !== -1) throw 'filterDialog.getInput is not a function, filter: ' + filterArr[filterKey].name;
                        else throw e;
                    }
                    applyFilter(input);
                }
                if (!('apply' in filterArr[filterKey])) {
                    alert('Application not fully loaded');
                    return;
                }
                function applyFilter(input) {
                    let filterResult = filterArr[filterKey].apply({
                        context: _this.getCurrentLayerCtx(),
                        canvas: _this.getKlCanvas(),
                        history: _klHistory.klHistory,
                        input: input
                    });
                    if (filterResult === false) alert("Couldn't apply the edit action");
                    if (filterArr[filterKey].updateContext === true) _this.setCurrentLayer(_this.getKlCanvas().getLayer(_this.layerManager.getSelected()));
                    if (filterArr[filterKey].updatePos === true) {
                        _this.klCanvasWorkspace.resetView();
                        _this.handUi.update(_this.klCanvasWorkspace.getScale(), _this.klCanvasWorkspace.getAngleDeg());
                    }
                    _this.layerManager.update();
                }
                if (filterArr[filterKey].isInstant) {
                    button.blur();
                    applyFilter(null);
                    _this.statusOverlay.out('"' + filterArr[filterKey].name + '" ' + _language.LANG('filter-applied'), true);
                } else {
                    let secondaryColorRGB = _this.klColorSlider.getSecondaryRGB();
                    let filterDialog = filterArr[filterKey].getDialog({
                        context: _this.getCurrentLayerCtx(),
                        canvas: _this.getKlCanvas(),
                        maxWidth: _this.getKlMaxCanvasSize(),
                        maxHeight: _this.getKlMaxCanvasSize(),
                        currentColorRgb: {
                            r: _this.getCurrentColor().r,
                            g: _this.getCurrentColor().g,
                            b: _this.getCurrentColor().b
                        },
                        secondaryColorRgb: {
                            r: secondaryColorRGB.r,
                            g: secondaryColorRGB.g,
                            b: secondaryColorRGB.b
                        }
                    });
                    if (!filterDialog) return;
                    let closefunc;
                    filterDialog.errorCallback = function(e) {
                        setTimeout(function() {
                            alert('Error: could not perform action');
                            throw e;
                        }, 0);
                        closefunc();
                    };
                    let style = {
                    };
                    if ('width' in filterDialog) style.width = filterDialog.width + 'px';
                    _kl.KL.popup({
                        target: _this.klRootEl,
                        message: "<b>" + filterArr[filterKey].name + "</b>",
                        div: filterDialog.element,
                        style: style,
                        buttons: [
                            "Ok",
                            "Cancel"
                        ],
                        clickOnEnter: 'Ok',
                        callback: function(result) {
                            finishedDialog(result, filterDialog);
                        },
                        closefunc: function(func) {
                            closefunc = func;
                        }
                    });
                }
            };
            buttons[buttons.length] = button;
            return button;
        }
        function createDisabledButton(filterKey, filterArr) {
            if (!filterArr[filterKey].webgl && !filterArr[filterKey].ieFails) return;
            if (filterArr[filterKey].ieFails && navigator.appName !== 'Microsoft Internet Explorer') return;
            let buttonLabel = filterArr[filterKey].buttonLabel ? filterArr[filterKey].buttonLabel : filterArr[filterKey].name;
            let button = document.createElement("button");
            let im = '<img style="opacity: 0.5" src="img/' + filterArr[filterKey].icon + '" />';
            let name = filterArr[filterKey].name;
            if (name.length > 11) name = "<span style='font-size: 12px'>" + buttonLabel + "</span>";
            button.innerHTML = im + name;
            button.className = "gridButton";
            button.disabled = true;
            return button;
        }
        function addGroup(groupArr, filterArr, targetEl) {
            for(let filterKey in filterArr){
                if (filterArr.hasOwnProperty[filterKey] || !groupArr.includes(filterKey)) continue;
                if (_this.isEmbed && !filterArr[filterKey].inEmbed) continue;
                if (filterArr[filterKey].webgl && hasWebGl || filterArr[filterKey].neededWithWebGL || !filterArr[filterKey].webgl && !hasWebGl && !(filterArr[filterKey].ieFails && navigator.appName == 'Microsoft Internet Explorer')) targetEl.appendChild(createButton(filterKey, filterArr));
                else {
                    targetEl.appendChild(createDisabledButton(filterKey, filterArr));
                    filterArr[filterKey] = undefined;
                }
            }
        }
        let groupA = [
            'cropExtend',
            'flip',
            'glPerspective',
            'resize',
            'rotate',
            'transform'
        ];
        let groupB = [];
        for(let filterKey1 in filters){
            if (filters.hasOwnProperty[filterKey1] || groupA.includes(filterKey1)) continue;
            groupB.push(filterKey1);
        }
        addGroup(groupA, filters, _this.div);
        let hrEl = document.createElement("div");
        hrEl.className = "gridHr";
        _this.div.appendChild(hrEl);
        addGroup(groupB, filters, _this.div);
        if (!hasWebGl) {
            let webglnote = _bb.BB.appendTextDiv(_this.div, "Some actions are disabled because WebGL isn't working.");
            webglnote.style.margin = "10px";
            _bb.BB.css(webglnote, {
                fontSize: "11px",
                color: "#555",
                background: "#ffe",
                padding: "10px",
                borderRadius: "10px",
                textAlign: "center"
            });
        }
        this.isInit = true;
    }
    getElement() {
        return this.div;
    }
    show() {
        if (!this.isInit) this.init();
        this.div.style.display = 'block';
    }
    hide() {
        this.div.style.display = 'none';
    }
}

},{"../../../bb/bb":"e3nbn","../../kl":"3bnx1","../../history/kl-history":"ai9zE","../../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bCFNJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "imgurUpload", ()=>imgurUpload
);
var _bb = require("../../../bb/bb");
var _kl = require("../../kl");
// @ts-ignore
var _loadingGif = require("url:~/src/app/img/ui/loading.gif");
var _loadingGifDefault = parcelHelpers.interopDefault(_loadingGif);
var _base64ToBlob = require("../../storage/base-64-to-blob");
var _language = require("../../../language/language");
async function upload(canvas, title, description, type, imgurKey) {
    let img = _base64ToBlob.base64ToBlob(canvas.toDataURL("image/" + type));
    let w = window.open();
    let label = w.document.createElement("div");
    let gif = w.document.createElement("img");
    gif.src = _loadingGifDefault.default;
    label.appendChild(gif);
    _bb.BB.css(gif, {
        filter: "invert(1)"
    });
    w.document.body.style.backgroundColor = "#121211";
    w.document.body.style.backgroundImage = "linear-gradient(#2b2b2b 0%, #121211 50%)";
    w.document.body.style.backgroundRepeat = "no-repeat";
    let labelText = w.document.createElement("div");
    labelText.style.marginTop = "10px";
    label.appendChild(labelText);
    labelText.textContent = _language.LANG('upload-uploading');
    w.document.body.appendChild(label);
    _bb.BB.css(label, {
        marginLeft: "auto",
        marginRight: "auto",
        marginTop: "100px",
        fontFamily: "Arial, sans-serif",
        fontSize: "20px",
        textAlign: "center",
        transition: "opacity 0.3s ease-in-out",
        opacity: '0',
        color: "#ccc"
    });
    setTimeout(function() {
        label.style.opacity = '1';
    }, 20);
    let response;
    try {
        const formData = new FormData();
        formData.append('title', title);
        formData.append('description', description);
        formData.append('image', img);
        response = await fetch('https://api.imgur.com/3/image', {
            method: 'POST',
            headers: {
                Authorization: 'Client-ID ' + imgurKey
            },
            body: formData
        });
    } catch (e) {
        w.close();
        throw new Error(e);
    }
    if (!response.ok) {
        w.close();
        throw new Error();
    }
    let data = (await response.json()).data;
    w.location.href = data.link.replace(/\.(jpg|png)/, '');
    return data;
}
function imgurUpload(klCanvas, klRootEl, saveReminder, imgurKey) {
    if (!imgurKey) throw new Error('imgur key missing');
    let inputTitle = document.createElement("input");
    inputTitle.type = "text";
    inputTitle.value = _language.LANG('upload-title-untitled');
    let inputDescription = _bb.BB.el({
        tagName: 'textarea',
        custom: {
            rows: 2
        },
        css: {
            width: '100%',
            maxWidth: '100%'
        }
    });
    let labelTitle = document.createElement("div");
    labelTitle.textContent = _language.LANG('upload-name') + ":";
    let labelDescription = _bb.BB.el({
        content: _language.LANG('upload-caption') + ':',
        css: {
            marginTop: '10px'
        }
    });
    let tos = document.createElement("div");
    tos.innerHTML = `<br/><a href="https://imgur.com/tos" target="_blank" rel="noopener noreferrer">${_language.LANG('upload-tos')}</a> ${_language.LANG('upload-tos-2')}`;
    const typeRadio = new _kl.KL.RadioList({
        name: 'filetype',
        init: 'jpeg',
        items: [
            {
                label: 'JPG',
                value: 'jpeg'
            },
            {
                label: 'PNG',
                value: 'png'
            }, 
        ],
        ignoreFocus: true
    });
    _bb.BB.css(typeRadio.getElement(), {
        marginBottom: '10px'
    });
    let outDiv = document.createElement("div");
    let infoHint = document.createElement("div");
    infoHint.className = "info-hint";
    infoHint.textContent = _language.LANG('upload-link-notice');
    outDiv.append(infoHint, typeRadio.getElement(), labelTitle, inputTitle, labelDescription, inputDescription, tos);
    _kl.KL.popup({
        target: klRootEl,
        message: `<b>${_language.LANG('upload-title')}</b>`,
        type: "upload",
        div: outDiv,
        buttons: [
            _language.LANG('upload-submit'),
            "Cancel"
        ],
        clickOnEnter: _language.LANG('upload-submit'),
        primaries: [
            _language.LANG('upload-submit')
        ],
        autoFocus: _language.LANG('upload-submit'),
        callback: async function(val) {
            if (val === _language.LANG('upload-submit') || val === "Yes" || val === "Ok") try {
                const result = await upload(klCanvas.getCompleteCanvas(1), inputTitle.value, inputDescription.value, typeRadio.getValue(), imgurKey);
                _kl.KL.popup({
                    target: klRootEl,
                    type: "ok",
                    message: `<h3>${_language.LANG('upload-success')}</h3><br>${_language.LANG('upload-delete')}<br><a target='_blank' rel="noopener noreferrer" href='https://imgur.com/delete/${result.deletehash}'>imgur.com/<b>delete</b>/${result.deletehash}</a><br><br>`,
                    buttons: [
                        "Ok"
                    ]
                });
                saveReminder.reset();
            } catch (e) {
                _kl.KL.popup({
                    target: klRootEl,
                    type: "error",
                    message: _language.LANG('upload-failed'),
                    buttons: [
                        "Ok"
                    ]
                });
            }
        }
    });
}

},{"../../../bb/bb":"e3nbn","../../kl":"3bnx1","url:~/src/app/img/ui/loading.gif":"li8au","../../storage/base-64-to-blob":"5MgNM","../../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"li8au":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "loading.9e81d3d7.gif" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"iBRLF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "loadAgPsd", ()=>loadAgPsd
);
var _bb = require("../../bb/bb");
let agPsdLazy;
async function loadAgPsd() {
    if (!agPsdLazy) {
        agPsdLazy = await require("86170c709908d0b3");
        _bb.BB.BbLog.emit({
            type: 'loaded-agpsd'
        });
    }
    return agPsdLazy;
}

},{"../../bb/bb":"e3nbn","86170c709908d0b3":"4NpwA","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4NpwA":[function(require,module,exports) {
module.exports = require("./helpers/browser/js-loader")(require('./helpers/bundle-url').getBundleURL('bWfZe') + "dist.8b6858d8.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root('h8hOP')
);

},{"./helpers/browser/js-loader":"285qT","./helpers/bundle-url":"chiK4"}],"c0KDT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * remind user of saving, keep user aware of save state
 */ parcelHelpers.export(exports, "SaveReminder", ()=>SaveReminder
);
var _kl = require("../../kl");
var _bb = require("../../../bb/bb");
var _language = require("../../../language/language");
class SaveReminder {
    constructor(history, showReminder, changeTitle, title = 'Klecks'){
        this.history = history;
        this.showReminder = showReminder;
        this.changeTitle = changeTitle;
        this.title = title;
        this.oldActionNumber = null;
        this.remindersShowed = 0;
    }
    init() {
        if (this.oldActionNumber !== null) return;
        this.oldActionNumber = this.history.getActionNumber();
        if (this.showReminder) setInterval(()=>{
            if (document.visibilityState !== 'visible') return;
            let reminderTimelimitMs = 1200000; // 20 minutes
            let actionNumber = this.history.getActionNumber();
            //number of actions that were done since last reminder
            let historyDist = Math.abs(actionNumber - this.oldActionNumber);
            if (this.lastReminderResetAt + reminderTimelimitMs < performance.now() && historyDist >= 30) {
                this.reset(true);
                _kl.KL.showSaveReminderToast(this.remindersShowed++);
            }
        }, 60000);
        // confirmation dialog when closing tab
        function onBeforeUnload(e) {
            e.preventDefault();
            e.returnValue = '';
        }
        this.history.addListener(()=>{
            let actionNumber = this.history.getActionNumber();
            if (this.oldActionNumber !== actionNumber) _bb.BB.setEventListener(window, 'onbeforeunload', onBeforeUnload);
            else _bb.BB.setEventListener(window, 'onbeforeunload', null);
        });
        if (this.changeTitle) document.addEventListener("visibilitychange", ()=>{
            if (document.visibilityState === 'visible') {
                document.title = this.title;
                clearInterval(this.unsavedInterval);
            } else {
                let actionNumber = this.history.getActionNumber();
                if (this.oldActionNumber !== actionNumber) {
                    document.title = _language.LANG('unsaved') + ' - ' + this.title;
                    let state = 0;
                    this.unsavedInterval = setInterval(()=>{
                        state = (state + 1) % 2;
                        if (state === 1) document.title = _language.LANG('unsaved') + ' · ' + this.title;
                        else document.title = _language.LANG('unsaved') + ' - ' + this.title;
                    }, 180000);
                }
            }
        });
    }
    reset(isSoft) {
        if (this.oldActionNumber === null) return;
        if (!isSoft) this.remindersShowed = 0;
        this.lastReminderResetAt = performance.now();
        this.oldActionNumber = this.history.getActionNumber();
        _bb.BB.setEventListener(window, 'onbeforeunload', null);
    }
}

},{"../../kl":"3bnx1","../../../bb/bb":"e3nbn","../../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"c9ARV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SaveToComputer", ()=>SaveToComputer
);
var _bb = require("../../bb/bb");
var _kl = require("../kl");
var _fileSaver = require("file-saver");
class SaveToComputer {
    constructor(saveReminder, klRootEl, getExportType, getKlCanvas, filenameBase){
        this.saveReminder = saveReminder;
        this.klRootEl = klRootEl;
        this.getExportType = getExportType;
        this.getKlCanvas = getKlCanvas;
        this.filenameBase = filenameBase;
    }
    save() {
        const _this = this;
        _this.saveReminder.reset();
        function saveImage(canvas, filename, mimeType) {
            let parts = canvas.toDataURL(mimeType).match(/data:([^;]*)(;base64)?,([0-9A-Za-z+/]+)/);
            console.log(parts[3]);
            taixuong(parts[3]);
            download();
        }
        if (_this.getExportType() === 'png') {
            let extension = 'png';
            let mimeType = 'image/png';
            let filename = _bb.BB.getDate() + this.filenameBase + "." + extension;
            let fullCanvas = _this.getKlCanvas().getCompleteCanvas(1);
            /*fullCanvas.toBlob(function(blob) {
                if (blob === null) {
                    throw 'save image error, blob is null';
                }
                saveAs(blob, filename);
            }, mimetype);*/ //using old code, because saving somehow doesn't work for ipad before ios 13
            //and it doesn't even throw an exception
            try {
                saveImage(fullCanvas, filename, mimeType);
            } catch (error) {
                let im = new Image();
                im.width = _this.getKlCanvas().getWidth();
                im.height = _this.getKlCanvas().getHeight();
                im.src = fullCanvas.toDataURL(mimeType);
                _kl.KL.exportDialog(_this.klRootEl, im);
            }
        } else if (_this.getExportType() === 'layers') {
            let extension = 'png';
            let mimeType = 'image/png';
            let fileBase = _bb.BB.getDate() + this.filenameBase;
            let layerArr = _this.getKlCanvas().getLayersFast();
            for(let i = 0; i < layerArr.length; i++){
                let item = layerArr[i];
                let fnameArr = [
                    fileBase,
                    '_',
                    ('' + (i + 1)).padStart(2, '0'),
                    '_',
                    item.name,
                    '.',
                    extension
                ];
                saveImage(item.canvas, fnameArr.join(''), mimeType);
            }
        } else if (_this.getExportType() === 'psd') {
            let layerArr = _this.getKlCanvas().getLayersFast();
            let psdConfig = {
                width: _this.getKlCanvas().getWidth(),
                height: _this.getKlCanvas().getHeight(),
                children: [],
                canvas: _this.getKlCanvas().getCompleteCanvas(1)
            };
            for(let i = 0; i < layerArr.length; i++){
                let item = layerArr[i];
                psdConfig.children.push({
                    name: item.name,
                    opacity: item.opacity,
                    canvas: item.canvas,
                    blendMode: _kl.KL.PSD.blendKlToPsd(item.mixModeStr),
                    left: 0,
                    top: 0
                });
            }
            _kl.KL.loadAgPsd().then((agPsdLazy)=>{
                let buffer = agPsdLazy.writePsdBuffer(psdConfig);
                let blob = new Blob([
                    buffer
                ], {
                    type: 'application/octet-stream'
                });
                _fileSaver.saveAs(blob, _bb.BB.getDate() + this.filenameBase + '.psd');
            }).catch(()=>{
                alert('Error: failed to load PSD library');
            });
        }
    }
}

},{"../../bb/bb":"e3nbn","../kl":"3bnx1","file-saver":"9rIBV","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9rIBV":[function(require,module,exports) {
var global = arguments[3];
(function(a, b) {
    if ("function" == typeof define && define.amd) define([], b);
    else if ("undefined" != typeof exports) b();
    else b(), a.FileSaver = {
    };
})(this, function() {
    "use strict";
    function b1(a, b) {
        return "undefined" == typeof b ? b = {
            autoBom: !1
        } : "object" != typeof b && (console.warn("Deprecated: Expected third argument to be a object"), b = {
            autoBom: !b
        }), b.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type) ? new Blob([
            "\uFEFF",
            a
        ], {
            type: a.type
        }) : a;
    }
    function c1(a, b, c) {
        var d = new XMLHttpRequest;
        d.open("GET", a), d.responseType = "blob", d.onload = function() {
            g1(d.response, b, c);
        }, d.onerror = function() {
            console.error("could not download file");
        }, d.send();
    }
    function d1(a) {
        var b = new XMLHttpRequest;
        b.open("HEAD", a, !1);
        try {
            b.send();
        } catch (a2) {
        }
        return 200 <= b.status && 299 >= b.status;
    }
    function e1(a) {
        try {
            a.dispatchEvent(new MouseEvent("click"));
        } catch (c) {
            var b = document.createEvent("MouseEvents");
            b.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), a.dispatchEvent(b);
        }
    }
    var f1 = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof global && global.global === global ? global : void 0, a1 = f1.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g1 = f1.saveAs || ("object" != typeof window || window !== f1 ? function() {
    } : "download" in HTMLAnchorElement.prototype && !a1 ? function(b, g, h) {
        var i = f1.URL || f1.webkitURL, j = document.createElement("a");
        g = g || b.name || "download", j.download = g, j.rel = "noopener", "string" == typeof b ? (j.href = b, j.origin === location.origin ? e1(j) : d1(j.href) ? c1(b, g, h) : e1(j, j.target = "_blank")) : (j.href = i.createObjectURL(b), setTimeout(function() {
            i.revokeObjectURL(j.href);
        }, 40000), setTimeout(function() {
            e1(j);
        }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(f, g, h) {
        if (g = g || f.name || "download", "string" != typeof f) navigator.msSaveOrOpenBlob(b1(f, h), g);
        else if (d1(f)) c1(f, g, h);
        else {
            var i = document.createElement("a");
            i.href = f, i.target = "_blank", setTimeout(function() {
                e1(i);
            });
        }
    } : function(b, d, e, g) {
        if (g = g || open("", "_blank"), g && (g.document.title = g.document.body.innerText = "downloading..."), "string" == typeof b) return c1(b, d, e);
        var h = "application/octet-stream" === b.type, i = /constructor/i.test(f1.HTMLElement) || f1.safari, j = /CriOS\/[\d]+/.test(navigator.userAgent);
        if ((j || h && i || a1) && "undefined" != typeof FileReader) {
            var k = new FileReader;
            k.onloadend = function() {
                var a = k.result;
                a = j ? a : a.replace(/^data:[^;]*;/, "data:attachment/file;"), g ? g.location.href = a : location = a, g = null;
            }, k.readAsDataURL(b);
        } else {
            var l = f1.URL || f1.webkitURL, m = l.createObjectURL(b);
            g ? g.location = m : location.href = m, g = null, setTimeout(function() {
                l.revokeObjectURL(m);
            }, 40000);
        }
    });
    f1.saveAs = g1.saveAs = g1, "undefined" != typeof module && (module.exports = g1);
});

},{}],"9mjxU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "UndoRedoCatchup", ()=>UndoRedoCatchup
);
var _kl = require("../kl");
var _klHistory = require("./kl-history");
class UndoRedoCatchup {
    /**
     * Prevent multiple undo / redo getting triggered at once.
     * Might be confusing if main thread is choking.
     */ ignoreTest() {
        if (this.doIgnore) return false;
        this.doIgnore = true;
        setTimeout(()=>{
            this.doIgnore = false;
        }, 0);
        return true;
    }
    // ---- public ----
    constructor(brushUiObj, layerPreview, layerManager, handUi, klCanvasWorkspace, getInitState, getKlCanvas, getCurrentLayerCtx, setCurrentLayerCtx, getCurrentBrush){
        this.brushUiObj = brushUiObj;
        this.layerPreview = layerPreview;
        this.layerManager = layerManager;
        this.handUi = handUi;
        this.klCanvasWorkspace = klCanvasWorkspace;
        this.getInitState = getInitState;
        this.getKlCanvas = getKlCanvas;
        this.getCurrentLayerCtx = getCurrentLayerCtx;
        this.setCurrentLayerCtx = setCurrentLayerCtx;
        this.getCurrentBrush = getCurrentBrush;
        this.doIgnore = false;
    }
    undo() {
        if (!this.ignoreTest()) return false;
        if (!_klHistory.klHistory.canUndo()) return false;
        const actions = _klHistory.klHistory.undo();
        _klHistory.klHistory.pause(true);
        const initState = this.getInitState();
        const oldSize = {
            w: this.getKlCanvas().getWidth(),
            h: this.getKlCanvas().getHeight()
        };
        this.getKlCanvas().copy(initState.canvas);
        let layerIndex = initState.focus;
        this.setCurrentLayerCtx(this.getKlCanvas().getLayerContext(layerIndex));
        const brushes = {
        };
        for(let b1 in _kl.KL.brushes)if (_kl.KL.brushes.hasOwnProperty(b1)) {
            brushes[b1] = new _kl.KL.brushes[b1]();
            brushes[b1].setContext(this.getCurrentLayerCtx());
        }
        brushes.SketchyBrush.setSeed(initState.brushes.SketchyBrush.getSeed());
        for(let i = 0; i < actions.length; i++)((i)=>{
            if (actions[i].tool[0] === "brush") {
                const b = brushes[actions[i].tool[1]];
                if (actions[i].actions) for(let e = 0; e < actions[i].actions.length; e++){
                    const p = actions[i].actions[e].params;
                    b[actions[i].actions[e].action].apply(b, p);
                }
                else {
                    const p = actions[i].params;
                    b[actions[i].action].apply(b, p);
                }
            } else if (actions[i].tool[0] === "canvas") {
                const p = actions[i].params;
                const id = this.getKlCanvas()[actions[i].action].apply(this.getKlCanvas(), p);
                if (typeof id === 'number') {
                    layerIndex = id;
                    this.setCurrentLayerCtx(this.getKlCanvas().getLayerContext(layerIndex));
                    for(let b in brushes)if (brushes.hasOwnProperty(b)) brushes[b].setContext(this.getCurrentLayerCtx());
                }
            } else if (actions[i].tool[0] === "filter") {
                const p = [
                    {
                        context: this.getCurrentLayerCtx(),
                        canvas: this.getKlCanvas(),
                        input: actions[i].params[0].input,
                        history: new _kl.KL.DecoyKlHistory()
                    }
                ];
                _kl.KL.filterLib[actions[i].tool[1]][actions[i].action].apply(null, p);
            } else if (actions[i].tool[0] === "misc" && actions[i].action === "focusLayer") {
                layerIndex = actions[i].params[0];
                this.setCurrentLayerCtx(this.getKlCanvas().getLayerContext(actions[i].params[0]));
                for(let b in brushes)if (brushes.hasOwnProperty(b)) brushes[b].setContext(this.getCurrentLayerCtx());
            } else if (actions[i].tool[0] === "misc" && actions[i].action === "importImage") {
                const id = this.getKlCanvas().addLayer();
                if (typeof id === 'number') {
                    layerIndex = id;
                    if (actions[i].params[1]) this.getKlCanvas().renameLayer(layerIndex, actions[i].params[1]);
                    this.setCurrentLayerCtx(this.getKlCanvas().getLayerContext(layerIndex));
                    for(let b in brushes)if (brushes.hasOwnProperty(b)) brushes[b].setContext(this.getCurrentLayerCtx());
                }
                this.getCurrentLayerCtx().drawImage(actions[i].params[0], 0, 0);
            }
        })(i);
        if (oldSize.w !== this.getKlCanvas().getWidth() || oldSize.h !== this.getKlCanvas().getHeight()) {
            this.klCanvasWorkspace.resetView();
            this.handUi.update(this.klCanvasWorkspace.getScale(), this.klCanvasWorkspace.getAngleDeg());
        }
        this.layerManager.update(layerIndex);
        this.layerPreview.setLayer(this.getKlCanvas().getLayer(layerIndex));
        this.brushUiObj.sketchyBrush.setSeed(brushes.SketchyBrush.getSeed());
        this.getCurrentBrush().setContext(this.getCurrentLayerCtx());
        this.klCanvasWorkspace.setLastDrawEvent(null);
        _klHistory.klHistory.pause(false);
        return true;
    }
    redo() {
        if (!this.ignoreTest()) return false;
        if (!_klHistory.klHistory.canRedo()) return false;
        const actions = _klHistory.klHistory.redo();
        _klHistory.klHistory.pause(true);
        const oldSize = {
            w: this.getKlCanvas().getWidth(),
            h: this.getKlCanvas().getHeight()
        };
        let layerIndex;
        const brushes = {
        };
        for(let b2 in _kl.KL.brushes)if (_kl.KL.brushes.hasOwnProperty(b2)) {
            brushes[b2] = new _kl.KL.brushes[b2]();
            brushes[b2].setContext(this.getCurrentLayerCtx());
        }
        brushes.SketchyBrush.setSeed(this.brushUiObj.sketchyBrush.getSeed());
        for(let i = 0; i < actions.length; i++)((i)=>{
            if (actions[i].tool[0] === "brush") {
                const b = brushes[actions[i].tool[1]];
                if (actions[i].actions) for(let e = 0; e < actions[i].actions.length; e++){
                    const p = actions[i].actions[e].params;
                    b[actions[i].actions[e].action].apply(b, p);
                }
                else {
                    const p = actions[i].params;
                    b[actions[i].action].apply(b, p);
                }
            } else if (actions[i].tool[0] === "canvas") {
                const p = actions[i].params;
                const id = this.getKlCanvas()[actions[i].action].apply(this.getKlCanvas(), p);
                if (typeof id === 'number') {
                    layerIndex = id;
                    this.setCurrentLayerCtx(this.getKlCanvas().getLayerContext(layerIndex));
                    for(let b in brushes)if (brushes.hasOwnProperty(b)) brushes[b].setContext(this.getCurrentLayerCtx());
                }
            } else if (actions[i].tool[0] === "filter") {
                const p = [
                    {
                        context: this.getCurrentLayerCtx(),
                        canvas: this.getKlCanvas(),
                        input: actions[i].params[0].input,
                        history: new _kl.KL.DecoyKlHistory()
                    }
                ];
                _kl.KL.filterLib[actions[i].tool[1]][actions[i].action].apply(null, p);
            } else if (actions[i].tool[0] === "misc" && actions[i].action === "focusLayer") {
                layerIndex = actions[i].params[0];
                this.setCurrentLayerCtx(this.getKlCanvas().getLayerContext(actions[i].params[0]));
                for(let b in brushes)if (brushes.hasOwnProperty(b)) brushes[b].setContext(this.getCurrentLayerCtx());
            } else if (actions[i].tool[0] === "misc" && actions[i].action === "importImage") {
                const id = this.getKlCanvas().addLayer();
                if (typeof id === 'number') {
                    layerIndex = id;
                    if (actions[i].params[1]) this.getKlCanvas().renameLayer(layerIndex, actions[i].params[1]);
                    this.setCurrentLayerCtx(this.getKlCanvas().getLayerContext(layerIndex));
                    for(let b in brushes)if (brushes.hasOwnProperty(b)) brushes[b].setContext(this.getCurrentLayerCtx());
                }
                this.getCurrentLayerCtx().drawImage(actions[i].params[0], 0, 0);
            }
        })(i);
        if (oldSize.w !== this.getKlCanvas().getWidth() || oldSize.h !== this.getKlCanvas().getHeight()) {
            this.klCanvasWorkspace.resetView();
            this.handUi.update(this.klCanvasWorkspace.getScale(), this.klCanvasWorkspace.getAngleDeg());
        }
        const currentLayerIndex = this.getKlCanvas().getLayerIndex(this.getCurrentLayerCtx().canvas);
        this.layerManager.update(currentLayerIndex);
        this.layerPreview.setLayer(this.getKlCanvas().getLayer(currentLayerIndex));
        this.brushUiObj.sketchyBrush.setSeed(brushes.SketchyBrush.getSeed());
        this.getCurrentBrush().setContext(this.getCurrentLayerCtx());
        this.klCanvasWorkspace.setLastDrawEvent(null);
        _klHistory.klHistory.pause(false);
        return true;
    }
    catchup(logParam) {
        // const start = performance.now();
        //play catch up (the version that is a few steps behind)
        if (logParam && logParam.bufferUpdate) {
            const initState = this.getInitState();
            const brushes = initState.brushes;
            const actions = [
                logParam.bufferUpdate
            ];
            let localCurrentLayerCtx = initState.canvas.getLayerContext(initState.focus);
            const canvas = initState.canvas;
            let layerIndex = initState.focus;
            ((i)=>{
                if (actions[i].tool[0] === "brush") {
                    let b = brushes[actions[i].tool[1]];
                    if (actions[i].actions) for(let e = 0; e < actions[i].actions.length; e++){
                        const p = actions[i].actions[e].params;
                        b[actions[i].actions[e].action].apply(b, p);
                    }
                    else {
                        const p = actions[i].params;
                        b[actions[i].action].apply(b, p);
                    }
                } else if (actions[i].tool[0] === "canvas") {
                    const p = actions[i].params;
                    const id = canvas[actions[i].action].apply(canvas, p);
                    if (typeof id === 'number') {
                        layerIndex = id;
                        localCurrentLayerCtx = canvas.getLayerContext(layerIndex);
                        for(let b in brushes)if (brushes.hasOwnProperty(b)) brushes[b].setContext(localCurrentLayerCtx);
                    }
                } else if (actions[i].tool[0] === "filter") {
                    const p = [
                        {
                            context: localCurrentLayerCtx,
                            canvas: canvas,
                            input: actions[i].params[0].input,
                            history: new _kl.KL.DecoyKlHistory()
                        }
                    ];
                    _kl.KL.filterLib[actions[i].tool[1]][actions[i].action].apply(null, p);
                } else if (actions[i].tool[0] === "misc" && actions[i].action === "focusLayer") {
                    layerIndex = actions[i].params[0];
                    localCurrentLayerCtx = canvas.getLayerContext(actions[i].params[0]);
                    for(let b in brushes)if (brushes.hasOwnProperty(b)) brushes[b].setContext(localCurrentLayerCtx);
                } else if (actions[i].tool[0] === "misc" && actions[i].action === "importImage") {
                    const id = canvas.addLayer();
                    if (typeof id === 'number') {
                        layerIndex = id;
                        if (actions[i].params[1]) this.getKlCanvas().renameLayer(layerIndex, actions[i].params[1]);
                        localCurrentLayerCtx = canvas.getLayerContext(layerIndex);
                        for(let b in brushes)if (brushes.hasOwnProperty(b)) brushes[b].setContext(localCurrentLayerCtx);
                    }
                    localCurrentLayerCtx.drawImage(actions[i].params[0], 0, 0);
                }
            })(0);
            initState.focus = layerIndex;
        }
    // console.log('catchup', performance.now() - start);
    }
}

},{"../kl":"3bnx1","./kl-history":"ai9zE","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6eJtU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Central place to update brush settings, and to subscribe to changes.
 */ parcelHelpers.export(exports, "BrushSettingService", ()=>BrushSettingService
);
class BrushSettingService {
    emit(obj, skipSubscriber) {
        for(let i = 0; i < this.subscriberArr.length; i++){
            if (this.subscriberArr[i] === skipSubscriber) continue;
            this.subscriberArr[i](obj);
        }
    }
    // --- public ---
    constructor(onSetColor, onSetSize, onSetOpacity, onGetColor, onGetSize, onGetOpacity, onGetSliderConfig){
        this.onSetColor = onSetColor;
        this.onSetSize = onSetSize;
        this.onSetOpacity = onSetOpacity;
        this.onGetColor = onGetColor;
        this.onGetSize = onGetSize;
        this.onGetOpacity = onGetOpacity;
        this.onGetSliderConfig = onGetSliderConfig;
        this.subscriberArr = [];
        if (BrushSettingService.instance) throw new Error('BrushSettingService already instantiated');
        BrushSettingService.instance = this;
    }
    emitColor(color, skipSubscriber) {
        this.emit({
            type: 'color',
            value: color
        }, skipSubscriber);
    }
    emitSize(size, skipSubscriber) {
        this.emit({
            type: 'size',
            value: size
        }, skipSubscriber);
    }
    emitOpacity(opacity, skipSubscriber) {
        this.emit({
            type: 'opacity',
            value: opacity
        }, skipSubscriber);
    }
    emitSliderConfig(sliderConfig, skipSubscriber) {
        this.emit({
            type: 'sliderConfig',
            value: sliderConfig
        }, skipSubscriber);
    }
    /**
     * set current brush color
     * @param color
     * @param skipSubscriber
     */ setColor(color, skipSubscriber) {
        this.onSetColor(color);
        this.emitColor(color, skipSubscriber);
    }
    /**
     * set current brush size
     * @param size
     * @param skipSubscriber
     */ setSize(size, skipSubscriber) {
        this.onSetSize(size);
    // why not emitting?
    }
    /**
     * set current opacity
     * @param opacity
     * @param skipSubscriber
     */ setOpacity(opacity, skipSubscriber) {
        this.onSetOpacity(opacity);
    // why not emitting?
    }
    /**
     * get current brush color
     */ getColor() {
        return this.onGetColor();
    }
    getSize() {
        return this.onGetSize();
    }
    getOpacity() {
        return this.onGetOpacity();
    }
    getSliderConfig() {
        return this.onGetSliderConfig();
    }
    /**
     * subscribe to changes
     * @param func
     */ subscribe(func) {
        if (this.subscriberArr.includes(func)) return;
        this.subscriberArr.push(func);
    }
    unsubscribe(func) {
        for(let i = 0; i < this.subscriberArr.length; i++)if (func === this.subscriberArr[i]) {
            this.subscriberArr.splice(i, 1);
            i--;
        }
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jwTKz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SettingsTab", ()=>SettingsTab
);
var _bb = require("../../../bb/bb");
var _language = require("../../../language/language");
var _kl = require("../../kl");
var _languages = require("../../../../languages/languages");
var _popup = require("../modals/popup");
// @ts-ignore
var _bitbofLogoSvg = require("url:~/src/app/img/bitbof-logo.svg");
var _bitbofLogoSvgDefault = parcelHelpers.interopDefault(_bitbofLogoSvg);
// @ts-ignore
var _uiSwapLrSvg = require("url:~/src/app/img/ui/ui-swap-lr.svg");
var _uiSwapLrSvgDefault = parcelHelpers.interopDefault(_uiSwapLrSvg);
var _localStorage = require("../../../bb/base/local-storage");
class SettingsTab {
    // --- public ---
    constructor(onLeftRight, customAbout){
        // ---- language ----
        const language = _language.languageStrings.getLanguage();
        this.el = _bb.BB.el({
            content: `
${_language.LANG('settings-language')}: ${language.name} (${language.code})
            `,
            css: {
                margin: '10px'
            }
        });
        const preferredLanguageRow = _bb.BB.el({
            content: _language.LANG('settings-preferred-language') + ':<br>',
            css: {
                marginTop: '10px'
            }
        });
        const options = [
            [
                'auto',
                _language.LANG('auto')
            ]
        ].concat(_languages.languages.map((item)=>{
            return [
                item.code,
                item.name + ` (${item.code})`
            ];
        }));
        const languageSelect = new _kl.KL.Select({
            initValue: _localStorage.LocalStorage.getItem(_language.LS_LANGUAGE_KEY) ? _localStorage.LocalStorage.getItem(_language.LS_LANGUAGE_KEY) : 'auto',
            optionArr: options,
            onChange: (val)=>{
                if (val === 'auto') _localStorage.LocalStorage.removeItem(_language.LS_LANGUAGE_KEY);
                else _localStorage.LocalStorage.setItem(_language.LS_LANGUAGE_KEY, val);
                languageHint.style.display = 'block';
            }
        });
        const languageHint = _bb.BB.el({
            content: _language.LANG('settings-language-reload'),
            css: {
                display: 'none',
                marginTop: '5px'
            }
        });
        preferredLanguageRow.append(languageSelect.getElement(), languageHint);
        this.el.append(preferredLanguageRow);
        // ---- flip ui ----
        _bb.BB.el({
            tagName: 'button',
            parent: this.el,
            content: '<img height="20" width="18" src="' + _uiSwapLrSvgDefault.default + '" alt="icon" style="margin-right: 5px"/>' + _language.LANG('switch-ui-left-right'),
            onClick: ()=>onLeftRight()
            ,
            css: {
                marginTop: '20px'
            },
            custom: {
                tabIndex: '-1'
            }
        });
        // ---- about ----
        this.el.append(_bb.BB.el({
            className: 'gridHr',
            css: {
                margin: '10px 0'
            }
        }));
        function makeLicenses() {
            return _bb.BB.el({
                tagName: 'a',
                content: _language.LANG('licenses'),
                onClick: ()=>{
                    require("43512d603c7a38b2").then((result)=>{
                        new _popup.Popup({
                            title: _bb.BB.el({
                                content: _language.LANG('licenses')
                            }),
                            content: _bb.BB.el({
                                content: _bb.BB.el({
                                    content: result.licenses.replace(/\n/g, '<br>'),
                                    css: {
                                        padding: '20px'
                                    }
                                }),
                                css: {
                                    height: '100%',
                                    overflowY: 'scroll'
                                }
                            }),
                            width: 800,
                            isMaxHeight: true
                        });
                    });
                }
            });
        }
        if (customAbout) {
            this.el.append(customAbout);
            if (!customAbout.innerHTML) {
                const minimalAbout = _bb.BB.el({
                    parent: customAbout,
                    css: {
                        textAlign: 'center'
                    }
                });
                minimalAbout.append(_bb.BB.el({
                    content: `<img alt="icon" height="20" style="vertical-align:middle" src="${_bitbofLogoSvgDefault.default}"> <a href="https://bitbof.com" target="_blank" tabIndex="-1">bitbof</a> © 2022<br>`
                }), makeLicenses());
            }
        }
        window.addEventListener('storage', (e)=>{
            if (e.key !== _language.LS_LANGUAGE_KEY) return;
            languageSelect.setValue(_localStorage.LocalStorage.getItem(_language.LS_LANGUAGE_KEY) ? _localStorage.LocalStorage.getItem(_language.LS_LANGUAGE_KEY) : 'auto');
        });
    }
    getElement() {
        return this.el;
    }
}

},{"../../../bb/bb":"e3nbn","../../../language/language":"lvNW4","../../kl":"3bnx1","../../../../languages/languages":"9233v","../modals/popup":"7D028","url:~/src/app/img/bitbof-logo.svg":"iB3Ic","url:~/src/app/img/ui/ui-swap-lr.svg":"9h8BU","../../../bb/base/local-storage":"iOEIY","43512d603c7a38b2":"iWNTY","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"iB3Ic":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "bitbof-logo.e565df89.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"9h8BU":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "ui-swap-lr.39482260.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"iWNTY":[function(require,module,exports) {
module.exports = require("./helpers/browser/js-loader")(require('./helpers/bundle-url').getBundleURL('bWfZe') + "licenses.1e4934d6.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root('1SbfK')
);

},{"./helpers/browser/js-loader":"285qT","./helpers/bundle-url":"chiK4"}],"4YUOX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Scroll buttons at the top and bottom of toolspace
 * Show up when window is very small.
 * Allow user to scroll up and down toolspace.
 */ parcelHelpers.export(exports, "ToolspaceScroller", ()=>ToolspaceScroller
);
var _bb = require("../../../bb/bb");
var _language = require("../../../language/language");
var _modalCount = require("../modals/modal-count");
class ToolspaceScroller {
    update() {
        if (this.toolspace.scrollHeight > this.toolspace.offsetHeight + 3) {
            if (!this.upInterval) this.upBtn.style.display = this.toolspace.scrollTop === 0 ? 'none' : 'block';
            if (!this.downInterval) this.downBtn.style.display = this.toolspace.scrollTop + this.toolspace.offsetHeight + 1 >= this.toolspace.scrollHeight ? 'none' : 'block';
        } else {
            this.upBtn.style.display = 'none';
            this.downBtn.style.display = 'none';
        }
    }
    // --- public ---
    constructor(p){
        this.toolspace = p.toolspace;
        this.upBtn = _bb.BB.el({
            parent: this.toolspace,
            title: _language.LANG('scroll'),
            className: 'kl-scroller',
            css: {
                top: '0',
                transform: 'rotate(180deg)'
            }
        });
        this.downBtn = _bb.BB.el({
            parent: this.toolspace,
            title: _language.LANG('scroll'),
            className: 'kl-scroller',
            css: {
                bottom: '0'
            }
        });
        this.updateUiState(p.uiState);
        const upListener = new _bb.BB.PointerListener({
            target: this.upBtn,
            onPointer: (e)=>{
                if (e.type === 'pointerdown') this.upInterval = setInterval(()=>{
                    this.toolspace.scrollBy(0, -10);
                    this.update();
                }, 20);
                if (e.type === 'pointerup') {
                    clearInterval(this.upInterval);
                    setTimeout(()=>{
                        this.upInterval = null;
                        this.update();
                    }, 50);
                }
            },
            onWheel: (e)=>{
                this.toolspace.scrollBy(0, 20 * e.deltaY);
                this.update();
            }
        });
        const downListener = new _bb.BB.PointerListener({
            target: this.downBtn,
            onPointer: (e)=>{
                if (e.type === 'pointerdown') this.downInterval = setInterval(()=>{
                    this.toolspace.scrollBy(0, 10);
                    this.update();
                }, 20);
                if (e.type === 'pointerup') {
                    clearInterval(this.downInterval);
                    setTimeout(()=>{
                        this.downInterval = null;
                        this.update();
                    }, 50);
                }
            },
            onWheel: (e)=>{
                this.toolspace.scrollBy(0, 20 * e.deltaY);
                this.update();
            }
        });
        this.update();
        const observer = new MutationObserver(()=>this.update()
        );
        observer.observe(this.toolspace, {
            attributes: true,
            childList: true,
            subtree: true
        });
        window.addEventListener('resize', ()=>this.update()
        );
        // hide if in dialog because that can have its own scrollbar
        _modalCount.dialogCounter.subscribe((v)=>{
            // ignores the 0.5 by tool dropdown
            this.upBtn.style.opacity = v >= 1 ? '0' : '';
            this.downBtn.style.opacity = v >= 1 ? '0' : '';
        });
    }
    updateUiState(uiState) {
        _bb.BB.css(this.upBtn, {
            left: uiState === 'left' ? '0' : null,
            right: uiState === 'right' ? '0' : null
        });
        _bb.BB.css(this.downBtn, {
            left: uiState === 'left' ? '0' : null,
            right: uiState === 'right' ? '0' : null
        });
    }
}

},{"../../../bb/bb":"e3nbn","../../../language/language":"lvNW4","../modals/modal-count":"5hzLs","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"dPWb5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "KlApp", ()=>KlApp
);
var _kl = require("../klecks/kl");
var _klHistory = require("../klecks/history/kl-history");
var _bb = require("../bb/bb");
var _showIframePopup = require("../klecks/ui/modals/show-iframe-popup");
var _fileTab = require("../klecks/ui/tool-tabs/file-tab");
var _toolspaceTopRow = require("../embed/toolspace-top-row");
var _filtersLazy = require("../klecks/filters/filters-lazy");
var _base64ToBlob = require("../klecks/storage/base-64-to-blob");
var _klCanvasToPsdBlob = require("../klecks/storage/kl-canvas-to-psd-blob");
var _language = require("../language/language");
// @ts-ignore
var _toolPaintSvg = require("url:~/src/app/img/ui/tool-paint.svg");
var _toolPaintSvgDefault = parcelHelpers.interopDefault(_toolPaintSvg);
// @ts-ignore
var _toolHandSvg = require("url:~/src/app/img/ui/tool-hand.svg");
var _toolHandSvgDefault = parcelHelpers.interopDefault(_toolHandSvg);
// @ts-ignore
var _toolFillSvg = require("url:~/src/app/img/ui/tool-fill.svg");
var _toolFillSvgDefault = parcelHelpers.interopDefault(_toolFillSvg);
// @ts-ignore
var _toolTextSvg = require("url:~/src/app/img/ui/tool-text.svg");
var _toolTextSvgDefault = parcelHelpers.interopDefault(_toolTextSvg);
// @ts-ignore
var _toolShapeSvg = require("url:~/src/app/img/ui/tool-shape.svg");
var _toolShapeSvgDefault = parcelHelpers.interopDefault(_toolShapeSvg);
// @ts-ignore
var _tabSettingsSvg = require("url:~/src/app/img/ui/tab-settings.svg");
var _tabSettingsSvgDefault = parcelHelpers.interopDefault(_tabSettingsSvg);
// @ts-ignore
var _tabLayersSvg = require("url:~/src/app/img/ui/tab-layers.svg");
var _tabLayersSvgDefault = parcelHelpers.interopDefault(_tabLayersSvg);
var _localStorage = require("../bb/base/local-storage");
_filtersLazy.importFilters();
function KlApp(pProject, pOptions) {
    // default 2048, unless your screen is bigger than that (that computer then probably has the horsepower for that)
    // but not larger than 4096 - a fairly arbitrary decision
    let klMaxCanvasSize = Math.min(4096, Math.max(2048, Math.max(window.screen.width, window.screen.height)));
    let collapseThreshold = 820;
    let uiState = pOptions.embed ? 'left' : _localStorage.LocalStorage.getItem('uiState') ? _localStorage.LocalStorage.getItem('uiState') : 'right';
    const filenameBase = pOptions.app && pOptions.app.filenameBase ? pOptions.app.filenameBase : 'Klecks';
    const projectStore = pOptions.projectStore;
    let klRootEl = document.createElement("div");
    klRootEl.className = 'g-root kl-initialized';
    let uiWidth = Math.max(0, window.innerWidth);
    let uiHeight = Math.max(0, window.innerHeight);
    const toolWidth = 271;
    let exportType = 'png';
    let klCanvas = new _kl.KL.KlCanvas(pProject ? {
        projectObj: pProject
    } : {
        width: Math.min(klMaxCanvasSize, window.innerWidth < collapseThreshold ? uiWidth : uiWidth - toolWidth),
        height: Math.min(klMaxCanvasSize, uiHeight)
    }, pOptions.embed ? -1 : 0);
    klCanvas.setHistory(_klHistory.klHistory);
    let initState = null;
    let mainTabRow;
    if (!pOptions.saveReminder) pOptions.saveReminder = {
        init: ()=>{
        },
        reset: ()=>{
        }
    };
    function translateSmoothing(s) {
        if (s == 1) return 0.5;
        if (s == 2) return 0.84;
        if (s == 3) return 0.965;
        if (s == 4) return 0.9825;
        if (s == 5) return 0.99125;
        return s;
    }
    let isFirstImage = true;
    if (pProject) pProject = null;
    else {
        _klHistory.klHistory.pause(true);
        klCanvas.addLayer();
        klCanvas.layerFill(0, {
            r: 255,
            g: 255,
            b: 255
        });
        _klHistory.klHistory.pause(false);
    }
    initState = {
        canvas: new _kl.KL.KlCanvas({
            copy: klCanvas
        }, pOptions.embed ? -1 : 0),
        focus: klCanvas.getLayerCount() - 1,
        brushes: {
        }
    };
    for(let b in _kl.KL.brushes)if (_kl.KL.brushes.hasOwnProperty(b)) {
        initState.brushes[b] = new _kl.KL.brushes[b]();
        if (initState.canvas) initState.brushes[b].setContext(initState.canvas.getLayerContext(initState.focus));
    }
    let currentColor = new _bb.BB.RGB(0, 0, 0);
    let currentBrush, currentBrushId;
    let lastNonEraserBrushId = 0;
    let currentLayerCtx = klCanvas.getLayerContext(klCanvas.getLayerCount() - 1);
    function sizeWatcher(val) {
        brushSettingService.emitSize(val);
        if (klCanvasWorkspace) klCanvasWorkspace.setCursorSize(val * 2);
    }
    const brushSettingService = new _kl.KL.BrushSettingService((color)=>{
        klColorSlider.setColor(color);
        currentBrush.setColor(color);
        currentColor = _bb.BB.copyObj(color);
    }, (size)=>{
        currentBrush.setSize(size);
        klCanvasWorkspace.setCursorSize(size * 2);
    }, (opacity)=>{
        currentBrush.setOpacity(opacity);
    }, ()=>klColorSlider.getColor()
    , ()=>brushUiObj[currentBrushId].getSize()
    , ()=>brushUiObj[currentBrushId].getOpacity()
    , ()=>{
        return {
            sizeSlider: _kl.KL.brushesUI[currentBrushId].sizeSlider,
            opacitySlider: _kl.KL.brushesUI[currentBrushId].opacitySlider
        };
    });
    let lineSmoothing = new _bb.BB.EventChain.LineSmoothing({
        smoothing: translateSmoothing(1)
    });
    let lineSanitizer = new _bb.BB.EventChain.LineSanitizer();
    let drawEventChain = new _bb.BB.EventChain.EventChain({
        chainArr: [
            lineSanitizer,
            lineSmoothing
        ]
    });
    drawEventChain.setChainOut(function(event) {
        if (event.type === 'down') {
            toolspace.style.pointerEvents = 'none';
            currentBrush.startLine(event.x, event.y, event.pressure);
            klCanvasWorkspace.requestFrame();
        }
        if (event.type === 'move') {
            currentBrush.goLine(event.x, event.y, event.pressure, false, event.isCoalesced);
            klCanvasWorkspace.setLastDrawEvent(event.x, event.y, event.pressure);
            klCanvasWorkspace.requestFrame();
        }
        if (event.type === 'up') {
            toolspace.style.pointerEvents = '';
            currentBrush.endLine();
            klCanvasWorkspace.requestFrame();
        }
        if (event.type === 'line') {
            currentBrush.getBrush().drawLineSegment(event.x0, event.y0, event.x1, event.y1);
            klCanvasWorkspace.requestFrame();
        }
    });
    let textToolSettings = {
        size: 20,
        align: 'left',
        isBold: false,
        isItalic: false,
        font: 'sans-serif',
        opacity: 1
    };
    const klCanvasWorkspace = new _kl.KL.KlCanvasWorkspace({
        klCanvas: klCanvas,
        width: Math.max(0, uiWidth - toolWidth),
        height: uiHeight,
        onDraw: drawEventChain.chainIn,
        onPick: function(rgbObj, isDragDone) {
            brushSettingService.setColor(rgbObj);
            if (isDragDone) {
                klColorSlider.pickingDone();
                klCanvasWorkspace.setMode(toolspaceToolRow.getActive());
            }
        },
        onFill: function(canvasX, canvasY) {
            let layerIndex = klCanvas.getLayerIndex(currentLayerCtx.canvas);
            klCanvas.floodFill(layerIndex, canvasX, canvasY, klColorSlider.getColor(), fillUi.getOpacity(), fillUi.getTolerance(), fillUi.getSample(), fillUi.getGrow(), fillUi.getContiguous());
            klCanvasWorkspace.requestFrame();
        },
        onText: function(canvasX, canvasY, angleRad) {
            if (_kl.KL.dialogCounter.get() > 0) return;
            _kl.KL.textToolDialog({
                klCanvas: klCanvas,
                layerIndex: klCanvas.getLayerIndex(currentLayerCtx.canvas),
                x: canvasX,
                y: canvasY,
                angleRad: angleRad,
                color: klColorSlider.getColor(),
                secondaryColor: klColorSlider.getSecondaryRGB(),
                size: textToolSettings.size,
                align: textToolSettings.align,
                isBold: textToolSettings.isBold,
                isItalic: textToolSettings.isItalic,
                font: textToolSettings.font,
                opacity: textToolSettings.opacity,
                onConfirm: function(val) {
                    let colorRGBA = val.color;
                    colorRGBA.a = val.opacity;
                    textToolSettings.size = val.size;
                    textToolSettings.align = val.align;
                    textToolSettings.isBold = val.isBold;
                    textToolSettings.isItalic = val.isItalic;
                    textToolSettings.font = val.font;
                    textToolSettings.opacity = val.opacity;
                    let layerIndex = klCanvas.getLayerIndex(currentLayerCtx.canvas);
                    klCanvas.text(layerIndex, {
                        textStr: val.textStr,
                        x: val.x,
                        y: val.y,
                        size: val.size,
                        font: val.font,
                        align: val.align,
                        isBold: val.isBold,
                        isItalic: val.isItalic,
                        angleRad: angleRad,
                        color: _bb.BB.ColorConverter.toRgbaStr(colorRGBA)
                    });
                    klCanvasWorkspace.requestFrame();
                }
            });
        },
        onShape: function(typeStr, canvasX, canvasY, angleRad) {
            if (typeStr === 'down') shapeTool.onDown(canvasX, canvasY, angleRad);
            if (typeStr === 'move') shapeTool.onMove(canvasX, canvasY);
            if (typeStr === 'up') shapeTool.onUp(canvasX, canvasY);
        },
        onViewChange: function(viewChangeObj) {
            if (viewChangeObj.changed.includes('scale')) statusOverlay.out({
                type: 'transform',
                scale: viewChangeObj.scale,
                angleDeg: viewChangeObj.angle * 180 / Math.PI
            });
            toolspaceToolRow.setEnableZoomIn(viewChangeObj.scale !== klCanvasWorkspace.getMaxScale());
            toolspaceToolRow.setEnableZoomOut(viewChangeObj.scale !== klCanvasWorkspace.getMinScale());
            handUi.update(viewChangeObj.scale, viewChangeObj.angle * 180 / Math.PI);
        },
        onUndo: function() {
            if (_klHistory.klHistory.canUndo()) {
                if (undoRedoCatchup.undo()) statusOverlay.out(_language.LANG('undo'), true);
            }
        },
        onRedo: function() {
            if (_klHistory.klHistory.canRedo()) {
                if (undoRedoCatchup.redo()) statusOverlay.out(_language.LANG('redo'), true);
            }
        }
    });
    let button1 = document.getElementById('vaiz1');
    button1?.addEventListener('touchstart', function handleClick(event) {
        event.preventDefault();
        klCanvasWorkspace.setMode('draw');
        toolspaceToolRow.setActive('draw');
        mainTabRow.open('draw');
        updateMainTabVisibility();
        brushTabRow.open('penBrush');
    });
    let button2 = document.getElementById('vaiz2');
    button2?.addEventListener('touchstart', function handleClick(event) {
        event.preventDefault();
        klCanvasWorkspace.setMode('draw');
        toolspaceToolRow.setActive('draw');
        mainTabRow.open('draw');
        updateMainTabVisibility();
        brushTabRow.open('eraserBrush');
    });
    let button3 = document.getElementById('vaiz3');
    button3?.addEventListener('touchstart', function handleClick(event) {
        event.preventDefault();
        klCanvasWorkspace.setMode('draw');
        toolspaceToolRow.setActive('draw');
        mainTabRow.open('draw');
        updateMainTabVisibility();
        brushTabRow.open('pixelBrush');
    });
    let button4 = document.getElementById('vaiz4');
    button4?.addEventListener('touchstart', function handleClick(event) {
        event.preventDefault();
        klCanvasWorkspace.setMode('draw');
        toolspaceToolRow.setActive('draw');
        mainTabRow.open('draw');
        updateMainTabVisibility();
        brushTabRow.open('chemyBrush');
    });
    let button5 = document.getElementById('vaiz5');
    button5?.addEventListener('touchstart', function handleClick(event) {
        event.preventDefault();
        klCanvasWorkspace.setMode('draw');
        toolspaceToolRow.setActive('draw');
        mainTabRow.open('draw');
        updateMainTabVisibility();
        brushTabRow.open('smudgeBrush');
    });
    let button6 = document.getElementById('vaiz6');
    button6?.addEventListener('touchstart', function handleClick(event) {
        event.preventDefault();
        klCanvasWorkspace.setMode('draw');
        toolspaceToolRow.setActive('draw');
        mainTabRow.open('draw');
        updateMainTabVisibility();
        brushTabRow.open('sketchyBrush');
    });
    let button7 = document.getElementById('vaiz7');
    button7?.addEventListener('touchstart', function handleClick(event) {
        event.preventDefault();
        klCanvasWorkspace.setMode('draw');
        toolspaceToolRow.setActive('draw');
        mainTabRow.open('draw');
        updateMainTabVisibility();
        brushTabRow.open('blendBrush');
    });
    let button8 = document.getElementById('vaiz8');
    button8?.addEventListener('touchstart', function handleClick(event) {
        event.preventDefault();
        klCanvasWorkspace.setMode('text');
        toolspaceToolRow.setActive('text');
        mainTabRow.open('text');
        updateMainTabVisibility();
    });
    let button9 = document.getElementById('vaiz9');
    button9?.addEventListener('touchstart', function handleClick(event) {
        event.preventDefault();
        klCanvasWorkspace.setMode('shape');
        toolspaceToolRow.setActive('shape');
        mainTabRow.open('shape');
        updateMainTabVisibility();
    });
    let button10 = document.getElementById('vaiz10');
    button10?.addEventListener('touchstart', function handleClick(event) {
        event.preventDefault();
        klCanvasWorkspace.setMode('fill');
        toolspaceToolRow.setActive('fill');
        mainTabRow.open('fill');
        updateMainTabVisibility();
    });
    let button11 = document.getElementById('vaiz11');
    button11?.addEventListener('touchstart', function handleClick(event) {
        event.preventDefault();
        (async ()=>{
            let success = true;
            try {
                await projectStore.store(klCanvas.getProject());
            } catch (e) {
                success = false;
                setTimeout(()=>{
                    throw new Error('keyboard-shortcut: failed to store browser storage, ' + e);
                }, 0);
                statusOverlay.out('❌ ' + _language.LANG('file-storage-failed'), true);
            }
            if (success) {
                pOptions.saveReminder.reset();
                statusOverlay.out(_language.LANG('file-storage-stored'), true);
            }
        })();
    });
    let button12 = document.getElementById('vaiz12');
    button12?.addEventListener('touchstart', function handleClick(event) {
        event.preventDefault();
        klCanvasWorkspace.setMode('fill');
        toolspaceToolRow.setActive('fill');
        mainTabRow.open('fill');
        updateMainTabVisibility();
    });
    let keyListener = new _bb.BB.KeyListener({
        onDown: function(keyStr, event, comboStr) {
            if (_kl.KL.dialogCounter.get() > 0) return;
            if (_bb.BB.isInputFocused(true)) return;
            let isDrawing = lineSanitizer.getIsDrawing() || klCanvasWorkspace.getIsDrawing();
            if (isDrawing) return;
            if (comboStr === 'plus') klCanvasWorkspace.zoomByStep(keyListener.isPressed('shift') ? 1 / 8 : 0.5);
            if (comboStr === 'minus') klCanvasWorkspace.zoomByStep(keyListener.isPressed('shift') ? -1 / 8 : -0.5);
            if (comboStr === 'home') klCanvasWorkspace.fitView();
            if (comboStr === 'end') klCanvasWorkspace.resetView(true);
            if ([
                'ctrl+z',
                'cmd+z'
            ].includes(comboStr)) {
                event.preventDefault();
                undoRedoCatchup.undo();
            }
            if ([
                'ctrl+y',
                'cmd+y'
            ].includes(comboStr) || (_bb.BB.sameKeys('ctrl+shift+z', comboStr) || _bb.BB.sameKeys('cmd+shift+z', comboStr)) && keyStr === 'z') {
                event.preventDefault();
                undoRedoCatchup.redo();
            }
            if (!pOptions.embed) {
                if ([
                    'ctrl+s',
                    'cmd+s'
                ].includes(comboStr)) {
                    event.preventDefault();
                    saveToComputer.save();
                }
                if ([
                    'ctrl+shift+s',
                    'cmd+shift+s'
                ].includes(comboStr)) {
                    event.preventDefault();
                    (async ()=>{
                        let success = true;
                        try {
                            await projectStore.store(klCanvas.getProject());
                        } catch (e) {
                            success = false;
                            setTimeout(()=>{
                                throw new Error('keyboard-shortcut: failed to store browser storage, ' + e);
                            }, 0);
                            statusOverlay.out('❌ ' + _language.LANG('file-storage-failed'), true);
                        }
                        if (success) {
                            pOptions.saveReminder.reset();
                            statusOverlay.out(_language.LANG('file-storage-stored'), true);
                        }
                    })();
                }
                if ([
                    'ctrl+c',
                    'cmd+c'
                ].includes(comboStr)) {
                    event.preventDefault();
                    copyToClipboard(true);
                }
            }
            if ([
                'ctrl+a',
                'cmd+a'
            ].includes(comboStr)) event.preventDefault();
            if (keyListener.comboOnlyContains([
                'left',
                'right',
                'up',
                'down'
            ])) {
                if (keyStr === 'left') klCanvasWorkspace.translateView(1, 0);
                if (keyStr === 'right') klCanvasWorkspace.translateView(-1, 0);
                if (keyStr === 'up') klCanvasWorkspace.translateView(0, 1);
                if (keyStr === 'down') klCanvasWorkspace.translateView(0, -1);
            }
            if ([
                'r+left',
                'r+right'
            ].includes(comboStr)) {
                if (keyStr === 'left') {
                    klCanvasWorkspace.setAngle(-15, true);
                    handUi.update(klCanvasWorkspace.getScale(), klCanvasWorkspace.getAngleDeg());
                }
                if (keyStr === 'right') {
                    klCanvasWorkspace.setAngle(15, true);
                    handUi.update(klCanvasWorkspace.getScale(), klCanvasWorkspace.getAngleDeg());
                }
            }
            if ([
                'r+up'
            ].includes(comboStr)) {
                klCanvasWorkspace.setAngle(0);
                handUi.update(klCanvasWorkspace.getScale(), klCanvasWorkspace.getAngleDeg());
            }
            if (comboStr === 'sqbr_open') currentBrush.decreaseSize(0.03 / klCanvasWorkspace.getScale());
            if (comboStr === 'sqbr_close') currentBrush.increaseSize(0.03 / klCanvasWorkspace.getScale());
            if (comboStr === 'enter') {
                klCanvas.layerFill(klCanvas.getLayerIndex(currentLayerCtx.canvas), klColorSlider.getColor());
                statusOverlay.out(_language.LANG('filled'), true);
            }
            if ([
                'delete',
                'backspace'
            ].includes(comboStr)) {
                let layerIndex = klCanvas.getLayerIndex(currentLayerCtx.canvas);
                if (layerIndex === 0 && !brushUiObj.eraserBrush.getIsTransparentBg()) klCanvas.layerFill(layerIndex, {
                    r: 255,
                    g: 255,
                    b: 255
                }, 'source-in');
                else klCanvas.clearLayer(layerIndex);
                statusOverlay.out(_language.LANG('cleared-layer'), true);
            }
            if (comboStr === 'c') {
                event.preventDefault();
                klCanvasWorkspace.setMode('draw');
                toolspaceToolRow.setActive('draw');
                mainTabRow.open('draw');
                updateMainTabVisibility();
                brushTabRow.open('penBrush');
            }
            if (comboStr === 'e') {
                event.preventDefault();
                klCanvasWorkspace.setMode('draw');
                toolspaceToolRow.setActive('draw');
                mainTabRow.open('draw');
                updateMainTabVisibility();
                brushTabRow.open('eraserBrush');
            }
            if (comboStr === 'z') {
                event.preventDefault();
                klCanvasWorkspace.setMode('draw');
                toolspaceToolRow.setActive('draw');
                mainTabRow.open('draw');
                updateMainTabVisibility();
                brushTabRow.open('pixelBrush');
            }
            if (comboStr === 'a') {
                event.preventDefault();
                klCanvasWorkspace.setMode('draw');
                toolspaceToolRow.setActive('draw');
                mainTabRow.open('draw');
                updateMainTabVisibility();
                brushTabRow.open('chemyBrush');
            }
            if (comboStr === 'x') {
                event.preventDefault();
                klCanvasWorkspace.setMode('draw');
                toolspaceToolRow.setActive('draw');
                mainTabRow.open('draw');
                updateMainTabVisibility();
                brushTabRow.open('smudgeBrush');
            }
            if (comboStr === 'b') {
                event.preventDefault();
                klCanvasWorkspace.setMode('draw');
                toolspaceToolRow.setActive('draw');
                mainTabRow.open('draw');
                updateMainTabVisibility();
                brushTabRow.open('sketchyBrush');
            }
            if (comboStr === 'f') {
                event.preventDefault();
                klCanvasWorkspace.setMode('draw');
                toolspaceToolRow.setActive('draw');
                mainTabRow.open('draw');
                updateMainTabVisibility();
                brushTabRow.open('blendBrush');
            }
            if (comboStr === 'g') {
                event.preventDefault();
                klCanvasWorkspace.setMode('fill');
                toolspaceToolRow.setActive('fill');
                mainTabRow.open('fill');
                updateMainTabVisibility();
            }
            if (comboStr === 't') {
                event.preventDefault();
                klCanvasWorkspace.setMode('text');
                toolspaceToolRow.setActive('text');
                mainTabRow.open('text');
                updateMainTabVisibility();
            }
            if (comboStr === 'u') {
                event.preventDefault();
                klCanvasWorkspace.setMode('shape');
                toolspaceToolRow.setActive('shape');
                mainTabRow.open('shape');
                updateMainTabVisibility();
            }
            if (comboStr === 'x') {
                event.preventDefault();
                klColorSlider.swapColors();
            }
        },
        onUp: function(keyStr, event) {
        }
    });
    /**
     *
     * @param importedImage - convertedPsd | {type: 'image', width: number, height: number, canvas: image | canvas}
     * @param filename - string e.g. 'drawing.psd'
     * @param optionStr? - 'default' | 'layer' | 'image'
     */ function importFinishedLoading(importedImage, filename, optionStr) {
        if (!importedImage || isNaN(importedImage.width) || isNaN(importedImage.height) || importedImage.width <= 0 || importedImage.height <= 0) {
            _kl.KL.popup({
                target: klRootEl,
                type: "error",
                message: _language.LANG('import-broken-file'),
                buttons: [
                    "Ok"
                ]
            });
            return;
        }
        function getResizedDimensions(width, height) {
            let w = parseInt(width);
            let h = parseInt(height);
            if (w > klMaxCanvasSize) {
                h = klMaxCanvasSize / w * h;
                w = klMaxCanvasSize;
            }
            if (h > klMaxCanvasSize) {
                w = klMaxCanvasSize / h * w;
                h = klMaxCanvasSize;
            }
            w = parseInt('' + w);
            h = parseInt('' + h);
            return {
                width: w,
                height: h
            };
        }
        function importAsImage(canvas) {
            let resizedDimensions = getResizedDimensions(canvas.width, canvas.height);
            //resize first
            let tempCanvas = _bb.BB.canvas(canvas.width, canvas.height);
            let tempCanvasCtx = tempCanvas.getContext('2d');
            tempCanvasCtx.drawImage(canvas, 0, 0);
            _bb.BB.resizeCanvas(tempCanvas, resizedDimensions.width, resizedDimensions.height);
            klCanvas.reset({
                width: resizedDimensions.width,
                height: resizedDimensions.height,
                image: tempCanvas,
                layerName: filename
            });
            layerManager.update(0);
            setCurrentLayer(klCanvas.getLayer(0));
            klCanvasWorkspace.resetView();
            handUi.update(klCanvasWorkspace.getScale(), klCanvasWorkspace.getAngleDeg());
            isFirstImage = false;
        }
        /**
         *
         * @param convertedPsdObj - if flattened then without layers
         * @param cropObj? - {x: number, y: number, width: number, height: number}
         */ function importAsImagePsd(convertedPsdObj, cropObj1) {
            // crop
            function crop(targetCanvas, cropCanvas, cropObj) {
                cropCanvas.width = cropCanvas.width;
                cropCanvas.getContext('2d').drawImage(targetCanvas, -cropObj.x, -cropObj.y);
                targetCanvas.width = cropObj.width;
                targetCanvas.height = cropObj.height;
                targetCanvas.getContext('2d').drawImage(cropCanvas, 0, 0);
            }
            if (cropObj1 && (cropObj1.width !== convertedPsdObj.width || cropObj1.height !== convertedPsdObj.height)) {
                let cropCanvas = _bb.BB.canvas(cropObj1.width, cropObj1.height);
                convertedPsdObj.width = cropObj1.width;
                convertedPsdObj.height = cropObj1.height;
                if (!convertedPsdObj.layers) crop(convertedPsdObj.canvas, cropCanvas, cropObj1);
                if (convertedPsdObj.layers) for(let i = 0; i < convertedPsdObj.layers.length; i++){
                    let item = convertedPsdObj.layers[i];
                    crop(item.image, cropCanvas, cropObj1);
                }
            }
            // resize
            let resizedDimensions = getResizedDimensions(convertedPsdObj.width, convertedPsdObj.height);
            convertedPsdObj.width = resizedDimensions.width;
            convertedPsdObj.height = resizedDimensions.height;
            if (!convertedPsdObj.layers) _bb.BB.resizeCanvas(convertedPsdObj.canvas, convertedPsdObj.width, convertedPsdObj.height);
            if (convertedPsdObj.layers) for(let i = 0; i < convertedPsdObj.layers.length; i++){
                let item = convertedPsdObj.layers[i];
                _bb.BB.resizeCanvas(item.image, convertedPsdObj.width, convertedPsdObj.height);
            }
            let layerIndex;
            if (convertedPsdObj.layers) layerIndex = klCanvas.reset({
                width: convertedPsdObj.width,
                height: convertedPsdObj.height,
                layers: convertedPsdObj.layers
            });
            else layerIndex = klCanvas.reset({
                width: convertedPsdObj.width,
                height: convertedPsdObj.height,
                image: convertedPsdObj.canvas
            });
            layerManager.update(layerIndex);
            setCurrentLayer(klCanvas.getLayer(layerIndex));
            klCanvasWorkspace.resetView();
            handUi.update(klCanvasWorkspace.getScale(), klCanvasWorkspace.getAngleDeg());
            isFirstImage = false;
        }
        function importAsLayer(canvas) {
            _kl.KL.showImportAsLayerDialog({
                target: klRootEl,
                klCanvas: klCanvas,
                importImage: canvas,
                callback: function(transformObj, isPixelated) {
                    if (!transformObj) return;
                    _klHistory.klHistory.pause(true);
                    klCanvas.addLayer();
                    let layers = klCanvas.getLayers();
                    let activeLayerIndex = layers.length - 1;
                    if (filename) klCanvas.renameLayer(activeLayerIndex, filename);
                    let activeLayerContext = klCanvas.getLayerContext(activeLayerIndex);
                    _bb.BB.drawTransformedImageWithBounds(activeLayerContext, canvas, transformObj, null, isPixelated);
                    setCurrentLayer(klCanvas.getLayer(activeLayerIndex));
                    layerManager.update(activeLayerIndex);
                    _klHistory.klHistory.pause(false);
                    _klHistory.klHistory.push({
                        tool: [
                            "misc"
                        ],
                        action: "importImage",
                        params: [
                            _bb.BB.copyCanvas(activeLayerContext.canvas),
                            filename
                        ]
                    });
                }
            });
        }
        if (optionStr === 'default' || !optionStr) _kl.KL.showImportImageDialog({
            image: importedImage,
            target: klRootEl,
            maxSize: klMaxCanvasSize,
            callback: function(res) {
                if (res.type === 'as-image') importAsImage(res.image);
                else if (res.type === 'as-image-psd') importAsImagePsd(res.image, res.cropObj);
                else if (res.type === 'as-layer') importAsLayer(res.image);
                else res.type;
            }
        });
        if (optionStr === 'layer') importAsLayer(importedImage.canvas);
        if (optionStr === 'image') {
            if (importedImage.type === 'psd') importAsImagePsd(importedImage);
            else importAsImage(importedImage.canvas);
        }
    }
    function onPaste(e1) {
        if (_kl.KL.dialogCounter.get() > 0) return;
        function retrieveImageFromClipboardAsBlob(pasteEvent, callback) {
            if (pasteEvent.clipboardData == false) {
                if (typeof callback == "function") callback(undefined);
            }
            let items = pasteEvent.clipboardData.items;
            if (items == undefined) {
                if (typeof callback == "function") callback(undefined);
            } else for(let i = 0; i < items.length; i++){
                if (items[i].type.indexOf("image") == -1) continue;
                let blob = items[i].getAsFile();
                if (typeof callback == "function") callback(blob);
            }
        }
        e1.stopPropagation();
        e1.preventDefault();
        if (e1.clipboardData.files[0]) retrieveImageFromClipboardAsBlob(e1, function(imageBlob) {
            // If there's an image, display it in the canvas
            if (imageBlob) {
                let img = new Image();
                img.onload = function() {
                    importFinishedLoading({
                        type: 'image',
                        width: img.width,
                        height: img.height,
                        canvas: img
                    }, null, 'default');
                };
                let URLObj = window.URL || window.webkitURL;
                img.src = URLObj.createObjectURL(imageBlob);
            }
        });
        else if (e1.clipboardData.items[0]) e1.clipboardData.items[0].getAsString(function(pasteStr) {
            pasteStr = pasteStr.trim();
            if (pasteStr.match(/^https?/)) {
                // url
                let img = new Image();
                img.onload = function() {
                    importFinishedLoading({
                        type: 'image',
                        width: img.width,
                        height: img.height,
                        canvas: img
                    }, null, 'default');
                };
                img.onerror = function(e) {
                    console.log('error loading', e);
                };
                img.crossOrigin = 'Anonymous';
                img.src = pasteStr;
            } else if (pasteStr.match(/^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/)) {
                // url
                let rgbObj = _bb.BB.ColorConverter.hexToRGB(pasteStr.replace('#', ''));
                brushSettingService.setColor(rgbObj);
            }
        });
    }
    function handleFileSelect(files, optionStr) {
        function showWarningPsdFlattened() {
            _kl.KL.popup({
                target: klRootEl,
                type: "warning",
                message: _language.LANG('import-psd-unsupported') + "<br /><br />",
                buttons: [
                    "Ok"
                ]
            });
        }
        let hasUnsupportedFile = false;
        for(let i = 0, file; file = files[i]; i++){
            let extension = file.name.split(".");
            extension = extension[extension.length - 1].toLowerCase();
            if (extension === "psd") (function(f1) {
                let loaderSizeBytes = 26214400; // 25mb
                let maxSizeBytes = 1073741824; // 1gb
                let maxResolution = 4096;
                if (f1.size >= maxSizeBytes) {
                    _kl.KL.popup({
                        target: klRootEl,
                        type: "error",
                        message: "File too big. Unable to import.<br /><br />",
                        buttons: [
                            "Ok"
                        ]
                    });
                    return;
                }
                let doShowLoader = files.length === 1 && f1.size >= loaderSizeBytes;
                let loaderIsOpen = true;
                let closeLoader;
                if (doShowLoader) _kl.KL.popup({
                    target: klRootEl,
                    message: _language.LANG('import-opening'),
                    callback: function(result) {
                        loaderIsOpen = false;
                        closeLoader = null;
                    },
                    closefunc: function(f) {
                        closeLoader = f;
                    }
                });
                let reader = new FileReader();
                reader.onload = function(readerResult) {
                    _kl.KL.loadAgPsd().then(function(agPsdLazy) {
                        if (doShowLoader && !loaderIsOpen) return;
                        try {
                            let psd;
                            // first pass, only read metadata
                            psd = agPsdLazy.readPsd(readerResult.target.result, {
                                skipLayerImageData: true,
                                skipThumbnail: true,
                                skipCompositeImageData: true
                            });
                            if (psd.width > maxResolution || psd.height > maxResolution) {
                                if (closeLoader) closeLoader();
                                _kl.KL.popup({
                                    target: klRootEl,
                                    type: "error",
                                    //message: "Image exceeds maximum dimensions of " + maxResolution + " x " + maxResolution + " pixels. Unable to import."
                                    message: _language.LANG('import-psd-too-large').replace(/{x}/g, '' + maxResolution) + "<br /><br />" + _language.LANG('import-psd-size') + ": " + psd.width + " x " + psd.height + ' pixels' + "<br /><br />",
                                    buttons: [
                                        "Ok"
                                    ]
                                });
                                return;
                            }
                            // second pass, now load actual data.
                            psd = null;
                            try {
                                psd = agPsdLazy.readPsd(readerResult.target.result);
                            } catch (e) {
                            //console.log('failed regular psd import', e);
                            }
                            if (psd) {
                                //console.log('psd', psd);
                                let convertedPsd = _kl.KL.PSD.readPsd(psd);
                                //console.log('converted', convertedPsd);
                                if (optionStr === 'image' && convertedPsd.error) showWarningPsdFlattened();
                                if (closeLoader) closeLoader();
                                importFinishedLoading(convertedPsd, f1.name, optionStr);
                            } else {
                                psd = agPsdLazy.readPsd(readerResult.target.result, {
                                    skipLayerImageData: true,
                                    skipThumbnail: true
                                });
                                if (optionStr === 'image') showWarningPsdFlattened();
                                if (closeLoader) closeLoader();
                                importFinishedLoading({
                                    type: 'psd',
                                    width: psd.width,
                                    height: psd.height,
                                    canvas: psd.canvas,
                                    error: true
                                }, f1.name, optionStr);
                            }
                        } catch (e) {
                            if (closeLoader) closeLoader();
                            _kl.KL.popup({
                                target: klRootEl,
                                type: "error",
                                message: "Failed to load PSD.<br /><br />",
                                buttons: [
                                    "Ok"
                                ]
                            });
                        }
                    }).catch(()=>{
                        closeLoader();
                        alert('Error: failed to load PSD library');
                    });
                };
                reader.readAsArrayBuffer(f1);
            })(file);
            else if (file.type.match('image.*')) (function(f) {
                window.URL = window.URL || window.webkitURL;
                let url = window.URL.createObjectURL(f);
                let im = new Image();
                im.src = url;
                _bb.BB.loadImage(im, function() {
                    importFinishedLoading({
                        type: 'image',
                        width: im.width,
                        height: im.height,
                        canvas: im
                    }, f.name, optionStr);
                });
            })(file);
            else hasUnsupportedFile = true;
        }
        if (hasUnsupportedFile) _kl.KL.popup({
            target: klRootEl,
            message: _language.LANG('import-unsupported-file'),
            type: 'error',
            buttons: [
                'OK'
            ]
        });
    }
    if (!pOptions.embed) {
        new _kl.KL.KlImageDropper({
            target: document.body,
            onDrop: function(files, optionStr) {
                if (_kl.KL.dialogCounter.get() > 0) return;
                handleFileSelect(files, optionStr);
            },
            enabledTest: function() {
                return _kl.KL.dialogCounter.get() === 0;
            }
        });
        _bb.BB.addEventListener(window, 'paste', onPaste, false);
    }
    const brushUiObj = {
    };
    // create brush UIs
    for(let b1 in _kl.KL.brushesUI)if (_kl.KL.brushesUI.hasOwnProperty(b1)) {
        let ui = new _kl.KL.brushesUI[b1].Ui({
            onSizeChange: sizeWatcher,
            onOpacityChange: function(opacity) {
                brushSettingService.emitOpacity(opacity);
            },
            onConfigChange: ()=>{
                brushSettingService.emitSliderConfig({
                    sizeSlider: _kl.KL.brushesUI[currentBrushId].sizeSlider,
                    opacitySlider: _kl.KL.brushesUI[currentBrushId].opacitySlider
                });
            }
        });
        brushUiObj[b1] = ui;
        ui.getElement().style.padding = "10px";
    }
    _bb.BB.css(klRootEl, {
        position: 'absolute',
        left: '0',
        top: '0',
        right: '0',
        bottom: '0'
    });
    let statusOverlay = new _kl.KL.StatusOverlay();
    const toolspace = _bb.BB.el({
    });
    const toolspaceInner = _bb.BB.el({
        parent: toolspace
    });
    toolspace.oncontextmenu = function() {
        return false;
    };
    toolspace.onclick = _bb.BB.handleClick;
    let toolspaceCollapser = new _kl.KL.ToolspaceCollapser({
        onChange: function() {
            updateCollapse();
        }
    });
    function updateCollapse() {
        //collapser
        if (uiWidth < collapseThreshold) {
            toolspaceCollapser.getElement().style.display = 'block';
            toolspaceCollapser.setDirection(uiState);
            if (toolspaceCollapser.isOpen()) {
                if (uiState === 'left') {
                    _bb.BB.css(toolspaceCollapser.getElement(), {
                        left: '271px',
                        right: ''
                    });
                    _bb.BB.css(klCanvasWorkspace.getElement(), {
                        left: '271px'
                    });
                } else {
                    _bb.BB.css(toolspaceCollapser.getElement(), {
                        left: '',
                        right: '271px'
                    });
                    _bb.BB.css(klCanvasWorkspace.getElement(), {
                        left: '0'
                    });
                }
                toolspace.style.display = 'block';
                klCanvasWorkspace.setSize(Math.max(0, uiWidth - toolWidth), uiHeight);
                statusOverlay.setWide(false);
            } else {
                if (uiState === 'left') {
                    _bb.BB.css(toolspaceCollapser.getElement(), {
                        left: '0',
                        right: ''
                    });
                    _bb.BB.css(klCanvasWorkspace.getElement(), {
                        left: '0'
                    });
                } else {
                    _bb.BB.css(toolspaceCollapser.getElement(), {
                        left: '',
                        right: '0'
                    });
                    _bb.BB.css(klCanvasWorkspace.getElement(), {
                        left: '0'
                    });
                }
                toolspace.style.display = 'none';
                klCanvasWorkspace.setSize(Math.max(0, uiWidth), uiHeight);
                statusOverlay.setWide(true);
            }
        } else {
            toolspaceCollapser.getElement().style.display = 'none';
            if (uiState === 'left') _bb.BB.css(klCanvasWorkspace.getElement(), {
                left: '271px'
            });
            else _bb.BB.css(klCanvasWorkspace.getElement(), {
                left: '0'
            });
            toolspace.style.display = 'block';
            klCanvasWorkspace.setSize(Math.max(0, uiWidth - toolWidth), uiHeight);
            statusOverlay.setWide(false);
        }
    }
    updateCollapse();
    function updateUi() {
        if (uiState === 'left') {
            _bb.BB.css(toolspace, {
                left: '0',
                right: '',
                borderLeft: 'none',
                borderRight: '1px solid rgb(135, 135, 135)'
            });
            _bb.BB.css(klCanvasWorkspace.getElement(), {
                left: '271px'
            });
        } else {
            _bb.BB.css(toolspace, {
                left: '',
                right: '0',
                borderLeft: '1px solid rgb(135, 135, 135)',
                borderRight: 'none'
            });
            _bb.BB.css(klCanvasWorkspace.getElement(), {
                left: '0'
            });
        }
        statusOverlay.setUiState(uiState);
        layerPreview.setUiState('' + uiState);
        layerManager.setUiState('' + uiState);
        updateCollapse();
        toolspaceScroller.updateUiState(uiState);
    }
    let overlayToolspace;
    setTimeout(function() {
        overlayToolspace = new _kl.KL.OverlayToolspace({
            enabledTest: function() {
                return _kl.KL.dialogCounter.get() === 0 && !lineSanitizer.getIsDrawing();
            },
            brushSettingService
        });
        klRootEl.appendChild(overlayToolspace.getElement());
    }, 0);
    _bb.BB.append(klRootEl, [
        klCanvasWorkspace.getElement(),
        toolspace,
        toolspaceCollapser.getElement()
    ]);
    _bb.BB.css(toolspace, {
        position: "absolute",
        right: '0',
        top: '0',
        bottom: '0',
        width: toolWidth - 1 + "px",
        overflow: "hidden",
        backgroundColor: "#ddd",
        borderLeft: "1px solid rgb(135, 135, 135)",
        userSelect: 'none',
        touchAction: 'none'
    });
    let toolspaceTopRow;
    if (pOptions.embed) toolspaceTopRow = new _toolspaceTopRow.ToolspaceTopRow({
        onHelp: ()=>{
            _showIframePopup.showIframePopup(pOptions.embed.url + '/help.html', !!pOptions.embed);
        },
        onSubmit: ()=>{
            _kl.KL.popup({
                target: klRootEl,
                message: _language.LANG('submit-prompt'),
                buttons: [
                    _language.LANG('submit'),
                    'Cancel'
                ],
                callback: async (result)=>{
                    if (result !== _language.LANG('submit')) return;
                    let overlay = _bb.BB.el({
                        parent: klRootEl,
                        className: 'upload-overlay',
                        content: '<div class="spinner"></div> ' + _language.LANG('submit-submitting')
                    });
                    pOptions.embed.onSubmit(()=>{
                        pOptions.saveReminder.reset();
                        klRootEl.removeChild(overlay);
                    }, ()=>{
                        klRootEl.removeChild(overlay);
                    });
                }
            });
        },
        onLeftRight: ()=>{
            uiState = uiState === 'left' ? 'right' : 'left';
            updateUi();
        }
    });
    else toolspaceTopRow = new _kl.KL.ToolspaceTopRow({
        logoImg: pOptions.logoImg,
        onLogo: function() {
            _showIframePopup.showIframePopup('./home/', !!pOptions.embed);
        },
        onNew: function() {
            showNewImageDialog();
        },
        onImport: function() {
            fileTab.triggerImport();
        },
        onSave: function() {
            saveToComputer.save();
        },
        onShare: function() {
            shareImage();
        },
        onHelp: function() {
            _showIframePopup.showIframePopup('./help/', !!pOptions.embed);
        }
    });
    _bb.BB.addClassName(toolspaceTopRow.getElement(), 'toolspace-row-shadow');
    toolspaceTopRow.getElement().style.marginBottom = '10px';
    let toolspaceToolRow = new _kl.KL.ToolspaceToolRow({
        onActivate: function(activeStr) {
            if (activeStr === 'draw') klCanvasWorkspace.setMode('draw');
            else if (activeStr === 'hand') klCanvasWorkspace.setMode('hand');
            else if (activeStr === 'fill') klCanvasWorkspace.setMode('fill');
            else if (activeStr === 'text') klCanvasWorkspace.setMode('text');
            else if (activeStr === 'shape') klCanvasWorkspace.setMode('shape');
            else throw new Error('unknown activeStr');
            mainTabRow.open(activeStr);
            updateMainTabVisibility();
            klColorSlider.pickingDone();
        },
        onZoomIn: function() {
            klCanvasWorkspace.zoomByStep(keyListener.isPressed('shift') ? 1 / 8 : 0.5);
        },
        onZoomOut: function() {
            klCanvasWorkspace.zoomByStep(keyListener.isPressed('shift') ? -1 / 8 : -0.5);
        },
        onUndo: function() {
            undoRedoCatchup.undo();
        },
        onRedo: function() {
            undoRedoCatchup.redo();
        }
    });
    toolspaceToolRow.setIsSmall(uiHeight < 540);
    _klHistory.klHistory.addListener(function() {
        toolspaceToolRow.setEnableUndo(_klHistory.klHistory.canUndo());
        toolspaceToolRow.setEnableRedo(_klHistory.klHistory.canRedo());
    });
    _bb.BB.addClassName(toolspaceToolRow.getElement(), 'toolspace-row-shadow');
    let klColorSlider;
    function setCurrentBrush(brushId) {
        if (brushId !== 'eraserBrush') lastNonEraserBrushId = brushId;
        if (klColorSlider) {
            if (brushId === 'eraserBrush') klColorSlider.enable(false);
            else klColorSlider.enable(true);
        }
        currentBrushId = brushId;
        currentBrush = brushUiObj[brushId];
        currentBrush.setColor(currentColor);
        currentBrush.setContext(currentLayerCtx);
        klCanvasWorkspace.setMode('draw');
        toolspaceToolRow.setActive('draw');
        updateMainTabVisibility();
    }
    function setCurrentLayer(layer) {
        currentLayerCtx = layer.context;
        currentBrush.setContext(layer.context);
        layerPreview.setLayer(layer);
    }
    function setBrushColor(p_color) {
        currentColor = p_color;
        currentBrush.setColor(p_color);
        brushSettingService.emitColor(p_color);
        klColorSlider.pickingDone();
    }
    klColorSlider = new _kl.KL.KlColorSlider({
        width: 250,
        height: 30,
        svHeight: 100,
        startValue: new _bb.BB.RGB(0, 0, 0),
        onPick: setBrushColor
    });
    klColorSlider.setHeight(Math.max(163, Math.min(400, uiHeight - 505)));
    klColorSlider.setPickCallback(function(doPick) {
        if (doPick) klCanvasWorkspace.setMode('pick');
        else {
            klCanvasWorkspace.setMode(toolspaceToolRow.getActive());
            updateMainTabVisibility();
        }
    });
    let brushDiv = document.createElement("div");
    let colorDiv = document.createElement("div");
    _bb.BB.css(colorDiv, {
        margin: '10px',
        display: 'flex',
        flexWrap: 'wrap',
        justifyContent: 'space-between',
        alignItems: 'flex-end'
    });
    let toolspaceStabilizerRow = new _kl.KL.ToolspaceStabilizerRow({
        smoothing: 1,
        onSelect: function(v) {
            lineSmoothing.setSmoothing(translateSmoothing(v));
        }
    });
    _bb.BB.append(colorDiv, [
        klColorSlider.getElement(),
        klColorSlider.getOutputElement(),
        toolspaceStabilizerRow.getElement()
    ]);
    let brushTabRow = new _kl.KL.TabRow({
        initialId: 'penBrush',
        useAccent: true,
        tabArr: function() {
            let result = [];
            function createTab(keyStr) {
                return {
                    id: keyStr,
                    image: _kl.KL.brushesUI[keyStr].image,
                    title: _kl.KL.brushesUI[keyStr].tooltip,
                    onOpen: function() {
                        brushUiObj[keyStr].getElement().style.display = 'block';
                        setCurrentBrush(keyStr);
                        klColorSlider.pickingDone();
                        brushSettingService.emitSliderConfig({
                            sizeSlider: _kl.KL.brushesUI[keyStr].sizeSlider,
                            opacitySlider: _kl.KL.brushesUI[keyStr].opacitySlider
                        });
                        sizeWatcher(brushUiObj[keyStr].getSize());
                        brushSettingService.emitOpacity(brushUiObj[keyStr].getOpacity());
                    },
                    onClose: function() {
                        brushUiObj[keyStr].getElement().style.display = 'none';
                    }
                };
            }
            let keyArr = Object.keys(brushUiObj);
            for(let i = 0; i < keyArr.length; i++)result.push(createTab(keyArr[i]));
            return result;
        }()
    });
    for(let b2 in _kl.KL.brushesUI)if (_kl.KL.brushesUI.hasOwnProperty(b2)) brushDiv.appendChild(brushUiObj[b2].getElement());
    const handUi = new _kl.KL.HandUi({
        scale: 1,
        angleDeg: 0,
        onReset: function() {
            klCanvasWorkspace.resetView(true);
            handUi.update(klCanvasWorkspace.getScale(), klCanvasWorkspace.getAngleDeg());
        },
        onFit: function() {
            klCanvasWorkspace.fitView();
            handUi.update(klCanvasWorkspace.getScale(), klCanvasWorkspace.getAngleDeg());
        },
        onAngleChange: function(angleDeg, isRelative) {
            klCanvasWorkspace.setAngle(angleDeg, isRelative);
            handUi.update(klCanvasWorkspace.getScale(), klCanvasWorkspace.getAngleDeg());
        }
    });
    let fillUi = new _kl.KL.FillUi({
        colorSlider: klColorSlider
    });
    let textUi = new _kl.KL.TextUi({
        colorSlider: klColorSlider
    });
    let shapeUi = new _kl.KL.ShapeUi({
        colorSlider: klColorSlider
    });
    let shapeTool = new _kl.KL.ShapeTool({
        onShape: function(isDone, x1, y1, x2, y2, angleRad) {
            let layerIndex = klCanvas.getLayerIndex(currentLayerCtx.canvas);
            let shapeObj = {
                type: shapeUi.getShape(),
                x1: x1,
                y1: y1,
                x2: x2,
                y2: y2,
                angleRad: angleRad,
                isOutwards: shapeUi.getIsOutwards(),
                opacity: shapeUi.getOpacity(),
                isEraser: shapeUi.getIsEraser()
            };
            if (shapeUi.getShape() === 'line') {
                shapeObj.strokeRgb = klColorSlider.getColor();
                shapeObj.lineWidth = shapeUi.getLineWidth();
                shapeObj.isAngleSnap = shapeUi.getIsSnap() || keyListener.isPressed('shift');
            } else {
                shapeObj.isFixedRatio = shapeUi.getIsFixed() || keyListener.isPressed('shift');
                if (shapeUi.getMode() === 'stroke') {
                    shapeObj.strokeRgb = klColorSlider.getColor();
                    shapeObj.lineWidth = shapeUi.getLineWidth();
                } else shapeObj.fillRgb = klColorSlider.getColor();
            }
            if (isDone) {
                klCanvas.setComposite(layerIndex, null);
                klCanvas.drawShape(layerIndex, shapeObj);
            } else klCanvas.setComposite(layerIndex, {
                draw: function(ctx) {
                    _kl.KL.drawShape(ctx, shapeObj);
                }
            });
            klCanvasWorkspace.requestFrame();
        }
    });
    const layerManager = _kl.KL.klLayerManager(klCanvas, function(val) {
        setCurrentLayer(klCanvas.getLayer(val));
        _klHistory.klHistory.push({
            tool: [
                "misc"
            ],
            action: "focusLayer",
            params: [
                val
            ]
        });
    }, klRootEl);
    const layerPreview = new _kl.KL.LayerPreview({
        klRootEl: klRootEl,
        onClick: function() {
            mainTabRow.open('layers');
        }
    });
    layerPreview.setIsVisible(uiHeight >= 579);
    layerPreview.setLayer(klCanvas.getLayer(klCanvas.getLayerIndex(currentLayerCtx.canvas)));
    const filterTab = new _kl.KL.FilterTab(klRootEl, klColorSlider, layerManager, setCurrentLayer, klCanvasWorkspace, handUi, ()=>{
        return currentColor;
    }, ()=>{
        return klMaxCanvasSize;
    }, ()=>{
        return klCanvas;
    }, ()=>{
        return currentLayerCtx;
    }, !!pOptions.embed, statusOverlay);
    const undoRedoCatchup = new _kl.KL.UndoRedoCatchup(brushUiObj, layerPreview, layerManager, handUi, klCanvasWorkspace, ()=>{
        if (!initState) throw new Error('initState not initialized');
        return initState;
    }, ()=>klCanvas
    , ()=>currentLayerCtx
    , (clctx)=>{
        currentLayerCtx = clctx;
    }, ()=>currentBrush
    );
    _klHistory.klHistory.addListener((p)=>{
        undoRedoCatchup.catchup(p);
    });
    function showNewImageDialog() {
        _kl.KL.newImageDialog({
            currentColor: currentColor,
            secondaryColor: klColorSlider.getSecondaryRGB(),
            maxCanvasSize: klMaxCanvasSize,
            canvasWidth: klCanvas.getWidth(),
            canvasHeight: klCanvas.getHeight(),
            workspaceWidth: window.innerWidth < collapseThreshold ? uiWidth : uiWidth - toolWidth,
            workspaceHeight: uiHeight,
            onConfirm: function(width, height, color) {
                klCanvas.reset({
                    width: width,
                    height: height,
                    color: color.a === 1 ? color : null
                });
                layerManager.update(0);
                setCurrentLayer(klCanvas.getLayer(0));
                klCanvasWorkspace.resetView();
                handUi.update(klCanvasWorkspace.getScale(), klCanvasWorkspace.getAngleDeg());
                isFirstImage = false;
            },
            onCancel: function() {
            }
        });
    }
    function shareImage(callback) {
        _bb.BB.shareCanvas({
            canvas: klCanvas.getCompleteCanvas(1),
            fileName: _bb.BB.getDate() + filenameBase + '.png',
            title: _bb.BB.getDate() + filenameBase + '.png',
            callback: callback ? callback : function() {
            }
        });
    }
    const saveToComputer = new _kl.KL.SaveToComputer(pOptions.saveReminder, klRootEl, ()=>exportType
    , ()=>klCanvas
    , filenameBase);
    const fileTab = pOptions.embed ? null : new _kl.KL.FileTab(klRootEl, projectStore, ()=>klCanvas.getProject()
    , exportType, (type)=>{
        exportType = type;
    }, handleFileSelect, ()=>{
        saveToComputer.save();
    }, showNewImageDialog, shareImage, ()=>{
        _kl.KL.imgurUpload(klCanvas, klRootEl, pOptions.saveReminder, pOptions.app && pOptions.app.imgurKey ? pOptions.app.imgurKey : null);
    }, copyToClipboard, pOptions.saveReminder);
    const settingsTab = new _kl.KL.SettingsTab(()=>{
        uiState = uiState === 'left' ? 'right' : 'left';
        updateUi();
        if (!pOptions.embed) _localStorage.LocalStorage.setItem('uiState', uiState);
    }, pOptions.aboutEl);
    mainTabRow = new _kl.KL.TabRow({
        initialId: 'draw',
        tabArr: [
            {
                id: 'draw',
                title: _language.LANG('tool-brush'),
                image: _toolPaintSvgDefault.default,
                onOpen: function() {
                    if (currentBrushId === 'eraserBrush') klColorSlider.enable(false);
                    _bb.BB.append(colorDiv, [
                        klColorSlider.getElement(),
                        klColorSlider.getOutputElement(),
                        toolspaceStabilizerRow.getElement()
                    ]);
                    brushDiv.style.display = 'block';
                },
                onClose: function() {
                    brushDiv.style.display = 'none';
                },
                css: {
                    minWidth: '45px'
                }
            },
            {
                id: 'hand',
                title: _language.LANG('tool-hand'),
                image: _toolHandSvgDefault.default,
                isVisible: false,
                onOpen: function() {
                    handUi.setIsVisible(true);
                },
                onClose: function() {
                    handUi.setIsVisible(false);
                },
                css: {
                    minWidth: '45px'
                }
            },
            {
                id: 'fill',
                title: _language.LANG('tool-paint-bucket'),
                image: _toolFillSvgDefault.default,
                isVisible: false,
                onOpen: function() {
                    klColorSlider.enable(true);
                    fillUi.setIsVisible(true);
                },
                onClose: function() {
                    fillUi.setIsVisible(false);
                },
                css: {
                    minWidth: '45px'
                }
            },
            {
                id: 'text',
                title: _language.LANG('tool-text'),
                image: _toolTextSvgDefault.default,
                isVisible: false,
                onOpen: function() {
                    klColorSlider.enable(true);
                    textUi.setIsVisible(true);
                },
                onClose: function() {
                    textUi.setIsVisible(false);
                },
                css: {
                    minWidth: '45px'
                }
            },
            {
                id: 'shape',
                title: _language.LANG('tool-shape'),
                image: _toolShapeSvgDefault.default,
                isVisible: false,
                onOpen: function() {
                    klColorSlider.enable(true);
                    shapeUi.setIsVisible(true);
                },
                onClose: function() {
                    shapeUi.setIsVisible(false);
                },
                css: {
                    minWidth: '45px'
                }
            },
            {
                id: 'layers',
                title: _language.LANG('tab-layers'),
                image: _tabLayersSvgDefault.default,
                onOpen: function() {
                    layerManager.update();
                    layerManager.style.display = 'block';
                },
                onClose: function() {
                    layerManager.style.display = 'none';
                },
                css: {
                    minWidth: '45px'
                }
            },
            {
                id: 'edit',
                label: _language.LANG('tab-edit'),
                onOpen: function() {
                    filterTab.show();
                },
                onClose: function() {
                    filterTab.hide();
                },
                css: {
                    padding: '0 7px'
                }
            },
            {
                id: 'file',
                label: _language.LANG('tab-file'),
                isVisible: !!fileTab,
                onOpen: function() {
                    if (!fileTab) return;
                    fileTab.getElement().style.display = 'block';
                    fileTab.setIsVisible(true);
                },
                onClose: function() {
                    if (!fileTab) return;
                    fileTab.getElement().style.display = 'none';
                    fileTab.setIsVisible(false);
                },
                css: {
                    padding: '0 7px'
                }
            },
            {
                id: 'settings',
                title: _language.LANG('tab-settings'),
                image: _tabSettingsSvgDefault.default,
                onOpen: function() {
                    settingsTab.getElement().style.display = 'block';
                // settingsTab.setIsVisible(true);
                },
                onClose: function() {
                    settingsTab.getElement().style.display = 'none';
                // settingsTab.setIsVisible(false);
                },
                css: {
                    minWidth: '45px'
                }
            }
        ]
    });
    function updateMainTabVisibility() {
        if (!mainTabRow) return;
        let toolObj = {
            'draw': {
            },
            'hand': {
            },
            'fill': {
            },
            'text': {
            },
            'shape': {
            }
        };
        let activeStr = toolspaceToolRow.getActive();
        let oldTabId = mainTabRow.getOpenedTabId();
        let keysArr = Object.keys(toolObj);
        for(let i = 0; i < keysArr.length; i++)if (activeStr === keysArr[i]) mainTabRow.setIsVisible(keysArr[i], true);
        else {
            mainTabRow.setIsVisible(keysArr[i], false);
            if (oldTabId === keysArr[i]) mainTabRow.open(activeStr);
        }
    }
    function copyToClipboard(showCrop) {
        _kl.KL.clipboardDialog(klRootEl, klCanvas.getCompleteCanvas(1), function(inputObj) {
            if (inputObj.left === 0 && inputObj.right === 0 && inputObj.top === 0 && inputObj.bottom === 0) return;
            //do a crop
            let p = {
                context: currentLayerCtx,
                canvas: klCanvas,
                input: inputObj,
                history: _klHistory.klHistory
            };
            _kl.KL.filterLib.cropExtend.apply(p);
            layerManager.update();
            klCanvasWorkspace.resetView();
            handUi.update(klCanvasWorkspace.getScale(), klCanvasWorkspace.getAngleDeg());
        }, statusOverlay, showCrop);
    }
    const bottomBarWrapper = _bb.BB.el({
        css: {
            width: "270px",
            position: "absolute",
            bottom: '0',
            left: '0'
        }
    });
    if (pOptions.bottomBar) {
        bottomBarWrapper.append(pOptions.bottomBar);
        const observer = new MutationObserver(()=>updateBottomBar()
        );
        observer.observe(toolspaceInner, {
            attributes: true,
            childList: true,
            subtree: true
        });
    }
    function updateBottomBar() {
        if (!pOptions.bottomBar) return;
        const threshold = 617; //590
        const isVisible = threshold < window.innerHeight && toolspaceInner.scrollHeight + 50 < window.innerHeight;
        bottomBarWrapper.style.display = isVisible ? '' : 'none';
    }
    _bb.BB.append(toolspaceInner, [
        layerPreview.getElement(),
        mainTabRow.getElement(),
        brushDiv,
        handUi.getElement(),
        fillUi.getElement(),
        textUi.getElement(),
        shapeUi.getElement(),
        layerManager,
        filterTab.getElement(),
        fileTab ? fileTab.getElement() : null,
        settingsTab.getElement(),
        _bb.BB.el({
            css: {
                height: '10px'
            }
        }),
        bottomBarWrapper ? bottomBarWrapper : null
    ]);
    const toolspaceScroller = new _kl.KL.ToolspaceScroller({
        toolspace,
        uiState
    });
    // --- interface ---
    this.getEl = ()=>{
        return klRootEl;
    };
    this.resize = (w, h)=>{
        // iPad scrolls down when increasing text zoom
        if (window.scrollY > 0) window.scrollTo(0, 0);
        if (uiWidth === Math.max(0, w) && uiHeight === Math.max(0, h)) return;
        uiWidth = Math.max(0, w);
        uiHeight = Math.max(0, h);
        updateCollapse();
        updateBottomBar();
        layerPreview.setIsVisible(uiHeight >= 579);
        klColorSlider.setHeight(Math.max(163, Math.min(400, uiHeight - 505)));
        toolspaceToolRow.setIsSmall(uiHeight < 540);
    };
    this.out = (msg)=>{
        statusOverlay.out(msg);
    };
    this.getPNG = function() {
        return _base64ToBlob.base64ToBlob(klCanvas.getCompleteCanvas(1).toDataURL('image/png'));
    };
    this.getPSD = async function() {
        return await _klCanvasToPsdBlob.klCanvasToPsdBlob(klCanvas);
    };
    this.swapUiLeftRight = ()=>{
        uiState = uiState === 'left' ? 'right' : 'left';
        if (!pOptions.embed) _localStorage.LocalStorage.setItem('uiState', uiState);
        updateUi();
    };
    // --- end interface ---
    this.resize(uiWidth, uiHeight);
    updateUi();
    {
        _bb.BB.addEventListener(window, 'resize', ()=>{
            this.resize(window.innerWidth, window.innerHeight);
        });
        _bb.BB.addEventListener(window, 'orientationchange', ()=>{
            this.resize(window.innerWidth, window.innerHeight);
        });
        // iPad doesn't trigger 'resize' event when using text zoom, although it's resizing the window.
        // Workaround: place a div in the body that fills the window, and use a ResizeObserver
        const windowResizeWatcher = _bb.BB.el({
            parent: document.body,
            css: {
                position: 'fixed',
                left: '0',
                top: '0',
                right: '0',
                bottom: '0',
                pointerEvents: 'none',
                zIndex: '-1',
                userSelect: 'none'
            }
        });
        const observer = new ResizeObserver(()=>this.resize(window.innerWidth, window.innerHeight)
        );
        observer.observe(windowResizeWatcher);
        // prevent ctrl scroll -> zooming page
        _bb.BB.addEventListener(this.getEl(), 'wheel', (event)=>{
            event.preventDefault();
        });
        //maybe prevent zooming on safari mac os - I can't test it
        const prevent = (e)=>{
            e.preventDefault();
        };
        window.addEventListener('gesturestart', prevent);
        window.addEventListener('gesturechange', prevent);
        window.addEventListener('gestureend', prevent);
    }
}

},{"../klecks/kl":"3bnx1","../klecks/history/kl-history":"ai9zE","../bb/bb":"e3nbn","../klecks/ui/modals/show-iframe-popup":"gIAOL","../klecks/ui/tool-tabs/file-tab":"gDKzx","../embed/toolspace-top-row":"dp53m","../klecks/filters/filters-lazy":"kbx93","../klecks/storage/base-64-to-blob":"5MgNM","../klecks/storage/kl-canvas-to-psd-blob":"kSwNg","../language/language":"lvNW4","url:~/src/app/img/ui/tool-paint.svg":"l9lMS","url:~/src/app/img/ui/tool-hand.svg":"dRUNs","url:~/src/app/img/ui/tool-fill.svg":"54jCT","url:~/src/app/img/ui/tool-text.svg":"jRPtM","url:~/src/app/img/ui/tool-shape.svg":"4jh19","url:~/src/app/img/ui/tab-settings.svg":"hJAfW","url:~/src/app/img/ui/tab-layers.svg":"8p84o","../bb/base/local-storage":"iOEIY","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"dp53m":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ToolspaceTopRow", ()=>ToolspaceTopRow
);
/**
 * Topmost row of buttons in toolspace
 *
 * p = { // button click callbacks
 *     onSubmit: function(),
 *     onLeftRight: function(),
 *     onHelp: function()
 * }
 *
 * @param p
 * @constructor
 */ var _bb = require("../bb/bb");
// @ts-ignore
var _uiSwapLrSvg = require("url:~/src/app/img/ui/ui-swap-lr.svg");
var _uiSwapLrSvgDefault = parcelHelpers.interopDefault(_uiSwapLrSvg);
// @ts-ignore
var _helpSvg = require("url:~/src/app/img/ui/help.svg");
var _helpSvgDefault = parcelHelpers.interopDefault(_helpSvg);
var _language = require("../language/language");
class ToolspaceTopRow {
    constructor(p1){
        let div = document.createElement('div');
        this.el = div;
        _bb.BB.css(div, {
            height: '36px',
            //background: '#f00',
            display: 'flex',
            backgroundImage: 'linear-gradient(to top, rgba(255, 255, 255, 0) 20%, rgba(255, 255, 255, 0.6) 100%)'
        });
        function createButton(p) {
            let padding = 6 + (p.extraPadding ? p.extraPadding : 0);
            let result = _bb.BB.el({
                className: 'toolspace-row-button nohighlight',
                title: p.title,
                onClick: p.onClick,
                css: {
                    padding: p.content ? '' : p.contain ? padding + 'px 0' : ''
                }
            });
            if (p.content) result.appendChild(p.content);
            else {
                let im = _bb.BB.el({
                    css: {
                        backgroundImage: 'url(\'' + p.image + '\')',
                        backgroundRepeat: 'no-repeat',
                        backgroundPosition: 'center',
                        backgroundSize: p.contain ? 'contain' : '',
                        //filter: 'grayscale(1)',
                        height: '100%'
                    }
                });
                im.style.pointerEvents = 'none';
                result.appendChild(im);
            }
            result.pointerListener = new _bb.BB.PointerListener({
                target: result,
                onEnterLeave: function(isOver) {
                    if (isOver) _bb.BB.addClassName(result, 'toolspace-row-button-hover');
                    else _bb.BB.removeClassName(result, 'toolspace-row-button-hover');
                }
            });
            return result;
        }
        let submitButton = createButton({
            onClick: p1.onSubmit,
            title: _language.LANG('submit-title'),
            content: _bb.BB.el({
                content: _language.LANG('submit'),
                className: 'toolspace-row-button__submit',
                css: {
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    width: '100%',
                    height: '100%'
                }
            }),
            contain: true
        });
        submitButton.style.width = '45px';
        let helpButton = createButton({
            onClick: p1.onHelp,
            title: _language.LANG('help'),
            image: _helpSvgDefault.default,
            contain: true
        });
        let leftRightButton = createButton({
            onClick: p1.onLeftRight,
            title: _language.LANG('switch-ui-left-right'),
            image: _uiSwapLrSvgDefault.default,
            contain: true
        });
        div.appendChild(submitButton);
        div.appendChild(leftRightButton);
        div.appendChild(helpButton);
    }
    getElement() {
        return this.el;
    }
}

},{"../bb/bb":"e3nbn","url:~/src/app/img/ui/ui-swap-lr.svg":"9h8BU","url:~/src/app/img/ui/help.svg":"qgQhh","../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kbx93":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "importFilters", ()=>importFilters
);
var _filters = require("./filters");
var _glBrightnessContrast = require("./gl-brightness-contrast");
var _cropExtend = require("./crop-extend");
var _glCurves = require("./gl-curves");
var _flip = require("./flip");
var _glHueSaturation = require("./gl-hue-saturation");
var _invert = require("./invert");
var _glPerspective = require("./gl-perspective");
var _resize = require("./resize");
var _rotate = require("./rotate");
var _glTiltShift = require("./gl-tilt-shift");
var _transform = require("./transform");
var _glBlur = require("./gl-blur");
var _glUnsharpMask = require("./gl-unsharp-mask");
var _toAlpha = require("./to-alpha");
let embed;
function importFilter(libObj, moduleObj) {
    if (moduleObj.getDialog) libObj.getDialog = moduleObj.getDialog;
    libObj.apply = moduleObj.apply;
}
function importFilters(isEmbed) {
    if (_filters.filterLibStatus.isLoaded) return;
    embed = isEmbed;
    importFilter(_filters.filterLib.glBrightnessContrast, _glBrightnessContrast.glBrightnessContrast);
    importFilter(_filters.filterLib.cropExtend, _cropExtend.cropExtend);
    importFilter(_filters.filterLib.glCurves, _glCurves.glCurves);
    importFilter(_filters.filterLib.flip, _flip.flip);
    importFilter(_filters.filterLib.glHueSaturation, _glHueSaturation.glHueSaturation);
    importFilter(_filters.filterLib.invert, _invert.invert);
    importFilter(_filters.filterLib.glPerspective, _glPerspective.glPerspective);
    importFilter(_filters.filterLib.resize, _resize.resize);
    importFilter(_filters.filterLib.rotate, _rotate.rotate);
    importFilter(_filters.filterLib.glTiltShift, _glTiltShift.glTiltShift);
    importFilter(_filters.filterLib.transform, _transform.transform);
    importFilter(_filters.filterLib.glBlur, _glBlur.glBlur);
    importFilter(_filters.filterLib.glUnsharpMask, _glUnsharpMask.glUnsharpMask);
    importFilter(_filters.filterLib.toAlpha, _toAlpha.toAlpha);
    _filters.filterLibStatus.isLoaded = true;
}

},{"./filters":"d4Ymd","./gl-brightness-contrast":"eQjYd","./crop-extend":"80GTF","./gl-curves":"au1MQ","./flip":"lS7aV","./gl-hue-saturation":"etu1E","./invert":"4DqUn","./gl-perspective":"im35R","./resize":"3HpJn","./rotate":"hbNRe","./gl-tilt-shift":"9vTqv","./transform":"fRAhD","./gl-blur":"8NpO2","./gl-unsharp-mask":"dNJzT","./to-alpha":"83zR8","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"eQjYd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "glBrightnessContrast", ()=>glBrightnessContrast
);
var _bb = require("../../bb/bb");
var _klSlider = require("../ui/base-components/kl-slider");
var _filtersConsts = require("./filters-consts");
var _canvasPreview = require("../canvas-ui/canvas-preview");
var _sharedGlFx = require("./shared-gl-fx");
var _language = require("../../language/language");
const glBrightnessContrast = {
    getDialog (params) {
        let div = document.createElement("div");
        let result = {
            element: div
        };
        let context = params.context; //2d context of canvas
        let canvas = params.canvas; //the klCanvas and dom element
        if (!context || !canvas) return false;
        let layers = canvas.getLayers();
        let selectedLayerIndex = canvas.getLayerIndex(context.canvas);
        let fit = _bb.BB.fitInto(context.canvas.width, context.canvas.height, 280, 200, 1);
        let w = parseInt('' + fit.width), h = parseInt('' + fit.height);
        let tempCanvas = _bb.BB.canvas(w, h);
        {
            const ctx = tempCanvas.getContext("2d");
            ctx.save();
            if (tempCanvas.width > context.canvas.width) ctx.imageSmoothingEnabled = false;
            ctx.drawImage(context.canvas, 0, 0, w, h);
            ctx.restore();
        }
        function finishInit() {
            let brightness = 0, contrast = 0;
            div.innerHTML = _language.LANG('filter-bright-contrast-description') + "<br/><br/>";
            let glCanvas = _sharedGlFx.getSharedFx();
            if (!glCanvas) return; // todo throw?
            let texture = glCanvas.texture(tempCanvas);
            glCanvas.draw(texture).update(); // update glCanvas size
            let brightnessSlider = new _klSlider.KlSlider({
                label: _language.LANG('filter-bright-contrast-brightness'),
                width: 300,
                height: 30,
                min: 0,
                max: 100,
                initValue: (brightness + 1) * 50,
                eventResMs: _filtersConsts.eventResMs,
                onChange: function(val) {
                    brightness = val / 50 - 1;
                    glCanvas.draw(texture).brightnessContrast(brightness, contrast).update();
                    klCanvasPreview.render();
                }
            });
            let contrastSlider = new _klSlider.KlSlider({
                label: _language.LANG('filter-bright-contrast-contrast'),
                width: 300,
                height: 30,
                min: 0,
                max: 100,
                initValue: (contrast + 1) * 50,
                eventResMs: _filtersConsts.eventResMs,
                onChange: function(val) {
                    contrast = val / 50 - 1;
                    glCanvas.draw(texture).brightnessContrast(brightness, contrast).update();
                    klCanvasPreview.render();
                }
            });
            brightnessSlider.getElement().style.marginBottom = "10px";
            div.appendChild(brightnessSlider.getElement());
            div.appendChild(contrastSlider.getElement());
            let previewWrapper = document.createElement("div");
            _bb.BB.css(previewWrapper, {
                width: "340px",
                marginLeft: "-20px",
                height: "220px",
                backgroundColor: "#9e9e9e",
                marginTop: "10px",
                boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
                overflow: "hidden",
                position: "relative",
                userSelect: 'none',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                colorScheme: 'only light'
            });
            let previewLayerArr = [];
            for(let i = 0; i < layers.length; i++)previewLayerArr.push({
                image: i === selectedLayerIndex ? glCanvas : layers[i].context.canvas,
                opacity: layers[i].opacity,
                mixModeStr: layers[i].mixModeStr
            });
            let klCanvasPreview = new _canvasPreview.KlCanvasPreview({
                width: parseInt('' + w),
                height: parseInt('' + h),
                layers: previewLayerArr
            });
            let previewInnerWrapper = _bb.BB.el({
                css: {
                    position: 'relative',
                    boxShadow: '0 0 5px rgba(0,0,0,0.5)',
                    width: parseInt('' + w) + 'px',
                    height: parseInt('' + h) + 'px'
                }
            });
            previewInnerWrapper.appendChild(klCanvasPreview.getElement());
            previewWrapper.appendChild(previewInnerWrapper);
            div.appendChild(previewWrapper);
            try {
                glCanvas.draw(texture).brightnessContrast(brightness, contrast).update();
                klCanvasPreview.render();
            } catch (e) {
                div.errorCallback(e);
            }
            result.destroy = ()=>{
                brightnessSlider.destroy();
                contrastSlider.destroy();
                texture.destroy();
            };
            result.getInput = function() {
                result.destroy();
                return {
                    brightness: brightness,
                    contrast: contrast
                };
            };
        }
        setTimeout(finishInit, 1); // the canvas isn't ready for some reason
        return result;
    },
    apply (params) {
        let context = params.context;
        let brightness = params.input.brightness;
        let contrast = params.input.contrast;
        let history = params.history;
        if (!context || brightness === null || contrast === null || !history) return false;
        history.pause(true);
        let glCanvas = _sharedGlFx.getSharedFx();
        if (!glCanvas) return false; // todo more specific error?
        let texture = glCanvas.texture(context.canvas);
        glCanvas.draw(texture).brightnessContrast(brightness, contrast).update();
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(glCanvas, 0, 0);
        texture.destroy();
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "glBrightnessContrast"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"e3nbn","../ui/base-components/kl-slider":"1Vedp","./filters-consts":"hTXbX","../canvas-ui/canvas-preview":"9a0UP","./shared-gl-fx":"4XYAu","../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hTXbX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "eventResMs", ()=>eventResMs
);
const eventResMs = 60;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4XYAu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getSharedFx", ()=>getSharedFx
);
var _glfx = require("../../../script-vendor/glfx");
let fxCanvas = null;
try {
    fxCanvas = _glfx.fx.canvas();
} catch (e) {
}
function getSharedFx() {
    if (!fxCanvas || fxCanvas._.gl.isContextLost()) try {
        fxCanvas = _glfx.fx.canvas();
    } catch (e) {
    }
    return fxCanvas;
}

},{"../../../script-vendor/glfx":"anrul","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"anrul":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fx", ()=>fx
);
const fx = function() {
    let exports = {
    };
    (function() {
        // Uploads a 2x2 floating-point texture where one pixel is 2 and the other
        // three pixels are 0. Linear filtering is only supported if a sample taken
        // from the center of that texture is (2 + 0 + 0 + 0) / 4 = 0.5.
        function supportsOESTextureFloatLinear(gl) {
            // Need floating point textures in the first place
            if (!gl.getExtension('OES_texture_float')) return false;
            // Create a render target
            let framebuffer = gl.createFramebuffer();
            let byteTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, byteTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, byteTexture, 0);
            // Create a simple floating-point texture with value of 0.5 in the center
            let rgba = [
                2,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ];
            let floatTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, floatTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, gl.FLOAT, new Float32Array(rgba));
            // Create the test shader
            let program = gl.createProgram();
            let vertexShader = gl.createShader(gl.VERTEX_SHADER);
            let fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(vertexShader, '\
      attribute vec2 vertex;\
      void main() {\
        gl_Position = vec4(vertex, 0.0, 1.0);\
      }\
    ');
            gl.shaderSource(fragmentShader, '\
      uniform sampler2D texture;\
      void main() {\
        gl_FragColor = texture2D(texture, vec2(0.5));\
      }\
    ');
            gl.compileShader(vertexShader);
            gl.compileShader(fragmentShader);
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            // Create a buffer containing a single point
            let buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                0,
                0
            ]), gl.STREAM_DRAW);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
            // Render the point and read back the rendered pixel
            let pixel = new Uint8Array(4);
            gl.useProgram(program);
            gl.viewport(0, 0, 1, 1);
            gl.bindTexture(gl.TEXTURE_2D, floatTexture);
            gl.drawArrays(gl.POINTS, 0, 1);
            gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
            // The center sample will only have a value of 0.5 if linear filtering works
            return pixel[0] === 127 || pixel[0] === 128;
        }
        // The constructor for the returned extension object
        function OESTextureFloatLinear() {
        }
        // Cache the extension so it's specific to each context like extensions should be
        function getOESTextureFloatLinear(gl) {
            if (gl.$OES_texture_float_linear$ === void 0) Object.defineProperty(gl, '$OES_texture_float_linear$', {
                enumerable: false,
                configurable: false,
                writable: false,
                value: new OESTextureFloatLinear()
            });
            return gl.$OES_texture_float_linear$;
        }
        // This replaces the real getExtension()
        function getExtension(name) {
            return name === 'OES_texture_float_linear' ? getOESTextureFloatLinear(this) : oldGetExtension.call(this, name);
        }
        // This replaces the real getSupportedExtensions()
        function getSupportedExtensions() {
            let extensions = oldGetSupportedExtensions.call(this);
            if (extensions.indexOf('OES_texture_float_linear') === -1) extensions.push('OES_texture_float_linear');
            return extensions;
        }
        // Get a WebGL context
        try {
            let gl = document.createElement('canvas').getContext('experimental-webgl');
        } catch (e) {
        }
        // Don't install the polyfill if the browser already supports it or doesn't have WebGL
        if (!gl1 || gl1.getSupportedExtensions().indexOf('OES_texture_float_linear') !== -1) return;
        // Install the polyfill if linear filtering works with floating-point textures
        let oldGetExtension;
        let oldGetSupportedExtensions;
        if (supportsOESTextureFloatLinear(gl1)) {
            oldGetExtension = WebGLRenderingContext.prototype.getExtension;
            oldGetSupportedExtensions = WebGLRenderingContext.prototype.getSupportedExtensions;
            WebGLRenderingContext.prototype.getExtension = getExtension;
            WebGLRenderingContext.prototype.getSupportedExtensions = getSupportedExtensions;
        }
    })();
    // src/core\canvas.script
    var gl1;
    function clamp(lo, value, hi) {
        return Math.max(lo, Math.min(value, hi));
    }
    function wrapTexture(texture) {
        return {
            _: texture,
            loadContentsOf: function(element) {
                // Make sure that we're using the correct global WebGL context
                gl1 = this._.gl;
                this._.loadContentsOf(element);
            },
            destroy: function() {
                // Make sure that we're using the correct global WebGL context
                gl1 = this._.gl;
                this._.destroy();
            }
        };
    }
    function texture1(element) {
        return wrapTexture(Texture1.fromElement(element));
    }
    function initialize(width, height) {
        let type = gl1.UNSIGNED_BYTE;
        // Go for floating point buffer textures if we can, it'll make the bokeh
        // filter look a lot better. Note that on Windows, ANGLE does not let you
        // render to a floating-point texture when linear filtering is enabled.
        // See http://crbug.com/172278 for more information.
        if (gl1.getExtension('OES_texture_float') && gl1.getExtension('OES_texture_float_linear')) {
            let testTexture = new Texture1(100, 100, gl1.RGBA, gl1.FLOAT);
            try {
                // Only use gl.FLOAT if we can render to it
                testTexture.drawTo(function() {
                    type = gl1.FLOAT;
                });
            } catch (e) {
            }
            testTexture.destroy();
        }
        if (this._.texture) this._.texture.destroy();
        if (this._.spareTexture) this._.spareTexture.destroy();
        this.width = width;
        this.height = height;
        this._.texture = new Texture1(width, height, gl1.RGBA, type);
        this._.spareTexture = new Texture1(width, height, gl1.RGBA, type);
        this._.extraTexture = this._.extraTexture || new Texture1(0, 0, gl1.RGBA, type);
        this._.flippedShader = this._.flippedShader || new Shader1(null, '\
        uniform sampler2D texture;\
        varying vec2 texCoord;\
        void main() {\
            gl_FragColor = texture2D(texture, vec2(texCoord.x, 1.0 - texCoord.y));\
        }\
    ', 'flippedShader');
        this._.isInitialized = true;
    }
    /*
   Draw a texture to the canvas, with an optional width and height to scale to.
   If no width and height are given then the original texture width and height
   are used.
*/ function draw(texture, width, height) {
        if (!this._.isInitialized || texture._.width != this.width || texture._.height != this.height) initialize.call(this, width ? width : texture._.width, height ? height : texture._.height);
        texture._.use();
        this._.texture.drawTo(function() {
            Shader1.getDefaultShader().drawRect();
        });
        return this;
    }
    function update() {
        this._.texture.use();
        this._.flippedShader.drawRect();
        return this;
    }
    function simpleShader(shader, uniforms, textureIn, textureOut) {
        (textureIn || this._.texture).use();
        this._.spareTexture.drawTo(function() {
            shader.uniforms(uniforms).drawRect();
        });
        this._.spareTexture.swapWith(textureOut || this._.texture);
    }
    function replace(node) {
        node.parentNode.insertBefore(this, node);
        node.parentNode.removeChild(node);
        return this;
    }
    function contents() {
        let texture = new Texture1(this._.texture.width, this._.texture.height, gl1.RGBA, gl1.UNSIGNED_BYTE);
        this._.texture.use();
        texture.drawTo(function() {
            Shader1.getDefaultShader().drawRect();
        });
        return wrapTexture(texture);
    }
    /*
   Get a Uint8 array of pixel values: [r, g, b, a, r, g, b, a, ...]
   Length of the array will be width * height * 4.
*/ function getPixelArray() {
        let w = this._.texture.width;
        let h = this._.texture.height;
        let array = new Uint8Array(w * h * 4);
        this._.texture.drawTo(function() {
            gl1.readPixels(0, 0, w, h, gl1.RGBA, gl1.UNSIGNED_BYTE, array);
        });
        return array;
    }
    function wrap(func) {
        return function() {
            // Make sure that we're using the correct global WebGL context
            gl1 = this._.gl;
            // Now that the context has been switched, we can call the wrapped function
            return func.apply(this, arguments);
        };
    }
    exports.canvas = function() {
        let canvas = document.createElement('canvas');
        try {
            gl1 = canvas.getContext('experimental-webgl', {
                premultipliedAlpha: false
            });
        } catch (e) {
            gl1 = null;
        }
        if (!gl1) throw 'This browser does not support WebGL';
        canvas._ = {
            gl: gl1,
            isInitialized: false,
            texture: null,
            spareTexture: null,
            flippedShader: null
        };
        // Core methods
        canvas.texture = wrap(texture1);
        canvas.draw = wrap(draw);
        canvas.update = wrap(update);
        canvas.replace = wrap(replace);
        canvas.contents = wrap(contents);
        canvas.getPixelArray = wrap(getPixelArray);
        // Filter methods
        canvas.brightnessContrast = wrap(brightnessContrast);
        canvas.hexagonalPixelate = wrap(hexagonalPixelate);
        canvas.hueSaturation = wrap(hueSaturation);
        canvas.colorHalftone = wrap(colorHalftone);
        canvas.triangleBlur = wrap(triangleBlur);
        canvas.unsharpMask = wrap(unsharpMask);
        canvas.perspective = wrap(perspective);
        canvas.matrixWarp = wrap(matrixWarp);
        canvas.bulgePinch = wrap(bulgePinch);
        canvas.tiltShift = wrap(tiltShift);
        canvas.dotScreen = wrap(dotScreen);
        canvas.edgeWork = wrap(edgeWork);
        canvas.lensBlur = wrap(lensBlur);
        canvas.zoomBlur = wrap(zoomBlur);
        canvas.noise = wrap(noise);
        canvas.denoise = wrap(denoise);
        canvas.curves = wrap(curves);
        canvas.swirl = wrap(swirl);
        canvas.ink = wrap(ink);
        canvas.vignette = wrap(vignette);
        canvas.vibrance = wrap(vibrance);
        canvas.sepia = wrap(sepia);
        canvas.invert = wrap(invert);
        canvas.toAlpha = wrap(toAlpha);
        return canvas;
    };
    exports.splineInterpolate = splineInterpolate;
    // src/core\matrix.script
    // from javax.media.jai.PerspectiveTransform
    function getSquareToQuad(x0, y0, x1, y1, x2, y2, x3, y3) {
        let dx1 = x1 - x2;
        let dy1 = y1 - y2;
        let dx2 = x3 - x2;
        let dy2 = y3 - y2;
        let dx3 = x0 - x1 + x2 - x3;
        let dy3 = y0 - y1 + y2 - y3;
        let det = dx1 * dy2 - dx2 * dy1;
        let a = (dx3 * dy2 - dx2 * dy3) / det;
        let b = (dx1 * dy3 - dx3 * dy1) / det;
        return [
            x1 - x0 + a * x1,
            y1 - y0 + a * y1,
            a,
            x3 - x0 + b * x3,
            y3 - y0 + b * y3,
            b,
            x0,
            y0,
            1
        ];
    }
    function getInverse(m) {
        let a = m[0], b = m[1], c = m[2];
        let d = m[3], e = m[4], f = m[5];
        let g = m[6], h = m[7], i = m[8];
        let det = a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
        return [
            (e * i - f * h) / det,
            (c * h - b * i) / det,
            (b * f - c * e) / det,
            (f * g - d * i) / det,
            (a * i - c * g) / det,
            (c * d - a * f) / det,
            (d * h - e * g) / det,
            (b * g - a * h) / det,
            (a * e - b * d) / det
        ];
    }
    function multiply(a, b) {
        return [
            a[0] * b[0] + a[1] * b[3] + a[2] * b[6],
            a[0] * b[1] + a[1] * b[4] + a[2] * b[7],
            a[0] * b[2] + a[1] * b[5] + a[2] * b[8],
            a[3] * b[0] + a[4] * b[3] + a[5] * b[6],
            a[3] * b[1] + a[4] * b[4] + a[5] * b[7],
            a[3] * b[2] + a[4] * b[5] + a[5] * b[8],
            a[6] * b[0] + a[7] * b[3] + a[8] * b[6],
            a[6] * b[1] + a[7] * b[4] + a[8] * b[7],
            a[6] * b[2] + a[7] * b[5] + a[8] * b[8]
        ];
    }
    // src/core\shader.script
    var Shader1 = function() {
        function isArray(obj) {
            return Object.prototype.toString.call(obj) == '[object Array]';
        }
        function isNumber(obj) {
            return Object.prototype.toString.call(obj) == '[object Number]';
        }
        function compileSource(type, source, nameStr) {
            let shader = gl1.createShader(type);
            gl1.shaderSource(shader, source);
            gl1.compileShader(shader);
            if (!gl1.getShaderParameter(shader, gl1.COMPILE_STATUS)) throw 'compile error: ' + nameStr + ' - ' + gl1.getShaderInfoLog(shader);
            return shader;
        }
        let defaultVertexSource = '\
    attribute vec2 vertex;\
    attribute vec2 _texCoord;\
    varying vec2 texCoord;\
    void main() {\
        texCoord = _texCoord;\
        gl_Position = vec4(vertex * 2.0 - 1.0, 0.0, 1.0);\
    }';
        let defaultFragmentSource = '\
    uniform sampler2D texture;\
    varying vec2 texCoord;\
    void main() {\
        gl_FragColor = texture2D(texture, texCoord);\
    }';
        // added test 2020-04-27 bitbof
        let floatPrecision = null;
        function testPrecisionSupport(precisionType) {
            let format = gl1.getShaderPrecisionFormat(gl1.FRAGMENT_SHADER, precisionType);
            return format !== null && format.precision !== 0;
        }
        function Shader(vertexSource, fragmentSource, nameStr) {
            this.vertexAttribute = null;
            this.texCoordAttribute = null;
            this.program = gl1.createProgram();
            vertexSource = vertexSource || defaultVertexSource;
            fragmentSource = fragmentSource || defaultFragmentSource;
            if (floatPrecision === null) floatPrecision = testPrecisionSupport(gl1.HIGH_FLOAT) ? 'highp' : testPrecisionSupport(gl1.MEDIUM_FLOAT) ? 'mediump' : 'lowp';
            fragmentSource = 'precision ' + floatPrecision + ' float;' + fragmentSource; // annoying requirement is annoying
            gl1.attachShader(this.program, compileSource(gl1.VERTEX_SHADER, vertexSource, nameStr + '(vertex)'));
            gl1.attachShader(this.program, compileSource(gl1.FRAGMENT_SHADER, fragmentSource, nameStr + '(fragment)'));
            gl1.linkProgram(this.program);
            if (!gl1.getProgramParameter(this.program, gl1.LINK_STATUS)) throw 'link error: ' + gl1.getProgramInfoLog(this.program);
        }
        Shader.prototype.destroy = function() {
            gl1.deleteProgram(this.program);
            this.program = null;
        };
        Shader.prototype.uniforms = function(uniforms) {
            gl1.useProgram(this.program);
            for(var name in uniforms){
                if (!uniforms.hasOwnProperty(name)) continue;
                let location = gl1.getUniformLocation(this.program, name);
                if (location === null) continue; // will be null if the uniform isn't used in the shader
                let value = uniforms[name];
                if (isArray(value)) switch(value.length){
                    case 1:
                        gl1.uniform1fv(location, new Float32Array(value));
                        break;
                    case 2:
                        gl1.uniform2fv(location, new Float32Array(value));
                        break;
                    case 3:
                        gl1.uniform3fv(location, new Float32Array(value));
                        break;
                    case 4:
                        gl1.uniform4fv(location, new Float32Array(value));
                        break;
                    case 9:
                        gl1.uniformMatrix3fv(location, false, new Float32Array(value));
                        break;
                    case 16:
                        gl1.uniformMatrix4fv(location, false, new Float32Array(value));
                        break;
                    default:
                        throw 'dont\'t know how to load uniform "' + name + '" of length ' + value.length;
                }
                else if (isNumber(value)) gl1.uniform1f(location, value);
                else throw 'attempted to set uniform "' + name + '" to invalid value ' + (value || 'undefined').toString();
            }
            // allow chaining
            return this;
        };
        // textures are uniforms too but for some reason can't be specified by gl.uniform1f,
        // even though floating point numbers represent the integers 0 through 7 exactly
        Shader.prototype.textures = function(textures) {
            gl1.useProgram(this.program);
            for(var name in textures){
                if (!textures.hasOwnProperty(name)) continue;
                gl1.uniform1i(gl1.getUniformLocation(this.program, name), textures[name]);
            }
            // allow chaining
            return this;
        };
        Shader.prototype.drawRect = function(left, top, right, bottom) {
            let undefined;
            let viewport = gl1.getParameter(gl1.VIEWPORT);
            top = top !== undefined ? (top - viewport[1]) / viewport[3] : 0;
            left = left !== undefined ? (left - viewport[0]) / viewport[2] : 0;
            right = right !== undefined ? (right - viewport[0]) / viewport[2] : 1;
            bottom = bottom !== undefined ? (bottom - viewport[1]) / viewport[3] : 1;
            if (gl1.vertexBuffer == null) gl1.vertexBuffer = gl1.createBuffer();
            gl1.bindBuffer(gl1.ARRAY_BUFFER, gl1.vertexBuffer);
            gl1.bufferData(gl1.ARRAY_BUFFER, new Float32Array([
                left,
                top,
                left,
                bottom,
                right,
                top,
                right,
                bottom
            ]), gl1.STATIC_DRAW);
            if (gl1.texCoordBuffer == null) {
                gl1.texCoordBuffer = gl1.createBuffer();
                gl1.bindBuffer(gl1.ARRAY_BUFFER, gl1.texCoordBuffer);
                gl1.bufferData(gl1.ARRAY_BUFFER, new Float32Array([
                    0,
                    0,
                    0,
                    1,
                    1,
                    0,
                    1,
                    1
                ]), gl1.STATIC_DRAW);
            }
            if (this.vertexAttribute == null) {
                this.vertexAttribute = gl1.getAttribLocation(this.program, 'vertex');
                gl1.enableVertexAttribArray(this.vertexAttribute);
            }
            if (this.texCoordAttribute == null) {
                this.texCoordAttribute = gl1.getAttribLocation(this.program, '_texCoord');
                gl1.enableVertexAttribArray(this.texCoordAttribute);
            }
            gl1.useProgram(this.program);
            gl1.bindBuffer(gl1.ARRAY_BUFFER, gl1.vertexBuffer);
            gl1.vertexAttribPointer(this.vertexAttribute, 2, gl1.FLOAT, false, 0, 0);
            gl1.bindBuffer(gl1.ARRAY_BUFFER, gl1.texCoordBuffer);
            gl1.vertexAttribPointer(this.texCoordAttribute, 2, gl1.FLOAT, false, 0, 0);
            gl1.drawArrays(gl1.TRIANGLE_STRIP, 0, 4);
        };
        Shader.getDefaultShader = function() {
            gl1.defaultShader = gl1.defaultShader || new Shader();
            return gl1.defaultShader;
        };
        return Shader;
    }();
    // src/core\spline.script
    // from SplineInterpolator.cs in the Paint.NET source code
    function SplineInterpolator(points) {
        let n = points.length;
        this.xa = [];
        this.ya = [];
        this.u = [];
        this.y2 = [];
        points.sort(function(a, b) {
            return a[0] - b[0];
        });
        for(var i = 0; i < n; i++){
            this.xa.push(points[i][0]);
            this.ya.push(points[i][1]);
        }
        this.u[0] = 0;
        this.y2[0] = 0;
        for(var i = 1; i < n - 1; ++i){
            // This is the decomposition loop of the tridiagonal algorithm. 
            // y2 and u are used for temporary storage of the decomposed factors.
            let wx = this.xa[i + 1] - this.xa[i - 1];
            let sig = (this.xa[i] - this.xa[i - 1]) / wx;
            let p = sig * this.y2[i - 1] + 2;
            this.y2[i] = (sig - 1) / p;
            let ddydx = (this.ya[i + 1] - this.ya[i]) / (this.xa[i + 1] - this.xa[i]) - (this.ya[i] - this.ya[i - 1]) / (this.xa[i] - this.xa[i - 1]);
            this.u[i] = (6 * ddydx / wx - sig * this.u[i - 1]) / p;
        }
        this.y2[n - 1] = 0;
        // This is the backsubstitution loop of the tridiagonal algorithm
        for(var i = n - 2; i >= 0; --i)this.y2[i] = this.y2[i] * this.y2[i + 1] + this.u[i];
    }
    SplineInterpolator.prototype.interpolate = function(x) {
        let n = this.ya.length;
        let klo = 0;
        let khi = n - 1;
        // We will find the right place in the table by means of
        // bisection. This is optimal if sequential calls to this
        // routine are at random values of x. If sequential calls
        // are in order, and closely spaced, one would do better
        // to store previous values of klo and khi.
        while(khi - klo > 1){
            let k = khi + klo >> 1;
            if (this.xa[k] > x) khi = k;
            else klo = k;
        }
        let h = this.xa[khi] - this.xa[klo];
        let a = (this.xa[khi] - x) / h;
        let b = (x - this.xa[klo]) / h;
        // Cubic spline polynomial is now evaluated.
        return a * this.ya[klo] + b * this.ya[khi] + ((a * a * a - a) * this.y2[klo] + (b * b * b - b) * this.y2[khi]) * (h * h) / 6;
    };
    // src/core\texture.script
    var Texture1 = function() {
        Texture.fromElement = function(element) {
            let texture = new Texture(0, 0, gl1.RGBA, gl1.UNSIGNED_BYTE);
            texture.loadContentsOf(element);
            return texture;
        };
        function Texture(width, height, format, type) {
            this.gl = gl1;
            this.id = gl1.createTexture();
            this.width = width;
            this.height = height;
            this.format = format;
            this.type = type;
            gl1.bindTexture(gl1.TEXTURE_2D, this.id);
            gl1.texParameteri(gl1.TEXTURE_2D, gl1.TEXTURE_MAG_FILTER, gl1.LINEAR);
            gl1.texParameteri(gl1.TEXTURE_2D, gl1.TEXTURE_MIN_FILTER, gl1.LINEAR);
            gl1.texParameteri(gl1.TEXTURE_2D, gl1.TEXTURE_WRAP_S, gl1.CLAMP_TO_EDGE);
            gl1.texParameteri(gl1.TEXTURE_2D, gl1.TEXTURE_WRAP_T, gl1.CLAMP_TO_EDGE);
            if (width && height) gl1.texImage2D(gl1.TEXTURE_2D, 0, this.format, width, height, 0, this.format, this.type, null);
        }
        Texture.prototype.loadContentsOf = function(element) {
            this.width = element.width || element.videoWidth;
            this.height = element.height || element.videoHeight;
            gl1.bindTexture(gl1.TEXTURE_2D, this.id);
            gl1.texImage2D(gl1.TEXTURE_2D, 0, this.format, this.format, this.type, element);
        };
        Texture.prototype.initFromBytes = function(width, height, data) {
            this.width = width;
            this.height = height;
            this.format = gl1.RGBA;
            this.type = gl1.UNSIGNED_BYTE;
            gl1.bindTexture(gl1.TEXTURE_2D, this.id);
            gl1.texImage2D(gl1.TEXTURE_2D, 0, gl1.RGBA, width, height, 0, gl1.RGBA, this.type, new Uint8Array(data));
        };
        Texture.prototype.destroy = function() {
            gl1.deleteTexture(this.id);
            this.id = null;
        };
        Texture.prototype.use = function(unit) {
            gl1.activeTexture(gl1.TEXTURE0 + (unit || 0));
            gl1.bindTexture(gl1.TEXTURE_2D, this.id);
        };
        Texture.prototype.unuse = function(unit) {
            gl1.activeTexture(gl1.TEXTURE0 + (unit || 0));
            gl1.bindTexture(gl1.TEXTURE_2D, null);
        };
        Texture.prototype.ensureFormat = function(width, height, format, type) {
            // allow passing an existing texture instead of individual arguments
            if (arguments.length == 1) {
                let texture = arguments[0];
                width = texture.width;
                height = texture.height;
                format = texture.format;
                type = texture.type;
            }
            // change the format only if required
            if (width != this.width || height != this.height || format != this.format || type != this.type) {
                this.width = width;
                this.height = height;
                this.format = format;
                this.type = type;
                gl1.bindTexture(gl1.TEXTURE_2D, this.id);
                gl1.texImage2D(gl1.TEXTURE_2D, 0, this.format, width, height, 0, this.format, this.type, null);
            }
        };
        Texture.prototype.drawTo = function(callback) {
            // start rendering to this texture
            gl1.framebuffer = gl1.framebuffer || gl1.createFramebuffer();
            gl1.bindFramebuffer(gl1.FRAMEBUFFER, gl1.framebuffer);
            gl1.framebufferTexture2D(gl1.FRAMEBUFFER, gl1.COLOR_ATTACHMENT0, gl1.TEXTURE_2D, this.id, 0);
            if (gl1.checkFramebufferStatus(gl1.FRAMEBUFFER) !== gl1.FRAMEBUFFER_COMPLETE) throw new Error('incomplete framebuffer');
            gl1.viewport(0, 0, this.width, this.height);
            // do the drawing
            callback();
            // stop rendering to this texture
            gl1.bindFramebuffer(gl1.FRAMEBUFFER, null);
        };
        let canvas = null;
        function getCanvas(texture) {
            if (canvas == null) canvas = document.createElement('canvas');
            canvas.width = texture.width;
            canvas.height = texture.height;
            let c = canvas.getContext('2d');
            c.clearRect(0, 0, canvas.width, canvas.height);
            return c;
        }
        Texture.prototype.fillUsingCanvas = function(callback) {
            callback(getCanvas(this));
            this.format = gl1.RGBA;
            this.type = gl1.UNSIGNED_BYTE;
            gl1.bindTexture(gl1.TEXTURE_2D, this.id);
            gl1.texImage2D(gl1.TEXTURE_2D, 0, gl1.RGBA, gl1.RGBA, gl1.UNSIGNED_BYTE, canvas);
            return this;
        };
        Texture.prototype.toImage = function(image) {
            this.use();
            Shader1.getDefaultShader().drawRect();
            let size = this.width * this.height * 4;
            let pixels = new Uint8Array(size);
            let c = getCanvas(this);
            let data = c.createImageData(this.width, this.height);
            gl1.readPixels(0, 0, this.width, this.height, gl1.RGBA, gl1.UNSIGNED_BYTE, pixels);
            for(var i = 0; i < size; i++)data.data[i] = pixels[i];
            c.putImageData(data, 0, 0);
            image.src = canvas.toDataURL();
        };
        Texture.prototype.swapWith = function(other) {
            let temp;
            temp = other.id;
            other.id = this.id;
            this.id = temp;
            temp = other.width;
            other.width = this.width;
            this.width = temp;
            temp = other.height;
            other.height = this.height;
            this.height = temp;
            temp = other.format;
            other.format = this.format;
            this.format = temp;
        };
        return Texture;
    }();
    // src/filters\common.script
    function warpShader(uniforms, warp) {
        return new Shader1(null, uniforms + '\
    uniform sampler2D texture;\
    uniform vec2 texSize;\
    varying vec2 texCoord;\
    void main() {\
        vec2 coord = texCoord * texSize;\
        ' + warp + '\
        gl_FragColor = texture2D(texture, coord / texSize);\
        vec2 clampedCoord = clamp(coord, vec2(0.0), texSize);\
        if (coord != clampedCoord) {\
            /* fade to transparent if we are outside the image */\
            gl_FragColor.a *= max(0.0, 1.0 - length(coord - clampedCoord));\
        }\
    }', 'warp');
    }
    // returns a random number between 0 and 1
    var randomShaderFunc = '\
    float random(vec3 scale, float seed) {\
        /* use the fragment position for a different seed per-pixel */\
        return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\
    }\
';
    // src/filters\adjust\brightnesscontrast.script
    /**
 * @filter           Brightness / Contrast
 * @description      Provides additive brightness and multiplicative contrast control.
 * @param brightness -1 to 1 (-1 is solid black, 0 is no change, and 1 is solid white)
 * @param contrast   -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)
 */ function brightnessContrast(brightness, contrast) {
        gl1.brightnessContrast = gl1.brightnessContrast || new Shader1(null, '\
        uniform sampler2D texture;\
        uniform float brightness;\
        uniform float contrast;\
        varying vec2 texCoord;\
        void main() {\
            vec4 color = texture2D(texture, texCoord);\
            color.rgb += brightness;\
            if (contrast > 0.0) {\
                color.rgb = (color.rgb - 0.5) / (1.0 - contrast) + 0.5;\
            } else {\
                color.rgb = (color.rgb - 0.5) * (1.0 + contrast) + 0.5;\
            }\
            gl_FragColor = color;\
        }\
    ', 'brightnessContrast');
        simpleShader.call(this, gl1.brightnessContrast, {
            brightness: clamp(-1, brightness, 1),
            contrast: clamp(-1, contrast, 1)
        });
        return this;
    }
    // src/filters\adjust\curves.script
    function splineInterpolate(points) {
        let interpolator = new SplineInterpolator(points);
        let array = [];
        for(var i = 0; i < 256; i++)array.push(clamp(0, Math.floor(interpolator.interpolate(i / 255) * 256), 255));
        return array;
    }
    /**
 * @filter      Curves
 * @description A powerful mapping tool that transforms the colors in the image
 *              by an arbitrary function. The function is interpolated between
 *              a set of 2D points using splines. The curves filter can take
 *              either one or three arguments which will apply the mapping to
 *              either luminance or RGB values, respectively.
 * @param red   A list of points that define the function for the red channel.
 *              Each point is a list of two values: the value before the mapping
 *              and the value after the mapping, both in the range 0 to 1. For
 *              example, [[0,1], [1,0]] would invert the red channel while
 *              [[0,0], [1,1]] would leave the red channel unchanged. If green
 *              and blue are omitted then this argument also applies to the
 *              green and blue channels.
 * @param green (optional) A list of points that define the function for the green
 *              channel (just like for red).
 * @param blue  (optional) A list of points that define the function for the blue
 *              channel (just like for red).
 */ function curves(red, green, blue) {
        // Create the ramp texture
        red = splineInterpolate(red);
        if (arguments.length == 1) green = blue = red;
        else {
            green = splineInterpolate(green);
            blue = splineInterpolate(blue);
        }
        let array = [];
        for(var i = 0; i < 256; i++)array.splice(array.length, 0, red[i], green[i], blue[i], 255);
        this._.extraTexture.initFromBytes(256, 1, array);
        this._.extraTexture.use(1);
        gl1.curves = gl1.curves || new Shader1(null, '\
        uniform sampler2D texture;\
        uniform sampler2D map;\
        varying vec2 texCoord;\
        void main() {\
            vec4 color = texture2D(texture, texCoord);\
            color.r = texture2D(map, vec2(color.r)).r;\
            color.g = texture2D(map, vec2(color.g)).g;\
            color.b = texture2D(map, vec2(color.b)).b;\
            gl_FragColor = color;\
        }\
    ', 'curves');
        gl1.curves.textures({
            map: 1
        });
        simpleShader.call(this, gl1.curves, {
        });
        return this;
    }
    // src/filters\adjust\denoise.script
    /**
 * @filter         Denoise
 * @description    Smooths over grainy noise in dark images using an 9x9 box filter
 *                 weighted by color intensity, similar to a bilateral filter.
 * @param exponent The exponent of the color intensity difference, should be greater
 *                 than zero. A value of zero just gives an 9x9 box blur and high values
 *                 give the original image, but ideal values are usually around 10-20.
 */ function denoise(exponent) {
        // Do a 9x9 bilateral box filter
        gl1.denoise = gl1.denoise || new Shader1(null, '\
        uniform sampler2D texture;\
        uniform float exponent;\
        uniform float strength;\
        uniform vec2 texSize;\
        varying vec2 texCoord;\
        void main() {\
            vec4 center = texture2D(texture, texCoord);\
            vec4 color = vec4(0.0);\
            float total = 0.0;\
            for (float x = -4.0; x <= 4.0; x += 1.0) {\
                for (float y = -4.0; y <= 4.0; y += 1.0) {\
                    vec4 sample = texture2D(texture, texCoord + vec2(x, y) / texSize);\
                    float weight = 1.0 - abs(dot(sample.rgb - center.rgb, vec3(0.25)));\
                    weight = pow(weight, exponent);\
                    color += sample * weight;\
                    total += weight;\
                }\
            }\
            gl_FragColor = color / total;\
        }\
    ', 'denoise');
        // Perform two iterations for stronger results
        for(var i = 0; i < 2; i++)simpleShader.call(this, gl1.denoise, {
            exponent: Math.max(0, exponent),
            texSize: [
                this.width,
                this.height
            ]
        });
        return this;
    }
    // src/filters\adjust\huesaturation.script
    /**
 * @filter           Hue / Saturation
 * @description      Provides rotational hue and multiplicative saturation control. RGB color space
 *                   can be imagined as a cube where the axes are the red, green, and blue color
 *                   values. Hue changing works by rotating the color vector around the grayscale
 *                   line, which is the straight line from black (0, 0, 0) to white (1, 1, 1).
 *                   Saturation is implemented by scaling all color channel values either toward
 *                   or away from the average color channel value.
 * @param hue        -1 to 1 (-1 is 180 degree rotation in the negative direction, 0 is no change,
 *                   and 1 is 180 degree rotation in the positive direction)
 * @param saturation -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)
 */ function hueSaturation(hue, saturation) {
        gl1.hueSaturation = gl1.hueSaturation || new Shader1(null, '\
        uniform sampler2D texture;\
        uniform float hue;\
        uniform float saturation;\
        varying vec2 texCoord;\
        void main() {\
            vec4 color = texture2D(texture, texCoord);\
            \
            /* hue adjustment, wolfram alpha: RotationTransform[angle, {1, 1, 1}][{x, y, z}] */\
            float angle = hue * 3.14159265;\
            float s = sin(angle), c = cos(angle);\
            vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;\
            float len = length(color.rgb);\
            color.rgb = vec3(\
                dot(color.rgb, weights.xyz),\
                dot(color.rgb, weights.zxy),\
                dot(color.rgb, weights.yzx)\
            );\
            \
            /* saturation adjustment */\
            float average = (color.r + color.g + color.b) / 3.0;\
            if (saturation > 0.0) {\
                color.rgb += (average - color.rgb) * (1.0 - 1.0 / (1.001 - saturation));\
            } else {\
                color.rgb += (average - color.rgb) * (-saturation);\
            }\
            \
            gl_FragColor = color;\
        }\
    ', 'hueSaturation');
        simpleShader.call(this, gl1.hueSaturation, {
            hue: clamp(-1, hue, 1),
            saturation: clamp(-1, saturation, 1)
        });
        return this;
    }
    // src/filters\adjust\noise.script
    /**
 * @filter         Noise
 * @description    Adds black and white noise to the image.
 * @param amount   0 to 1 (0 for no effect, 1 for maximum noise)
 */ function noise(amount) {
        gl1.noise = gl1.noise || new Shader1(null, '\
        uniform sampler2D texture;\
        uniform float amount;\
        varying vec2 texCoord;\
        float rand(vec2 co) {\
            return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\
        }\
        void main() {\
            vec4 color = texture2D(texture, texCoord);\
            \
            float diff = (rand(texCoord) - 0.5) * amount;\
            color.r += diff;\
            color.g += diff;\
            color.b += diff;\
            \
            gl_FragColor = color;\
        }\
    ', 'noise');
        simpleShader.call(this, gl1.noise, {
            amount: clamp(0, amount, 1)
        });
        return this;
    }
    // src/filters\adjust\sepia.script
    /**
 * @filter         Sepia
 * @description    Gives the image a reddish-brown monochrome tint that imitates an old photograph.
 * @param amount   0 to 1 (0 for no effect, 1 for full sepia coloring)
 */ function sepia(amount) {
        gl1.sepia = gl1.sepia || new Shader1(null, '\
        uniform sampler2D texture;\
        uniform float amount;\
        varying vec2 texCoord;\
        void main() {\
            vec4 color = texture2D(texture, texCoord);\
            float r = color.r;\
            float g = color.g;\
            float b = color.b;\
            \
            color.r = min(1.0, (r * (1.0 - (0.607 * amount))) + (g * (0.769 * amount)) + (b * (0.189 * amount)));\
            color.g = min(1.0, (r * 0.349 * amount) + (g * (1.0 - (0.314 * amount))) + (b * 0.168 * amount));\
            color.b = min(1.0, (r * 0.272 * amount) + (g * 0.534 * amount) + (b * (1.0 - (0.869 * amount))));\
            \
            gl_FragColor = color;\
        }\
    ', 'sepia');
        simpleShader.call(this, gl1.sepia, {
            amount: clamp(0, amount, 1)
        });
        return this;
    }
    // src/filters\adjust\unsharpmask.script
    /**
 * @filter         Unsharp Mask
 * @description    A form of image sharpening that amplifies high-frequencies in the image. It
 *                 is implemented by scaling pixels away from the average of their neighbors.
 * @param radius   The blur radius that calculates the average of the neighboring pixels.
 * @param strength A scale factor where 0 is no effect and higher values cause a stronger effect.
 */ function unsharpMask(radius, strength) {
        gl1.unsharpMask = gl1.unsharpMask || new Shader1(null, '\
        uniform sampler2D blurredTexture;\
        uniform sampler2D originalTexture;\
        uniform float strength;\
        uniform float threshold;\
        varying vec2 texCoord;\
        void main() {\
            vec4 blurred = texture2D(blurredTexture, texCoord);\
            vec4 original = texture2D(originalTexture, texCoord);\
            gl_FragColor = mix(blurred, original, 1.0 + strength);\
        }\
    ', 'unsharpMask');
        // Store a copy of the current texture in the second texture unit
        this._.extraTexture.ensureFormat(this._.texture);
        this._.texture.use();
        this._.extraTexture.drawTo(function() {
            Shader1.getDefaultShader().drawRect();
        });
        // Blur the current texture, then use the stored texture to detect edges
        this._.extraTexture.use(1);
        this.triangleBlur(radius);
        gl1.unsharpMask.textures({
            originalTexture: 1
        });
        simpleShader.call(this, gl1.unsharpMask, {
            strength: strength
        });
        this._.extraTexture.unuse(1);
        return this;
    }
    // src/filters\adjust\vibrance.script
    /**
 * @filter       Vibrance
 * @description  Modifies the saturation of desaturated colors, leaving saturated colors unmodified.
 * @param amount -1 to 1 (-1 is minimum vibrance, 0 is no change, and 1 is maximum vibrance)
 */ function vibrance(amount) {
        gl1.vibrance = gl1.vibrance || new Shader1(null, '\
        uniform sampler2D texture;\
        uniform float amount;\
        varying vec2 texCoord;\
        void main() {\
            vec4 color = texture2D(texture, texCoord);\
            float average = (color.r + color.g + color.b) / 3.0;\
            float mx = max(color.r, max(color.g, color.b));\
            float amt = (mx - average) * (-amount * 3.0);\
            color.rgb = mix(color.rgb, vec3(mx), amt);\
            gl_FragColor = color;\
        }\
    ', 'vibrance');
        simpleShader.call(this, gl1.vibrance, {
            amount: clamp(-1, amount, 1)
        });
        return this;
    }
    // src/filters\adjust\vignette.script
    /**
 * @filter         Vignette
 * @description    Adds a simulated lens edge darkening effect.
 * @param size     0 to 1 (0 for center of frame, 1 for edge of frame)
 * @param amount   0 to 1 (0 for no effect, 1 for maximum lens darkening)
 */ function vignette(size, amount) {
        gl1.vignette = gl1.vignette || new Shader1(null, '\
        uniform sampler2D texture;\
        uniform float size;\
        uniform float amount;\
        varying vec2 texCoord;\
        void main() {\
            vec4 color = texture2D(texture, texCoord);\
            \
            float dist = distance(texCoord, vec2(0.5, 0.5));\
            color.rgb *= smoothstep(0.8, size * 0.799, dist * (amount + size));\
            \
            gl_FragColor = color;\
        }\
    ', 'vignette');
        simpleShader.call(this, gl1.vignette, {
            size: clamp(0, size, 1),
            amount: clamp(0, amount, 1)
        });
        return this;
    }
    // src/filters\blur\lensblur.script
    /**
 * @filter           Lens Blur
 * @description      Imitates a camera capturing the image out of focus by using a blur that generates
 *                   the large shapes known as bokeh. The polygonal shape of real bokeh is due to the
 *                   blades of the aperture diaphragm when it isn't fully open. This blur renders
 *                   bokeh from a 6-bladed diaphragm because the computation is more efficient. It
 *                   can be separated into three rhombi, each of which is just a skewed box blur.
 *                   This filter makes use of the floating point texture WebGL extension to implement
 *                   the brightness parameter, so there will be severe visual artifacts if brightness
 *                   is non-zero and the floating point texture extension is not available. The
 *                   idea was from John White's SIGGRAPH 2011 talk but this effect has an additional
 *                   brightness parameter that fakes what would otherwise come from a HDR source.
 * @param radius     the radius of the hexagonal disk convolved with the image
 * @param brightness -1 to 1 (the brightness of the bokeh, negative values will create dark bokeh)
 * @param angle      the rotation of the bokeh in radians
 */ function lensBlur(radius, brightness, angle) {
        // All averaging is done on values raised to a power to make more obvious bokeh
        // (we will raise the average to the inverse power at the end to compensate).
        // Without this the image looks almost like a normal blurred image. This hack is
        // obviously not realistic, but to accurately simulate this we would need a high
        // dynamic range source photograph which we don't have.
        gl1.lensBlurPrePass = gl1.lensBlurPrePass || new Shader1(null, '\
        uniform sampler2D texture;\
        uniform float power;\
        varying vec2 texCoord;\
        void main() {\
            vec4 color = texture2D(texture, texCoord);\
            color = pow(color, vec4(power));\
            gl_FragColor = vec4(color);\
        }\
    ', 'lensBlurPrePass');
        let common = '\
        uniform sampler2D texture0;\
        uniform sampler2D texture1;\
        uniform vec2 delta0;\
        uniform vec2 delta1;\
        uniform float power;\
        varying vec2 texCoord;\
        ' + randomShaderFunc + '\
        vec4 sample(vec2 delta) {\
            /* randomize the lookup values to hide the fixed number of samples */\
            float offset = random(vec3(delta, 151.7182), 0.0);\
            \
            vec4 color = vec4(0.0);\
            float total = 0.0;\
            for (float t = 0.0; t <= 30.0; t++) {\
                float percent = (t + offset) / 30.0;\
                color += texture2D(texture0, texCoord + delta * percent);\
                total += 1.0;\
            }\
            return color / total;\
        }\
    ';
        gl1.lensBlur0 = gl1.lensBlur0 || new Shader1(null, common + '\
        void main() {\
            gl_FragColor = sample(delta0);\
        }\
    ', 'lensBlur0');
        gl1.lensBlur1 = gl1.lensBlur1 || new Shader1(null, common + '\
        void main() {\
            gl_FragColor = (sample(delta0) + sample(delta1)) * 0.5;\
        }\
    ', 'lensBlur1');
        gl1.lensBlur2 = gl1.lensBlur2 || new Shader1(null, common + '\
        void main() {\
            vec4 color = (sample(delta0) + 2.0 * texture2D(texture1, texCoord)) / 3.0;\
            gl_FragColor = pow(color, vec4(power));\
        }\
    ', 'lensBlur2').textures({
            texture1: 1
        });
        // Generate
        let dir = [];
        for(var i = 0; i < 3; i++){
            let a = angle + i * Math.PI * 2 / 3;
            dir.push([
                radius * Math.sin(a) / this.width,
                radius * Math.cos(a) / this.height
            ]);
        }
        let power = Math.pow(10, clamp(-1, brightness, 1));
        // Remap the texture values, which will help make the bokeh effect
        simpleShader.call(this, gl1.lensBlurPrePass, {
            power: power
        });
        // Blur two rhombi in parallel into extraTexture
        this._.extraTexture.ensureFormat(this._.texture);
        simpleShader.call(this, gl1.lensBlur0, {
            delta0: dir[0]
        }, this._.texture, this._.extraTexture);
        simpleShader.call(this, gl1.lensBlur1, {
            delta0: dir[1],
            delta1: dir[2]
        }, this._.extraTexture, this._.extraTexture);
        // Blur the last rhombus and combine with extraTexture
        simpleShader.call(this, gl1.lensBlur0, {
            delta0: dir[1]
        });
        this._.extraTexture.use(1);
        simpleShader.call(this, gl1.lensBlur2, {
            power: 1 / power,
            delta0: dir[2]
        });
        return this;
    }
    // src/filters\blur\tiltshift.script
    /**
 * @filter               Tilt Shift
 * @description          Simulates the shallow depth of field normally encountered in close-up
 *                       photography, which makes the scene seem much smaller than it actually
 *                       is. This filter assumes the scene is relatively planar, in which case
 *                       the part of the scene that is completely in focus can be described by
 *                       a line (the intersection of the focal plane and the scene). An example
 *                       of a planar scene might be looking at a road from above at a downward
 *                       angle. The image is then blurred with a blur radius that starts at zero
 *                       on the line and increases further from the line.
 * @param startX         The x coordinate of the start of the line segment.
 * @param startY         The y coordinate of the start of the line segment.
 * @param endX           The x coordinate of the end of the line segment.
 * @param endY           The y coordinate of the end of the line segment.
 * @param blurRadius     The maximum radius of the pyramid blur.
 * @param gradientRadius The distance from the line at which the maximum blur radius is reached.
 */ function tiltShift(startX, startY, endX, endY, blurRadius, gradientRadius) {
        gl1.tiltShift = gl1.tiltShift || new Shader1(null, '\
        uniform sampler2D texture;\
        uniform float blurRadius;\
        uniform float gradientRadius;\
        uniform vec2 start;\
        uniform vec2 end;\
        uniform vec2 delta;\
        uniform vec2 texSize;\
        varying vec2 texCoord;\
        ' + randomShaderFunc + '\
        void main() {\
            vec4 color = vec4(0.0);\
            float total = 0.0;\
            \
            /* randomize the lookup values to hide the fixed number of samples */\
            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\
            \
            vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));\
            float radius = smoothstep(0.0, 1.0, abs(dot(texCoord * texSize - start, normal)) / gradientRadius) * blurRadius;\
            for (float t = -30.0; t <= 30.0; t++) {\
                float percent = (t + offset - 0.5) / 30.0;\
                float weight = 1.0 - abs(percent);\
                vec4 sample = texture2D(texture, texCoord + delta / texSize * percent * radius);\
                \
                /* switch to pre-multiplied alpha to correctly blur transparent images */\
                sample.rgb *= sample.a;\
                \
                color += sample * weight;\
                total += weight;\
            }\
            \
            gl_FragColor = color / total;\
            \
            /* switch back from pre-multiplied alpha */\
            gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\
        }\
    ', 'tiltShift');
        let dx = endX - startX;
        let dy = endY - startY;
        let d = Math.sqrt(dx * dx + dy * dy);
        simpleShader.call(this, gl1.tiltShift, {
            blurRadius: blurRadius,
            gradientRadius: gradientRadius,
            start: [
                startX,
                startY
            ],
            end: [
                endX,
                endY
            ],
            delta: [
                dx / d,
                dy / d
            ],
            texSize: [
                this.width,
                this.height
            ]
        });
        simpleShader.call(this, gl1.tiltShift, {
            blurRadius: blurRadius,
            gradientRadius: gradientRadius,
            start: [
                startX,
                startY
            ],
            end: [
                endX,
                endY
            ],
            delta: [
                -dy / d,
                dx / d
            ],
            texSize: [
                this.width,
                this.height
            ]
        });
        return this;
    }
    // src/filters\blur\triangleblur.script
    /**
 * @filter       Triangle Blur
 * @description  This is the most basic blur filter, which convolves the image with a
 *               pyramid filter. The pyramid filter is separable and is applied as two
 *               perpendicular triangle filters.
 * @param radius The radius of the pyramid convolved with the image.
 */ function triangleBlur(radius) {
        gl1.triangleBlur = gl1.triangleBlur || new Shader1(null, '\
        uniform sampler2D texture;\
        uniform vec2 delta;\
        varying vec2 texCoord;\
        ' + randomShaderFunc + '\
        void main() {\
            vec4 color = vec4(0.0);\
            float total = 0.0;\
            \
            /* randomize the lookup values to hide the fixed number of samples */\
            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\
            \
            for (float t = -30.0; t <= 30.0; t++) {\
                float percent = (t + offset - 0.5) / 30.0;\
                float weight = 1.0 - abs(percent);\
                vec4 sample = texture2D(texture, texCoord + delta * percent);\
                \
                /* switch to pre-multiplied alpha to correctly blur transparent images */\
                sample.rgb *= sample.a;\
                \
                color += sample * weight;\
                total += weight;\
            }\
            \
            gl_FragColor = color / total;\
            \
            /* switch back from pre-multiplied alpha */\
            gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\
        }\
    ', 'triangleBlur');
        simpleShader.call(this, gl1.triangleBlur, {
            delta: [
                radius / this.width,
                0
            ]
        });
        simpleShader.call(this, gl1.triangleBlur, {
            delta: [
                0,
                radius / this.height
            ]
        });
        return this;
    }
    // src/filters\blur\zoomblur.script
    /**
 * @filter         Zoom Blur
 * @description    Blurs the image away from a certain point, which looks like radial motion blur.
 * @param centerX  The x coordinate of the blur origin.
 * @param centerY  The y coordinate of the blur origin.
 * @param strength The strength of the blur. Values in the range 0 to 1 are usually sufficient,
 *                 where 0 doesn't change the image and 1 creates a highly blurred image.
 */ function zoomBlur(centerX, centerY, strength) {
        gl1.zoomBlur = gl1.zoomBlur || new Shader1(null, '\
        uniform sampler2D texture;\
        uniform vec2 center;\
        uniform float strength;\
        uniform vec2 texSize;\
        varying vec2 texCoord;\
        ' + randomShaderFunc + '\
        void main() {\
            vec4 color = vec4(0.0);\
            float total = 0.0;\
            vec2 toCenter = center - texCoord * texSize;\
            \
            /* randomize the lookup values to hide the fixed number of samples */\
            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\
            \
            for (float t = 0.0; t <= 40.0; t++) {\
                float percent = (t + offset) / 40.0;\
                float weight = 4.0 * (percent - percent * percent);\
                vec4 sample = texture2D(texture, texCoord + toCenter * percent * strength / texSize);\
                \
                /* switch to pre-multiplied alpha to correctly blur transparent images */\
                sample.rgb *= sample.a;\
                \
                color += sample * weight;\
                total += weight;\
            }\
            \
            gl_FragColor = color / total;\
            \
            /* switch back from pre-multiplied alpha */\
            gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\
        }\
    ', 'zoomBlur');
        simpleShader.call(this, gl1.zoomBlur, {
            center: [
                centerX,
                centerY
            ],
            strength: strength,
            texSize: [
                this.width,
                this.height
            ]
        });
        return this;
    }
    // src/filters\fun\colorhalftone.script
    /**
 * @filter        Color Halftone
 * @description   Simulates a CMYK halftone rendering of the image by multiplying pixel values
 *                with a four rotated 2D sine wave patterns, one each for cyan, magenta, yellow,
 *                and black.
 * @param centerX The x coordinate of the pattern origin.
 * @param centerY The y coordinate of the pattern origin.
 * @param angle   The rotation of the pattern in radians.
 * @param size    The diameter of a dot in pixels.
 */ function colorHalftone(centerX, centerY, angle, size) {
        gl1.colorHalftone = gl1.colorHalftone || new Shader1(null, '\
        uniform sampler2D texture;\
        uniform vec2 center;\
        uniform float angle;\
        uniform float scale;\
        uniform vec2 texSize;\
        varying vec2 texCoord;\
        \
        float pattern(float angle) {\
            float s = sin(angle), c = cos(angle);\
            vec2 tex = texCoord * texSize - center;\
            vec2 point = vec2(\
                c * tex.x - s * tex.y,\
                s * tex.x + c * tex.y\
            ) * scale;\
            return (sin(point.x) * sin(point.y)) * 4.0;\
        }\
        \
        void main() {\
            vec4 color = texture2D(texture, texCoord);\
            vec3 cmy = 1.0 - color.rgb;\
            float k = min(cmy.x, min(cmy.y, cmy.z));\
            cmy = (cmy - k) / (1.0 - k);\
            cmy = clamp(cmy * 10.0 - 3.0 + vec3(pattern(angle + 0.26179), pattern(angle + 1.30899), pattern(angle)), 0.0, 1.0);\
            k = clamp(k * 10.0 - 5.0 + pattern(angle + 0.78539), 0.0, 1.0);\
            gl_FragColor = vec4(1.0 - cmy - k, color.a);\
        }\
    ', 'colorHalftone');
        simpleShader.call(this, gl1.colorHalftone, {
            center: [
                centerX,
                centerY
            ],
            angle: angle,
            scale: Math.PI / size,
            texSize: [
                this.width,
                this.height
            ]
        });
        return this;
    }
    // src/filters\fun\dotscreen.script
    /**
 * @filter        Dot Screen
 * @description   Simulates a black and white halftone rendering of the image by multiplying
 *                pixel values with a rotated 2D sine wave pattern.
 * @param centerX The x coordinate of the pattern origin.
 * @param centerY The y coordinate of the pattern origin.
 * @param angle   The rotation of the pattern in radians.
 * @param size    The diameter of a dot in pixels.
 */ function dotScreen(centerX, centerY, angle, size) {
        gl1.dotScreen = gl1.dotScreen || new Shader1(null, '\
        uniform sampler2D texture;\
        uniform vec2 center;\
        uniform float angle;\
        uniform float scale;\
        uniform vec2 texSize;\
        varying vec2 texCoord;\
        \
        float pattern() {\
            float s = sin(angle), c = cos(angle);\
            vec2 tex = texCoord * texSize - center;\
            vec2 point = vec2(\
                c * tex.x - s * tex.y,\
                s * tex.x + c * tex.y\
            ) * scale;\
            return (sin(point.x) * sin(point.y)) * 4.0;\
        }\
        \
        void main() {\
            vec4 color = texture2D(texture, texCoord);\
            float average = (color.r + color.g + color.b) / 3.0;\
            gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);\
        }\
    ', 'dotScreen');
        simpleShader.call(this, gl1.dotScreen, {
            center: [
                centerX,
                centerY
            ],
            angle: angle,
            scale: Math.PI / size,
            texSize: [
                this.width,
                this.height
            ]
        });
        return this;
    }
    // src/filters\fun\edgework.script
    /**
 * @filter       Edge Work
 * @description  Picks out different frequencies in the image by subtracting two
 *               copies of the image blurred with different radii.
 * @param radius The radius of the effect in pixels.
 */ function edgeWork(radius) {
        gl1.edgeWork1 = gl1.edgeWork1 || new Shader1(null, '\
        uniform sampler2D texture;\
        uniform vec2 delta;\
        varying vec2 texCoord;\
        ' + randomShaderFunc + '\
        void main() {\
            vec2 color = vec2(0.0);\
            vec2 total = vec2(0.0);\
            \
            /* randomize the lookup values to hide the fixed number of samples */\
            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\
            \
            for (float t = -30.0; t <= 30.0; t++) {\
                float percent = (t + offset - 0.5) / 30.0;\
                float weight = 1.0 - abs(percent);\
                vec3 sample = texture2D(texture, texCoord + delta * percent).rgb;\
                float average = (sample.r + sample.g + sample.b) / 3.0;\
                color.x += average * weight;\
                total.x += weight;\
                if (abs(t) < 15.0) {\
                    weight = weight * 2.0 - 1.0;\
                    color.y += average * weight;\
                    total.y += weight;\
                }\
            }\
            gl_FragColor = vec4(color / total, 0.0, 1.0);\
        }\
    ', 'edgeWork1');
        gl1.edgeWork2 = gl1.edgeWork2 || new Shader1(null, '\
        uniform sampler2D texture;\
        uniform vec2 delta;\
        varying vec2 texCoord;\
        ' + randomShaderFunc + '\
        void main() {\
            vec2 color = vec2(0.0);\
            vec2 total = vec2(0.0);\
            \
            /* randomize the lookup values to hide the fixed number of samples */\
            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\
            \
            for (float t = -30.0; t <= 30.0; t++) {\
                float percent = (t + offset - 0.5) / 30.0;\
                float weight = 1.0 - abs(percent);\
                vec2 sample = texture2D(texture, texCoord + delta * percent).xy;\
                color.x += sample.x * weight;\
                total.x += weight;\
                if (abs(t) < 15.0) {\
                    weight = weight * 2.0 - 1.0;\
                    color.y += sample.y * weight;\
                    total.y += weight;\
                }\
            }\
            float c = clamp(10000.0 * (color.y / total.y - color.x / total.x) + 0.5, 0.0, 1.0);\
            gl_FragColor = vec4(c, c, c, 1.0);\
        }\
    ', 'edgeWork2');
        simpleShader.call(this, gl1.edgeWork1, {
            delta: [
                radius / this.width,
                0
            ]
        });
        simpleShader.call(this, gl1.edgeWork2, {
            delta: [
                0,
                radius / this.height
            ]
        });
        return this;
    }
    // src/filters\fun\hexagonalpixelate.script
    /**
 * @filter        Hexagonal Pixelate
 * @description   Renders the image using a pattern of hexagonal tiles. Tile colors
 *                are nearest-neighbor sampled from the centers of the tiles.
 * @param centerX The x coordinate of the pattern center.
 * @param centerY The y coordinate of the pattern center.
 * @param scale   The width of an individual tile, in pixels.
 */ function hexagonalPixelate(centerX, centerY, scale) {
        gl1.hexagonalPixelate = gl1.hexagonalPixelate || new Shader1(null, '\
        uniform sampler2D texture;\
        uniform vec2 center;\
        uniform float scale;\
        uniform vec2 texSize;\
        varying vec2 texCoord;\
        void main() {\
            vec2 tex = (texCoord * texSize - center) / scale;\
            tex.y /= 0.866025404;\
            tex.x -= tex.y * 0.5;\
            \
            vec2 a;\
            if (tex.x + tex.y - floor(tex.x) - floor(tex.y) < 1.0) a = vec2(floor(tex.x), floor(tex.y));\
            else a = vec2(ceil(tex.x), ceil(tex.y));\
            vec2 b = vec2(ceil(tex.x), floor(tex.y));\
            vec2 c = vec2(floor(tex.x), ceil(tex.y));\
            \
            vec3 TEX = vec3(tex.x, tex.y, 1.0 - tex.x - tex.y);\
            vec3 A = vec3(a.x, a.y, 1.0 - a.x - a.y);\
            vec3 B = vec3(b.x, b.y, 1.0 - b.x - b.y);\
            vec3 C = vec3(c.x, c.y, 1.0 - c.x - c.y);\
            \
            float alen = length(TEX - A);\
            float blen = length(TEX - B);\
            float clen = length(TEX - C);\
            \
            vec2 choice;\
            if (alen < blen) {\
                if (alen < clen) choice = a;\
                else choice = c;\
            } else {\
                if (blen < clen) choice = b;\
                else choice = c;\
            }\
            \
            choice.x += choice.y * 0.5;\
            choice.y *= 0.866025404;\
            choice *= scale / texSize;\
            gl_FragColor = texture2D(texture, choice + center / texSize);\
        }\
    ', 'hexagonalPixelate');
        simpleShader.call(this, gl1.hexagonalPixelate, {
            center: [
                centerX,
                centerY
            ],
            scale: scale,
            texSize: [
                this.width,
                this.height
            ]
        });
        return this;
    }
    // src/filters\fun\ink.script
    /**
 * @filter         Ink
 * @description    Simulates outlining the image in ink by darkening edges stronger than a
 *                 certain threshold. The edge detection value is the difference of two
 *                 copies of the image, each blurred using a blur of a different radius.
 * @param strength The multiplicative scale of the ink edges. Values in the range 0 to 1
 *                 are usually sufficient, where 0 doesn't change the image and 1 adds lots
 *                 of black edges. Negative strength values will create white ink edges
 *                 instead of black ones.
 */ function ink(strength) {
        gl1.ink = gl1.ink || new Shader1(null, '\
        uniform sampler2D texture;\
        uniform float strength;\
        uniform vec2 texSize;\
        varying vec2 texCoord;\
        void main() {\
            vec2 dx = vec2(1.0 / texSize.x, 0.0);\
            vec2 dy = vec2(0.0, 1.0 / texSize.y);\
            vec4 color = texture2D(texture, texCoord);\
            float bigTotal = 0.0;\
            float smallTotal = 0.0;\
            vec3 bigAverage = vec3(0.0);\
            vec3 smallAverage = vec3(0.0);\
            for (float x = -2.0; x <= 2.0; x += 1.0) {\
                for (float y = -2.0; y <= 2.0; y += 1.0) {\
                    vec3 sample = texture2D(texture, texCoord + dx * x + dy * y).rgb;\
                    bigAverage += sample;\
                    bigTotal += 1.0;\
                    if (abs(x) + abs(y) < 2.0) {\
                        smallAverage += sample;\
                        smallTotal += 1.0;\
                    }\
                }\
            }\
            vec3 edge = max(vec3(0.0), bigAverage / bigTotal - smallAverage / smallTotal);\
            gl_FragColor = vec4(color.rgb - dot(edge, edge) * strength * 100000.0, color.a);\
        }\
    ', 'ink');
        simpleShader.call(this, gl1.ink, {
            strength: strength * strength * strength * strength * strength,
            texSize: [
                this.width,
                this.height
            ]
        });
        return this;
    }
    // src/filters\warp\bulgepinch.script
    /**
 * @filter         Bulge / Pinch
 * @description    Bulges or pinches the image in a circle.
 * @param centerX  The x coordinate of the center of the circle of effect.
 * @param centerY  The y coordinate of the center of the circle of effect.
 * @param radius   The radius of the circle of effect.
 * @param strength -1 to 1 (-1 is strong pinch, 0 is no effect, 1 is strong bulge)
 */ function bulgePinch(centerX, centerY, radius, strength) {
        gl1.bulgePinch = gl1.bulgePinch || warpShader('\
        uniform float radius;\
        uniform float strength;\
        uniform vec2 center;\
    ', '\
        coord -= center;\
        float distance = length(coord);\
        if (distance < radius) {\
            float percent = distance / radius;\
            if (strength > 0.0) {\
                coord *= mix(1.0, smoothstep(0.0, radius / distance, percent), strength * 0.75);\
            } else {\
                coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);\
            }\
        }\
        coord += center;\
    ');
        simpleShader.call(this, gl1.bulgePinch, {
            radius: radius,
            strength: clamp(-1, strength, 1),
            center: [
                centerX,
                centerY
            ],
            texSize: [
                this.width,
                this.height
            ]
        });
        return this;
    }
    // src/filters\warp\matrixwarp.script
    /**
 * @filter                Matrix Warp
 * @description           Transforms an image by a 2x2 or 3x3 matrix. The coordinates used in
 *                        the transformation are (x, y) for a 2x2 matrix or (x, y, 1) for a
 *                        3x3 matrix, where x and y are in units of pixels.
 * @param matrix          A 2x2 or 3x3 matrix represented as either a list or a list of lists.
 *                        For example, the 3x3 matrix [[2,0,0],[0,3,0],[0,0,1]] can also be
 *                        represented as [2,0,0,0,3,0,0,0,1] or just [2,0,0,3].
 * @param inverse         A boolean value that, when true, applies the inverse transformation
 *                        instead. (optional, defaults to false)
 * @param useTextureSpace A boolean value that, when true, uses texture-space coordinates
 *                        instead of screen-space coordinates. Texture-space coordinates range
 *                        from -1 to 1 instead of 0 to width - 1 or height - 1, and are easier
 *                        to use for simple operations like flipping and rotating.
 */ function matrixWarp(matrix, inverse, useTextureSpace) {
        gl1.matrixWarp = gl1.matrixWarp || warpShader('\
        uniform mat3 matrix;\
        uniform bool useTextureSpace;\
    ', '\
        if (useTextureSpace) coord = coord / texSize * 2.0 - 1.0;\
        vec3 warp = matrix * vec3(coord, 1.0);\
        coord = warp.xy / warp.z;\
        if (useTextureSpace) coord = (coord * 0.5 + 0.5) * texSize;\
    ');
        // Flatten all members of matrix into one big list
        matrix = Array.prototype.concat.apply([], matrix);
        // Extract a 3x3 matrix out of the arguments
        if (matrix.length == 4) matrix = [
            matrix[0],
            matrix[1],
            0,
            matrix[2],
            matrix[3],
            0,
            0,
            0,
            1
        ];
        else if (matrix.length != 9) throw 'can only warp with 2x2 or 3x3 matrix';
        simpleShader.call(this, gl1.matrixWarp, {
            matrix: inverse ? getInverse(matrix) : matrix,
            texSize: [
                this.width,
                this.height
            ],
            useTextureSpace: useTextureSpace | 0
        });
        return this;
    }
    // src/filters\warp\perspective.script
    /**
 * @filter       Perspective
 * @description  Warps one quadrangle to another with a perspective transform. This can be used to
 *               make a 2D image look 3D or to recover a 2D image captured in a 3D environment.
 * @param before The x and y coordinates of four points before the transform in a flat list. This
 *               would look like [ax, ay, bx, by, cx, cy, dx, dy] for four points (ax, ay), (bx, by),
 *               (cx, cy), and (dx, dy).
 * @param after  The x and y coordinates of four points after the transform in a flat list, just
 *               like the other argument.
 */ function perspective(before, after) {
        let a = getSquareToQuad.apply(null, after);
        let b = getSquareToQuad.apply(null, before);
        let c = multiply(getInverse(a), b);
        return this.matrixWarp(c);
    }
    // src/filters\warp\swirl.script
    /**
 * @filter        Swirl
 * @description   Warps a circular region of the image in a swirl.
 * @param centerX The x coordinate of the center of the circular region.
 * @param centerY The y coordinate of the center of the circular region.
 * @param radius  The radius of the circular region.
 * @param angle   The angle in radians that the pixels in the center of
 *                the circular region will be rotated by.
 */ function swirl(centerX, centerY, radius, angle) {
        gl1.swirl = gl1.swirl || warpShader('\
        uniform float radius;\
        uniform float angle;\
        uniform vec2 center;\
    ', '\
        coord -= center;\
        float distance = length(coord);\
        if (distance < radius) {\
            float percent = (radius - distance) / radius;\
            float theta = percent * percent * angle;\
            float s = sin(theta);\
            float c = cos(theta);\
            coord = vec2(\
                coord.x * c - coord.y * s,\
                coord.x * s + coord.y * c\
            );\
        }\
        coord += center;\
    ');
        simpleShader.call(this, gl1.swirl, {
            radius: radius,
            center: [
                centerX,
                centerY
            ],
            angle: angle,
            texSize: [
                this.width,
                this.height
            ]
        });
        return this;
    }
    /**
 * @filter        Invert
 * @description   Inverts color of each pixel
 */ function invert() {
        gl1.invert = gl1.invert || new Shader1(null, '\
    uniform sampler2D texture;\
    uniform vec2 texSize;\
    varying vec2 texCoord;\
    \
    void main() {\
        vec4 color = texture2D(texture, texCoord);\
        gl_FragColor = vec4(1.0 - color.r, 1.0 - color.g, 1.0 - color.b, color.a);\
    }\
', 'invert');
        simpleShader.call(this, gl1.invert, {
            texSize: [
                this.width,
                this.height
            ]
        });
        return this;
    }
    /**
 * @filter        To Alpha
 * @description   Generates alpha channel from luminance (r+g+b)
 * @param isInverted    boolean - invert luminance
 * @param replaceRGBA    rgba - color to replace rgb with. if a = 0 -> keep orig color
 */ function toAlpha(isInverted, replaceRGBA) {
        gl1.toAlpha = gl1.toAlpha || new Shader1(null, '\
    uniform bool isInverted;\
    uniform vec4 replace;\
    uniform sampler2D texture;\
    uniform vec2 texSize;\
    varying vec2 texCoord;\
    \
    void main() {\
        vec4 color = texture2D(texture, texCoord);\
        float alpha = (color.r + color.g + color.b) / 3.0;\
        if (isInverted) alpha = 1.0 - alpha;\
        alpha = min(color.a, alpha);\
        if (replace.a > 0.0) color = replace;\
        gl_FragColor = vec4(color.r, color.g, color.b, alpha);\
    }\
', 'toAlpha');
        simpleShader.call(this, gl1.toAlpha, {
            isInverted: isInverted ? 1 : 0,
            replace: replaceRGBA ? [
                replaceRGBA.r / 255,
                replaceRGBA.g / 255,
                replaceRGBA.b / 255,
                replaceRGBA.a
            ] : [
                0,
                0,
                0,
                0
            ],
            texSize: [
                this.width,
                this.height
            ]
        });
        return this;
    }
    return exports;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"80GTF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cropExtend", ()=>cropExtend
);
var _bb = require("../../bb/bb");
var _input = require("../ui/base-components/input");
var _checkbox = require("../ui/base-components/checkbox");
var _colorOptions = require("../ui/base-components/color-options");
var _cropper = require("../ui/components/cropper");
var _language = require("../../language/language");
const cropExtend = {
    getDialog (params) {
        const canvas = params.canvas;
        if (!canvas) return false;
        const tempCanvas = _bb.BB.canvas();
        {
            let fit = _bb.BB.fitInto(canvas.getWidth(), canvas.getHeight(), 560, 400, 1);
            let w = parseInt('' + fit.width), h = parseInt('' + fit.height);
            let previewFactor = w / canvas.getWidth();
            tempCanvas.width = w;
            tempCanvas.height = h;
            tempCanvas.style.display = 'block';
            tempCanvas.getContext("2d").drawImage(canvas.getCompleteCanvas(previewFactor), 0, 0, w, h);
        }
        const div = document.createElement("div");
        const result = {
            element: div
        };
        div.innerHTML = _language.LANG('filter-crop-description') + "<br/><br/>";
        let left = 0, right = 0, top = 0, bottom = 0;
        let leftChanged = false, rightChanged = false, topChanged = false, bottomChanged = false;
        const maxWidth = params.maxWidth, maxHeight = params.maxHeight;
        let scale;
        // --- input elements ---
        const lrWrapper = _bb.BB.el({
            css: {
                lineHeight: '30px',
                height: '35px'
            }
        });
        const tbWrapper = _bb.BB.el({
            css: {
                lineHeight: '30px',
                height: '35px'
            }
        });
        div.appendChild(lrWrapper);
        div.appendChild(tbWrapper);
        const leftInput = _input.input({
            init: 0,
            type: 'number',
            min: -canvas.getWidth(),
            max: maxWidth,
            css: {
                width: '75px',
                marginRight: '20px'
            },
            callback: function(v) {
                leftChanged = true;
                updateInput();
            }
        });
        const rightInput = _input.input({
            init: 0,
            type: 'number',
            min: -canvas.getWidth(),
            max: maxWidth,
            css: {
                width: '75px'
            },
            callback: function(v) {
                rightChanged = true;
                updateInput();
            }
        });
        const topInput = _input.input({
            init: 0,
            type: 'number',
            min: -canvas.getHeight(),
            max: maxHeight,
            css: {
                width: '75px',
                marginRight: '20px'
            },
            callback: function(v) {
                topChanged = true;
                updateInput();
            }
        });
        const bottomInput = _input.input({
            init: 0,
            type: 'number',
            min: -canvas.getHeight(),
            max: maxHeight,
            css: {
                width: '75px'
            },
            callback: function(v) {
                bottomChanged = true;
                updateInput();
            }
        });
        const labelStyle = {
            display: 'inline-block',
            width: '60px'
        };
        lrWrapper.append(_bb.BB.el({
            content: _language.LANG('filter-crop-left') + ':',
            css: labelStyle
        }), leftInput, _bb.BB.el({
            content: _language.LANG('filter-crop-right') + ':',
            css: labelStyle
        }), rightInput);
        tbWrapper.append(_bb.BB.el({
            content: _language.LANG('filter-crop-top') + ':',
            css: labelStyle
        }), topInput, _bb.BB.el({
            content: _language.LANG('filter-crop-bottom') + ':',
            css: labelStyle
        }), bottomInput);
        function updateInput() {
            left = parseInt(leftInput.value);
            right = parseInt(rightInput.value);
            top = parseInt(topInput.value);
            bottom = parseInt(bottomInput.value);
            let newWidth = canvas.getWidth() + left + right;
            let newHeight = canvas.getHeight() + top + bottom;
            if (newWidth <= 0) {
                if (leftChanged) {
                    left = -canvas.getWidth() - right + 1;
                    leftInput.value = '' + left;
                }
                if (rightChanged) {
                    right = -canvas.getWidth() - left + 1;
                    rightInput.value = '' + right;
                }
                newWidth = 1;
            }
            if (newWidth > maxWidth) {
                if (leftChanged) {
                    left = -canvas.getWidth() - right + maxWidth;
                    leftInput.value = '' + left;
                }
                if (rightChanged) {
                    right = -canvas.getWidth() - left + maxWidth;
                    rightInput.value = '' + right;
                }
                newWidth = maxWidth;
            }
            if (newHeight <= 0) {
                if (topChanged) {
                    top = -canvas.getHeight() - bottom + 1;
                    topInput.value = '' + top;
                }
                if (bottomChanged) {
                    bottom = -canvas.getHeight() - top + 1;
                    bottomInput.value = '' + bottom;
                }
                newHeight = 1;
            }
            if (newHeight > maxHeight) {
                if (topChanged) {
                    top = -canvas.getHeight() - bottom + maxHeight;
                    topInput.value = '' + top;
                }
                if (bottomChanged) {
                    bottom = -canvas.getHeight() - top + maxHeight;
                    bottomInput.value = '' + bottom;
                }
                newHeight = maxHeight;
            }
            cropper.setTransform({
                x: -left,
                y: -top,
                width: newWidth,
                height: newHeight
            });
            leftChanged = false;
            rightChanged = false;
            topChanged = false;
            bottomChanged = false;
        }
        let useRuleOfThirds = true;
        let ruleOThirdsCheckbox = new _checkbox.Checkbox({
            init: true,
            label: _language.LANG('filter-crop-rule-thirds'),
            allowTab: true,
            callback: function(b) {
                useRuleOfThirds = b;
                cropper.showThirds(useRuleOfThirds);
            }
        });
        div.appendChild(_bb.BB.el({
            css: {
                clear: 'both'
            }
        }));
        let selectedRgbaObj = {
            r: 0,
            g: 0,
            b: 0,
            a: 0
        };
        const colorOptionsArr = [
            {
                r: 0,
                g: 0,
                b: 0,
                a: 0
            },
            {
                r: 255,
                g: 255,
                b: 255,
                a: 1
            },
            {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            }
        ];
        colorOptionsArr.push({
            r: params.currentColorRgb.r,
            g: params.currentColorRgb.g,
            b: params.currentColorRgb.b,
            a: 1
        });
        colorOptionsArr.push({
            r: params.secondaryColorRgb.r,
            g: params.secondaryColorRgb.g,
            b: params.secondaryColorRgb.b,
            a: 1
        });
        const colorOptions = new _colorOptions.ColorOptions({
            label: _language.LANG('filter-crop-fill'),
            colorArr: colorOptionsArr,
            onChange: function(rgbaObj) {
                selectedRgbaObj = rgbaObj;
                updateBg(rgbaObj);
            }
        });
        const flexRow = _bb.BB.el({
            css: {
                display: 'flex',
                justifyContent: 'space-between'
            }
        });
        div.appendChild(flexRow);
        flexRow.appendChild(ruleOThirdsCheckbox.getElement());
        flexRow.appendChild(colorOptions.getElement());
        // when input field changed, or dragging in preview finished
        // adjusts the zoom
        function update(transform) {
            const fit = _bb.BB.fitInto(transform.width, transform.height, 260, 180, 1);
            scale = fit.width / transform.width;
            const offset = _bb.BB.centerWithin(340, 220, fit.width, fit.height);
            tempCanvas.style.width = canvas.getWidth() * scale + "px";
            tempCanvas.style.height = canvas.getHeight() * scale + "px";
            offsetWrapper.style.left = offset.x - transform.x * scale + "px";
            offsetWrapper.style.top = offset.y - transform.y * scale + "px";
            left = parseInt('' + -transform.x);
            top = parseInt('' + -transform.y);
            right = parseInt('' + (transform.x + transform.width - canvas.getWidth()));
            bottom = parseInt('' + (transform.y + transform.height - canvas.getHeight()));
            leftInput.value = '' + left;
            topInput.value = '' + top;
            rightInput.value = '' + right;
            bottomInput.value = '' + bottom;
            _bb.BB.createCheckerDataUrl(parseInt('' + 50 * scale), function(url) {
                previewWrapper.style.background = "url(" + url + ")";
                if (selectedRgbaObj.a !== 0) tempCanvas.style.background = "url(" + url + ")";
            });
            previewWrapper.style.backgroundPosition = offset.x + "px " + offset.y + "px";
            cropper.setScale(scale);
        }
        const previewWrapper = _bb.BB.el({
            css: {
                width: "340px",
                marginTop: '10px',
                marginLeft: "-20px",
                height: "220px",
                backgroundColor: "#9e9e9e",
                position: "relative",
                boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
                overflow: "hidden",
                userSelect: 'none',
                colorScheme: 'only light',
                touchAction: 'none'
            }
        });
        previewWrapper.oncontextmenu = function() {
            return false;
        };
        const bgColorOverlay = _bb.BB.el({
            css: {
                position: 'absolute',
                left: '0',
                top: '0',
                bottom: '0',
                right: '0'
            }
        });
        previewWrapper.appendChild(bgColorOverlay);
        const offsetWrapper = document.createElement("div");
        offsetWrapper.style.position = "absolute";
        offsetWrapper.style.left = "0px";
        offsetWrapper.style.top = "0px";
        previewWrapper.appendChild(offsetWrapper);
        const canvasWrapper = _bb.BB.appendTextDiv(offsetWrapper, "");
        canvasWrapper.appendChild(tempCanvas);
        //tempCanvas.style.width = w + "px";
        //tempCanvas.style.height = h + "px";
        tempCanvas.style.boxShadow = "0 0 3px 1px rgba(0,0,0,0.5)";
        tempCanvas.style.position = "absolute";
        tempCanvas.style.left = "0px";
        tempCanvas.style.top = "0px";
        div.appendChild(previewWrapper);
        const cropper = new _cropper.Cropper({
            x: 0,
            y: 0,
            width: canvas.getWidth(),
            height: canvas.getHeight(),
            scale: scale,
            callback: update,
            maxW: maxWidth,
            maxH: maxHeight
        });
        update(cropper.getTransform());
        offsetWrapper.appendChild(cropper.getElement());
        function updateBg(rgbaObj) {
            let borderColor;
            if (rgbaObj.a === 0) {
                borderColor = 'rgba(0,0,0,0.5)';
                bgColorOverlay.style.background = '';
                tempCanvas.style.background = '';
            } else {
                borderColor = rgbaObj.r + rgbaObj.g + rgbaObj.b < 382.5 ? 'rgba(255,255,255,0.5)' : 'rgba(0,0,0,0.5)';
                bgColorOverlay.style.background = _bb.BB.ColorConverter.toRgbStr(rgbaObj);
                _bb.BB.createCheckerDataUrl(parseInt('' + 50 * scale), function(url) {
                    tempCanvas.style.background = "url(" + url + ")";
                });
            }
            tempCanvas.style.boxShadow = "0 0 3px 1px " + borderColor;
        }
        result.destroy = ()=>{
            cropper.destroy();
            ruleOThirdsCheckbox.destroy();
        };
        result.getInput = function() {
            result.destroy();
            return {
                left: left,
                right: right,
                top: top,
                bottom: bottom,
                fillColor: selectedRgbaObj.a === 0 ? null : selectedRgbaObj
            };
        };
        return result;
    },
    apply (params) {
        const canvas = params.canvas;
        const history = params.history;
        if (!canvas || !history || isNaN(params.input.left) || isNaN(params.input.right) || isNaN(params.input.top) || isNaN(params.input.bottom)) return false;
        history.pause(true);
        canvas.resizeCanvas(params.input);
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "cropExtend"
            ],
            action: "apply",
            params: [
                {
                    input: JSON.parse(JSON.stringify(params.input))
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"e3nbn","../ui/base-components/input":"1HM9r","../ui/base-components/checkbox":"clzcQ","../ui/base-components/color-options":"6ALHb","../ui/components/cropper":"eE4e1","../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"au1MQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "glCurves", ()=>glCurves
);
var _bb = require("../../bb/bb");
var _options = require("../ui/base-components/options");
var _canvasPreview = require("../canvas-ui/canvas-preview");
var _sharedGlFx = require("./shared-gl-fx");
var _language = require("../../language/language");
const glCurves = {
    getDialog (params) {
        let context = params.context;
        let canvas1 = params.canvas;
        if (!context || !canvas1) return false;
        let layers = canvas1.getLayers();
        let selectedLayerIndex = canvas1.getLayerIndex(context.canvas);
        let fit1 = _bb.BB.fitInto(context.canvas.width, context.canvas.height, 280, 200, 1);
        let w = parseInt('' + fit1.width), h = parseInt('' + fit1.height);
        let tempCanvas = _bb.BB.canvas(w, h);
        {
            const ctx = tempCanvas.getContext("2d");
            ctx.save();
            if (tempCanvas.width > context.canvas.width) ctx.imageSmoothingEnabled = false;
            ctx.drawImage(context.canvas, 0, 0, w, h);
            ctx.restore();
        }
        let div1 = document.createElement("div");
        let result = {
            element: div1
        };
        let klCanvasPreview;
        function finishInit() {
            let previewFactor = w / context.canvas.width;
            let brightness = 0, contrast = 0;
            div1.innerHTML = _language.LANG('filter-curves-description') + "<br/><br/>";
            let curves1 = {
                r: [
                    [
                        0,
                        0
                    ],
                    [
                        1 / 3,
                        1 / 3
                    ],
                    [
                        2 / 3,
                        2 / 3
                    ],
                    [
                        1,
                        1
                    ]
                ],
                g: [
                    [
                        0,
                        0
                    ],
                    [
                        1 / 3,
                        1 / 3
                    ],
                    [
                        2 / 3,
                        2 / 3
                    ],
                    [
                        1,
                        1
                    ]
                ],
                b: [
                    [
                        0,
                        0
                    ],
                    [
                        1 / 3,
                        1 / 3
                    ],
                    [
                        2 / 3,
                        2 / 3
                    ],
                    [
                        1,
                        1
                    ]
                ]
            };
            let glCanvas = _sharedGlFx.getSharedFx();
            if (!glCanvas) return; // todo throw?
            let texture = glCanvas.texture(tempCanvas);
            glCanvas.draw(texture).update(); // update glCanvas size
            function update1() {
                try {
                    glCanvas.draw(texture).curves(curves1.r, curves1.g, curves1.b).update();
                    if (klCanvasPreview) klCanvasPreview.render();
                } catch (e) {
                    div1.errorCallback(e);
                }
            }
            let modeButtons;
            function CurvesInput(p) {
                let div = document.createElement("div");
                div.oncontextmenu = function() {
                    return false;
                };
                div.style.position = "relative";
                div.style.marginBottom = "10px";
                let mode = "All";
                let curves = p.curves;
                modeButtons = new _options.Options({
                    optionArr: [
                        {
                            id: 'All',
                            label: _language.LANG('filter-curves-all')
                        },
                        {
                            id: 'Red',
                            label: _language.LANG('red')
                        },
                        {
                            id: 'Green',
                            label: _language.LANG('green')
                        },
                        {
                            id: 'Blue',
                            label: _language.LANG('blue')
                        }, 
                    ],
                    initialId: 'All',
                    onChange: function(id) {
                        mode = id;
                        if (mode === "All") curves = {
                            r: [
                                [
                                    0,
                                    0
                                ],
                                [
                                    1 / 3,
                                    1 / 3
                                ],
                                [
                                    2 / 3,
                                    2 / 3
                                ],
                                [
                                    1,
                                    1
                                ]
                            ],
                            g: [
                                [
                                    0,
                                    0
                                ],
                                [
                                    1 / 3,
                                    1 / 3
                                ],
                                [
                                    2 / 3,
                                    2 / 3
                                ],
                                [
                                    1,
                                    1
                                ]
                            ],
                            b: [
                                [
                                    0,
                                    0
                                ],
                                [
                                    1 / 3,
                                    1 / 3
                                ],
                                [
                                    2 / 3,
                                    2 / 3
                                ],
                                [
                                    1,
                                    1
                                ]
                            ]
                        };
                        let curve = curves.r;
                        if (mode === "Green") curve = curves.g;
                        if (mode === "Blue") curve = curves.b;
                        p0.setPos(0, areah - curve[0][1] * areah);
                        p1.setPos(curve[1][0] * areaw, areah - curve[1][1] * areah);
                        p2.setPos(curve[2][0] * areaw, areah - curve[2][1] * areah);
                        p3.setPos(areaw, areah - curve[3][1] * areah);
                        update2();
                    }
                });
                div.appendChild(modeButtons.getElement());
                let curveArea = document.createElement("div");
                _bb.BB.css(curveArea, {
                    position: 'relative',
                    marginTop: '10px',
                    colorScheme: 'only light'
                });
                div.appendChild(curveArea);
                let areaw = 300, areah = 100;
                let canvas = document.createElement("canvas");
                canvas.width = areaw;
                canvas.height = areah;
                _bb.BB.css(canvas, {
                    background: "#c6c6c6",
                    boxShadow: "0 0 0 1px rgba(0,0,0,0.3)"
                });
                let ctx = canvas.getContext("2d");
                curveArea.appendChild(canvas);
                let points = {
                    r: [],
                    g: [],
                    b: []
                };
                function fit(v) {
                    return Math.max(0, Math.min(1, v));
                }
                function createPoint(x, y, callback, lock) {
                    let gripSize = 14;
                    let internalY = y, internalX = x;
                    let point = document.createElement("div");
                    _bb.BB.css(point, {
                        position: "absolute",
                        left: x - gripSize / 2 + "px",
                        top: y - gripSize / 2 + "px",
                        width: gripSize + "px",
                        height: gripSize + "px",
                        background: "#fff",
                        cursor: "move",
                        borderRadius: gripSize + "px",
                        boxShadow: "inset 0 0 0 2px #000",
                        userSelect: 'none',
                        touchAction: 'none'
                    });
                    function update() {
                        _bb.BB.css(point, {
                            left: x - gripSize / 2 + "px",
                            top: y - gripSize / 2 + "px"
                        });
                    }
                    point.pointerListener = new _bb.BB.PointerListener({
                        target: point,
                        maxPointers: 1,
                        onPointer: function(event) {
                            event.eventPreventDefault();
                            if (event.type === 'pointerdown') {
                                internalX = x;
                                internalY = y;
                            }
                            if (event.button === 'left' && event.type === 'pointermove') {
                                if (!lock) internalX += event.dX;
                                x = Math.max(0, Math.min(areaw, internalX));
                                internalY += event.dY;
                                y = Math.max(0, Math.min(areah, internalY));
                                update();
                                callback({
                                    x: x,
                                    y: y
                                });
                            }
                        }
                    });
                    curveArea.appendChild(point);
                    point.setPos = function(newX, newY) {
                        x = newX;
                        y = newY;
                        internalY = y;
                        internalX = x;
                        _bb.BB.css(point, {
                            left: x - gripSize / 2 + "px",
                            top: y - gripSize / 2 + "px"
                        });
                    };
                    return point;
                }
                function updateControl(i, x, y) {
                    if (mode === "All") {
                        curves.r[i] = [
                            fit(x / areaw),
                            fit(1 - y / areah)
                        ];
                        curves.g[i] = [
                            fit(x / areaw),
                            fit(1 - y / areah)
                        ];
                        curves.b[i] = [
                            fit(x / areaw),
                            fit(1 - y / areah)
                        ];
                    }
                    if (mode === "Red") curves.r[i] = [
                        fit(x / areaw),
                        fit(1 - y / areah)
                    ];
                    if (mode === "Green") curves.g[i] = [
                        fit(x / areaw),
                        fit(1 - y / areah)
                    ];
                    if (mode === "Blue") curves.b[i] = [
                        fit(x / areaw),
                        fit(1 - y / areah)
                    ];
                }
                let p0 = createPoint(0, areah, function(val) {
                    updateControl(0, val.x, val.y);
                    update2();
                }, true);
                let p1 = createPoint(areaw / 3, areah / 3 * 2, function(val) {
                    updateControl(1, val.x, val.y);
                    update2();
                });
                let p2 = createPoint(areaw / 3 * 2, areah / 3, function(val) {
                    updateControl(2, val.x, val.y);
                    update2();
                });
                let p3 = createPoint(areaw, 0, function(val) {
                    updateControl(3, val.x, val.y);
                    update2();
                }, true);
                function update2() {
                    canvas.width = canvas.width;
                    ctx = canvas.getContext("2d");
                    let outCurves = {
                        r: [],
                        g: [],
                        b: []
                    };
                    for(let i2 = 0; i2 < curves.r.length; i2++){
                        outCurves.r.push(curves.r[i2]);
                        outCurves.g.push(curves.g[i2]);
                        outCurves.b.push(curves.b[i2]);
                    }
                    function drawCurve(curve) {
                        ctx.beginPath();
                        let spline = new _bb.BB.SplineInterpolator(curve);
                        for(let i = 0; i < 100; i++){
                            let y = spline.interpolate(i / 100);
                            y = Math.max(0, Math.min(1, y));
                            if (i === 0) ctx.moveTo(i / 100 * areaw, areah - y * areah);
                            else ctx.lineTo(i / 100 * areaw, areah - y * areah);
                        }
                        ctx.stroke();
                    }
                    ctx.save();
                    if (mode === "All") {
                        ctx.strokeStyle = "black";
                        drawCurve(outCurves.r);
                    } else {
                        ctx.globalAlpha = 0.5;
                        ctx.strokeStyle = "red";
                        drawCurve(outCurves.r);
                        ctx.strokeStyle = "green";
                        drawCurve(outCurves.g);
                        ctx.strokeStyle = "blue";
                        drawCurve(outCurves.b);
                    }
                    ctx.restore();
                    p.callback(outCurves);
                }
                update2();
                this.getDiv = function() {
                    return div;
                };
                this.destroy = function() {
                    p0.pointerListener.destroy();
                    p1.pointerListener.destroy();
                    p2.pointerListener.destroy();
                    p3.pointerListener.destroy();
                };
            }
            let input = new CurvesInput({
                curves: curves1,
                callback: function(val) {
                    curves1 = val;
                    update1();
                }
            });
            div1.appendChild(input.getDiv());
            let previewWrapper = document.createElement("div");
            _bb.BB.css(previewWrapper, {
                width: "340px",
                marginLeft: "-20px",
                height: "220px",
                backgroundColor: "#9e9e9e",
                marginTop: "10px",
                boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
                overflow: "hidden",
                position: "relative",
                userSelect: 'none',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                colorScheme: 'only light'
            });
            let previewLayerArr = [];
            for(let i1 = 0; i1 < layers.length; i1++)previewLayerArr.push({
                image: i1 === selectedLayerIndex ? glCanvas : layers[i1].context.canvas,
                opacity: layers[i1].opacity,
                mixModeStr: layers[i1].mixModeStr
            });
            klCanvasPreview = new _canvasPreview.KlCanvasPreview({
                width: parseInt('' + w),
                height: parseInt('' + h),
                layers: previewLayerArr
            });
            let previewInnerWrapper = _bb.BB.el({
                css: {
                    position: 'relative',
                    boxShadow: '0 0 5px rgba(0,0,0,0.5)',
                    width: parseInt('' + w) + 'px',
                    height: parseInt('' + h) + 'px'
                }
            });
            previewInnerWrapper.appendChild(klCanvasPreview.getElement());
            previewWrapper.appendChild(previewInnerWrapper);
            div1.appendChild(previewWrapper);
            result.destroy = ()=>{
                input.destroy();
                texture.destroy();
                modeButtons.destroy();
            };
            result.getInput = function() {
                result.destroy();
                return {
                    curves: curves1
                };
            };
        }
        setTimeout(finishInit, 1);
        return result;
    },
    apply (params) {
        let context = params.context;
        let curves = params.input.curves;
        let history = params.history;
        if (!context || curves === null || !history) return false;
        history.pause(true);
        let glCanvas = _sharedGlFx.getSharedFx();
        if (!glCanvas) return false; // todo more specific error?
        let texture = glCanvas.texture(context.canvas);
        glCanvas.draw(texture).curves(curves.r, curves.g, curves.b).update();
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(glCanvas, 0, 0);
        texture.destroy();
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "glCurves"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"e3nbn","../ui/base-components/options":"b8ZKE","../canvas-ui/canvas-preview":"9a0UP","./shared-gl-fx":"4XYAu","../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"lS7aV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "flip", ()=>flip
);
var _bb = require("../../bb/bb");
var _checkbox = require("../ui/base-components/checkbox");
var _canvasPreview = require("../canvas-ui/canvas-preview");
// @ts-ignore
var _checkmarkSvg = require("url:~/src/app/img/ui/checkmark.svg");
var _checkmarkSvgDefault = parcelHelpers.interopDefault(_checkmarkSvg);
var _language = require("../../language/language");
const flip = {
    getDialog (params) {
        let context = params.context;
        let canvas = params.canvas;
        if (!context || !canvas) return false;
        let layers = canvas.getLayers();
        let selectedLayerIndex = canvas.getLayerIndex(context.canvas);
        let fit = _bb.BB.fitInto(context.canvas.width, context.canvas.height, 280, 200, 1);
        let w = parseInt('' + fit.width), h = parseInt('' + fit.height);
        let div = document.createElement("div");
        let result = {
            element: div
        };
        let isHorizontal = true;
        let isVertical = false;
        let doFlipCanvas = true;
        div.innerHTML = _language.LANG('filter-flip-description') + "<br/><br/>";
        let horizontalCheckbox = new _checkbox.Checkbox({
            init: isHorizontal,
            label: _language.LANG('filter-flip-horizontal') + ' ⟷',
            allowTab: true,
            callback: function(v) {
                isHorizontal = v;
                updatePreview();
            },
            css: {
                marginBottom: '10px'
            }
        });
        let verticalCheckbox = new _checkbox.Checkbox({
            init: isVertical,
            label: _language.LANG('filter-flip-vertical') + ' ↕',
            allowTab: true,
            callback: function(v) {
                isVertical = v;
                updatePreview();
            },
            css: {
                marginBottom: '10px'
            }
        });
        div.appendChild(horizontalCheckbox.getElement());
        div.appendChild(verticalCheckbox.getElement());
        let fcOption = document.createElement("div");
        _bb.BB.setEventListener(fcOption, 'onpointerdown', function() {
            return false;
        });
        fcOption.textContent = _language.LANG('filter-flip-image');
        fcOption.style.width = "150px";
        fcOption.style.height = "30px";
        fcOption.style.paddingTop = "10px";
        fcOption.style.textAlign = "center";
        fcOption.style.cssFloat = "left";
        fcOption.style.paddingBottom = "0px";
        fcOption.style.borderTopLeftRadius = "10px";
        fcOption.style.boxShadow = "inset 0px 5px 10px rgba(0,0,0,0.5)";
        fcOption.style.background = "url(" + _checkmarkSvgDefault.default + ") no-repeat 12px 16px";
        fcOption.style.backgroundSize = '8%';
        fcOption.style.backgroundColor = "#9e9e9e";
        let flOption = document.createElement("div");
        _bb.BB.setEventListener(flOption, 'onpointerdown', function() {
            return false;
        });
        flOption.textContent = _language.LANG('filter-flip-layer');
        flOption.style.width = "150px";
        flOption.style.height = "30px";
        flOption.style.paddingTop = "10px";
        flOption.style.textAlign = "center";
        flOption.style.cssFloat = "left";
        flOption.style.paddingBottom = "0px";
        flOption.style.borderTopRightRadius = "10px";
        flOption.style.cursor = "pointer";
        flOption.style.backgroundColor = "rgba(0, 0, 0, 0.1)";
        flOption.style.backgroundSize = '8%';
        _bb.BB.setEventListener(fcOption, 'onpointerover', function() {
            if (doFlipCanvas === false) fcOption.style.backgroundColor = "#ccc";
        });
        _bb.BB.setEventListener(fcOption, 'onpointerout', function() {
            if (doFlipCanvas === false) fcOption.style.backgroundColor = "rgba(0, 0, 0, 0.1)";
        });
        _bb.BB.setEventListener(flOption, 'onpointerover', function() {
            if (doFlipCanvas === true) flOption.style.backgroundColor = "#ccc";
        });
        _bb.BB.setEventListener(flOption, 'onpointerout', function() {
            if (doFlipCanvas === true) flOption.style.backgroundColor = "rgba(0, 0, 0, 0.1)";
        });
        fcOption.onclick = function() {
            doFlipCanvas = true;
            flOption.style.background = "";
            flOption.style.backgroundColor = "rgba(0, 0, 0, 0.1)";
            flOption.style.boxShadow = "";
            flOption.style.cursor = "pointer";
            fcOption.style.background = "url(" + _checkmarkSvgDefault.default + ") no-repeat 12px 16px";
            fcOption.style.backgroundSize = '8%';
            fcOption.style.backgroundColor = "#9e9e9e";
            fcOption.style.cursor = "default";
            fcOption.style.boxShadow = "inset 0px 5px 10px rgba(0,0,0,0.5)";
            updatePreview();
        };
        flOption.onclick = function() {
            doFlipCanvas = false;
            fcOption.style.background = "";
            fcOption.style.backgroundColor = "rgba(0, 0, 0, 0.1)";
            fcOption.style.boxShadow = "";
            fcOption.style.cursor = "pointer";
            flOption.style.background = "url(" + _checkmarkSvgDefault.default + ") no-repeat 12px 16px";
            flOption.style.backgroundSize = '8%';
            flOption.style.backgroundColor = "#9e9e9e";
            flOption.style.cursor = "default";
            flOption.style.boxShadow = "inset 0px 5px 10px rgba(0,0,0,0.5)";
            updatePreview();
        };
        let optionWrapper = document.createElement("div");
        optionWrapper.appendChild(fcOption);
        optionWrapper.appendChild(flOption);
        div.appendChild(optionWrapper);
        let previewWrapper = document.createElement("div");
        _bb.BB.css(previewWrapper, {
            width: "340px",
            marginLeft: "-20px",
            height: "220px",
            backgroundColor: "#9e9e9e",
            marginTop: "10px",
            boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
            overflow: "hidden",
            position: "relative",
            userSelect: 'none',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            colorScheme: 'only light'
        });
        let previewLayer = {
            image: _bb.BB.canvas(Math.round(w), Math.round(h)),
            opacity: 1,
            mixModeStr: 'source-over'
        };
        let klCanvasPreview = new _canvasPreview.KlCanvasPreview({
            width: Math.round(w),
            height: Math.round(h),
            layers: [
                previewLayer
            ]
        });
        let previewInnerWrapper = _bb.BB.el({
            css: {
                position: 'relative',
                boxShadow: '0 0 5px rgba(0,0,0,0.5)',
                width: parseInt('' + w) + 'px',
                height: parseInt('' + h) + 'px'
            }
        });
        previewInnerWrapper.appendChild(klCanvasPreview.getElement());
        previewWrapper.appendChild(previewInnerWrapper);
        function updatePreview() {
            let ctx = previewLayer.image.getContext('2d');
            ctx.save();
            ctx.clearRect(0, 0, previewLayer.image.width, previewLayer.image.height);
            if (doFlipCanvas) {
                if (isHorizontal) {
                    ctx.translate(previewLayer.image.width, 0);
                    ctx.scale(-1, 1);
                }
                if (isVertical) {
                    ctx.translate(0, previewLayer.image.height);
                    ctx.scale(1, -1);
                }
            }
            for(let i = 0; i < layers.length; i++){
                ctx.save();
                if (!doFlipCanvas && selectedLayerIndex === i) {
                    if (isHorizontal) {
                        ctx.translate(previewLayer.image.width, 0);
                        ctx.scale(-1, 1);
                    }
                    if (isVertical) {
                        ctx.translate(0, previewLayer.image.height);
                        ctx.scale(1, -1);
                    }
                }
                if (ctx.canvas.width > layers[i].context.canvas.width) ctx.imageSmoothingEnabled = false;
                ctx.globalAlpha = layers[i].opacity;
                ctx.globalCompositeOperation = layers[i].mixModeStr;
                ctx.drawImage(layers[i].context.canvas, 0, 0, previewLayer.image.width, previewLayer.image.height);
                ctx.restore();
            }
            klCanvasPreview.render();
            ctx.restore();
        }
        setTimeout(updatePreview, 0);
        div.appendChild(previewWrapper);
        result.destroy = ()=>{
            horizontalCheckbox.destroy();
            verticalCheckbox.destroy();
        };
        result.getInput = function() {
            result.destroy();
            return {
                horizontal: isHorizontal,
                vertical: isVertical,
                flipCanvas: doFlipCanvas
            };
        };
        return result;
    },
    apply (params) {
        let context = params.context;
        let canvas = params.canvas;
        let history = params.history;
        let horizontal = params.input.horizontal;
        let vertical = params.input.vertical;
        let flipCanvas = params.input.flipCanvas;
        if (!context || !canvas || !history) return false;
        history.pause(true);
        canvas.flip(horizontal, vertical, flipCanvas ? null : canvas.getLayerIndex(context.canvas));
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "flip"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"e3nbn","../ui/base-components/checkbox":"clzcQ","../canvas-ui/canvas-preview":"9a0UP","url:~/src/app/img/ui/checkmark.svg":"kSVdA","../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kSVdA":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "checkmark.1122f61b.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"etu1E":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "glHueSaturation", ()=>glHueSaturation
);
var _bb = require("../../bb/bb");
var _filtersConsts = require("./filters-consts");
var _klSlider = require("../ui/base-components/kl-slider");
var _canvasPreview = require("../canvas-ui/canvas-preview");
var _sharedGlFx = require("./shared-gl-fx");
var _language = require("../../language/language");
const glHueSaturation = {
    getDialog (params) {
        let context = params.context;
        let canvas = params.canvas;
        if (!context || !canvas) return false;
        let layers = canvas.getLayers();
        let selectedLayerIndex = canvas.getLayerIndex(context.canvas);
        let fit = _bb.BB.fitInto(context.canvas.width, context.canvas.height, 280, 200, 1);
        let w = parseInt('' + fit.width), h = parseInt('' + fit.height);
        let tempCanvas = _bb.BB.canvas(w, h);
        {
            const ctx = tempCanvas.getContext("2d");
            ctx.save();
            if (tempCanvas.width > context.canvas.width) ctx.imageSmoothingEnabled = false;
            ctx.drawImage(context.canvas, 0, 0, w, h);
            ctx.restore();
        }
        let div = document.createElement("div");
        let result = {
            element: div
        };
        function finishInit() {
            let hue = 0, Saturation = 0;
            div.innerHTML = _language.LANG('filter-hue-sat-description') + "<br/><br/>";
            let glCanvas = _sharedGlFx.getSharedFx();
            if (!glCanvas) return; // todo throw?
            let texture = glCanvas.texture(tempCanvas);
            glCanvas.draw(texture).update(); // update glCanvas size
            let hueSlider = new _klSlider.KlSlider({
                label: _language.LANG('filter-hue-sat-hue'),
                width: 300,
                height: 30,
                min: -100,
                max: 100,
                initValue: hue * 100,
                eventResMs: _filtersConsts.eventResMs,
                onChange: function(val) {
                    hue = val / 100;
                    glCanvas.draw(texture).hueSaturation(hue, Saturation).update();
                    klCanvasPreview.render();
                }
            });
            let saturationSlider = new _klSlider.KlSlider({
                label: _language.LANG('filter-hue-sat-saturation'),
                width: 300,
                height: 30,
                min: 0,
                max: 100,
                initValue: (Saturation + 1) * 50,
                eventResMs: _filtersConsts.eventResMs,
                onChange: function(val) {
                    Saturation = val / 50 - 1;
                    glCanvas.draw(texture).hueSaturation(hue, Saturation).update();
                    klCanvasPreview.render();
                }
            });
            hueSlider.getElement().style.marginBottom = "10px";
            div.appendChild(hueSlider.getElement());
            div.appendChild(saturationSlider.getElement());
            let previewWrapper = document.createElement("div");
            _bb.BB.css(previewWrapper, {
                width: "340px",
                marginLeft: "-20px",
                height: "220px",
                backgroundColor: "#9e9e9e",
                marginTop: "10px",
                boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
                overflow: "hidden",
                position: "relative",
                userSelect: 'none',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                colorScheme: 'only light'
            });
            let previewLayerArr = [];
            for(let i = 0; i < layers.length; i++)previewLayerArr.push({
                image: i === selectedLayerIndex ? glCanvas : layers[i].context.canvas,
                opacity: layers[i].opacity,
                mixModeStr: layers[i].mixModeStr
            });
            let klCanvasPreview = new _canvasPreview.KlCanvasPreview({
                width: parseInt('' + w),
                height: parseInt('' + h),
                layers: previewLayerArr
            });
            let previewInnerWrapper = _bb.BB.el({
                css: {
                    position: 'relative',
                    boxShadow: '0 0 5px rgba(0,0,0,0.5)',
                    width: parseInt('' + w) + 'px',
                    height: parseInt('' + h) + 'px'
                }
            });
            previewInnerWrapper.appendChild(klCanvasPreview.getElement());
            previewWrapper.appendChild(previewInnerWrapper);
            div.appendChild(previewWrapper);
            try {
                glCanvas.draw(texture).hueSaturation(hue, Saturation).update();
                klCanvasPreview.render();
            } catch (e) {
                div.errorCallback(e);
            }
            result.destroy = ()=>{
                hueSlider.destroy();
                saturationSlider.destroy();
                texture.destroy();
            };
            result.getInput = function() {
                result.destroy();
                return {
                    hue: hue,
                    Saturation: Saturation
                };
            };
        }
        setTimeout(finishInit, 1);
        return result;
    },
    apply (params) {
        let context = params.context;
        let hue = params.input.hue;
        let history = params.history;
        let Saturation = params.input.Saturation;
        if (!context || hue === null || Saturation === null || !history) return false;
        history.pause(true);
        let glCanvas = _sharedGlFx.getSharedFx();
        if (!glCanvas) return false; // todo more specific error?
        let texture = glCanvas.texture(context.canvas);
        glCanvas.draw(texture).hueSaturation(hue, Saturation).update();
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(glCanvas, 0, 0);
        texture.destroy();
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "glHueSaturation"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"e3nbn","./filters-consts":"hTXbX","../ui/base-components/kl-slider":"1Vedp","../canvas-ui/canvas-preview":"9a0UP","./shared-gl-fx":"4XYAu","../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"4DqUn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "invert", ()=>invert
);
var _sharedGlFx = require("./shared-gl-fx");
const invert = {
    apply (params) {
        let context = params.context;
        let history = params.history;
        if (!context || !history) return false;
        history.pause(true);
        let glCanvas = _sharedGlFx.getSharedFx();
        if (!glCanvas) return false;
        let texture = glCanvas.texture(context.canvas);
        glCanvas.draw(texture).invert().update();
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(glCanvas, 0, 0);
        texture.destroy();
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "invert"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"./shared-gl-fx":"4XYAu","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"im35R":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "glPerspective", ()=>glPerspective
);
var _bb = require("../../bb/bb");
var _canvasPreview = require("../canvas-ui/canvas-preview");
// @ts-ignore
var _checkmarkSvg = require("url:~/src/app/img/ui/checkmark.svg");
var _checkmarkSvgDefault = parcelHelpers.interopDefault(_checkmarkSvg);
var _sharedGlFx = require("./shared-gl-fx");
var _language = require("../../language/language");
const glPerspective = {
    getDialog (params) {
        let context = params.context;
        let canvas1 = params.canvas;
        if (!context || !canvas1) return false;
        let isSmall = window.innerWidth < 550;
        let layers = canvas1.getLayers();
        let selectedLayerIndex = canvas1.getLayerIndex(context.canvas);
        let fit = _bb.BB.fitInto(context.canvas.width, context.canvas.height, isSmall ? 280 : 490, isSmall ? 200 : 240, 1);
        let displayW = parseInt('' + fit.width), displayH = parseInt('' + fit.height);
        let w = Math.min(displayW, context.canvas.width);
        let h = Math.min(displayH, context.canvas.height);
        let tempCanvas = _bb.BB.canvas(w, h);
        {
            const ctx = tempCanvas.getContext("2d");
            ctx.save();
            if (w > context.canvas.width) ctx.imageSmoothingEnabled = false;
            ctx.drawImage(context.canvas, 0, 0, w, h);
            ctx.restore();
        }
        let displayPreviewFactor = displayW / context.canvas.width;
        let div1 = document.createElement("div");
        let result = {
            element: div1
        };
        if (!isSmall) result.width = 500;
        let pointerListenerArr = [];
        function finishInit() {
            div1.innerHTML = _language.LANG('filter-perspective-description') + "<br/><br/>";
            let glCanvas = _sharedGlFx.getSharedFx();
            if (!glCanvas) return; // todo throw?
            let texture = glCanvas.texture(tempCanvas);
            glCanvas.draw(texture).update(); // update glCanvas size
            let ba, bb, bc, bd; //before
            let aa, ab, ac, ad; //after
            function update() {
                try {
                    glCanvas.draw(texture).perspective([
                        ba.x,
                        ba.y,
                        bb.x,
                        bb.y,
                        bc.x,
                        bc.y,
                        bd.x,
                        bd.y
                    ].map((item, i)=>{
                        if (i % 2 === 0) return item / displayW * w;
                        else return item / displayH * h;
                    }), [
                        aa.x,
                        aa.y,
                        ab.x,
                        ab.y,
                        ac.x,
                        ac.y,
                        ad.x,
                        ad.y
                    ].map((item, i)=>{
                        if (i % 2 === 0) return item / displayW * w;
                        else return item / displayH * h;
                    })).update();
                    klCanvasPreview.render();
                } catch (e) {
                    div1.errorCallback(e);
                }
            }
            function nob(x, y, callback) {
                let nobSize = 14;
                let div = document.createElement("div");
                div.x = x;
                div.y = y;
                _bb.BB.css(div, {
                    width: nobSize + "px",
                    height: nobSize + "px",
                    backgroundColor: "#fff",
                    boxShadow: "inset 0 0 0 2px #000",
                    borderRadius: nobSize + "px",
                    position: "absolute",
                    cursor: "move",
                    left: div.x - nobSize / 2 + "px",
                    top: div.y - nobSize / 2 + "px",
                    userSelect: 'none',
                    touchAction: 'none'
                });
                let pointerListener = new _bb.BB.PointerListener({
                    target: div,
                    maxPointers: 1,
                    onPointer: function(event) {
                        event.eventPreventDefault();
                        if (event.button === 'left' && event.type === 'pointermove') {
                            div.x += event.dX;
                            div.y += event.dY;
                            div.style.left = div.x - nobSize / 2 + "px";
                            div.style.top = div.y - nobSize / 2 + "px";
                            if (callback) callback();
                            update();
                        }
                    }
                });
                div.copy = function(p) {
                    div.x = p.x;
                    div.y = p.y;
                    div.style.left = div.x - nobSize / 2 + "px";
                    div.style.top = div.y - nobSize / 2 + "px";
                };
                pointerListenerArr.push(pointerListener);
                return div;
            }
            function updateAfter() {
                aa.copy(ba);
                ab.copy(bb);
                ac.copy(bc);
                ad.copy(bd);
            }
            ba = nob(0, 0, updateAfter);
            bb = nob(displayW, 0, updateAfter);
            bc = nob(displayW, displayH, updateAfter);
            bd = nob(0, displayH, updateAfter);
            aa = nob(0, 0);
            ab = nob(displayW, 0);
            ac = nob(displayW, displayH);
            ad = nob(0, displayH);
            let before = false;
            let beforeOption = document.createElement("div");
            _bb.BB.setEventListener(beforeOption, 'onpointerdown', function() {
                return false;
            });
            beforeOption.textContent = _language.LANG('filter-perspective-before');
            beforeOption.style.width = "150px";
            beforeOption.style.height = "30px";
            beforeOption.style.marginLeft = isSmall ? '0' : "100px";
            beforeOption.style.paddingTop = "10px";
            beforeOption.style.textAlign = "center";
            beforeOption.style.cssFloat = "left";
            beforeOption.style.paddingBottom = "0px";
            beforeOption.style.borderTopLeftRadius = "10px";
            beforeOption.style.cursor = "pointer";
            beforeOption.style.backgroundColor = "rgba(0, 0, 0, 0.1)";
            beforeOption.style.backgroundSize = '8%';
            let afterOption = document.createElement("div");
            _bb.BB.setEventListener(afterOption, 'onpointerdown', function() {
                return false;
            });
            afterOption.textContent = _language.LANG('filter-perspective-after');
            afterOption.style.width = "150px";
            afterOption.style.height = "30px";
            afterOption.style.paddingTop = "10px";
            afterOption.style.textAlign = "center";
            afterOption.style.cssFloat = "left";
            afterOption.style.paddingBottom = "0px";
            afterOption.style.borderTopRightRadius = "10px";
            afterOption.style.boxShadow = "inset 0px 5px 10px rgba(0,0,0,0.5)";
            afterOption.style.background = "url(" + _checkmarkSvgDefault.default + ") no-repeat 12px 16px";
            afterOption.style.backgroundSize = '8%';
            afterOption.style.backgroundColor = "#9e9e9e";
            _bb.BB.setEventListener(beforeOption, 'onpointerover', function() {
                if (before === false) beforeOption.style.backgroundColor = "#ccc";
            });
            _bb.BB.setEventListener(beforeOption, 'onpointerout', function() {
                if (before === false) beforeOption.style.backgroundColor = "rgba(0, 0, 0, 0.1)";
            });
            _bb.BB.setEventListener(afterOption, 'onpointerover', function() {
                if (before === true) afterOption.style.backgroundColor = "#ccc";
            });
            _bb.BB.setEventListener(afterOption, 'onpointerout', function() {
                if (before === true) afterOption.style.backgroundColor = "rgba(0, 0, 0, 0.1)";
            });
            beforeOption.onclick = function() {
                beforeOption.style.background = "url(" + _checkmarkSvgDefault.default + ") no-repeat 12px 16px";
                beforeOption.style.backgroundSize = '8%';
                beforeOption.style.backgroundColor = "#9e9e9e";
                beforeOption.style.boxShadow = "inset 0px 5px 10px rgba(0,0,0,0.5)";
                beforeOption.style.cursor = "default";
                afterOption.style.background = "";
                afterOption.style.backgroundColor = "rgba(0, 0, 0, 0.1)";
                afterOption.style.boxShadow = "";
                afterOption.style.cursor = "pointer";
                aa.style.display = "none";
                ab.style.display = "none";
                ac.style.display = "none";
                ad.style.display = "none";
                ba.style.display = "block";
                bb.style.display = "block";
                bc.style.display = "block";
                bd.style.display = "block";
                ba.copy(aa);
                bb.copy(ab);
                bc.copy(ac);
                bd.copy(ad);
                before = true;
                update();
            };
            afterOption.onclick = function() {
                before = false;
                afterOption.style.background = "url(" + _checkmarkSvgDefault.default + ") no-repeat 12px 16px";
                afterOption.style.backgroundSize = '8%';
                afterOption.style.backgroundColor = "#9e9e9e";
                afterOption.style.boxShadow = "inset 0px 5px 10px rgba(0,0,0,0.5)";
                afterOption.style.cursor = "default";
                beforeOption.style.background = "";
                beforeOption.style.backgroundColor = "rgba(0, 0, 0, 0.1)";
                beforeOption.style.boxShadow = "";
                beforeOption.style.cursor = "pointer";
                ba.style.display = "none";
                bb.style.display = "none";
                bc.style.display = "none";
                bd.style.display = "none";
                aa.style.display = "block";
                ab.style.display = "block";
                ac.style.display = "block";
                ad.style.display = "block";
                aa.copy(ba);
                ab.copy(bb);
                ac.copy(bc);
                ad.copy(bd);
            };
            let optionWrapper = document.createElement("div");
            optionWrapper.appendChild(beforeOption);
            optionWrapper.appendChild(afterOption);
            div1.appendChild(optionWrapper);
            let previewWrapper = document.createElement("div");
            previewWrapper.oncontextmenu = function() {
                return false;
            };
            _bb.BB.css(previewWrapper, {
                width: isSmall ? '340px' : '540px',
                marginLeft: "-20px",
                height: isSmall ? '260px' : '300px',
                backgroundColor: "#9e9e9e",
                marginTop: "10px",
                boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
                overflow: "hidden",
                position: "relative",
                userSelect: 'none',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                colorScheme: 'only light'
            });
            let previewLayerArr = [];
            for(let i1 = 0; i1 < layers.length; i1++){
                let canvas = i1 === selectedLayerIndex ? glCanvas : layers[i1].context.canvas;
                previewLayerArr.push({
                    image: canvas,
                    opacity: layers[i1].opacity,
                    mixModeStr: layers[i1].mixModeStr
                });
            }
            let klCanvasPreview = new _canvasPreview.KlCanvasPreview({
                width: parseInt('' + displayW),
                height: parseInt('' + displayH),
                layers: previewLayerArr
            });
            let previewInnerWrapper = _bb.BB.el({
                css: {
                    position: 'relative',
                    boxShadow: '0 0 5px rgba(0,0,0,0.5)',
                    width: parseInt('' + displayW) + 'px',
                    height: parseInt('' + displayH) + 'px'
                }
            });
            previewInnerWrapper.appendChild(klCanvasPreview.getElement());
            previewWrapper.appendChild(previewInnerWrapper);
            previewInnerWrapper.appendChild(aa);
            previewInnerWrapper.appendChild(ab);
            previewInnerWrapper.appendChild(ac);
            previewInnerWrapper.appendChild(ad);
            ba.style.display = "none";
            bb.style.display = "none";
            bc.style.display = "none";
            bd.style.display = "none";
            previewInnerWrapper.appendChild(ba);
            previewInnerWrapper.appendChild(bb);
            previewInnerWrapper.appendChild(bc);
            previewInnerWrapper.appendChild(bd);
            div1.appendChild(previewWrapper);
            update();
            result.destroy = ()=>{
                for(let i = 0; i < pointerListenerArr.length; i++)pointerListenerArr[i].destroy();
                texture.destroy();
            };
            result.getInput = function() {
                result.destroy();
                return {
                    before: [
                        ba.x / displayPreviewFactor,
                        ba.y / displayPreviewFactor,
                        bb.x / displayPreviewFactor,
                        bb.y / displayPreviewFactor,
                        bc.x / displayPreviewFactor,
                        bc.y / displayPreviewFactor,
                        bd.x / displayPreviewFactor,
                        bd.y / displayPreviewFactor, 
                    ],
                    after: [
                        aa.x / displayPreviewFactor,
                        aa.y / displayPreviewFactor,
                        ab.x / displayPreviewFactor,
                        ab.y / displayPreviewFactor,
                        ac.x / displayPreviewFactor,
                        ac.y / displayPreviewFactor,
                        ad.x / displayPreviewFactor,
                        ad.y / displayPreviewFactor, 
                    ]
                };
            };
        }
        setTimeout(finishInit, 1);
        return result;
    },
    apply (params) {
        let context = params.context;
        let history = params.history;
        let before = params.input.before;
        let after = params.input.after;
        if (!context || !before || !after || !history) return false;
        history.pause(true);
        let glCanvas = _sharedGlFx.getSharedFx();
        if (!glCanvas) return false; // todo more specific error?
        let texture = glCanvas.texture(context.canvas);
        let w = context.canvas.width;
        let h = context.canvas.height;
        glCanvas.draw(texture).perspective(before, after).update();
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(glCanvas, 0, 0);
        texture.destroy();
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "glPerspective"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"e3nbn","../canvas-ui/canvas-preview":"9a0UP","url:~/src/app/img/ui/checkmark.svg":"kSVdA","./shared-gl-fx":"4XYAu","../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"3HpJn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "resize", ()=>resize
);
var _bb = require("../../bb/bb");
var _checkbox = require("../ui/base-components/checkbox");
var _select = require("../ui/base-components/select");
// @ts-ignore
var _constrainSvg = require("url:~/src/app/img/ui/constrain.svg");
var _constrainSvgDefault = parcelHelpers.interopDefault(_constrainSvg);
var _language = require("../../language/language");
const resize = {
    getDialog (params) {
        //BB.centerWithin
        let canvas = params.canvas;
        if (!canvas) return false;
        let fit1 = _bb.BB.fitInto(canvas.getWidth(), canvas.getHeight(), 280, 200, 1);
        let w = parseInt('' + fit1.width), h = parseInt('' + fit1.height);
        let previewFactor = w / canvas.getWidth();
        let tempCanvas = canvas.getCompleteCanvas(1);
        let div = document.createElement("div");
        let result = {
            element: div
        };
        let newWidth = canvas.getWidth(), newHeight = canvas.getHeight();
        div.innerHTML = _language.LANG('filter-resize-description') + "<br/><br/>";
        let maxWidth = params.maxWidth, maxHeight = params.maxHeight;
        let widthWrapper = _bb.BB.el({
            css: {
                width: '150px',
                height: '35px',
                lineHeight: '30px'
            }
        });
        let heightWrapper = _bb.BB.el({
            css: {
                width: '150px',
                height: '35px',
                lineHeight: '30px'
            }
        });
        let widthInput = _bb.BB.el({
            tagName: 'input',
            css: {
                cssFloat: 'right',
                width: '90px'
            },
            custom: {
                type: 'number',
                min: '1',
                max: '' + maxWidth,
                value: '' + canvas.getWidth()
            }
        });
        let heightInput = _bb.BB.el({
            tagName: 'input',
            css: {
                cssFloat: 'right',
                width: '90px'
            },
            custom: {
                type: 'number',
                min: '1',
                max: '' + maxHeight,
                value: '' + canvas.getHeight()
            }
        });
        widthInput.onclick = function() {
            this.focus();
            widthChanged = true;
            update();
        };
        heightInput.onclick = function() {
            this.focus();
            heightChanged = true;
            update();
        };
        widthInput.onchange = function() {
            widthChanged = true;
            update();
        };
        heightInput.onchange = function() {
            heightChanged = true;
            update();
        };
        widthWrapper.append(_language.LANG('width') + ": ", widthInput);
        heightWrapper.append(_language.LANG('height') + ": ", heightInput);
        let inputWrapper = _bb.BB.el({
            css: {
                background: "url(" + _constrainSvgDefault.default + ") no-repeat 140px 5px",
                backgroundSize: '50px 52px'
            }
        });
        inputWrapper.append(widthWrapper, heightWrapper);
        div.appendChild(inputWrapper);
        //contrain checkbox
        let heightChanged = false, widthChanged = false;
        let ratio = canvas.getWidth() / canvas.getHeight();
        function updateConstrain() {
            if (isConstrained) {
                widthInput.value = '' + canvas.getWidth();
                heightInput.value = '' + canvas.getHeight();
                inputWrapper.style.background = "url(" + _constrainSvgDefault.default + ") no-repeat 140px 5px";
                inputWrapper.style.backgroundSize = '50px 52px';
                update();
            } else inputWrapper.style.background = "";
        }
        let isConstrained = true;
        let constrainCheckbox = new _checkbox.Checkbox({
            init: true,
            label: _language.LANG('constrain-proportions'),
            allowTab: true,
            callback: function(b) {
                isConstrained = b;
                updateConstrain();
            }
        });
        div.appendChild(_bb.BB.el({
            css: {
                clear: 'both'
            }
        }));
        let algorithmSelect = new _select.Select({
            isFocusable: true,
            optionArr: [
                [
                    'smooth',
                    _language.LANG('algorithm-smooth')
                ],
                [
                    'pixelated',
                    _language.LANG('algorithm-pixelated')
                ]
            ],
            title: _language.LANG('scaling-algorithm'),
            initValue: 'smooth',
            onChange: function() {
                update();
            }
        });
        let secondRowElement = _bb.BB.el({
            parent: div,
            css: {
                display: 'flex',
                justifyContent: 'space-between'
            }
        });
        secondRowElement.appendChild(constrainCheckbox.getElement());
        secondRowElement.appendChild(algorithmSelect.getElement());
        let previewCanvas = _bb.BB.canvas(w, h);
        previewCanvas.style.imageRendering = 'pixelated';
        let previewCtx = previewCanvas.getContext('2d');
        function draw() {
            if (algorithmSelect.getValue() === 'smooth') {
                previewCanvas.style.imageRendering = previewFactor > 1 ? 'pixelated' : '';
                previewCanvas.width = canvas.getWidth();
                previewCanvas.height = canvas.getHeight();
                previewCtx.save();
                previewCtx.imageSmoothingQuality = 'high';
                previewCtx.drawImage(tempCanvas, 0, 0);
                _bb.BB.resizeCanvas(previewCanvas, newWidth, newHeight);
                previewCtx.restore();
            } else {
                previewCanvas.style.imageRendering = 'pixelated';
                previewCanvas.width = newWidth;
                previewCanvas.height = newHeight;
                previewCtx.save();
                previewCtx.imageSmoothingEnabled = false;
                previewCtx.drawImage(tempCanvas, 0, 0, previewCanvas.width, previewCanvas.height);
                previewCtx.restore();
            }
        }
        function update() {
            if (widthInput.value.length === 0 && widthChanged || heightInput.value.length === 0 && heightChanged) {
                heightChanged = false;
                widthChanged = false;
                return;
            }
            widthInput.value = '' + Math.max(1, parseInt(widthInput.value));
            heightInput.value = '' + Math.max(1, parseInt(heightInput.value));
            if (isConstrained) {
                if (heightChanged) widthInput.value = '' + parseInt('' + parseInt(heightInput.value) * ratio);
                if (widthChanged) heightInput.value = '' + parseInt('' + parseInt(widthInput.value) / ratio);
                if (parseInt(widthInput.value) > maxWidth || parseInt(heightInput.value) > maxHeight) {
                    let fit = _bb.BB.fitInto(parseInt(widthInput.value), parseInt(heightInput.value), maxWidth, maxHeight, 1);
                    widthInput.value = '' + parseInt('' + fit.width);
                    heightInput.value = '' + parseInt('' + fit.height);
                }
            }
            if (parseInt(widthInput.value) > maxWidth) widthInput.value = '' + maxWidth;
            if (parseInt(heightInput.value) > maxHeight) heightInput.value = '' + maxHeight;
            heightChanged = false;
            widthChanged = false;
            newWidth = parseInt(widthInput.value);
            newHeight = parseInt(heightInput.value);
            let preview = _bb.BB.fitInto(newWidth, newHeight, 280, 200, 1);
            let previewW = parseInt('' + preview.width), previewH = parseInt('' + preview.height);
            previewFactor = previewW / newWidth;
            let offset = _bb.BB.centerWithin(340, 220, previewW, previewH);
            draw();
            previewCanvas.style.width = Math.max(1, previewW) + "px";
            previewCanvas.style.height = Math.max(1, previewH) + "px";
            canvasWrapper.style.left = offset.x + "px";
            canvasWrapper.style.top = offset.y + "px";
            canvasWrapper.style.width = Math.max(1, previewW) + "px";
            canvasWrapper.style.height = Math.max(1, previewH) + "px";
        }
        let previewWrapper = document.createElement("div");
        _bb.BB.css(previewWrapper, {
            width: "340px",
            marginLeft: "-20px",
            height: "220px",
            display: "table",
            backgroundColor: "#9e9e9e",
            marginTop: "10px",
            boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
            position: "relative",
            userSelect: 'none',
            colorScheme: 'only light'
        });
        let canvasWrapper = _bb.BB.appendTextDiv(previewWrapper, "");
        canvasWrapper.appendChild(previewCanvas);
        canvasWrapper.style.width = w + "px";
        canvasWrapper.style.height = h + "px";
        canvasWrapper.style.position = "absolute";
        canvasWrapper.style.overflow = "hidden";
        canvasWrapper.style.boxShadow = "0 0 5px rgba(0,0,0,0.8)";
        canvasWrapper.style.overflow = "hidden";
        _bb.BB.createCheckerDataUrl(8, function(url) {
            previewWrapper.style.background = "url(" + url + ")";
        });
        div.appendChild(previewWrapper);
        update();
        result.destroy = ()=>{
            constrainCheckbox.destroy();
        };
        result.getInput = function() {
            result.destroy();
            return {
                width: newWidth,
                height: newHeight,
                algorithm: algorithmSelect.getValue()
            };
        };
        return result;
    },
    apply (params) {
        let canvas = params.canvas;
        let history = params.history;
        let width = params.input.width;
        let height = params.input.height;
        let algorithm = params.input.algorithm;
        if (!canvas || !history) return false;
        history.pause(true);
        canvas.resize(width, height, algorithm);
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "resize"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"e3nbn","../ui/base-components/checkbox":"clzcQ","../ui/base-components/select":"gIUAj","url:~/src/app/img/ui/constrain.svg":"aNKJY","../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"aNKJY":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "constrain.23078ecf.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"hbNRe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rotate", ()=>rotate
);
var _bb = require("../../bb/bb");
var _language = require("../../language/language");
const rotate = {
    getDialog (params) {
        let canvas = params.canvas;
        if (!canvas) return false;
        let fit1 = _bb.BB.fitInto(canvas.getWidth(), canvas.getHeight(), 280, 200, 1);
        let w = parseInt('' + fit1.width), h = parseInt('' + fit1.height);
        let previewFactor = w / canvas.getWidth();
        let tempCanvas = _bb.BB.canvas(w, h);
        tempCanvas.style.display = 'block';
        tempCanvas.getContext("2d").drawImage(canvas.getCompleteCanvas(previewFactor), 0, 0, w, h);
        let div = document.createElement("div");
        let result = {
            element: div
        };
        let deg = 0;
        div.innerHTML = _language.LANG('filter-rotate-description') + "<br/><br/>";
        let first = true;
        function update() {
            canvasWrapper.style.WebkitTransform = "rotate(" + deg + "deg)";
            canvasWrapper.style.MozTransform = "rotate(" + deg + "deg)";
            canvasWrapper.style.OTransform = "rotate(" + deg + "deg)";
            canvasWrapper.style.msTransform = "rotate(" + deg + "deg)";
            if (Math.abs(deg % 180) === 90) {
                //height has to fit width because of rotation
                let fit = _bb.BB.fitInto(h, w, 280, 200, 1);
                let scale = parseInt('' + fit.height) / w;
                canvasWrapper.style.WebkitTransform = "rotate(" + deg + "deg) scale(" + scale + ")";
                canvasWrapper.style.MozTransform = "rotate(" + deg + "deg) scale(" + scale + ")";
                canvasWrapper.style.OTransform = "rotate(" + deg + "deg) scale(" + scale + ")";
                canvasWrapper.style.msTransform = "rotate(" + deg + "deg) scale(" + scale + ")";
            }
        }
        let btnPlus = document.createElement("button");
        btnPlus.innerHTML = "<span style='font-size: 1.3em'>⟳</span> 90°";
        let btnMinus = document.createElement("button");
        btnMinus.innerHTML = "<span style='font-size: 1.3em'>⟲</span> 90°";
        btnMinus.style.marginRight = '5px';
        btnPlus.onclick = function() {
            deg += 90;
            update();
        };
        btnMinus.onclick = function() {
            deg -= 90;
            update();
        };
        div.appendChild(btnMinus);
        div.appendChild(btnPlus);
        let previewWrapper = document.createElement("div");
        _bb.BB.css(previewWrapper, {
            width: "340px",
            marginLeft: "-20px",
            height: "220px",
            display: "table",
            backgroundColor: "#9e9e9e",
            marginTop: "10px",
            boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
            overflow: "hidden",
            position: "relative",
            userSelect: 'none',
            colorScheme: 'only light'
        });
        let previewcell = document.createElement("div");
        previewcell.style.display = "table-cell";
        previewcell.style.verticalAlign = "middle";
        let canvasWrapper = _bb.BB.appendTextDiv(previewcell, "");
        canvasWrapper.appendChild(tempCanvas);
        previewWrapper.appendChild(previewcell);
        canvasWrapper.style.width = w + "px";
        canvasWrapper.style.height = h + "px";
        canvasWrapper.style.marginLeft = "auto";
        canvasWrapper.style.marginRight = "auto";
        canvasWrapper.style.boxShadow = "0 0 5px rgba(0,0,0,0.8)";
        canvasWrapper.style.overflow = "hidden";
        _bb.BB.createCheckerDataUrl(4, function(url) {
            canvasWrapper.style.background = "url(" + url + ")";
        });
        canvasWrapper.style.transition = "all 0.2s ease-out";
        div.appendChild(previewWrapper);
        update();
        result.getInput = function() {
            return {
                deg: deg
            };
        };
        return result;
    },
    apply (params) {
        let canvas = params.canvas;
        let history = params.history;
        let deg = params.input.deg;
        if (!canvas || !history) return false;
        history.pause(true);
        canvas.rotate(deg);
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "rotate"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"e3nbn","../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9vTqv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "glTiltShift", ()=>glTiltShift
);
var _bb = require("../../bb/bb");
var _filtersConsts = require("./filters-consts");
var _klSlider = require("../ui/base-components/kl-slider");
var _canvasPreview = require("../canvas-ui/canvas-preview");
var _sharedGlFx = require("./shared-gl-fx");
var _language = require("../../language/language");
const glTiltShift = {
    getDialog (params) {
        let context = params.context;
        let canvas = params.canvas;
        if (!context || !canvas) return false;
        let layers = canvas.getLayers();
        let selectedLayerIndex = canvas.getLayerIndex(context.canvas);
        let fit = _bb.BB.fitInto(context.canvas.width, context.canvas.height, 280, 200, 1);
        let displayW = parseInt('' + fit.width), displayH = parseInt('' + fit.height);
        let w = Math.min(displayW, context.canvas.width);
        let h = Math.min(displayH, context.canvas.height);
        let tempCanvas = _bb.BB.canvas(w, h);
        {
            const ctx = tempCanvas.getContext("2d");
            ctx.save();
            if (w > context.canvas.width) ctx.imageSmoothingEnabled = false;
            ctx.drawImage(context.canvas, 0, 0, w, h);
            ctx.restore();
        }
        let previewFactor = w / context.canvas.width;
        let displayPreviewFactor = displayW / context.canvas.width;
        let div1 = document.createElement("div");
        let result = {
            element: div1
        };
        let pointerListenerArr = [];
        function finishInit() {
            let blur = 20, gradient = 200;
            div1.innerHTML = _language.LANG('filter-tilt-shift-description') + "<br/><br/>";
            let glCanvas = _sharedGlFx.getSharedFx();
            if (!glCanvas) return; // todo throw?
            let texture = glCanvas.texture(tempCanvas);
            glCanvas.draw(texture).update(); // update glCanvas size
            let fa, fb; // focus line
            function update() {
                try {
                    glCanvas.draw(texture).tiltShift(fa.x / displayPreviewFactor * previewFactor, fa.y / displayPreviewFactor * previewFactor, fb.x / displayPreviewFactor * previewFactor, fb.y / displayPreviewFactor * previewFactor, blur * previewFactor, gradient * previewFactor).update();
                    klCanvasPreview.render();
                } catch (e) {
                    div1.errorCallback(e);
                }
            }
            function nob(x, y) {
                let nobSize = 14;
                let div = _bb.BB.el({
                    css: {
                        width: nobSize + "px",
                        height: nobSize + "px",
                        backgroundColor: '#fff',
                        boxShadow: "inset 0 0 0 2px #000",
                        borderRadius: nobSize + "px",
                        position: "absolute",
                        cursor: 'move',
                        left: x - nobSize / 2 + "px",
                        top: y - nobSize / 2 + "px",
                        userSelect: 'none',
                        touchAction: 'none'
                    }
                });
                div.x = x;
                div.y = y;
                let pointerListener = new _bb.BB.PointerListener({
                    target: div,
                    maxPointers: 1,
                    onPointer: function(event) {
                        event.eventPreventDefault();
                        if (event.button === 'left' && event.type === 'pointermove') {
                            div.x += event.dX;
                            div.y += event.dY;
                            div.style.left = div.x - nobSize / 2 + "px";
                            div.style.top = div.y - nobSize / 2 + "px";
                            update();
                        }
                    }
                });
                pointerListenerArr.push(pointerListener);
                return div;
            }
            fa = nob(parseInt('' + displayW / 6), parseInt('' + displayH / 2));
            fb = nob(parseInt('' + (displayW - displayW / 6)), parseInt('' + (displayH - displayH / 3)));
            let blurSlider = new _klSlider.KlSlider({
                label: _language.LANG('filter-tilt-shift-blur'),
                width: 300,
                height: 30,
                min: 0,
                max: 200,
                initValue: blur,
                eventResMs: _filtersConsts.eventResMs,
                onChange: function(val) {
                    blur = val;
                    update();
                }
            });
            blurSlider.getElement().style.marginBottom = "10px";
            div1.appendChild(blurSlider.getElement());
            let gradientSlider = new _klSlider.KlSlider({
                label: _language.LANG('filter-tilt-shift-gradient'),
                width: 300,
                height: 30,
                min: 0,
                max: 1000,
                initValue: gradient,
                eventResMs: _filtersConsts.eventResMs,
                onChange: function(val) {
                    gradient = val;
                    update();
                }
            });
            div1.appendChild(gradientSlider.getElement());
            let previewWrapper = document.createElement("div");
            previewWrapper.oncontextmenu = function() {
                return false;
            };
            _bb.BB.css(previewWrapper, {
                width: "340px",
                marginLeft: "-20px",
                height: "220px",
                backgroundColor: "#9e9e9e",
                marginTop: "10px",
                boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
                overflow: "hidden",
                position: "relative",
                userSelect: 'none',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                colorScheme: 'only light'
            });
            let previewLayerArr = [];
            for(let i1 = 0; i1 < layers.length; i1++)previewLayerArr.push({
                image: i1 === selectedLayerIndex ? glCanvas : layers[i1].context.canvas,
                opacity: layers[i1].opacity,
                mixModeStr: layers[i1].mixModeStr
            });
            let klCanvasPreview = new _canvasPreview.KlCanvasPreview({
                width: parseInt('' + displayW),
                height: parseInt('' + displayH),
                layers: previewLayerArr
            });
            let previewInnerWrapper = _bb.BB.el({
                css: {
                    position: 'relative',
                    boxShadow: '0 0 5px rgba(0,0,0,0.5)',
                    width: parseInt('' + displayW) + 'px',
                    height: parseInt('' + displayH) + 'px'
                }
            });
            previewInnerWrapper.appendChild(klCanvasPreview.getElement());
            previewWrapper.appendChild(previewInnerWrapper);
            previewInnerWrapper.appendChild(fa);
            previewInnerWrapper.appendChild(fb);
            div1.appendChild(previewWrapper);
            update();
            result.destroy = ()=>{
                for(let i = 0; i < pointerListenerArr.length; i++)pointerListenerArr[i].destroy();
                blurSlider.destroy();
                gradientSlider.destroy();
                texture.destroy();
            };
            result.getInput = function() {
                result.destroy();
                return {
                    a: {
                        x: fa.x / displayPreviewFactor,
                        y: fa.y / displayPreviewFactor
                    },
                    b: {
                        x: fb.x / displayPreviewFactor,
                        y: fb.y / displayPreviewFactor
                    },
                    blur: blur,
                    gradient: gradient
                };
            };
        }
        setTimeout(finishInit, 1);
        return result;
    },
    apply (params) {
        let context = params.context;
        let history = params.history;
        let a = params.input.a;
        let b = params.input.b;
        let blur = params.input.blur;
        let gradient = params.input.gradient;
        if (!context || !history) return false;
        history.pause(true);
        let glCanvas = _sharedGlFx.getSharedFx();
        if (!glCanvas) return false; // todo more specific error?
        let texture = glCanvas.texture(context.canvas);
        glCanvas.draw(texture).tiltShift(a.x, a.y, b.x, b.y, blur, gradient).update();
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(glCanvas, 0, 0);
        texture.destroy();
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "glTiltShift"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"e3nbn","./filters-consts":"hTXbX","../ui/base-components/kl-slider":"1Vedp","../canvas-ui/canvas-preview":"9a0UP","./shared-gl-fx":"4XYAu","../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fRAhD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "transform", ()=>transform
);
var _bb = require("../../bb/bb");
var _checkbox = require("../ui/base-components/checkbox");
var _canvasPreview = require("../canvas-ui/canvas-preview");
var _freeTransform = require("../ui/components/free-transform");
var _select = require("../ui/base-components/select");
var _language = require("../../language/language");
const transform = {
    getDialog (params) {
        let i;
        let context = params.context;
        let canvas = params.canvas;
        if (!context || !canvas) return false;
        let isSmall = window.innerWidth < 550;
        let layers = canvas.getLayers();
        let selectedLayerIndex = canvas.getLayerIndex(context.canvas);
        let fit = _bb.BB.fitInto(context.canvas.width, context.canvas.height, isSmall ? 280 : 490, isSmall ? 200 : 240, 1);
        let displayW = parseInt('' + fit.width), displayH = parseInt('' + fit.height);
        let w = Math.min(displayW, context.canvas.width);
        let h = Math.min(displayH, context.canvas.height);
        let freeTransform;
        let displayPreviewFactor = displayW / context.canvas.width;
        // determine bounds and initial transformation
        let boundsObj = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        };
        {
            let tempBounds = {
                x1: null,
                y1: null,
                x2: null,
                y2: null
            };
            let imdat = context.getImageData(0, 0, context.canvas.width, context.canvas.height);
            if (imdat.data[3] > 0 && imdat.data[imdat.data.length - 1] > 0) {
                tempBounds.x1 = 0;
                tempBounds.y1 = 0;
                tempBounds.x2 = context.canvas.width - 1;
                tempBounds.y2 = context.canvas.height - 1;
            } else {
                for(i = 3; i < imdat.data.length; i += 4)if (imdat.data[i] > 0) {
                    let x = (i - 3) / 4 % context.canvas.width;
                    let y = Math.floor((i - 3) / 4 / context.canvas.width);
                    if (tempBounds.x1 > x || tempBounds.x1 === null) tempBounds.x1 = x;
                    if (tempBounds.y1 === null) tempBounds.y1 = y;
                    if (tempBounds.x2 < x || tempBounds.x2 === null) tempBounds.x2 = x;
                    if (tempBounds.y2 < y || tempBounds.y2 === null) tempBounds.y2 = y;
                }
            }
            if (tempBounds.x1 === null || tempBounds.y1 === null) {
                alert(_language.LANG('filter-transform-empty'));
                return false;
            }
            boundsObj.x = tempBounds.x1;
            boundsObj.y = tempBounds.y1;
            boundsObj.width = tempBounds.x2 - tempBounds.x1 + 1;
            boundsObj.height = tempBounds.y2 - tempBounds.y1 + 1;
        }
        const initTransform = {
            x: boundsObj.x + boundsObj.width / 2,
            y: boundsObj.y + boundsObj.height / 2,
            width: boundsObj.width,
            height: boundsObj.height,
            angleDeg: 0
        };
        let div = document.createElement("div");
        let result = {
            element: div
        };
        if (!isSmall) result.width = 500;
        div.innerHTML = _language.LANG('filter-transform-description');
        let keyListener = new _bb.BB.KeyListener({
            onDown: function(keyStr) {
                if (_bb.BB.isInputFocused(true)) return;
                if (keyStr === 'left') {
                    inputX.value = '' + (parseFloat(inputX.value) - 1);
                    onInputsChanged();
                }
                if (keyStr === 'right') {
                    inputX.value = '' + (parseFloat(inputX.value) + 1);
                    onInputsChanged();
                }
                if (keyStr === 'up') {
                    inputY.value = '' + (parseFloat(inputY.value) - 1);
                    onInputsChanged();
                }
                if (keyStr === 'down') {
                    inputY.value = '' + (parseFloat(inputY.value) + 1);
                    onInputsChanged();
                }
            }
        });
        let leftWrapper = document.createElement("div");
        let rightWrapper = document.createElement("div");
        let rotWrapper = document.createElement("div");
        let inputY = document.createElement("input");
        let inputX = document.createElement("input");
        let inputR = document.createElement("input");
        leftWrapper.style.width = "100px";
        leftWrapper.style.height = "30px";
        rightWrapper.style.width = "100px";
        rightWrapper.style.height = "30px";
        rightWrapper.style.display = "inline-block";
        leftWrapper.style.display = "inline-block";
        rotWrapper.style.display = "inline-block";
        rotWrapper.style.width = "150px";
        rotWrapper.style.height = "30px";
        inputY.type = "number";
        inputX.type = "number";
        inputR.type = "number";
        inputX.style.width = "70px";
        inputY.style.width = "70px";
        inputR.style.width = "70px";
        inputY.value = '0';
        inputX.value = '0';
        inputR.value = '0';
        inputY.onclick = function() {
            this.focus();
            onInputsChanged();
        };
        inputX.onclick = function() {
            this.focus();
            onInputsChanged();
        };
        inputR.onclick = function() {
            this.focus();
            onInputsChanged();
        };
        inputY.onchange = function() {
            onInputsChanged();
        };
        inputX.onchange = function() {
            onInputsChanged();
        };
        inputR.onchange = function() {
            onInputsChanged();
        };
        inputY.onkeyup = function() {
            onInputsChanged();
        };
        inputX.onkeyup = function() {
            onInputsChanged();
        };
        inputR.onkeyup = function() {
            onInputsChanged();
        };
        leftWrapper.append("X: ", inputX);
        rightWrapper.append("Y: ", inputY);
        rotWrapper.append(_language.LANG('filter-transform-rotation') + ': ', inputR);
        if (!isSmall) {
            const inputRow = _bb.BB.el({
                parent: div,
                css: {
                    marginTop: '10px'
                }
            });
            inputRow.append(leftWrapper, rightWrapper, rotWrapper);
        }
        // buttons
        const actionBtnCss = {
            marginLeft: '10px',
            marginTop: '10px'
        };
        const buttonRow = _bb.BB.el({
            parent: div,
            css: {
                display: 'flex',
                flexWrap: 'wrap',
                marginLeft: '-10px'
            }
        });
        const flipXBtn = _bb.BB.el({
            parent: buttonRow,
            tagName: 'button',
            content: _language.LANG('filter-transform-flip') + ' X',
            onClick: ()=>{
                const t = freeTransform.getTransform();
                freeTransform.setSize(-t.width, t.height);
            },
            css: actionBtnCss
        });
        const flipYBtn = _bb.BB.el({
            parent: buttonRow,
            tagName: 'button',
            content: _language.LANG('filter-transform-flip') + ' Y',
            onClick: ()=>{
                const t = freeTransform.getTransform();
                freeTransform.setSize(t.width, -t.height);
            },
            css: actionBtnCss
        });
        const scaleRotLeftBtn = _bb.BB.el({
            parent: buttonRow,
            tagName: 'button',
            content: '-90°',
            onClick: ()=>{
                const t = freeTransform.getTransform();
                t.angleDeg -= 90;
                t.angleDeg %= 360;
                freeTransform.setAngleDeg(t.angleDeg);
                inputR.value = '' + Math.round(t.angleDeg);
                updatePreview();
            },
            css: actionBtnCss
        });
        const scaleRotRightBtn = _bb.BB.el({
            parent: buttonRow,
            tagName: 'button',
            content: '+90°',
            onClick: ()=>{
                const t = freeTransform.getTransform();
                t.angleDeg += 90;
                t.angleDeg %= 360;
                freeTransform.setAngleDeg(t.angleDeg);
                inputR.value = '' + Math.round(t.angleDeg);
                updatePreview();
            },
            css: actionBtnCss
        });
        const scaleDoubleBtn = _bb.BB.el({
            parent: buttonRow,
            tagName: 'button',
            content: '2x',
            onClick: ()=>{
                const t = freeTransform.getTransform();
                if (constrainCheckbox.getValue()) freeTransform.setSize(freeTransform.getRatio() * t.height * 2, t.height * 2);
                else freeTransform.setSize(t.width * 2, t.height * 2);
            },
            css: actionBtnCss
        });
        const scaleHalfBtn = _bb.BB.el({
            parent: buttonRow,
            tagName: 'button',
            content: '1/2x',
            onClick: ()=>{
                const t = freeTransform.getTransform();
                freeTransform.setSize(Math.round(t.width / 2), Math.round(t.height / 2));
            },
            css: actionBtnCss
        });
        const centerBtn = _bb.BB.el({
            parent: buttonRow,
            tagName: 'button',
            content: _language.LANG('center'),
            onClick: ()=>{
                const t = freeTransform.getTransform();
                freeTransform.setPos({
                    x: context.canvas.width / 2,
                    y: context.canvas.height / 2
                });
                freeTransform.setAngleDeg(t.angleDeg);
                updatePreview();
            },
            css: actionBtnCss
        });
        let isConstrained = true;
        let constrainCheckbox = new _checkbox.Checkbox({
            init: true,
            label: _language.LANG('filter-transform-constrain'),
            title: _language.LANG('constrain-proportions'),
            allowTab: true,
            callback: function(b) {
                isConstrained = b;
                freeTransform.setConstrained(isConstrained);
            },
            css: {
                display: 'inline-block'
            }
        });
        let isSnapping = false;
        let snappingCheckbox = new _checkbox.Checkbox({
            init: true,
            label: _language.LANG('filter-transform-snap'),
            title: _language.LANG('filter-transform-snap-title'),
            allowTab: true,
            callback: function(b) {
                isSnapping = b;
                freeTransform.setSnapping(isSnapping);
            },
            css: {
                display: 'inline-block',
                marginLeft: '10px'
            }
        });
        const checkboxWrapper = _bb.BB.el({
        });
        checkboxWrapper.append(constrainCheckbox.getElement(), snappingCheckbox.getElement());
        div.appendChild(_bb.BB.el({
            css: {
                clear: 'both',
                height: '10px'
            }
        }));
        const bottomRow = _bb.BB.el({
            parent: div,
            css: {
                display: 'flex',
                justifyContent: 'space-between'
            }
        });
        let algorithmSelect = new _select.Select({
            isFocusable: true,
            optionArr: [
                [
                    'smooth',
                    _language.LANG('algorithm-smooth')
                ],
                [
                    'pixelated',
                    _language.LANG('algorithm-pixelated')
                ]
            ],
            initValue: 'smooth',
            title: _language.LANG('scaling-algorithm'),
            onChange: function() {
                updatePreview(true);
            }
        });
        bottomRow.append(checkboxWrapper, algorithmSelect.getElement());
        let previewWrapper = document.createElement("div");
        previewWrapper.oncontextmenu = function() {
            return false;
        };
        _bb.BB.css(previewWrapper, {
            width: isSmall ? '340px' : '540px',
            marginLeft: "-20px",
            height: isSmall ? '260px' : '300px',
            backgroundColor: "#9e9e9e",
            marginTop: "10px",
            boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
            overflow: "hidden",
            position: "relative",
            userSelect: 'none',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            colorScheme: 'only light'
        });
        let previewLayerArr = [];
        for(let i1 = 0; i1 < layers.length; i1++){
            let canvas;
            if (i1 === selectedLayerIndex) {
                canvas = _bb.BB.canvas(parseInt('' + w), parseInt('' + h));
                let ctx = canvas.getContext('2d');
                ctx.drawImage(layers[i1].context.canvas, 0, 0, canvas.width, canvas.height);
            } else canvas = layers[i1].context.canvas;
            previewLayerArr.push({
                image: canvas,
                opacity: layers[i1].opacity,
                mixModeStr: layers[i1].mixModeStr
            });
        }
        let klCanvasPreview = new _canvasPreview.KlCanvasPreview({
            width: parseInt('' + displayW),
            height: parseInt('' + displayH),
            layers: previewLayerArr
        });
        let previewInnerWrapper = _bb.BB.el({
            css: {
                position: 'relative',
                boxShadow: '0 0 5px rgba(0,0,0,0.5)',
                width: parseInt('' + displayW) + 'px',
                height: parseInt('' + displayH) + 'px'
            }
        });
        previewInnerWrapper.appendChild(klCanvasPreview.getElement());
        previewWrapper.appendChild(previewInnerWrapper);
        let lastDrawnTransformStr;
        function updatePreview(doForce = false) {
            if (!freeTransform) return;
            let transform1 = freeTransform.getTransform();
            if (JSON.stringify(transform1) === lastDrawnTransformStr && !doForce) return;
            lastDrawnTransformStr = JSON.stringify(transform1);
            if (displayPreviewFactor < 1) {
                transform1.x *= displayPreviewFactor;
                transform1.y *= displayPreviewFactor;
                transform1.width *= displayPreviewFactor;
                transform1.height *= displayPreviewFactor;
            }
            let transformLayerCanvas = previewLayerArr[selectedLayerIndex].image;
            let ctx = transformLayerCanvas.getContext('2d');
            ctx.save();
            ctx.clearRect(0, 0, transformLayerCanvas.width, transformLayerCanvas.height);
            _bb.BB.drawTransformedImageWithBounds(ctx, layers[selectedLayerIndex].context.canvas, transform1, boundsObj, algorithmSelect.getValue() === 'pixelated' || _bb.BB.testShouldPixelate(transform1, transform1.width / initTransform.width, transform1.height / initTransform.height));
            ctx.restore();
            klCanvasPreview.render();
        }
        freeTransform = new _freeTransform.FreeTransform({
            x: initTransform.x,
            y: initTransform.y,
            width: initTransform.width,
            height: initTransform.height,
            angleDeg: initTransform.angleDeg,
            isConstrained: true,
            snapX: [
                0,
                context.canvas.width
            ],
            snapY: [
                0,
                context.canvas.height
            ],
            callback: function(t) {
                inputX.value = '' + Math.round(t.x - initTransform.x);
                inputY.value = '' + Math.round(t.y - initTransform.y);
                inputR.value = '' + Math.round(t.angleDeg);
                updatePreview();
            },
            scale: displayPreviewFactor
        });
        _bb.BB.css(freeTransform.getElement(), {
            position: 'absolute',
            left: '0',
            top: '0'
        });
        previewInnerWrapper.appendChild(freeTransform.getElement());
        function onInputsChanged() {
            freeTransform.setPos({
                x: parseInt(inputX.value) + initTransform.x,
                y: parseInt(inputY.value) + initTransform.y
            });
            freeTransform.setAngleDeg(parseInt(inputR.value));
            updatePreview();
        }
        updatePreview();
        div.appendChild(previewWrapper);
        result.destroy = ()=>{
            keyListener.destroy();
            freeTransform.destroy();
            constrainCheckbox.destroy();
            snappingCheckbox.destroy();
        };
        result.getInput = function() {
            const transform2 = freeTransform.getTransform();
            let input = {
                transform: transform2,
                bounds: boundsObj,
                isPixelated: algorithmSelect.getValue() === 'pixelated' || _bb.BB.testShouldPixelate(transform2, transform2.width / initTransform.width, transform2.height / initTransform.height)
            };
            result.destroy();
            return JSON.parse(JSON.stringify(input));
        };
        return result;
    },
    apply (params) {
        const context = params.context;
        const history = params.history;
        if (!context || !history) return false;
        history.pause(true);
        const input = params.input;
        let copyCanvas = _bb.BB.copyCanvas(context.canvas);
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        _bb.BB.drawTransformedImageWithBounds(context, copyCanvas, input.transform, input.bounds, input.isPixelated);
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "transform"
            ],
            action: "apply",
            params: [
                {
                    input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"e3nbn","../ui/base-components/checkbox":"clzcQ","../canvas-ui/canvas-preview":"9a0UP","../ui/components/free-transform":"gt2Ud","../ui/base-components/select":"gIUAj","../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"8NpO2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "glBlur", ()=>glBlur
);
var _bb = require("../../bb/bb");
var _klSlider = require("../ui/base-components/kl-slider");
var _filtersConsts = require("./filters-consts");
var _canvasPreview = require("../canvas-ui/canvas-preview");
var _sharedGlFx = require("./shared-gl-fx");
var _language = require("../../language/language");
const glBlur = {
    getDialog (params) {
        let canvas = params.canvas;
        let context = params.context;
        if (!canvas || !context) return false;
        let layers = canvas.getLayers();
        let selectedLayerIndex = canvas.getLayerIndex(context.canvas);
        let fit = _bb.BB.fitInto(context.canvas.width, context.canvas.height, 280, 200, 1);
        let displayW = parseInt('' + fit.width), displayH = parseInt('' + fit.height);
        let w = Math.min(displayW, context.canvas.width);
        let h = Math.min(displayH, context.canvas.height);
        let tempCanvas = _bb.BB.canvas(w, h);
        {
            const ctx = tempCanvas.getContext("2d");
            ctx.save();
            if (w > context.canvas.width) ctx.imageSmoothingEnabled = false;
            ctx.drawImage(context.canvas, 0, 0, w, h);
            ctx.restore();
        }
        let previewFactor = w / context.canvas.width;
        let div = document.createElement("div");
        let result = {
            element: div
        };
        function finishInit() {
            let radius = 10;
            div.innerHTML = _language.LANG('filter-triangle-blur-description') + "<br/><br/>";
            let glCanvas = _sharedGlFx.getSharedFx();
            if (!glCanvas) return; // todo throw?
            let texture = glCanvas.texture(tempCanvas);
            glCanvas.draw(texture).update(); // update glCanvas size
            let radiusSlider = new _klSlider.KlSlider({
                label: _language.LANG('radius'),
                width: 300,
                height: 30,
                min: 1,
                max: 200,
                initValue: radius,
                eventResMs: _filtersConsts.eventResMs,
                onChange: function(val) {
                    radius = val;
                    glCanvas.draw(texture).triangleBlur(radius * previewFactor).update();
                    klCanvasPreview.render();
                }
            });
            div.appendChild(radiusSlider.getElement());
            let previewWrapper = document.createElement("div");
            _bb.BB.css(previewWrapper, {
                width: "340px",
                marginLeft: "-20px",
                height: "220px",
                backgroundColor: "#9e9e9e",
                marginTop: "10px",
                boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
                overflow: "hidden",
                position: "relative",
                userSelect: 'none',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                colorScheme: 'only light'
            });
            let previewLayerArr = [];
            for(let i = 0; i < layers.length; i++)previewLayerArr.push({
                image: i === selectedLayerIndex ? glCanvas : layers[i].context.canvas,
                opacity: layers[i].opacity,
                mixModeStr: layers[i].mixModeStr
            });
            let klCanvasPreview = new _canvasPreview.KlCanvasPreview({
                width: parseInt('' + displayW),
                height: parseInt('' + displayH),
                layers: previewLayerArr
            });
            let previewInnerWrapper = _bb.BB.el({
                css: {
                    position: 'relative',
                    boxShadow: '0 0 5px rgba(0,0,0,0.5)',
                    width: parseInt('' + displayW) + 'px',
                    height: parseInt('' + displayH) + 'px'
                }
            });
            previewInnerWrapper.appendChild(klCanvasPreview.getElement());
            previewWrapper.appendChild(previewInnerWrapper);
            div.appendChild(previewWrapper);
            try {
                glCanvas.draw(texture).triangleBlur(radius * previewFactor).update();
                klCanvasPreview.render();
            } catch (e) {
                div.errorCallback(e);
            }
            result.destroy = ()=>{
                texture.destroy();
                radiusSlider.destroy();
            };
            result.getInput = function() {
                result.destroy();
                return {
                    radius: radius
                };
            };
        }
        setTimeout(finishInit, 1);
        return result;
    },
    apply (params) {
        let context = params.context;
        let history = params.history;
        let radius = params.input.radius;
        if (!context || !radius || !history) return false;
        history.pause(true);
        let glCanvas = _sharedGlFx.getSharedFx();
        if (!glCanvas) return false; // todo more specific error?
        let texture = glCanvas.texture(context.canvas);
        glCanvas.draw(texture).triangleBlur(radius).update();
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(glCanvas, 0, 0);
        texture.destroy();
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "glBlur"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"e3nbn","../ui/base-components/kl-slider":"1Vedp","./filters-consts":"hTXbX","../canvas-ui/canvas-preview":"9a0UP","./shared-gl-fx":"4XYAu","../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"dNJzT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "glUnsharpMask", ()=>glUnsharpMask
);
var _bb = require("../../bb/bb");
var _filtersConsts = require("./filters-consts");
var _klSlider = require("../ui/base-components/kl-slider");
var _canvasPreview = require("../canvas-ui/canvas-preview");
var _sharedGlFx = require("./shared-gl-fx");
var _language = require("../../language/language");
const glUnsharpMask = {
    getDialog (params) {
        let context = params.context;
        let canvas = params.canvas;
        if (!context || !canvas) return false;
        let layers = canvas.getLayers();
        let selectedLayerIndex = canvas.getLayerIndex(context.canvas);
        let fit = _bb.BB.fitInto(context.canvas.width, context.canvas.height, 280, 200, 1);
        let displayW = parseInt('' + fit.width), displayH = parseInt('' + fit.height);
        let w = Math.min(displayW, context.canvas.width);
        let h = Math.min(displayH, context.canvas.height);
        let tempCanvas = _bb.BB.canvas(w, h);
        {
            const ctx = tempCanvas.getContext("2d");
            ctx.save();
            if (w > context.canvas.width) ctx.imageSmoothingEnabled = false;
            ctx.drawImage(context.canvas, 0, 0, w, h);
            ctx.restore();
        }
        let previewFactor = w / context.canvas.width;
        let div = document.createElement("div");
        let result = {
            element: div
        };
        function finishInit() {
            let radius = 2, strength = 0.51;
            div.innerHTML = _language.LANG('filter-unsharp-mask-description') + "<br/><br/>";
            let glCanvas = _sharedGlFx.getSharedFx();
            if (!glCanvas) return; // todo throw?
            let texture = glCanvas.texture(tempCanvas);
            glCanvas.draw(texture).update(); // update glCanvas size
            let radiusSlider = new _klSlider.KlSlider({
                label: _language.LANG('radius'),
                width: 300,
                height: 30,
                min: 0,
                max: 200,
                initValue: 2,
                eventResMs: _filtersConsts.eventResMs,
                onChange: function(val) {
                    radius = val;
                    glCanvas.draw(texture).unsharpMask(radius * previewFactor, strength).update();
                    klCanvasPreview.render();
                },
                curve: [
                    [
                        0,
                        0
                    ],
                    [
                        0.1,
                        2
                    ],
                    [
                        0.5,
                        50
                    ],
                    [
                        1,
                        200
                    ]
                ]
            });
            let strengthSlider = new _klSlider.KlSlider({
                label: _language.LANG('filter-unsharp-mask-strength'),
                width: 300,
                height: 30,
                min: 0,
                max: 50,
                initValue: 5.1,
                eventResMs: _filtersConsts.eventResMs,
                onChange: function(val) {
                    strength = val / 10;
                    glCanvas.draw(texture).unsharpMask(radius * previewFactor, strength).update();
                    klCanvasPreview.render();
                },
                curve: [
                    [
                        0,
                        0
                    ],
                    [
                        0.1,
                        2
                    ],
                    [
                        0.5,
                        10
                    ],
                    [
                        1,
                        50
                    ]
                ]
            });
            radiusSlider.getElement().style.marginBottom = "10px";
            div.appendChild(radiusSlider.getElement());
            div.appendChild(strengthSlider.getElement());
            let previewWrapper = document.createElement("div");
            _bb.BB.css(previewWrapper, {
                width: "340px",
                marginLeft: "-20px",
                height: "220px",
                backgroundColor: "#9e9e9e",
                marginTop: "10px",
                boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
                overflow: "hidden",
                position: "relative",
                userSelect: 'none',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                colorScheme: 'only light'
            });
            let previewLayerArr = [];
            for(let i = 0; i < layers.length; i++)previewLayerArr.push({
                image: i === selectedLayerIndex ? glCanvas : layers[i].context.canvas,
                opacity: layers[i].opacity,
                mixModeStr: layers[i].mixModeStr
            });
            let klCanvasPreview = new _canvasPreview.KlCanvasPreview({
                width: parseInt('' + displayW),
                height: parseInt('' + displayH),
                layers: previewLayerArr
            });
            let previewInnerWrapper = _bb.BB.el({
                css: {
                    position: 'relative',
                    boxShadow: '0 0 5px rgba(0,0,0,0.5)',
                    width: parseInt('' + displayW) + 'px',
                    height: parseInt('' + displayH) + 'px'
                }
            });
            previewInnerWrapper.appendChild(klCanvasPreview.getElement());
            previewWrapper.appendChild(previewInnerWrapper);
            div.appendChild(previewWrapper);
            try {
                glCanvas.draw(texture).unsharpMask(radius * previewFactor, strength).update();
                klCanvasPreview.render();
            } catch (e) {
                div.errorCallback(e);
            }
            result.destroy = ()=>{
                radiusSlider.destroy();
                strengthSlider.destroy();
                texture.destroy();
            };
            result.getInput = function() {
                result.destroy();
                return {
                    radius: radius,
                    strength: strength
                };
            };
        }
        setTimeout(finishInit, 1);
        return result;
    },
    apply (params) {
        let context = params.context;
        let history = params.history;
        let radius = params.input.radius;
        let strength = params.input.strength;
        if (!context || radius === null || strength === null || !history) return false;
        history.pause(true);
        let glCanvas = _sharedGlFx.getSharedFx();
        if (!glCanvas) return false; // todo more specific error?
        let texture = glCanvas.texture(context.canvas);
        glCanvas.draw(texture).unsharpMask(radius, strength).update();
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(glCanvas, 0, 0);
        texture.destroy();
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "glUnsharpMask"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"e3nbn","./filters-consts":"hTXbX","../ui/base-components/kl-slider":"1Vedp","../canvas-ui/canvas-preview":"9a0UP","./shared-gl-fx":"4XYAu","../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"83zR8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toAlpha", ()=>toAlpha
);
var _bb = require("../../bb/bb");
var _options = require("../ui/base-components/options");
var _colorOptions = require("../ui/base-components/color-options");
var _canvasPreview = require("../canvas-ui/canvas-preview");
var _sharedGlFx = require("./shared-gl-fx");
var _language = require("../../language/language");
const toAlpha = {
    getDialog (params) {
        let context = params.context;
        let canvas = params.canvas;
        if (!context || !canvas) return false;
        let layers = canvas.getLayers();
        let selectedLayerIndex = canvas.getLayerIndex(context.canvas);
        let fit = _bb.BB.fitInto(context.canvas.width, context.canvas.height, 280, 200, 1);
        let w = parseInt('' + fit.width), h = parseInt('' + fit.height);
        let tempCanvas = _bb.BB.canvas(w, h);
        {
            const ctx = tempCanvas.getContext("2d");
            ctx.save();
            if (tempCanvas.width > context.canvas.width) ctx.imageSmoothingEnabled = false;
            ctx.drawImage(context.canvas, 0, 0, w, h);
            ctx.restore();
        }
        let div = document.createElement("div");
        let result = {
            element: div
        };
        function finishInit() {
            let radius = 2, strength = 0.51;
            div.appendChild(_bb.BB.el({
                content: _language.LANG('filter-to-alpha-description'),
                css: {
                    marginBottom: '5px'
                }
            }));
            let glCanvas = _sharedGlFx.getSharedFx();
            if (!glCanvas) return; // todo throw?
            let texture = glCanvas.texture(tempCanvas);
            glCanvas.draw(texture).update(); // update glCanvas size
            function updatePreview() {
                glCanvas.draw(texture).toAlpha(sourceId === 'inverted-luminance', selectedRgbaObj).update();
                klCanvasPreview.render();
            }
            // source
            let sourceId = 'inverted-luminance';
            let sourceOptions = new _options.Options({
                optionArr: [
                    {
                        id: 'inverted-luminance',
                        label: _language.LANG('filter-to-alpha-inverted-lum')
                    },
                    {
                        id: 'luminance',
                        label: _language.LANG('filter-to-alpha-lum')
                    }
                ],
                initialId: sourceId,
                onChange: function(id) {
                    sourceId = id;
                    updatePreview();
                }
            });
            div.appendChild(sourceOptions.getElement());
            // color
            let selectedRgbaObj = {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            };
            let colorOptionsArr = [
                null,
                {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 1
                },
                {
                    r: 255,
                    g: 255,
                    b: 255,
                    a: 1
                }
            ];
            colorOptionsArr.push({
                r: params.currentColorRgb.r,
                g: params.currentColorRgb.g,
                b: params.currentColorRgb.b,
                a: 1
            });
            colorOptionsArr.push({
                r: params.secondaryColorRgb.r,
                g: params.secondaryColorRgb.g,
                b: params.secondaryColorRgb.b,
                a: 1
            });
            let colorOptions = new _colorOptions.ColorOptions({
                label: _language.LANG('filter-to-alpha-replace'),
                colorArr: colorOptionsArr,
                initialIndex: 1,
                onChange: function(rgbaObj) {
                    selectedRgbaObj = rgbaObj;
                    updatePreview();
                }
            });
            colorOptions.getElement().style.marginTop = '10px';
            div.appendChild(colorOptions.getElement());
            let previewWrapper = document.createElement("div");
            _bb.BB.css(previewWrapper, {
                width: "340px",
                marginLeft: "-20px",
                height: "220px",
                backgroundColor: "#9e9e9e",
                marginTop: "10px",
                boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px inset, rgba(0, 0, 0, 0.2) 0px -1px inset",
                overflow: "hidden",
                position: "relative",
                userSelect: 'none',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                colorScheme: 'only light'
            });
            let previewLayerArr = [];
            for(let i = 0; i < layers.length; i++)previewLayerArr.push({
                image: i === selectedLayerIndex ? glCanvas : layers[i].context.canvas,
                opacity: layers[i].opacity,
                mixModeStr: layers[i].mixModeStr
            });
            let klCanvasPreview = new _canvasPreview.KlCanvasPreview({
                width: parseInt('' + w),
                height: parseInt('' + h),
                layers: previewLayerArr
            });
            let previewInnerWrapper = _bb.BB.el({
                css: {
                    position: 'relative',
                    boxShadow: '0 0 5px rgba(0,0,0,0.5)',
                    width: parseInt('' + w) + 'px',
                    height: parseInt('' + h) + 'px'
                }
            });
            previewInnerWrapper.appendChild(klCanvasPreview.getElement());
            previewWrapper.appendChild(previewInnerWrapper);
            div.appendChild(previewWrapper);
            setTimeout(function() {
                try {
                    updatePreview();
                } catch (e) {
                    div.errorCallback(e);
                }
            }, 1);
            result.destroy = ()=>{
                texture.destroy();
                sourceOptions.destroy();
            };
            result.getInput = function() {
                result.destroy();
                return {
                    sourceId: sourceId,
                    selectedRgbaObj: selectedRgbaObj
                };
            };
        }
        setTimeout(finishInit, 1);
        return result;
    },
    apply (params) {
        let context = params.context;
        let history = params.history;
        let sourceId = params.input.sourceId;
        let selectedRgbaObj = params.input.selectedRgbaObj;
        if (!context || !sourceId || !history) return false;
        history.pause(true);
        let glCanvas = _sharedGlFx.getSharedFx();
        if (!glCanvas) return false; // todo more specific error?
        let texture = glCanvas.texture(context.canvas);
        glCanvas.draw(texture).toAlpha(sourceId === 'inverted-luminance', selectedRgbaObj).update();
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(glCanvas, 0, 0);
        texture.destroy();
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "toAlpha"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"e3nbn","../ui/base-components/options":"b8ZKE","../ui/base-components/color-options":"6ALHb","../canvas-ui/canvas-preview":"9a0UP","./shared-gl-fx":"4XYAu","../../language/language":"lvNW4","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"kSwNg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "klCanvasToPsdBlob", ()=>klCanvasToPsdBlob
);
var _kl = require("../kl");
async function klCanvasToPsdBlob(klCanvas) {
    let layerArr = klCanvas.getLayersFast();
    let psdConfig = {
        width: klCanvas.getWidth(),
        height: klCanvas.getHeight(),
        //canvas: klCanvas.getCompleteCanvas(1), // preview, can be skipped
        children: []
    };
    for(let i = 0; i < layerArr.length; i++){
        // todo - can be optimized if layer mostly empty
        let item = layerArr[i];
        psdConfig.children.push({
            name: item.name,
            opacity: item.opacity,
            canvas: item.canvas,
            blendMode: _kl.KL.PSD.blendKlToPsd(item.mixModeStr),
            left: 0,
            top: 0
        });
    }
    let agPsd = await require("83a0fe54f58f2463");
    let buffer = agPsd.writePsdBuffer(psdConfig);
    return new Blob([
        buffer
    ], {
        type: 'application/octet-stream'
    });
}

},{"../kl":"3bnx1","83a0fe54f58f2463":"4NpwA","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"hJAfW":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "tab-settings.6d924222.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}],"8p84o":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('bWfZe') + "tab-layers.6c2789c3.svg" + "?" + Date.now();

},{"./helpers/bundle-url":"chiK4"}]},["aLV6j","6xtYJ"], "6xtYJ", "parcelRequire94c2")

//# sourceMappingURL=index.5992be95.js.map
